---
title: 原型继承和类式继承
date: 2018-01-10
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/23.jpg
---

在一些基于类的语言（比如 `Java`）当中，继承（`inheritance/extends`）提供了两个有用的服务，如果一个新的类与一个已存在的类大部分相似，那么你只需说明其不同点即可

`JavaScript` 是一门弱类型语言，从不需要类型转换，它可以模拟那些基于类的模式，同时它也支持其他更具表现力的模式

<!--more-->

在基于类的语言中，对象是类的实例，并且类可以用另一个类继承，`JavaScript` 是一门基于原型的语言，这意味着对象也是可以直接从其他对象继承

在 `JavaScript` 当中比较常见的继承方法有类式继承和原型继承




## 类式继承（构造函数）

`JavaScript` 在 `ES5` 当中其实是没有类的概念的，所谓的类也是模拟出来的，特别是当我们是用 `new` 关键字的时候，就使得类的概念就越像其他语言中的类了

类式继承是在函数对象内调用父类的构造函数，使得自身获得父类的方法和属性（`call` 和 `apply` 方法为类式继承提供了支持）

通过改变 `this` 的作用环境，使得子类本身具有父类的各种属性

```js
var father = function () {
  this.age = 20;
  this.say = function () {
    alert(this.name + this.age);
  }
}

var child = function () {
  this.name = 'zhangsan';
  father.call(this);
}

var man = new child();
man.say();
```


## 原型继承

我们先来看一张珍藏多年的图


![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/06.png)


原型继承有别于类继承，因为继承不在对象本身，而在对象的原型上（`prototype`）

每一个对象都有原型，在浏览器中它体现在一个隐藏的 `__proto__` 属性上，在一些现代浏览器中你可以更改它们（不过不太建议这样操作）

比如在 `zepto` 中，就是通过添加 `zepto` 的 `fn` 对象到一个空的数组的 `__proto__` 属性上去，从而使得该数组成为一个 `zepto` 对象并且拥有所有的方法

当一个对象需要调用某个方法时，它会去最近的原型上查找该方法，如果没有找到，它会再次往下继续查找

这样逐级查找，一直找到了要找的方法，这些查找的原型构成了该对象的原型链条（最后指向 `Object.prototype.__proto__` 也就是 `null`），类似于下面这样

```js
function Foo() {}
var f1 = new Foo()

// f1 的 __proto__ 是指向 Foo.prototype 的
f1.__proto__ === Foo.prototype

// 而 Foo.prototype.__proto__ 又是指向 Object.prototype
Foo.prototype.__proto__ === Object.prototype

// 而 Object.prototype.__proto__ 则是指向 null 的
Object.prototype.__proto__ === null
```

下面我们再来看看原型继承的例子，如下

```js
var father = function () { }
father.prototype.a = function () { }

var child = function () { }
child.prototype = new father();

var man = new child();
man.a();
```

这里面比较重要的一句就是

```js
child.prototype = new father();
```

可以发现，`child` 是通过中间层继承了 `father` 的原型上的东西的，但是这里有一个问题，为什么不直接使用 `child.prototype = father.prototype`

如果这样做 `child` 和 `father` 就没有区别了，通过上面的图可以发现，在 `prototype` 中有个 `constructor` 属性，是指向的是构造函数的

按照正常的情况我们要把 `constructor` 的值改回来指向 `child` 的构造函数，但如果直接把 `father.prototype` 赋值给 `child.prototype`

那么 `constructor` 应该指向谁呢？所以很显然只能通过中间层才能使得 `child` 和 `father` 保持为独立的对象




## 对比

和原型对比起来，构造函数（类）式继承有什么不一样呢？首先，构造函数继承的方法都会存在父对象之中，每一次实例，都会将 `funciton` 保存在内存中，这样的做法毫无疑问会带来性能上的问题

其次类式继承是不可变的，在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法

而原型继承是可以通过改变原型链接而对子类进行修改的（重写方法即可）

另外就是类式继承不支持多重继承，而对于原型继承来说，可以使用类似 `extend` 等方法对对象进行扩展

所以在某种程度上来说，上面提到的两种方式或多或少都存在一定的缺点，那么有没有一种各取所长的做法呢？


## 组合模式

另外的一种模式，也是现在使用较多的方式，是结合类继承和原型继承的各自优点来进行对父类的继承，用类式继承属性，而原型继承方法

这种模式避免了属性的公用，因为一般来说，每一个子类的属性都是私有的，而方法得到了统一

这种模式称为组合模式（寄生组合继承），也是继承类式常用到的一种方法

```js
function father() {
  this.a = 'father'
}

father.prototype.b = function () {
  alert(this.a)
}

var child = function () {
  father.call(this)
}

child.prototype = new father();
```

其实这种方式也是存在一定的问题的，继续往下看


## new 关键字和 Obeject.create 方法

这里引用 [why-prototypal-inheritance-matters](http://aaditmshah.github.io/why-prototypal-inheritance-matters/) 这篇文章当中的一句话

> `new` 关键字掩盖了 `JavaScript` 中真正的原型继承，使得它更像是基于类的继承
>
> 其实 `new` 关键字只是 `Javascript` 在为了获得流行度而加入与 `Java` 类似的语法时期留下来的一个残留物

作者推荐我们使用 `Object.create()` 方法创建或者实例化对象，我们可以对比一下使用类式继承和 `Object.create` 方法两者之间的区别

```js
// 类式继承 
var father = function () {
  this.a = 'father'
}

father.prototype.b = function () { alert(this.a) }
var obj = new father();


// 使用 Object.create()
var father = {
  a: 'father',
  b: function () {
    alert(this.a);
  }
}

var obj = Object.create(father);
console.dir(obj)
```

通过在控制台查看结果，我们可以发现

用 `create` 的方法构造出来的对象，`a` 属性和 `b` 方法都是在对象的原型上，也就是说我们可以通过更改 `father` 的属性动态改变 `obj` 的原型上的方法和属性

而上面通过 `new` 关键字用构造函数生成的实例，`a` 属性是无法改变的

下面我们就来看看 `Object.create()` 方法到底是个什么东西

这里只是简单介绍，更多详细的可以查看 [Object.create( ... )](https://heptaluan.github.io/2017/03/03/JavaScript/07/) 这篇文章


## 使用 Object.create()

`Object.create()` 的作用是创建一个空对象，并且这个对象的原型指向这个参数

典型的原型风格

```js
function Foo(name) {
  this.name = name
}

Foo.prototype.sayName = function () {
  return this.name
}

function Bar(name, age) {
  Foo.call(this, name)
  this.age = age
}

// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype
Bar.prototype = Object.create(Foo.prototype)

// 注意，现在没有 Bar.prototype.constructor 了
// 如果你需要这个属性的话可能需要手动修复一下它
// Bar.prototype.constructor = Bar
Bar.prototype.constructor = Bar

Bar.prototype.sayAge = function () {
  return this.age
}

var man = new Bar('zhangsan', 20)

man.sayName()  // zhangsan
man.sayAge()   // 20
```

## 关于 constructor

代码如下：

```js
var father = function () {}
var child = function () { }

child.prototype = new father();
var man = new child();
```

任何一个 `prototype` 对象都有一个 `constructor` 属性，指向它的构造函数，在执行比如下面步骤之前

```js
child.prototype = new father();
```

`child.prototype.constructor` 是指向 `child` 的，但是在执行以后，`child.prototype.constructor` 便指向了 `father`

更重要的是，每一个实例也有一个 `constructor` 属性，默认调用 `prototype` 对象的 `constructor` 属性

```js
// 运行前
man.constructor === child.prototype.constructor  // true

// 运行后
man.constructor === father  // true
```

这显然会导致继承链的紊乱（`man` 明明是用构造函数 `child` 生成的），因此我们必须手动纠正，将 `child.prototype` 对象的 `constructor` 值改为 `child`

这是很重要的一点，即如果替换了 `prototype` 对象

```js
o.prototype = {};
```

那么，下一步必然是为新的 `prototype` 对象加上 `constructor` 属性，并将这个属性指回原来的构造函数

```js
o.prototype.constructor = o;
```




## 几种实现继承方式的优缺点

```js
function Person () {}

function Student () {}
```

下面来对比一下几种方式的优缺点

```js
// 方式一
Student.prototype = Person.prototype
```

在改变 `Student` 的同时，也改变了 `Person`，这样一来，在改变 `child` 的同时，也将同时改变 `father`

即 `child.prototype` 和 `father.prototype` 现在指向了同一个对象

那么任何对 `child.prototype` 的修改，都会反映到 `father.prototype`，强烈不推荐

```js
// 方式二
Student.prototype = new Person()
```

也可以实现继承，但是 `Student` 只是一个类，还没有实例化，只是为了继承，而调用构造函数

```js
// 方式三
Student.prototype = Object.create(Person.prototype)
```

相对来说比较妥当的，自己的修改不会影响到原型链，`ES5` 之后才实现，推荐使用

```js
// ES5 之前可以先判断一下，然后模拟实现
if (!Object.create) {
  Object.create = function (proto) {
    function F() {}
    F.prototype = proto;
    return new F;
  };
}
```

调用子类方法

```js
function Person (name) {
  this.name = name;
}

function Student (name, className) {
  this.className = className;
  Person.call(this, name);    
}

// test
var man = new Student('man','abc');
man; // Student{className: 'abc', name: 'man'}

// 若子类的方法覆盖了基类的方法
Person.prototype.init = function () {};

Student.prototype.init = function () {
  // do something...
  Person.prototype.init.apply(this, arguments);
}
```
