---
title: 数据库中的事务和锁
date: 2018-11-04
categories: MySQL
tags: MySQL
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/02.jpg
---

在数据库方向，我们会经常听到事务这个东西，我们就来看看它到底是什么

<!--more-->

## 事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消

也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做

事务的结束有两种

* 当事务中的所以步骤全部成功执行时，事务提交

* 如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作

## 事务的 ACID 

* A （`Atomicity`）  原子性

  * 事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行

* C （`Consistency`） 一致性

  * 事务在完成时，必须使所有的数据都保持一致状态
  
  * 在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性
  
  * 事务结束时，所有的内部数据结构（如 `B` 树索引或双向链表）都必须是正确的

* I （`Isolation`）   隔离性 

  * 并发事务所做的修改必须与任何其他并发事务所做的修改隔离
  
  * 事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态
  
  * 事务不会识别中间状态的数据

* D （`Durability`）  持久性

  * 事务完成之后，它对于系统的影响是永久性的，该修改即使出现系统故障也将一直保持


## 锁

在事务获取数据块当前状态的依赖关系（比如通过读取或修改数据）之前，它必须保护自己不受其他事务对同一数据进行修改的影响，事务通过请求锁定数据块来达到此目的，锁有多种模式，如**共享**或**独占**

锁模式定义了事务对数据所拥有的依赖关系级别，如果某个事务已获得特定数据的锁，则其他事务不能获得会与该锁模式发生冲突的锁，如果事务请求的锁模式与已授予同一数据的锁发生冲突，则数据库引擎实例将暂停事务请求直到第一个锁释放

引入锁的机制主要是用来处理多个用户同时对数据库的并发操作时会带来以下几种数据不一致的问题（四大冲突问题）

* 脏读

  * 某个事务读取的数据是另一个事务正在处理的数据，而另一个事务可能会回滚，造成第一个事务读取的数据是错误的

* 不可重复读

  * 在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据

* 幻读

  * 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据，那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样

* 更新丢失

  * 多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失


## 锁模式

* 共享锁（`S` 锁）

  * 允许并发事务在封闭式并发控制下读取 （`SELECT`）资源，资源上存在共享锁（`S` 锁）时，任何其他事务都不能修改数据
  
  * 读取操作一完成，就立即释放资源上的共享锁（`S` 锁），除非将事务隔离级别设置为可重复读或更高级别，或者在事务持续时间内用锁定提示保留共享锁（`S` 锁）

* 更新锁（`U` 锁）

  * 更新锁在共享锁和排他锁的杂交，更新锁意味着在做一个更新时，一个共享锁在扫描完成符合条件的数据后可能会转化成排他锁

  * 这里面有两个步骤：

    * 扫描获取 `Where` 条件时，这部分是一个更新查询，此时是一个更新锁

    * 如果将执行写入更新，此时该锁升级到排他锁，否则，该锁转变成共享锁

  * 更新锁可以防止常见的死锁

* 排他锁

  * 排他锁（`X` 锁）可以防止并发事务对资源进行访问，排他锁不与其他任何锁兼容
  
  * 使用排他锁（`X` 锁）时，任何其他事务都无法修改数据，仅在使用 `NOLOCK` 提示或未提交读隔离级别时才会进行读取操作
