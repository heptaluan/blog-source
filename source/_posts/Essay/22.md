---
title: 图的遍历
date: 2020-03-03
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/22.jpg
---

之前我们介绍了 [图的存储结构](http://localhost:4000/2020/03/07/Essay/21/)，主要有五种方式，有两种使用较多的 **邻接矩阵** 和 **邻接表**，另外还有三种使用较少的，它们是 **十字链表**，**邻接多重表** 和 **边集数组**

本章我们主要来看一下图的遍历

<!--more-->


## 图的遍历

在之前介绍过的二叉树的遍历当中，我们提到来四种遍历方式，它们分别是 **前序遍历**，**中序遍历**，**后序遍历** 和 **层序遍历**

针对于二叉树而言，因为根结点只有一个，并且所有的结点都只有一个双亲，所以我们实现起来不算泰国困难

但是针对图的遍历，因为它的任一顶点都可以和其余的所有顶点相邻接，所以极有可能存在重复走过某个顶点或漏了某个顶点的遍历过程

所以对于图的遍历，如果要避免以上情况，那就需要科学地设计遍历方案，通常有两种遍历方案，**深度优先遍历** 和 **广度优先遍历**，下面我们就一个一个来进行了解




## 深度优先遍历

深度优化遍历（`DepthFirstSearch`），也有称为 **深度优化搜索**，简称为 `DFS`

我们以下面这个图为例

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/175.png)

如果我们想要进行遍历，我们可以约定右手原则，即在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号

如果走到终点的时候发现分叉路都是已经被标记过的，则执行回退操作，一直回退到起点

比如针对上图，它的执行流程是

* 我们首先从 `A` 出发开始进行遍历，按照我们的右手原则，它会依次经过 `A，B，C，D，E`，最终到达 `F` 处
* 到达 `F` 以后可以发现，`A` 和 `E` 都是已经被标记过了，所以它会走向 `G`，这时发现 `B` 和 `D` 也都是已经标记过了，所以会走向 `H`
* 到达 `H` 以后会发现，`E，D，G` 都是已经标记过了，所以这时就会回退到 `G` 到位置，同理此时可以发现 `B，D，F` 也都是标记过了，所以依次经过 `F，E`，一直会回退到 `D` 到位置
* 到达 `D` 到位置以后会发现 `C` 是被标记过到，但是 `I` 是没有标记过到，所以会走向 `I`，下一步同理，发现 `B` 和 `C` 都是被标记过到，所以会往回走，在依次经过 `D，C，B` 回到 `A` 到位置上
* 回到 `A` 到位置上以后就算是结束遍历过程，这就是 **深度优先遍历**

简单总结一下可以发现，**深度优先遍历** 其实就是一个 **递归** 的过程，如果再细心观察，可以发现，其实整个遍历过程就 **像是一棵树的前序遍历**

我们将上面到流程简单总结一下其实就是下图这样到流程

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/176.png)



## 深度优先遍历的代码实现

下面我们来看看如何进行实现，首先使用 `C` 语言来进行实现，分为两种情况 **邻接表** 和 **邻接矩阵**

图结构的生成可以参考我们在图的存储结构当中介绍过的 [图的存储结构的实现](http://localhost:4000/2020/03/07/Essay/21/#%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)，这里我们只介绍遍历方法

```c
// 邻接表 的深度有限递归算法
#define TRUE 1
#define FALSE 0
#define MAX 256

typedef int Boolean;   // 这里我们定义 Boolean 为布尔类型，其值为 TRUE 或 FALSE
Boolean visited[MAX];  // 访问标志的数组

void DFS(GraphAdjList GL, int i) {
  EdgeNode *p;

  // 访问过的顶点设置为 TRUE
  visited[i] = TRUE;
  printf("%c " GL->adjList[i].data);
  p = GL->adjList[i].firstEdge;

  while (p) {
    if (!visited[p->adjvex]) {
      DFS(GL, p->adjvex);
    }
    p = p->next;
  }
}

// 邻接表 的深度遍历操作
void DFSTraverse(GraphAdjList GL) {
  int i;

  for (i = 0; i < GL->numVertexes; i++) {
    // 初始化所有顶点状态都是未访问过状态
    visited[i] = FALSE;
  }

  for (i = 0; i < GL->numVertexes; i++){
    // 若是连通图，只会执行一次
    if (!visited[i]) {
      DFS(GL, i);
    }
  }
}
```

```c
// 邻接矩阵 的深度有限递归算法
#define TRUE 1
#define FALSE 0
#define MAX 256

typedef int Boolean;   // 这里我们定义 Boolean 为布尔类型，其值为 TRUE 或 FALSE
Boolean visited[MAX];  // 访问标志的数组

void DFS(MGraph G, int i) {
  int j;

  // 访问过的顶点设置为 TRUE
  visited[j] = TRUE;        
  printf("%c ", G.vexs[i]);

  for (j = 0; j < G.numVertexes; j++) {
    if (G.arc[i][j] == 1 && !visited[j]) {
      // 对为访问的邻接顶点递归调用
      DFS(G, j); 
    }
  }
}

// 邻接矩阵 的深度遍历操作
void DFSTraverse(MGraph G) {
  int i;

  for (i = 0; i < G.numVertexes; i++) {
    // 初始化所有顶点状态都是未访问过状态
    visited[i] = FALSE;
  }

  for (i = 0; i < G.numVertexes; i++) {
    // 若是连通图，只会执行一次
    if (!visited[i]) {
      DFS(G, i);
    }
  }
}
```

下面我们再来看看如何使用 `JavaScript` 来进行实现，原理是一样的

```js
// 访问标志数组，遍历时使用
let visited = []

// 邻接矩阵的深度优先递归算法
function DFS(i) {

  // 访问过的顶点设置为 TRUE
  visited[i] = true
  console.log('打印顶点:', G.vexs[i])

  for (let j = 0; j < G.numVertexes; j++) {
    if (G.arc[i][j] == 1 && !visited[j]) {
      console.log(G.vexs[i], '->', G.vexs[j])

      //对未访问的顶点进行递归
      DFS(j)
    }
  }
}

// 邻接矩阵的深度遍历操作
function DFSTraverse() {
  for (let i = 0; i < G.numVertexes; i++) {
    // 初始化所有顶点状态都是未访问过状态
    visited[i] = false;
  }

  for (let i = 0; i < G.numVertexes; i++) {
    // 若是连通图，只会执行一次
    if (!visited[i])
      DFS(i)
  }
}
```

















广度遍历算法

```js
// 邻接矩阵 的广度遍历算法
function BFSTraverse() {
  // 初始化队列
  let queue = []

  for (let i = 0; i < G.numVertexes; i++) {
    // 初始化所有顶点状态都是未访问过状态
    visited[i] = false
  }

  //对每一个顶点做循环
  for (let i = 0; i < G.numVertexes; i++) {
    // 如果没有访问过就处理
    if (!visited[i]) {

      // 访问过的顶点设置为TRUE
      visited[i] = true
      console.log('打印顶点：', G.vexs[i])

      //将此顶点入队列
      queue.push(i)

      // 退出条件为当前队列不为空
      while (queue.length != 0) {
        queue.shift()

        for (let j = 0; j < G.numVertexes; j++) {
          // 判断其他顶点若与当前顶点存在边且未访问过
          if (G.arc[i][j] == 1 && !visited[j]) {
            visited[j] = true
            console.log(G.vexs[i], '->', G.vexs[j])
            console.log('打印顶点：', G.vexs[j])

            // 将此顶点放入队列
            queue.push(j)
          }
        }
      }
    }
  }
}
```