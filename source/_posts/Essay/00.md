---
title: 数据结构与算法知识梳理
date: 2020-08-23
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/32.jpg
---

本章主要是梳理一下之前在学习数据结构与算法的过程当中涉及到的一些内容和知识点，其他相关内容可以参考 [前端知识体系整理](https://heptaluan.github.io/target/)，本章大致内容有下面这些

<!--more-->

* 线性表（顺序存储结构/链式存储结构/循环链表/双向循环链表）
* 栈和队列
* 递归（尾调用/分治思想/汉诺塔/八皇后问题）
* 树和二叉树
  * 树的定义/二叉树的定义/二叉树的遍历/线索二叉树
  * 树、森林与二叉树之间的转换/赫夫曼树
* 图结构
  * 存储结构与遍历
  * 最小生成树（普里姆算法/克鲁斯卡尔算法）
  * 最短路径（迪杰斯特拉算法/弗洛伊德算法）
  * 关键路径（拓扑序列/拓扑排序/`AOV` 网/`AOE` 网）
* 查找算法
  * 顺序查找/二分查找/插值查找/斐波那契查找/线性索引查找（有序）
  * 散列表查找（无序）
  * 二叉排序树/平衡二叉排序树/散列表查找
* 排序算法
  * 比较排序（冒泡排序/选择排序/插入排序/希尔排序/归并排序/快速排序/堆排序）
  * 非比较排序（计数排序/基数排序/桶排序）




## 线性表

线性表由零个或多个数据元素组成的有序序列，它有以下特点

* 它是一个序列，也就是说元素之间是先来后到的
* 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继
* 另外，线性表强调是有限的，事实上无论计算机发展到多大，它所处理的元素都是有限的

它有两种物理存储结构，顺序存储结构和链式存储结构，物理上的存储方式事实上就是在内存中找一个初始地址，然后通过占位的形式，把一定的内存空间给占用，然后把相同数据类型的数据元素依次放在这块空地中，具体内容可以见下方列表

* [顺序存储结构](https://heptaluan.github.io/2019/12/14/Essay/05/)
  * 读取操作/插入操作/删除操作
  * 顺序存储结构的优缺点
* [链式存储结构](https://heptaluan.github.io/2020/01/12/Essay/07/)
  * 单链表
  * 读取操作/插入操作/删除操作
  * 单链表整表创建（头插法/尾插法）与删除
  * 单链表结构与顺序存储结构优缺点
* [静态链表](https://heptaluan.github.io/2020/02/05/Essay/08/)
  * 插入操作/删除操作
  * 静态链表的优缺点
* [循环链表](https://heptaluan.github.io/2020/02/06/Essay/09/)
  * 约瑟夫问题
  * 循环链表的特点
  * 判断链表中是否有环
* [双向链表与双向循环链表](https://heptaluan.github.io/2020/02/17/Essay/10/)
  * 双向链表结点结构
  * 双向链表的插入操作
  * 双向链表的删除操作





## 栈和队列

使用栈结构存储数据，讲究 **先进后出**，即最先进栈的数据，最后出栈，而使用队列存储数据，讲究 **先进先出**，即最先进队列的数据，也最先出队列，既然栈和队列都属于线性表，所以根据线性表分为顺序表和链表的特点，栈也可分为顺序栈和链表，队列也分为顺序队列和链队列

* [栈](https://heptaluan.github.io/2020/02/22/Essay/11/)
  * 栈的定义
  * 入栈操作和出栈操作
  * 栈的链式存储结构
    * 进栈操作
    * 出栈操作
  * `JavaScript` 中的栈的实现
    * 顺序存储
    * 链式存储
* [队列](https://heptaluan.github.io/2020/03/02/Essay/12/)
  * 队列的定义
  * 队列的顺序存储结构
  * 队列的链式存储结构
    * 入队列操作
    * 出队列操作
    * 销毁一个队列
  * 循环队列定义以及操作
  * `JavaScript` 中的队列实现
    * 链式存储
    * 顺序存储



## 递归

递归（`Recursion algorithm`）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法，递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念，绝大多数编程语言支持函数的自调用，简单来说，就是函数直接或间接调用函数本身，则该函数称为 **递归函数**，详细可见 [递归](https://heptaluan.github.io/2020/03/05/Essay/13/)，内容包括

* 什么是递归
* 斐波那契数列
* 尾调用
* 分治思想
* 汉诺塔
* 八皇后问题



## 树和二叉树

在上面我们介绍了 [单链表](https://heptaluan.github.io/2020/01/12/Essay/07/)，[循环链表](https://heptaluan.github.io/2020/02/06/Essay/09/)，[双向链表与双向循环链表](https://heptaluan.github.io/2020/02/17/Essay/10/)，[栈和队列](https://heptaluan.github.io/2020/02/22/Essay/11/) 等相关知识，但是如果细心观察可以发现，我们之前介绍的种种，它们其实都是一种 **一对一** 的线性结构，无论是线性表也好，或者说是栈和队列，都是一样的，所以下面我们就来看一种 **一对多** 的数据结构，那就是 **树结构**，内容如下

* [树](https://heptaluan.github.io/2020/03/12/Essay/15/)
  * 树的定义
  * 结点分类
  * 结点间的关系
  * 树的存储结构（双亲表示法/孩子表示法）
* [二叉树](https://heptaluan.github.io/2020/03/22/Essay/16/)
  * 二叉树的定义
  * 特殊二叉树（斜树/满二叉树/完全二叉树）
  * 二叉树的存储结构（顺序存储结构/二叉链表）
* [二叉树的遍历](https://heptaluan.github.io/2020/03/25/Essay/17/)
  * 前序遍历/中序遍历/后序遍历/层序遍历
* [线索二叉树](https://heptaluan.github.io/2020/03/27/Essay/18/)
  * 为什么需要线索二叉树
  * 线索二叉树的定义与遍历
* [树、森林与二叉树之间的转换](https://heptaluan.github.io/2020/04/02/Essay/19/)
  * 普通树转换为二叉树
  * 森林转换为二叉树
  * 二叉树转换为树、森林
  * 树与森林的遍历
  * 赫夫曼树
  * 赫夫曼编码




## 图结构

在上面的 [单链表](https://heptaluan.github.io/2020/01/12/Essay/07/)，[循环链表](https://heptaluan.github.io/2020/02/06/Essay/09/) 等链表章节当中我们知道了每个元素之间只有一个直接前驱和一个直接后继元素，同样的在 [树](https://heptaluan.github.io/2020/03/12/Essay/15/) 与 [二叉树](https://heptaluan.github.io/2020/03/22/Essay/16/) 等章节当中知道了树这种结构中，数据元素之间是层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关，但是以上这些仅仅都只是一对一，一对多的简单模型，那么如果元素之间存在多对多的关系呢，我们又该如何来处理呢？下面我们就来看看图这种结构

* [图结构](https://heptaluan.github.io/2020/04/05/Essay/20/)
  * 图的定义（无向边/有向边）
  * 简单图/无向完全图/有向完全图/稀疏图/稠密图/网/子图
  * 连通图/连通分量/强连通图
  * 生成树/有向树
* [图的存储结构](https://heptaluan.github.io/2020/04/09/Essay/21/)
  * 邻接矩阵（无向图/有向图/网）
  * 邻接表（无向图/有向图/网）
  * 十字链表
  * 邻接多重表
  * 边集数组
* [图的遍历](https://heptaluan.github.io/2020/04/14/Essay/22/)
  * 深度优先遍历/广度优先遍历
  * 马踏棋盘算法
  * [普里姆算法/克鲁斯卡尔算法](https://heptaluan.github.io/2020/04/22/Essay/23/)
* [最短路径](https://heptaluan.github.io/2020/05/06/Essay/24/)
  * 迪杰斯特拉算法/弗洛伊德算法
* [关键路径](https://heptaluan.github.io/2020/05/08/Essay/25/)
  * 拓扑序列/拓扑排序
  * 关键路径的作用
  * `AOV` 网与 `AOE` 网的比较



## 查找算法

在小节当中，我们会介绍一类在平常开发过程当中经常会使用的算法，那就是查找算法，关于查找算法肯定不需要多说，都是耳熟能详的，什么顺序、二分之类的就算是没有用过应该也听闻过，那么今天我们就来简单的总结整理一下查找算法的分类和一些比较常用的算法

* [查找算法](https://heptaluan.github.io/2020/05/25/Essay/26/)
  * 查找算法的分类
  * 顺序查找/二分查找/插值查找/斐波那契查找/线性索引查找（有序）
  * 散列表查找（无序）
* [二叉排序树](https://heptaluan.github.io/2020/06/12/Essay/27/)
  * 为什么需要二叉排序树
  * 二叉排序树
  * 查找/删除
* [平衡二叉排序树](https://heptaluan.github.io/2020/06/18/Essay/28/)
  * 二叉排序树存在的问题
  * 平衡二叉排序树
  * 平衡二叉排序树的构建过程
  * 平衡二叉排序树的旋转（`LL` 型/`RR` 型/`LR` 型/`RL` 型）
* [散列表查找](https://heptaluan.github.io/2020/06/22/Essay/29/)
  * 散列函数设计（直接定址法/数字分析法/平方取中法/折叠法/除留余数法/随机数法）
  * 处理散列冲突的方法（开放定址法/再散列函数法/链地址法/公共溢出区法）

## 排序算法

排序算法算得上是在所有的算法当中应该算是应用最为广泛的一类算法，详细可见 [排序算法](https://heptaluan.github.io/2020/07/02/Essay/30/)，总共有十种方式，如下

* 比较排序（冒泡排序/选择排序/插入排序/希尔排序/归并排序/快速排序/堆排序）
* 非比较排序（计数排序/基数排序/桶排序）

