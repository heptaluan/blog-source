---
title: 二叉树的遍历
date: 2020-02-16
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/17.jpg
---

因为二叉树的遍历是一个比较重要的概念，所以我们单独将其拿出来整理成一篇，然后深入的了解一下

<!--more-->

## 二叉树的遍历

二叉树的遍历（`traversing binary tree`）是指从**根结点**出发，按照**某种次序依次访问**二叉树中所有结点，使得每个结点被**访问一次且仅被访问一次**

这里需要注意上文提及的两个概念 **某种次序依次访问** 和 **访问一次且仅被访问一次**

这是因为二叉树的遍历次序不同于线性结构，因为线性结构最多也就是分为顺序、循环、双向等简单的遍历方式

而树的结点之间不存在唯一的前驱和后继这样的关系，所以在访问一个结点后，下一个被访问的结点面临着不同的选择

所以二叉树的遍历方式就可以有很多，在这里我们简单的总结一下，主要分为以下四种遍历方式

* 前序遍历
* 中序遍历
* 后序遍历
* 层序遍历

有个比较简单的记忆方式就是

* 先序遍历，根 ==> 左 ==> 右
* 中序遍历，左 ==> 根 ==> 右
* 中序遍历，左 ==> 右 ==> 根

可以发现，前中后的遍历顺序是看 **根结点** 放在何处来决定的

下面我们就借助下方这个二叉树的图（注意不是完全二叉树），一个一个来进行了解

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/108.png)


## 前序遍历

基本逻辑是，如果二叉树为空，则空操作返回，否则 **先访问根结点**，然后 **前序遍历左子树**，再 **前序遍历右子树**

顺序如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/109.png)

遍历的顺序为 `A ==> B ==> D ==> H ==> I ==> E ==> J ==> C ==> F ==> K ==> G`


## 中序遍历

若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），**中序遍历根结点的左子树**，然后是访问 **根结点**，最后 **中序遍历右子树**

顺序如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/110.png)

遍历的顺序为 `H ==> D ==> I ==> B ==> E ==> J ==> A ==> F ==> K ==> C ==> G`


## 后序遍历

若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，**最后访问根结点**

顺序如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/111.png)

遍历的顺序为 `H ==> I ==> D ==> J ==> E ==> B ==> K ==> F ==> G ==> C ==> A`


## 层序遍历

这个也是我们最好理解的方式，就是一层一层的遍历

若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问

顺序如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/112.png)

遍历的顺序为 `A ==> B ==> C ==> D ==> E ==> F ==> G ==> H ==> I ==> J ==> K`


## 二叉树的建立和遍历

我们直接通过一个问题来进行了解，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/113.png)

要求建立一个二叉树并输出每个字符所在的层数，比如 `A` 在第一层，`B`、`C` 在第二层，`D`、`E` 在第三层

我们来看看如何实现

```c
#include <stdio.h>
#include <stdlib.h>

typedef char ElemType;

typedef struct BiTNode {
  char data;
  struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 创建一棵二叉树，约定遵循 前序遍历 的方式输入数据
CreateBiTree(BiTree *T) {
  char c;

  scanf("%c", &c);

  // 如果输入空格，则初始化为 NULL
  if (' ' == c) {
    *T = NULL;
  } else {
    *T = (BiTNode *)malloc(sizeof(BiTNode));
    (*T)->data = c;
    CreateBiTree(&(*T)->lchild);
    CreateBiTree(&(*T)->rchild);
  }
}

// 访问二叉树结点的具体操作
visit(char c, int level) {
  printf("%c 位于第 %d 层\n", c, level);
}

// 前序遍历二叉树（调整顺序只需要改变三者之间的顺序即可，以根结点来进行区分）
PreOrderTraverse(BiTree T, int level) {
  if (T) {
    visit(T->data, level);
    PreOrderTraverse(T->lchild, level + 1);
    PreOrderTraverse(T->rchild, level + 1);
  }
}

int main() {
  int level = 1;
  BiTree T = NULL;

  CreateBiTree(&T);
  PreOrderTraverse(T, level);

  return 0;
}
```

## JavaScript 中的二叉树

原理上是一致的，我们直接来看如何实现，同 `C` 语言的实现类似，改变顺序即为不同的遍历方式

```js
function BST() {

  // 首先创建一个类来表示二叉查找树，它的内部有一个 Node 类，用来创建节点
  var Node = function (key) {
    this.key = key,
      this.left = null,
      this.right = null
  }

  var root = null

  // 插入节点
  this.insert = function (key) {
    // 传入需要插入的 key 值，它会自动初始化为左右节点为 null 的一个新节点
    var newNode = new Node(key)
    if (root === null) {
      root = newNode
    } else {
      insertNode(root, newNode)
    }
  }

  // 通过递归来调用自身，来找到新添加节点的合适位置
  var insertNode = function (node, newNode) {
    if (newNode.key <= node.key) {
      if (node.left === null) {
        node.left = newNode
      } else {
        insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        insertNode(node.right, newNode)
      }
    }
  }

  // 中序遍历
  this.inOrderTraverse = function () {
    inOrderTraverseNode(root)
  }

  var inOrderTraverseNode = function (node) {
    // 检查传入的 node 是否为 null，如果不为空，就继续递归调用自身检查 node 的 left、right 节点
    if (node !== null) {
      inOrderTraverseNode(node.left)
      console.log(node.key)
      inOrderTraverseNode(node.right)
    }
  }

  // 实现先序遍历
  this.preOrderTraverse = function () {
    preOrderTraverseNode(root)
  }

  var preOrderTraverseNode = function (node) {
    if (node !== null) {
      console.log(node.key)
      preOrderTraverseNode(node.left)
      preOrderTraverseNode(node.right)
    }
  }

  // 后序遍历
  this.postOrderTraverse = function () {
    postOrderTraverseNode(root)
  }

  var postOrderTraverseNode = function (node) {
    if (node !== null) {
      postOrderTraverseNode(node.left)
      postOrderTraverseNode(node.right)
      console.log(node.key)
    }
  }
}

var arr = [13, 21, 15, 29, 3, 55]
var bst = new BST()

arr.map(item => {
  bst.insert(item)
})


bst.inOrderTraverse()
bst.preOrderTraverse()
bst.postOrderTraverse()
```

我们通过上面的方式实现了对二叉树的节点插入，和三种遍历方法，同时我们很明显可以看到，在二叉树当中，最左侧的节点的值是最小的，而最右侧的节点的值是最大的，所以二叉查找树可以很方便的拿到其中的最大值和最小值

另外可以发现，我们也并没有涉及到比如在二叉树当中查找给定的值，亦或者删除否个给定的值的操作，关于这些内容我们会在后面的二叉查找树当中来进行介绍