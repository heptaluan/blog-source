---
title: 线性表（链式存储结构）
date: 2020-02-20
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/07.jpg
---

之前我们介绍过了[线性表（顺序存储结构）](http://localhost:4000/2019/12/14/Essay/05/)，它最大的缺点就是插入和删除的时候需要移动大量元素，这显然就需要耗费时间

如果我们想要解决这个问题，就需要考虑一下是如何导致这个问题出现的原因

即为什么当插入和删除的时候，需要移动大量元素？

<!--more-->

原因就是在于相邻两元素的存储位置也具有邻居关系，它们在内存中的位置是紧挨着的，中间没有缝隙，所以无法快速的插入和删除

所以今天我们就来看一下链式存储结构


## 链式存储结构

线性表的链式存储结构的特点就是用一组任意的存储但愿存粗线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置

比起顺序存储结构每个数据元素只需要存储一个位置就可以了，而在链式存储结构中，除了要存储元素信息外，还要存储它的后继元素的存储地址（指针）

也就是说出了存储其本身的信息外，还需要存储一个指示其直接后继的存储位置的信息

我们把存粗数据元素信息的域称为**数据域**，把存储直接后继位置的域称为**指针域**，指针域中存储的信息称为**指针域链**

这两部分信息组成数据元素称为存储映像，也称之为**结点**（`node`）

> 这里有一个需要注意的地方，就是注意区分**节点**和**结点**，具体可以见下方



## 单链表

比如 `n` 个结点链接成一个链表，即为线性表（`a1`, `a2`, `a3` ... `an`）的链式存储结构

因为此链表的每个结点中只包含一个指针域，所以叫做单链表，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/05.png)

对于线性表来说，存在头部和尾部，链表也不例外

我们把链表中的第一个结点的存储位置称为**头指针**，最后一个结点称为**空**（`null`）

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/06.png)




## 头指针域头结点

通过之前的内容我们可以知道，头结点的数据域一般是不存储任何信息的，那么又与头指针有什么区别呢

* 头指针
  * 是指链表指向第一个结点的指针，如果链表有头结点，则是指向头结点的指针
  * 头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）
  * 无论链表是否为空，头指针**均不为空**
  * 头指针是链表的**必要元素**
* 头结点
  * 头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）
  * 有了头结点，对在第一元素结点前插入和删除的操作就可以与其他结点的操作相统一
  * 头结点不一定是链表的必须要素（**非必要元素**）

单链表的示例如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/07.png)

空链表的示例如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/08.png)




## 单链表存储结构

我们在 `C` 语言中可以使用结构指针来描述单链表

```c
typedef struct Node {
  ElemType data;      // 数据域
  struct Node* Next;  // 指针域
} Node;

typedef struct Node* LinkList;
```

再次强调，我们一般看到的结点是由**存放数据元素的数据域**和**存放后继结点地址的指针域**组成

比如我们假设 `p` 是指向线性表第 `i` 个元素的指针

则该结点 `ai` 的**数据域**我们可以用 `p -> data` 的值来进行表示（它是一个数据元素），而结点 `ai` 的指针域可以用 `p -> next` 来进行表示（它的值是一个指针）

所以我们可以推断出 `p -> next` 是指向第 `i + 1` 个元素的，也就是指向 `ai + 1` 的指针

同理，如果 `p -> data = ai`，那么 `p -> next -> data = ai + 1` 的



## 单链表的读取

在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的，直接获取元素的下标即可

但是在单链表中，由于第 `i` 个元素的位置我们是不知道的，所以必须要从第一个结点开始挨个查找

我们可以依靠上述所说首先整理出一个大体的思路
