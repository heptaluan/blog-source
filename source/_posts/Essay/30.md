---
title: 排序算法
date: 2020-03-04
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/30.jpg
---

今天我们来看看一个比较重要的算法，那就是 **排序算法**，排序算法在所有的算法当中应该算是应用最为广泛的一类算法

<!--more-->


## 基本概念

我们先来看官方定义，如下

假设含有 `n` 个记录的序列为 `{ r1, r2 ... rn }`，其相应的关键字分别为 `{ k1, k2 ... kn }`，需确定 `1, 2 ... n` 的一种排列 `p1, p2 ... pn`,使其相应的关键字满足 `kp1 <= kp2 <= ... <= kpn` 非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列 `{ rp1, rp2 ... rpn }`，这样的操作就称为排序

其实简单来说，在排序问题中，通常将数据元素称为记录，显然我们输入的是一个记录集合，排序后输出的也是一个记录集合，所以我们可以将排序看成是线性表的一种操作

排序的依据是关键字之间的大小关系，那么对同一记录集合，针对不同的关键字进行排序，可以得到不同序列


## 排序的稳定性

假设 `ki = kj（1 <= i <= n，1 <= j <=n， i != j）`，且在排序前的序列中 `ri` 领先于 `rj`（即 `i < j`）

* 如果排序后 `ri` 仍领先于 `rj`，则称所用的排序方法是稳定的
* 反之，若可能使得排序后的序列中 `rj` 领先 `ri`，则称所用的排序方法是不稳定的


## 排序算法性能

下面我们来看看影响排序算法性能的几个要素，主要有下面三个

* 时间性能，其实内排序主要进行的就是比较和移动，而高效率的内排序算法，应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数
* 辅助空间，优秀的排序算法是不需要太多的辅助空间的
* 算法的复杂性，这里不是指算法的时间复杂度，而是算法本身是否复杂


## 内部排序和外部排序

根据排序过程中涉及的存储器不同，可以将排序方法分为两大类，一类是内部排序，指的是待排序的几率存放在计算机随机存储器中进行的排序过程，另一类的外部排序，指的是排序中要对外存储器进行访问的排序过程（比如与硬盘进行数据交换等）

根据排序过程的时间复杂度来分，可以分为三类，简单排序、先进排序、基数排序

而在本章当中我们会介绍七种排序算法，其中 **冒泡排序**，**选择排序** 和 **插入排序** 属于简单的算法，而 **希尔排序**，**堆排序**，**归并排序** 和 **快速排序** 则属于改进后的算法，下面我们就从简单的开始，一个一个来看


## 冒泡排序

冒泡排序算法的原理如下

* 比较相邻的元素，如果第一个比第二个大，就交换它们两个
* 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，在这一点，最后的元素应该会是最大的数 
* 针对所有的元素重复以上的步骤，除了最后一个
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

也就是下图这样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-01.gif)

我们下面就可以对照着原理来尝试进行实现，如下

```js
// 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换
// 对所有元素均重复以上步骤，直至最后一个元素
function sort(arr) {
  var temp, l = arr.length - 1

  // 外循环为排序趟数，len 个数进行 len - 1 趟
  for (var i = 0; i < l; i++) {

    // 内循环为每趟比较的次数，第 i 趟比较 len - i 次
    for (var j = 0; j < l - i; j++) {

      // 相邻元素比较，若逆序则交换（升序为左大于右，降序反之）
      if (arr[j] > arr[j + 1]) {
        temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
    }
  }
  return arr
}

sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0])
```

这里需要注意的一点就是在于内层循环，第 `i` 趟只需要比较 `len - i` 次即可

但是还存在一些可以优化的空间，因为当数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到 `arr.length - 1` 次，因而后面的比较没有意义的

所以我们可以设置一个标志位，`flag`，如果发生了交换 `flag` 设置为 `true`，如果没有交换就设置为 `false`

这样当一轮比较结束后如果 `flag` 仍为 `false`，那么我们就可以知道这一轮是没有发生交换的，说明数据的顺序已经排好，没有必要继续进行下去

```js
function sort(arr) {
  // flag 为是否交换的标志
  var temp, flag
  for (var i = 0; i < arr.length - 1; i++) {

    // 每次遍历标志位都要先置为 false，才能判断后面的元素是否发生了交换
    flag = false

    // 选出该趟排序的最大值往后移动
    for (var j = arr.length - 1; j > i; j--) {
      if (arr[j - 1] > arr[j]) {
        temp = arr[j - 1]
        arr[j - 1] = arr[j]
        arr[j] = temp
        // 只要有发生了交换，flag 就置为 true
        flag = true
      }
    }
    // 判断标志位是否为 false，如果为 false，说明后面的元素已经有序，就直接 return
    if (!flag) break
  }
  return arr
}

sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0])
```

下面这种使用 `flag` 的方式，比较适用于序列当中有部分是已经是排序完成的，比如 `arr = [1, 0, 2, 3, 4, 5, 6, 7]` 这样的序列






## 选择排序

选择排序也是一种简单直观的排序算法，它的工作原理是这样的

第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（或最大）元素，然后放到已排序的序列的末尾，以此类推，直到全部待排序的数据元素的个数为零

但是需要注意的是，选择排序是不稳定的排序方法，下面我们来看看它的具体实现原理

* 简单来说就是，对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量 `k` 来记住他的位置，以此类推，等到循环结束的时候，我们就可以找到了最小的那个数的下标了
* 然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了，然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推

也就是下图这样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-02.gif)

下面我们来看代码如何实现

```js
function sort(arr) {
  var min, temp, l = arr.length
  for (var i = 0; i < l - 1; i++) {
    min = i
    for (var j = i + 1; j < l; j++) {
      if (arr[j] < arr[min]) {
        min = j
      }
    }

    // 第 i 个数与最小的数 arr[i] 交换
    if (min != i) {
      temp = arr[i]
      arr[i] = arr[min]
      arr[min] = temp
    }
  }
  return arr
}

sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0])
```



## 插入排序

插入排序（`Insertion sort`）是一种简单直观且稳定的排序算法，如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法 **插入排序法**

算法适用于少量数据的排序，时间复杂度 `O(n^2)`，是 **稳定** 的排序方法

插入排序的基本思想是，每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止

如果用现实当中的例子来看的话，就类似与我们的斗地主，在摸排阶段手里的牌都按照从小到大排序，如果每摸一张牌，我们就把他插入合适的位置，使得它比后面位置的牌小，比前面位置的牌大或者相等，这样的一种排序方法就是插入排序

下面我们来看一下插入排序的实现原理

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤 `3`，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复执行步骤二到五

所以我们可以考虑使用双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，与已排序的元素进行比较，小于则交换位置，大于则位置不动

也就是下图这样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-03.gif)

下面我们来看代码如何实现

```js
function sort(arr) {
  var temp
  for (var i = 1; i < arr.length; i++) {
    for (var j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
      temp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = temp
    }
  }
  return arr
}

sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0])
```



## 希尔排序

希尔排序是 **插入排序** 的一种，又称 **缩小增量排序**（`Diminishing Increment Sort`），是 **直接插入排序** 算法的一种更高效的改进版本，但是需要注意的是，希尔排序是非稳定排序算法

希尔排序的原理是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 `1` 时，整个文件恰被分成一组，算法便终止

希尔排序是基于 **插入排序** 的以下两点性质而提出改进方法的

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

该方法实质上是一种分组插入方法，它的原理是，先取一个正整数 `d1 < n`，把所有序号相隔 `d1` 的数组元素放一组，组内进行直接插入排序，然后取 `d2 < d1`，重复上述分组和排序操作，直至 `di = 1`，即所有记录放进一个组中排序为止

可以如下图所示，假设我们的初始化关键字如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-04.png)

然后我们将其先分为两组，然后分别对当前数组进行 **插入排序**，如下所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-05.png)

我们以 `49` 和 `13` 为起始，对比它们两者直接的大小，小的放左边，大的放右边，然后在比较 `38` 和 `27`，以此类推

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-06.png)

在第一趟结束以后，结果是下面这样的

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-07.png)

然后我们再将之前的数组再次分割，也就是下面这样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-08.png)

这次我们就以 `13，55，38，76` 为起始，依次比对，接下来就是 `27，04，65`，往后在以此类推

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-09.png)

第二趟结束以后，结果是下面这样的

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-10.png)

以此类推

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-11.png)

最终结果如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/30-12.png)

下面我们来看看如何用代码进行实现，其实我们的代码就是在 **插入排序** 的基础上来进行调整就可以来

```js
function sort(arr) {
  var temp, l = arr.length
  for (var gap = Math.floor(l / 2); gap > 0; gap = Math.floor(gap / 2)) {
    for (var i = gap; i < l; i++) {
      for (var j = i - gap; j >= 0 && arr [j] > arr[gap + j]; j -= gap) {
        temp = arr[j]
        arr[j] = arr[gap + j]
        arr[gap + j] = temp
      }
    }
  }
  return arr
}

sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0])
```

可以发现，我们的主体逻辑没有改变，而是仅仅只添加来一个 `gap` 变量来进行分组

最主要的变化就是之前的外层循环的判断条件由 `i = 1` 变成了 `i = gap`，内层循环的判断条件由 `var j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--` 变成了 `var j = i - gap; j >= 0 && arr [j] > arr[gap + j]; j -= gap`



