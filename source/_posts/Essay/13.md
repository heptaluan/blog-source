---
title: 递归
date: 2020-03-03
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/13.jpg
---

递归（`Recursion algorithm`）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法

递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念，绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归

在平常可以说是经常可以听到的概念，今天我们就来深入的了解一下，什么是递归，以及递归的一些相关应用

<!--more-->


## 什么是递归

简单来说，在编程语言中，函数直接或间接调用函数本身，则该函数称为**递归函数**

我们可以用数学代入法来理解，假设我们用递归来算阶乘 `f(n)`，常用的方式是这样的

```js
f = n => n === 1 ? 1 : n * f(n - 1) 
```

我们可以发现，在 `f` 的里面再次用到了 `f`，我们把它展开了来看看

```console
f(6)
=> 6 * f(5)
=> 6 * (5 * f(4))
=> 6 * (5 * (4 * f(3)))
=> 6 * (5 * (4 * (3 * f(2))))
=> 6 * (5 * (4 * (3 * (2 * f(1)))))
=> 6 * (5 * (4 * (3 * (2 * 1))))
=> 6 * (5 * (4 * (3 * 2)))
=> 6 * (5 * (4 * 6))
=> 6 * (5 * 24)
=> 6 * 120
=> 720 
```

也就是下图这样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/54.png)

通过上面的拆解，我们可以发现，其实就是先递进，再回归，而这就是「**递归**」


## 斐波那契数列

我们先来看看不使用递归如何来实现斐波那契（`Fibonacci`）数列，如下

```c
#include <stdio.h>

int main() {
  int i;
  int a[40];

  a[0] = 0;
  a[1] = 1;
  printf("%d %d ", a[0], a[1]);

  for (i = 2; i < 40; i++) {
    a[i] = a[i - 1] + a[i - 2];
    printf("%d ", a[i]);
  }

  return 0;
}
```

看上去就很麻烦的样子，下面我们在用递归的方式改写一下

```c
#include <stdio.h>

int Fib(int i) {
  if (i < 2) {
    return i == 0 ? 0 : 1;
  }

  return Fib(i - 1) + Fib(i - 2);
}

int main() {
  int i;
  for (i = 0; i < 40; i++) {
    printf("%d ", Fib(i));
  }

  return 0;
}
```

拆解后如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/55.png)



## 递归定义

之前我们通过了几个示例简单的了解了一下什么是递归，下面我们就来看看递归的具体含义

在高级语言中，函数自己调用和调用其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作**递归函数**

不过，递归程序最怕的就是陷入永不结束的无穷递归中，所以需要注意，每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值

比如之前我们的 `Fbi` 函数结束条件就是 `i < 2`

之前我们对比了两种实现斐波那契的代码，迭代和递归的区别是

* 迭代使用的是循环结构
* 递归使用的是选择结构

使用递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间，但大量的递归调用会建立函数的副本，会消耗大量的时间和内存，而迭代则不需要此种付出，所以需要根据当前环境进行考虑使用

递归函数分为调用和回退阶段，递归的回退顺序是它调用顺序的逆序


## 分治思想

分而治之的思想古已有之，秦灭六国，统一天下正是采取各个击破、分而治之的原则

而分治思想在算法设计中也是非常常见的，当一个问题规模较大且不易求解的时候，就可以考虑将问题分成几个小的模块，逐一解决

因为采用分治思想处理问题，其各个小模块通常具有与大问题相同的结构，这种特性也使递归技术有了用武之地

下面我们就通过一个实例来了解一下

## 折半查找算法

折半查找法是一种常用的查找方法，该方法通过不断缩小一半查找的范围，直到达到目的，所以效率比较高

比如有一个数组 `A[10]`，里面存放了 `10` 个整数

```c
A[10] = { 2, 3, 5, 7, 8, 10, 12, 15, 19, 21 }
```

任意输入一个用数字 `n`，用折半查找法找到 `n` 位于数组中的位置，如果 `n` 不属于数组 `A`，则显示错误提示

```c
#include <stdio.h>

int bin_search(int key[], int low, int high, int k) {
  
  int mid;
  
  if (low > high) {
    return -1;
  }  else {
    mid = (low + high) / 2;

    if (key[mid] == k)
      return mid;
    
    if (k > key[mid])
      // 在序列的后半部分查找
      return bin_search(key, mid + 1, high, k);
    else
      // 在序列的前半部分查找
      return bin_search(key, low, mid - 1, k);
  }
}

int main() {
  
  int n, i, addr;
  int A[10] = {2, 3, 5, 7, 8, 10, 12, 15, 19, 21};

  for (i = 0; i < 10; i++)
    // 显示数组A中的内容
    printf("%d ", A[i]);

  // 输入待查找的元素
  scanf("%d", &n);
  addr = bin_search(A, 0, 9, n);

  if (-1 != addr)
    // 查找成功
    printf("%d is at the %dth unit is array A\n ", n, addr);
  else
    // 查找失败
    printf("There is no %d in array A\n", n);

  getchar();
  
  return 0;
}
```


## 

