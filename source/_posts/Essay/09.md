---
title: 循环链表
date: 2020-02-02
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/09.jpg
---

之前我们介绍过了[单链表](http://localhost:4000/2020/02/20/Essay/07/)，对于单链表，由于每个结点只存储了向后的指针，到了尾部标识就停止了向后链的操作（也就是 `NULL`，空指针）

所以说按照这样的方式，只能索引后继结点而不能索引前驱结点，所引起的问题也是显而易见的

比如如果不从头结点出发，就无法访问到全部结点，遇到这种情况，我们就可以采用我们今天将要介绍到的**循环链表**

<!--more-->

## 循环链表

要解决上面的问题也并不麻烦，我们只需要将单链表中的终端结点的指针（`NULL`）由空指针改为指向头结点就可以解决

这样一来整个单链表就形成了一个环，这种头尾相接的单链表也就成为了**单循环链表**，简称**循环链表**

如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/16.png)

但是这里需要注意，并不是说循环链表一定要有头结点

其实**循环链表**和单链表的主要差异就在于循环的判断空链表的条件上

* 单链表只需要判断 `head -> next` 是否为 `null` 即可
* 但是单链表则需要判断 `head -> next` 是否等于 `head`

回到之前的问题，由于终端结点通常我们使用**尾指针**（`rear`）来进行指示，则查找终端结点是 `O(1)`，而开始结点则是 `rear -> next -> next`，所以当然也是 `O(1)`

也就是不以 `head` 作为定义，而已尾指针作为定义

下面我们就来看看**单循环链表**的初始化，删除，插入等方法的实现


#### 初始化

```c
/* 初始化循环链表 */
void ds_init(node **pNode) {
  int item;
  node *temp;
  node *target;

  printf("输入结点的值，输入 0 完成初始化\n");

  while (1) {
    scanf("%d", &item);
    fflush(stdin);

    if (item == 0)
      return;

    /* 循环链表中只有一个结点 */
    if ((*pNode) == NULL) { 
      *pNode = (node *)malloc(sizeof(struct CLinkList));

      if (!(*pNode))
        exit(0);

      (*pNode)->data = item;
      (*pNode)->next = *pNode;
    } else {
      /* 找到 next 指向第一个结点的结点 */
      for (target = (*pNode); target->next != (*pNode); target = target->next);

      /* 生成一个新的结点 */
      temp = (node *)malloc(sizeof(struct CLinkList));

      if (!temp)
        exit(0);

      temp->data = item;
      temp->next = *pNode;
      target->next = temp;
    }
  }
}

```



#### 插入结点

```c
/* 链表存储结构的定义 */
typedef struct CLinkList {
  int data;
  struct CLinkList *next;
} node;

/* 插入结点 */
/* 参数：链表的第一个结点，插入的位置 */
void ds_insert(node **pNode, int i) {
  node *temp;
  node *target;
  node *p;
  int item;
  int j = 1;

  printf("输入要插入结点的值:");
  scanf("%d", &item);

  // 新插入的结点作为第一个结点
  if (i == 1) { 
    temp = (node *)malloc(sizeof(struct CLinkList));

    if (!temp)
      exit(0);

    temp->data = item;

    /* 寻找到最后一个结点 */
    for (target = (*pNode); target->next != (*pNode); target = target->next);

    temp->next = (*pNode);
    target->next = temp;
    *pNode = temp;
  } else {
    target = *pNode;

    for (; j < (i - 1); ++j) {
      target = target->next;
    }

    temp = (node *)malloc(sizeof(struct CLinkList));

    if (!temp)
      exit(0);

    temp->data = item;

    p = target->next;
    target->next = temp;
    temp->next = p;
  }
}
```


#### 删除结点

```c
/* 删除结点 */
void ds_delete(node **pNode, int i) {
  node *target;
  node *temp;
  int j = 1;

  // 删除的是第一个结点
  if (i == 1) { 
    /* 找到最后一个结点 */
    for (target = *pNode; target->next != *pNode; target = target->next);

    temp = *pNode;
    *pNode = (*pNode)->next;
    target->next = *pNode;
    free(temp);
  } else {
    target = *pNode;

    for (; j < i - 1; ++j) {
      target = target->next;
    }

    temp = target->next;
    target->next = temp->next;
    free(temp);
  }
}
```

#### 返回结点所在位置

```c
/* 返回结点所在位置 */
int ds_search(node *pNode, int elem) {
  node *target;
  int i = 1;

  for (target = pNode; target->data != elem && target->next != pNode; ++i) {
    target = target->next;
  }

  /* 表中不存在该元素 */
  if (target->next == pNode)
    return 0;
  else
    return i;
}
```



## 约瑟夫问题

我们来看一个比较近经典的问题，约瑟夫问题

据说在罗马人占领乔塔帕特后，`39` 个犹太人与约瑟夫及他的朋友躲到一个洞中，`39` 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，`41` 个人排成一个圆圈，由第 `1` 个人开始报数，每报数到第 `3` 人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止

然而约瑟夫和他的朋友并不想遵从，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第 `16` 个与第 `31` 个位置，于是逃过了这场死亡游戏

我们可以用程序来进行模拟，就是用我们之前介绍过的循环链表，来把 41 人自杀的顺序编号进行输出

```c
// n 个人围着报数，报 m 出列，最后剩下的是几号
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
  int data;
  struct node *next;
}node;


node *create(int n) {
  node *p = NULL, *head;
  head = (node*)malloc(sizeof(node));
  
  p = head;
  node *s;
  int i = 1;
  
  if (0 != n) {
    while(i <= n) {
      s = (node *)malloc(sizeof(node));
      // 为循环列表初始化，第一个结点为 1，第二个结点为 2 ...
      s -> data = i++;
      p -> next = s;
      p = s;
    }
    s -> next = head -> next;
  }
  free(head);
  return s -> next;
}

int main() {
  int n = 41;
  int m = 3;
  int i;
  node *p = create(n);
  node *temp;
  
  m %= n;
  
  while(p != p -> next) {
    for (i = 1; i < m - 1; i++) {
      p = p -> next;
    }
    
    printf("%d->", p -> next -> data);
    
    // 删除第 m 个结点
    temp = p -> next;
    p -> next = temp -> next;
    
    free(temp);
    p = p -> next;
  }
  
  printf("%d\n", p -> data);
  return 0;
}
```

最终结果如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/17.png)

## 循环链表的特点

在单链表中，我们有了头结点时，我们可以用 `O(1)` 的时间访问第一个结点，但对于要访问最后一个结点，我们必须要挨个向下索引，所以需要 `O(n)` 的时间

如果使用循环链表的话，用 `O(1)` 的时间就可以由链表指针访问到最后一个结点，可以参考开头部分的单循环链表示意图

但是在此之前，我们先来稍微的调整一下，不再和开头的时候一样，而是采用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了

如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/18.png)

但是相对应的，我们的判断条件也需要相对的调整一下，即判断是否为空链表的条件应该调整为判断 `rear` 是否等于 `rear -> next`

循环链表的特点是无须增加存储量，仅对链接方式稍作改变，即可使得表处理更加方便灵活

下面我们来看一个实例加深一下印象

## 实例

比如现在我们要将两个线性表 `(a1, a2, ... an)` 和 `(b1, b2, ... bm)` 连接成一个线性表 `(a1, ... an, b1, ... bm)`

通过观察我们可以发现， 若在单链表或头指针表示的单循环表上做这种链接操作，都需要遍历第一个链表，找到结点 `an`，然后将结点 `b1` 链到 `an` 的后面，其执行时间是 `O(n)`

若在尾指针表示的单循环链表上实现，则只需修改指针，无须遍历，其执行时间是 `O(1)`，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/19.png)

代码如下

```c
// 假设 A，B 为非空循环链表的尾指针
LinkList Connect(LinkList A, LinkList B) {
  LinkList p = A->next;     // 保存 A 表的头结点位置
  A->next = B->next->next;  // B 表的开始结点链接到 A 表尾
  free(B->next);            // 释放 B 表的头结点
  B->next = p;
  return B;                 // 返回新循环链表的尾指针
}
```


## 判断单链表中是否有环

有环的定义是，链表的尾节点指向了链表中的某个节点，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/20.png)

我们可以发现在第六个位置的指针是指向第三个位置的，那么我们如何判断这种情况呢

主要有以下两种方法

* 方法一，使用 `p`、`q` 两个指针，`p` 总是向前走，但 `q` 每次都从头开始走，对于每个节点，看 `p` 走的步数是否和 `q` 一样，如上图当中，当 `p` 从 `6` 走到 `3` 时，用了 `6` 步，此时若 `q` 从 `head` 出发，则只需两步就到 `3`，因而步数不等，出现矛盾，即表示存在环
* 方法二，使用 `p`、`q` 两个指针，`p` 每次向前走一步，`q` 每次向前走两步，若在某个时候 `p == q`，则存在环

```c
#include "stdio.h"

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

typedef int Status;   /* Status 是函数的类型，其值是函数结果状态代码，如 OK 等 */
typedef int ElemType; /* ElemType 类型根据实际情况而定，这里假设为 int */

typedef struct Node {
  ElemType data;
  struct Node *next;
} Node, *LinkList;

/* 初始化带头结点的空链表 */
Status InitList(LinkList *L) {

  /* 产生头结点,并使L指向此头结点 */
  *L = (LinkList)malloc(sizeof(Node));

  if (!(*L))          /* 存储分配失败 */
    return ERROR;

  (*L)->next = NULL;  /* 指针域为空 */

  return OK;
}

/* 初始条件：顺序线性表 L 已存在，操作结果：返回 L 中数据元素个数 */
int ListLength(LinkList L) {
  int i = 0;
  /* p 指向第一个结点 */
  LinkList p = L->next;
  while (p) {
    i++;
    p = p->next;
  }
  return i;
}

/* 随机产生 n 个元素的值，建立带表头结点的单链线性表 L（头插法） */
void CreateListHead(LinkList *L, int n) {
  LinkList p;
  int i;

  /* 初始化随机数种子 */
  srand(time(0)); 

  *L = (LinkList)malloc(sizeof(Node));

  /* 建立一个带头结点的单链表 */
  (*L)->next = NULL; 

  for (i = 0; i < n; i++) {
    p = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */
    p->data = rand() % 100 + 1;         /* 随机生成 100 以内的数字 */
    p->next = (*L)->next;

    /*插入到表头 */
    (*L)->next = p;
  }
}

/*  随机产生 n 个元素的值，建立带表头结点的单链线性表 L（尾插法） */
void CreateListTail(LinkList *L, int n) {
  LinkList p, r;
  int i;

  srand(time(0));                      /* 初始化随机数种子 */
  *L = (LinkList)malloc(sizeof(Node)); /* L 为整个线性表 */
  r = *L;                              /* r 为指向尾部的结点 */

  for (i = 0; i < n; i++)
  {
    p = (Node *)malloc(sizeof(Node));  /* 生成新结点 */
    p->data = rand() % 100 + 1;        /* 随机生成 100 以内的数字 */
    r->next = p;                       /* 将表尾终端结点的指针指向新结点 */
    r = p;                             /* 将当前的新结点定义为表尾终端结点 */
  }

  r->next = (*L)->next->next;
}

// 比较步数的方法
int HasLoop1(LinkList L) {
  LinkList cur1 = L;            // 定义结点 cur1
  int pos1 = 0;                 // cur1 的步数

  while (cur1) {                // cur1 结点存在
    LinkList cur2 = L;          // 定义结点 cur2
    int pos2 = 0;               // cur2 的步数
    while (cur2) {              // cur2 结点不为空
      if (cur2 == cur1) {       // 当 cur1 与 cur2 到达相同结点时
        if (pos1 == pos2) {     // 走过的步数一样
          break;                // 说明没有环
        } else {
          printf("环的位置在第%d个结点处。\n\n", pos2);
          return 1;             // 有环并返回 1
        }
      }
      cur2 = cur2->next;        // 如果没发现环，继续下一个结点
      pos2++;                   // cur2 步数自增
    }
    cur1 = cur1->next;          // cur1 继续向后一个结点
    pos1++;                     // cur1 步数自增
  }
  return 0;
}

// 利用快慢指针的方法
int HasLoop2(LinkList L) {
  int step1 = 1;
  int step2 = 2;
  LinkList p = L;
  LinkList q = L;

  while (p != NULL && q != NULL && q->next != NULL) {
    p = p->next;
    if (q->next != NULL)
      q = q->next->next;

    printf("p:%d, q:%d \n", p->data, q->data);

    if (p == q)
      return 1;
  }
  return 0;
}

int main() {
  LinkList L;
  Status i;
  char opp;
  ElemType e;
  int find;
  int tmp;

  i = InitList(&L);
  printf("初始化L后：ListLength(L)=%d\n", ListLength(L));

  printf("\n1.创建有环链表（尾插法） \n2.创建无环链表（头插法） \n3.判断链表是否有环 \n0.退出 \n\n请选择你的操作：\n");
  while (opp != '0')
  {
    scanf("%c", &opp);
    switch (opp)
    {
    case '1':
      CreateListTail(&L, 10);
      printf("成功创建有环L(尾插法)\n");
      printf("\n");
      break;

    case '2':
      CreateListHead(&L, 10);
      printf("成功创建无环L(头插法)\n");
      printf("\n");
      break;

    case '3':
      printf("方法一: \n\n");
      if (HasLoop1(L))
      {
        printf("结论：链表有环\n\n\n");
      }
      else
      {
        printf("结论：链表无环\n\n\n");
      }

      printf("方法二：\n\n");
      if (HasLoop2(L))
      {
        printf("结论：链表有环\n\n\n");
      }
      else
      {
        printf("结论：链表无环\n\n\n");
      }
      printf("\n");
      break;

    case '0':
      exit(0);
    }
  }
}
```


## 魔术师发牌问题

最后我们再来看一个魔术师发牌问题，问题是这样的

魔术师利用一副牌中的 `13` 张黑牌，预先将他们排好后叠放在一起，牌面朝下，然后将最上面的那张牌数为 `1`，把他翻过来正好是黑桃 `A`，将黑桃 `A` 放在桌子上，第二次数 `1`，`2`，将第一张牌放在这些牌的下面，将第二张牌翻过来，正好是黑桃 `2`，然后依次进行，最后将 `13` 张牌全部翻出，准确无误

问题就是，牌的开始顺序是如何安排的？


```c
#include <stdio.h>
#include <stdlib.h>

#define CardNumber 13

typedef struct node {
  int data;
  struct node *next;
} sqlist, *linklist;

// 创建循环链表
linklist CreateLinkList() {
  linklist head = NULL;
  linklist s, r;
  int i;

  r = head;

  for (i = 1; i <= CardNumber; i++) {
    s = (linklist)malloc(sizeof(sqlist));
    s->data = 0;

    if (head == NULL)
      head = s;
    else
      r->next = s;

    r = s;
  }

  r->next = head;

  return head;
}

// 发牌顺序计算
void Magician(linklist head) {
  linklist p;
  int j;
  int Countnumber = 2;

  p = head;

  // 第一张牌放 1
  p->data = 1;

  while (1) {
    for (j = 0; j < Countnumber; j++) {
      p = p->next;
      // 该位置有牌的话，则忽略当前位置，转至下一个位置
      if (p->data != 0) {
        p->next;
        j--;
      }
    }

    if (p->data == 0) {
      p->data = Countnumber;
      Countnumber++;

      if (Countnumber == 14)
        break;
    }
  }
}

int main() {
  linklist p;
  int i;

  p = CreateLinkList();
  Magician(p);

  printf("按如下顺序排列：\n")
  for (i = 0; i < CardNumber; i++) {
    printf("黑桃%d ", p->data);
    p = p->next;
  }
  return 0;
}
```