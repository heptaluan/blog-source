---
title: 浏览器相关知识梳理
date: 2020-07-26
categories: Essay
tags: Essay
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/31.webp
---

最近在梳理浏览器相关知识，在这里大致的整理一下，其他相关内容可以参考 [前端知识体系整理](https://heptaluan.github.io/target/)，本章大致内容有下面这些

<!--more-->

* `HTTP` 请求流程
* 渲染机制
  * `DOM/CSSOM/渲染树`
  * 重绘/回流
* 用户认证（`Session/Cookie/Token/JWT`）
* 前端安全（`XSS/CSRF`）




## HTTP 请求流程

也算是一个比较久远的面试题了，题目是问在页面当中输入网址到网站打开的过程之中都经历了什么，这个在之前已经整理过了，详细可见 [浏览器输入网址到页面展示所经历的过程](https://heptaluan.github.io/2017/11/07/HTTP/01/)，大致的流程如下

* `DNS` 查询
* `ARP` 过程
* 使用套接字
* `HTTP` 协议
* `HTTP` 服务器请求处理
* 浏览器
* `HTML` 解析
* `CSS` 解析
* 页面渲染
* `GPU` 渲染
* 后期渲染与用户引发的处理






## 渲染机制

![](https://gitee.com/heptaluan/backups/raw/master/cdn/essay/00.png)

浏览器的渲染机制可以参考上图，大体流程如下

* `HTML` 和 `CSS` 经过各自解析，生成 `DOM` 树和 `CSSOM` 树
* 合并成为渲染树
* 根据渲染树进行布局
* 最后调用 `GPU` 进行绘制，显示在屏幕上

更多详细流程可以参考 [浏览器的渲染机制](https://heptaluan.github.io/2019/07/07/JavaScript/37/)，主要包括

* `FOUC`
* 页面解析和页面渲染
* 渲染机制
* 浏览器的渲染过程
* 关于 `CSSOM`

在这里可能遇到比较多的问题就是如何根据浏览器渲染机制加快首屏速度，可以从两个方面下手

* 优化文件大小，`HTML` 和 `CSS` 的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少 `CSS` 文件层级的方法来加快首屏速度
* 避免资源下载阻塞文档解析，浏览器解析到 `<script>` 标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把 `<script>` 标签放在底部，或者加上 `defer`、`async` 来进行异步下载





## 回流与重绘

这两点可能经常会弄混淆，它们两者的区别如下

* 当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流
* `DOM` 样式发生了变化，但没有影响 `DOM` 的几何属性时，会触发重绘，而不会触发回流

触发回流的情况有下面这些

* `DOM` 元素的几何属性（`width/height/padding/margin/border`）发生变化时会触发回流
* `DOM` 元素移动或增加会触发回流
* 读写 `offset/scroll/client` 等属性时会触发回流
* 调用 `window.getComputedStyle` 会触发回流

而重绘由于 `DOM` 位置信息不需要更新，省去了布局过程，因而性能上优于回流，所以在平时我们遇到较多的都是如何减少回流，方法有下面这些

* 使用 `class` 替代 `style`，减少 `style` 的使用
* 使用 `resize`、`scroll` 时进行防抖和节流处理，这两者会直接导致回流
* 使用 `visibility` 替换 `display: none`，因为前者只会引起重绘，后者会引发回流
* 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流
* 避免触发同步布局事件，我们在获取 `offsetWidth` 这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对 `offset/scroll/client` 等属性进行查询时都会触发回流
* 对于复杂动画效果，使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘

当我们在使用 `transform`、`opacity`、`filters` 等属性时，会直接在 `GPU` 中完成处理，这些属性的变化不会引起回流重绘，但是它也是存在一些缺点的，比如 `GPU` 渲染字体会导致字体模糊，过多的 `GPU` 处理会导致内存问题




## 用户认证

主要包括 `Cookie`、`Session`、`Token` 与 `JWT` 等相关内容，详细可见 [Cookie、Session、Token 与 JWT](https://heptaluan.github.io/2017/11/26/HTTP/02/)，主要内容包括以下这些

* 认证/授权/凭证
* 什么是 `Cookie`
* 什么是 `Session`
* 什么是 `Token`
* 什么是 `JWT`
* `Cookie` 和 `Session` 的区别
* `Token` 和 `Session` 的区别
* `Token` 和 `JWT` 的区别
* 常见的加密算法





## 安全

在这里我们简单的梳理一下几种常见的前端攻击方式以及如何进行应对，主要包括 `CSRF` 和 `XSS`

**CSRF**

`CSRF` 即 `Cross-site request forgery`（跨站请求伪造），是一种挟制用户在当前已登录的 `Web` 应用程序上执行非本意的操作的攻击方法

假如黑客在自己的站点上放置了其他网站的外链，例如 `www.weibo.com/api`，默认情况下浏览器会带着 `weibo.com` 的 `Cookie` 访问这个网址，如果用户已登录过该网站且网站没有对 `CSRF` 攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持，那么我们该如何防御 `CSRF` 攻击呢？常见的当时有以下这些

* 验证 `Token`，浏览器请求服务器时，服务器返回一个 `Token`，每个请求都需要同时带上 `Token` 和 `Cookie` 才会被认为是合法请求
* 验证 `Referer`，通过验证请求头的 `Referer` 来验证来源站点，但请求头很容易伪造
* 设置 `SameSite`，设置 `Cookie` 的 `SameSite`，可以让 `Cookie` 不随跨域请求发出，但浏览器兼容不一

**XSS**

`XSS` 即 `Cross Site Scripting`（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序，常见的例如在评论区植入 `JavaScript` 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取等，它的类型有以下这些

* 存储型，即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击，
* 反射型，攻击者将脚本混在 `URL` 里，服务端接收到 `URL` 将恶意代码当做参数取出并拼接在 `HTML` 里返回，浏览器解析此 `HTML` 后即执行恶意代码
* `DOM` 型，将攻击脚本写在 `URL` 中，诱导用户点击该 `URL`，如果 `URL` 被解析，那么攻击脚本就会被运行，和前两者的差别主要在于 `DOM` 型攻击不经过服务端

一般常见的防御 `XSS` 攻击的方式有以下这些

* 输入检查，对输入内容中的 `<script>`，`<iframe>` 等标签进行转义或者过滤
* 设置 `httpOnly`，很多 `XSS` 攻击目标都是窃取用户 `Cookie` 伪造身份认证，设置此属性可防止 `JavaScript` 获取 `Cookie`
* 开启 `CSP`，即开启白名单，可阻止白名单以外的资源加载和运行