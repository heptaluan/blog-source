---
title: 变量的赋值与深浅拷贝
date: 2018-01-14
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/24.jpg
---

在 `JavaScript` 中，变量的赋值分为 「传值」 与 「传址」

给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」

基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较

<!--more-->

```js
var num1 = 123;
var num2 = 123;
var num3 = num1;

num1 === num2;  // true
num1 === num3;  // true

num1 = 456;
num1 === num2;  // false
num1 === num3;  // false
```

引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较

```js
var arr1 = [1, 2, 3];
var arr2 = [1, 2, 3];
var arr3 = arr1;

arr1 === arr2;  // false
arr1 === arr3;  // true

arr3 = [1, 2, 3];
arr1 === arr3;  // false
arr2 === arr3;  // false
```


在 `JavaScript` 当中，拷贝分为浅拷贝和深拷贝，一般我们操作也只针对像 `Object`，`Array` 这样的复杂对象

简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级

## 浅拷贝

浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性

对于目标对象第一层为基本类型的数据，就是直接赋值，即「传值」

而对于目标对象第一层为引用数据类型的数据，就是直接赋与内存中的堆内存地址，即「传址」

实现的方法有很多种，第一种比较简单的对象复制的方法，就是使用 `JSON.stringify()` 方法，如下

```js
var newObject = JSON.parse(JSON.stringify(oldObject))
```

但是这种写法会存在一些问题，可能不是一种很好的方法，但能适用于部分场景，具体存在的问题可以参考 [JSON.parse() && JSON.stringify()](https://heptaluan.github.io/2017/07/06/JavaScript/23/)

另外还可以使用 `ES6` 内置的 `Object.assign(target, source1, source2, ...)` 方法

* 第一个参数是目标参数，后面是需要合并的源对象可以有多个，后合并的属性（方法）会覆盖之前的同名属性（方法）

* 需要注意 `Object.assign()` 进行的拷贝是浅拷贝

```js
const obj1 = { a: { b: 1 } }
const obj2 = Object.assign({}, obj1)

obj2.a.b = 3
obj2.aa = 'aa'

console.log(obj1.a.b)  // 3
console.log(obj2.a.b)  // 3

console.log(obj1.aa)   // undefined
console.log(obj2.aa)   // aa
```

下面是一个比较通用的简单浅复制的实现

```js
var obj = { a: 1, arr: [2, 3] };
var shallowObj = shallowCopy(obj);

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}
```

因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 `JavaScript` 存储对象都是存地址的

所以浅复制会导致 `obj.arr` 和 `shallowObj.arr` 指向**同一块内存地址**

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/16.png)

所以

```js
shallowObj.arr[1] = 5;

obj.arr[1]   // = 5
```

## 深拷贝

深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性

一般来说，在 `JavaScript` 中考虑复合类型的深层复制的时候，往往就是指对于 `Date`，`Object` 和 `Array` 三个复合类型的处

一般简单的处理方式是建立一个新的空对象，然后递归遍历旧的的对象，直到发现基础类型的子节点才赋予到新对象对应的位置

不过这个方法存在一个问题，就是 `JavaScript` 中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后需要考虑原型应不应该被赋予给新对象

一般在使用过程中，我们通常会使用 `hasOwnProperty` 方法来进行判断是否过滤掉那些继承自原型链上的属性

先来看看一个简单的实现

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/17.png)

对于一个复杂的数组对象，要做到深度拷贝（采用递归的方式），在每次遍历之前创建一个新的对象或者数组，从而开辟一个新的存储地址，这样就切断了引用对象的指针联系

```js
function deepCopy(o) {

  // 根据传入的元素判断是数组还是对象
  let c = o instanceof Array ? [] : {};

  for (let i in o) {
    // 注意数组也是对象类型，如果遍历的元素是对象，进行深度拷贝
    c[i] = typeof o[i] === 'object' ? deepCopy(o[i]) : o[i];
  }

  return c;
}
```

下面这个则是较为完善的实现

```js
function _isPlainObject(target) {
  return (typeof target === 'object' && !!target && !Array.isArray(target));
}

function shallowExtend() {
  var args = Array.prototype.slice.call(arguments);
  // 第一个参数作为 target
  var target = args[0];
  var src;
  target = _isPlainObject(target) ? target : {};
  // 从 1 开始循环
  for (var i = 1; i < args.length; i++) {
    src = args[i];
    if (!_isPlainObject(src)) {
      continue;
    }
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        if (src[key] != undefined) {
          target[key] = src[key];
        }
      }
    }
  }
  return target;
}

var target = {
  key: 'value',
  num: 1,
  bool: false,
  arr: [1, 2, 3],
  obj: {
    objKey: 'objValue'
  },
};

var result = shallowExtend({}, target, {
  key: 'changeValue',
  num: 2
})

// 对原引用类型数据做修改
target.arr.push(4);

console.log(target.arr === result.arr)  // true
console.log(result)

// {
//   key: 'changeValue',
//   num: 2,
//   bool: false,
//   arr: [1, 2, 3, 4],
//   obj: {
//     objKey: 'objValue'
//   },
// }
```




## JavaScript 中的 mixin


`JavaScript` 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承，可以使用 `mixin`

`mixin` 简单通俗的讲就是把一个对象的方法和属性拷贝到另一个对象上（和继承有区别）

`mixin` 就是一个正常的类，不仅定义了接口，还定义了接口的实现

子类通过在 `this` 对象上面绑定方法，达到多重继承的目的

一个简单的 `mixin`

```js
function extend(destClass, srcClass) {
  var destProto = destClass.prototype;
  var srcProto = srcClass.prototype;
  for (var method in srcProto) {
    if (!destProto[method]) {
      destProto[method] = srcProto[method];
    }
  }
}

function Book() { }
Book.prototype.printName = function () {
  console.log('I am a book, named hello');
};

function JS() { }

extend(JS, Book);

var js = new JS();
js.printName()
```

`mixin` 实现多继承

```js
function extend(destClass) {
  var classes = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < classes.length; i++) {
    var srcClass = classes[i];
    var srcProto = srcClass.prototype;
    var destProto = destClass.prototype;
    for (var method in srcProto) {
      if (!destProto[method]) {
        destProto[method] = srcProto[method];
      }
    }
  }
}

function Book() { }
Book.prototype.getName = function () { };
Book.prototype.setName = function () { };

function Tech() { }
Tech.prototype.showTech = function () { };

function JS() { }

extend(JS, Book, Tech);
var js = new JS();
console.log(js.__proto__);
```

很多前端库里都有 `mixin` 方法，比如 `jQuery` 的 `extend`，`Underscore` 中的 `_.extend`

> `jQuery` 中的 `extend` 的实现可见 [jQuery.extend([deep], target, object1[, objectN])](https://heptaluan.github.io/2017/07/16/jQuery/05/#jQuery-extend-deep-target-object1-objectN)
