---
title: JavaScript 中的深浅拷贝
date: 2018-01-14
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/24.webp
---

在深入深浅拷贝之前，我们先来了解一些关于 `JavaScript` 当中变量的一些知识点

<!--more-->

## 数据类型

我们都知道，在 `JavaScript` 中，变量包含两种不同数据类型的值「基本类型」和「引用类型」，在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值

* 基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值
* 引用类型的值是保存在内存中的对象

与其他语言不同，`JavaScript` 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，所以在操作对象时，实际上是在操作对象的引用而不是实际的对象


## 变量的存储方式

在 `JavaScript` 中，变量的存储方式主要分为栈（`Stack`）和堆（`Heap`）两种

* 栈，自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址
* 堆，动态分配的内存，大小不定，也不会自动释放，里面存放引用类型的值


## 变量的赋值

通过上面的介绍我们可以知道，变量的赋值行为可以分为「传值」与「传址」两种，给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」，基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较

```js
var a = 123
var b = 123
var c = a

a === b  // true
a === c  // true

a = 456
a === b  // false
a === c  // false
```

引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较

```js
let a = ['a', 'b', 'c']
let b = a
b.push('d')

console.log(a)  // ['a', 'b', 'c', 'd']
console.log(b)  // ['a', 'b', 'c', 'd']
```

由于 `a` 和 `b` 都是引用类型，采用的是「址」传递，即 `a` 将地址传递给 `b`，那么 `a` 和 `b` 必然指向同一个地址（引用类型的地址存放在栈内存中），而这个地址都指向了堆内存中引用类型的值，当 `b` 改变了这个值的同时，因为 `a` 的地址也指向了这个值，故 `a` 的值也跟着变化，那么如何解决这样的问题呢，这就可以引出我们今天的主题，浅拷贝或者深拷贝了

> 但是这里有个需要注意的地方，即 `JavaScript` 中的深浅拷贝主要是针对于引用类型而言




## 什么是深浅拷贝

* 浅拷贝，是指复制对象的时候，只对第一层键值对进行独立的复制，并不会进行递归复制，如果对象内还有对象，则只能复制嵌套对象的地址
* 深拷贝，是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个
  * 其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部一一进行复制即可



## 浅拷贝

简单来说，浅拷贝就是先设置一个新的对象，通过遍历的方式将旧对象的值一一赋值给新对象，我们先来看看数组当中的浅拷贝


#### 数组的浅拷贝

通过前面所说的逻辑，我们可以尝试使用最基本的方式来进行实现，如下

```js
let arr1 = [1, 2, 3]
let arr2 = []

for (let i in arr1) {
  arr2[i] = arr1[i]
}

arr2.push(4)

console.log(arr1)  // [1, 2, 3]
console.log(arr2)  // [1, 2, 3, 4]
```

但是对于数组而言，并不需要这么复杂，我们可以利用数组的一些方法比如 `slice()`、`concat()` 等返回一个新数组的特性来实现拷贝

```js
let arr1 = [1, 2, 3]
// let arr2 = arr1.slice()
let arr2 = arr1.concat()

arr1.push(4)

console.log(arr1)  // [1, 2, 3, 4]
console.log(arr2)  // [1, 2, 3]
```

但是如果数组嵌套了对象或者数组的话

```js
let arr1 = [1, 2, { a: 1 }]
let arr2 = arr1.concat()

arr1[2].a = 2

console.log(arr1)  // [1, 2, { a: 2 }]
console.log(arr2)  // [1, 2, { a: 2 }]
```

我们会发现，无论是新数组还是旧数组都发生了变化（使用之前的 `for` 循环结果也是一致的），也就是说使用 `concat` 方法，克隆的并不彻底，只是一种浅拷贝，另外还有 `...`（扩展运算符）也算是浅拷贝

```js
let arr1 = [1, 2, { a: 1 }]
let arr2 = [...arr1]

arr1[2].a = 2

console.log(arr1)  // [1, 2, { a: 2 }]
console.log(arr2)  // [1, 2, { a: 2 }]
```


#### 对象的浅拷贝

同理，跟数组的基本实现的方法有些类似，如下

```js
let obj1 = {
  a: '1',
  b: '2',
  c: '3'
}

let obj2 = {}

for (let i in obj1) {
  obj2[i] = obj1[i]
}

obj2.d = '4'

console.log(obj1)  // {a: '1', b: '2', c: '3'}
console.log(obj2)  // {a: '1', b: '2', c: '3', d: '4'}
```

我们也将其中一个变量调整为对象试试

```js
let obj1 = {
  a: '1',
  b: '2',
  c: { a: 1 }
}

let obj2 = {}

for (let i in obj1) {
  obj2[i] = obj1[i]
}

obj1.c.a = 2

console.log(obj1)  // { a: '1', b: '2', c: { a: 2 } }
console.log(obj2)  // { a: '1', b: '2', c: { a: 1 } }
```

发现结果还是一样的，克隆的并不彻底，另外还有一个比较常见的方法，即 `Object.assign()`，它的第一个参数是目标参数，后面是需要合并的源对象可以有多个，后合并的属性（方法）会覆盖之前的同名属性（方法），不过需要注意的是，`Object.assign()` 进行的拷贝是浅拷贝，因为它只复制第一层的内容

```js
let obj1 = {
  a: 1,
  b: 2,
  c: { a: 3 }
}

let obj2 = Object.assign({}, obj1)
obj2.c.a = 4

console.log(obj1)  // {a: 1, b: 2, c: { a: 4 }}
console.log(obj2)  // {a: 1, b: 2, c: { a: 4 }}
```

所以说如果对象内还有对象，则只能复制嵌套对象的地址，无法进行深层次的拷贝，下面是一个比较通用的浅拷贝的实现

```js
function shallowCopy(obj) {
  var newObj = {}
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      newObj[prop] = obj[prop]
    }
  }
  return dst
}
```

简单来说就是创建一个新对象，然后将旧的对象当中的属性使用 `for-in` 循环依次复制到新对象身上


## 深拷贝

所以在这种情况我们可以使用深拷贝来完成，所谓深拷贝，就是能够实现真正意义上的数组和对象的拷贝

#### 数组的深拷贝

> 这里需要注意，如果目标数组是内部不包含对象的一维数组，使用 `Array.slice()` 和 `Array.concat()` 方法是可以达到深拷贝的目的的

我们先来看一种比较简单方法，不仅适用于数组还适用于对象，不过存在一些小问题，就是不能拷贝函数等一些特殊的对象（也就是 `JSON.stringify()` 方法所不支持的部分），如下

```js
let arr1 = {
  a: 1,
  b: 2,
  c: {
    name: 3
  },
  d: _ => {
    console.log(`test`)
  },
  e: ['1', undefined, undefined]
}

let arr2 = JSON.parse(JSON.stringify(arr1))
arr2.c.name = 4

console.log(arr1)  // { a: 1, b: 2, c: { name: 3 }, d: _ => { console.log(`test`) }, e: ['1', undefined, undefined] }
console.log(arr2)  // { a: 1, b: 2, c: { name: 4 }, e: ['1', null, null] }
```

通过上面的示例可以发现，这种写法是会存在一些问题的，但也能适用于部分场景，比如需要拷贝的对象内部没有一些特殊的字符，关于具体存在的问题可以参考 [JSON.parse() && JSON.stringify()](https://heptaluan.github.io/2017/07/06/JavaScript/23/)


#### 对象的深拷贝

那么如何实现一个深拷贝呢？根据前面的了解我们可以知道，主要问题就是出现在对象内还有对象的情况下，那么如果在这种情况下，我们只需递归调用我们的拷贝函数即可，具体原理就是我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数就好了，如下

```js
let deepCopy = function (obj) {
  // 只拷贝对象
  if (typeof obj !== 'object') return
  // 根据 obj 的类型判断是新建一个数组还是对象
  let newObj = obj instanceof Array ? [] : {}
  // 遍历 obj，并且判断是 obj 的属性才拷贝
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 如果 obj 的子属性是对象，则进行递归操作,否则直接赋值
      newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
    }
  }
  return newObj
}
```

当然在平常开发过程中也不需要一味的去使用深拷贝，因为深拷贝使用了递归，性能会不如浅拷贝，还是需要根据实际情况进行选择比较妥善，下面我们在来看看 `JavaScript` 当中的 `Mixin`，来与上面我们介绍过的深浅拷贝做一个对比




## JavaScript 中的 Mixin

`JavaScript` 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承，可以尝试使用 `Mixin`，`Mixin` 简单通俗的讲就是把一个对象的方法和属性拷贝到另一个对象上（但是和继承有所区别）

其实简单来说，`Mixin` 就是一个正常的类，不仅定义了接口，还定义了接口的实现，子类通过在 `this` 对象上面绑定方法，达到多重继承的目的，比如下面这个简单的 `Mixin`

```js
function mixin(destClass, srcClass) {
  var destProto = destClass.prototype
  var srcProto = srcClass.prototype
  for (var method in srcProto) {
    if (!destProto[method]) {
      destProto[method] = srcProto[method]
    }
  }
}

function Parent() { }
Parent.prototype.say = function () {
  console.log('hello')
}

function Child() { }

mixin(Child, Parent)

var child = new Child()
child.say()  // hello
```

再比如下面这个 `Mixin` 实现多继承

```js
function mixin(destClass) {
  var classes = Array.prototype.slice.call(arguments, 1)
  for (var i = 0; i < classes.length; i++) {
    var srcClass = classes[i]
    var srcProto = srcClass.prototype
    var destProto = destClass.prototype
    for (var method in srcProto) {
      if (!destProto[method]) {
        destProto[method] = srcProto[method]
      }
    }
  }
}

function Parent() { }
Parent.prototype.getName = function () { }
Parent.prototype.setName = function () { }

function Child() { }
Child.prototype.showName = function () { }

function Man() { }

mixin(Man, Child, Parent)
var man = new Man()

console.log(man.__proto__)
// {
//   getName: ƒ ()
//   setName: ƒ ()
//   showName: ƒ ()
//   constructor: ƒ Man()
// }
```

很多前端库里都有 `Mixin` 方法，比如 `jQuery` 的 `extend`，`Underscore` 中的 `_.extend`

> `jQuery` 中的 `extend` 的实现可见 [jQuery.extend([deep], target, object1[, objectN])](https://heptaluan.github.io/2017/07/16/jQuery/05/#jQuery-extend-deep-target-object1-objectN)


