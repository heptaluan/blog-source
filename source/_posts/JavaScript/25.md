---
title: JavaScript 中的类型判断
date: 2018-03-17
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/25.webp
---

> 最后更新于 `2020-05-25`

`JavaScript` 由于各种各样的原因，在判断一个变量的数据类型方面一直存在着一些问题，其中最典型的问题恐怕就是 `typeof null` 会返回 `Object`，关于这个问题简单来说，`JavaScript` 中的数据在底层是以二进制存储，比如 `Null` 所有存储位都是 `0`，但是底层的判断机制，只要前三位为 `0`，就会判定为 `Object`，所以才会有 `typeof null === 'object'` 这个结果，更多相关内容可以参考 [The history of typeof null](https://2ality.com/2013/10/typeof-null.html) 这篇文章，本章就不详细展开了，我们在这里只是简单的总结一下判断数据类型时常见的陷阱，以及正确的处理姿势

在 `JavaScript` 规范中，共定义了八种数据类型（截止本文最后更新时间），分为「基本类型」和「引用类型」两大类

<!--more-->

## 基本类型

* 基本类型有 `Number`、`String`、`Boolean`、`Undefined`、`Null`，`BigInt`、`Symbol`（`ES6` 新增）
* 引用类型有 `Object`

这里有一个需要注意的就是，我们所提及的基本类型当中的 `Number`、`String`、`Boolean` 是非内置函数（`new`）生成的，不是包装对象，如果你希望检测一个值是否为基本类型，最佳选择是使用 `typeof` 运算符

* 对于数字类型的值，`typeof` 会返回 `number`（`NaN` 也是一个数字类型，因为它在 `JavaScript` 中代表的是特殊非数字值）
* 对于字符串类型的值，`typeof` 会返回 `string`
* 对于布尔类型的值，`typeof` 会返回 `boolean`
* 对于函数类型而言，`typeof` 返回 `function`
* 对于 `Symbol` 类型而言，`typeof` 返回 `Symbol`
* 如果运算数没有定义（不存在或未赋值），将会返回 `undefined`

`typeof` 运算符的独特之处在于，将其用于一个未声明的变量也不会报错，未定义的变量和值为 `undefined` 的变量通过 `typeof` 都将返回 `'undefined'`，最后一个原始值 `null`，一般不用于检测语句，但有一个例外，如果所期望的值真的是 `null`，则可以直接和 `null` 进行比较，这时应当使用 `'==='` 或者 `'!=='` 来和 `null` 进行比较

```js
var element = document.getElementById('myDiv')

if (element !== null) {
  element.classList.add('found')
}
```

如果 `DOM` 元素不存在，则通过 `document.getElementById()` 得到的值为 `null`，这个方法要么返回一个节点，要么返回 `null`，由于这时的 `null` 是可预见的一种输出，则可以使用 `!==` 来检测返回结果，这里还有一个特殊的值需要单独处理一下，那就是 `NaN`，如果使用 `typeof` 的话，返回的结果将是 `number`

```js
typeof NaN  // number
```

也许你会想到 `isNaN` 这个方法，如下

```js
isNaN(NaN)          // true  不能转换
isNaN('123')        // false 可以转换
isNaN('abc')        // true  不能转换
isNaN('123ab')      // true  不能转换
isNaN('123.45abc')  // true  不能转换
```

可以看出，`isNaN()` 没有办法判断某个值本身是否为 `NaN`，如果想判断某个值是否为 `NaN`，可以采用 `NaN` 不等于自身这一特性来判断

```js
function valueIsNaN(value){
  return value !== value
}
```

最后在来简单的介绍一下 `BigInt` 这个类型，`BigInt` 主要是用于解决使用 `Number` 类型的限制，比如无法精确表示的非常大的整数等，因为在 `JavaScript` 当中缺少显式整数类型，所以它无法精确表示的非常大的整数，而会自动的四舍五入，比如

```js
9007199254740992 === 9007199254740993    // true

console.log(9999999999999999)            // 10000000000000000
```

其实在之前，`JavaScript` 也提供了 `Number.MAX_SAFE_INTEGER` 和 `Number.MIN_SAFE_INTEGER` 常量来表示最大（最小）安全整数，但是在进行计算的时候也存在一定的误差，如下

```js
const minInt = Number.MIN_SAFE_INTEGER

console.log(minInt)      // -9007199254740991

// 注意两者结果的对比
console.log(minInt - 5)  // -9007199254740996
console.log(minInt - 4)  // -9007199254740996
```

所以在这种情况之下，我们就可以考虑来使用 `BigInt`，使用了 `BigInt` 以后就可以在标准的 `JavaScript` 当中执行对大整数的算术运算，而不会有精度损失的风险，下面我们来看看如何进行使用，如果要创建 `BigInt`，只需在整数的末尾追加 `n` 即可，如下

```js
console.log(9007199254740995n)  // 9007199254740995n
console.log(9007199254740995)   // 9007199254740996
```

或者，可以调用 `BigInt()` 构造函数来进行实现

```js
BigInt('9007199254740995')      // 9007199254740995n
```

但是需要注意的是，不能使用严格相等运算符将 `BigInt` 与常规数字进行比较，因为它们的类型不同

```js
console.log(10n === 10)         // false

console.log(typeof 10n)         // bigint
console.log(typeof 10)          // number
```

相反，可以使用等号运算符，它在处理操作数之前执行隐式类型转换

```js
console.log(10n == 10)          // true
```

其他更多内容在这里也就不具体展开了，感兴趣的话可以自行查阅相关内容


## 引用类型

在 `JavaScript` 中除了基本类型之外的值都是引用，有这几种内置的引用的类型 `Object`，`Array`，`Error`，`Date`，`typeof` 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 `'object'`

```js
console.log(typeof {})            // 'object'

console.log(typeof [])            // 'object'

console.log(typeof new Date())    // 'object'

console.log(typeof new RegExp())  // 'object'
```

`typeof` 另外一种不推荐的用法是检测 `Null` 的类型的时候，将会返回 `'object'`

```js
console.log(typeof null)          // 'object'
```

所以，在检测某个引用值的类型的最好的方法是使用 `instanceof` 运算符

```js
// 检测日期
if (value instanceof Date) {
  console.log(value.getFullYear())
}
 
// 检测正则表达式
if (value instanceof RegExp) {
  if (value.test(anotherValue)) {
    console.log('Matches')
  }
}
 
// 检测 Error
if (value instanceof Error) {
  throw value
}
```

`instanceof` 的一个有意思的特征是它不仅检测构造这个对象的构造器，还检测原型链，原型链包含了很多信息，包括定义对象所采用的继承模式，比如，默认情况下，每个对象都继承自 `Object`，因此每个对象的 `value instanceof Object` 都会返回 `true`

```js
var now = new Date()

console.log(now instanceof Date)    // true
console.log(now instanceof Object)  // true
```

正因为这个原因，使用 `value instanceof Object` 来判断对象是否属于某个特定类型的做法并非最佳，`instanceof` 运算符也可以检测自定义的类型

```js
function Person(name) {
  this.name = name
}

var me = new Person('zhangsan')

console.log(me instanceof Person)   // true
console.log(me instanceof Object)   // true
```

变量 `me` 是 `Person` 的实例，因此 `me instanceof Person` 返回的是 `true`，之前也提到过，所有对象都被认为是 `Object` 的实例，故也返回 `true`，在 `JavaScript` 中检测自定义类型的时候，最好的做法就是使用 `instanceof` 运算符，这也是唯一的方法，但是也有例外，假设在一 `iframeA` 中的一个对象被传入到了 `iframeB` 中，两个 `iframe` 中都定义了构造函数 `Person`，如果来自 `A` 的对象是 `A` 的 `Person` 的实例，则如下规则成立

```js
// true
frameAPersonInstance instanceof frameAPersonInstance

// false
frameAPersonInstance instanceof frameBPersonInstance
```

因为每个 `iframe` 内都有用 `Person` 的一份 `copy`，它被认为是该 `iframe` 中的 `Person` 拷贝的实例，尽管两个定义可能完全不一样，这个问题不仅出现在自定义类型身上，其他两个非常重要的内置类型也有这个问题，也就是函数和数组，对于这两个类型来说，一般不使用 `instanceof`




## 函数检测

从技术上讲，`JavaScript` 中的函数是引用类型，同样存在 `Function` 构造函数，每个函数都是其实例，比如

```js
function myFunc () {}

// 不推荐
console.log(myFunc instanceof Function)    // true
```

然而，这个方法并不能跨 `iframe` 使用，因为每个 `iframe` 中都有各自的 `Function` 构造函数，好在 `typeof` 运算符也可以用于函数

```js
function myFunc () {}

// 推荐，返回的是 function
console.log(typeof myFunc === 'function')  // true
```

检测函数最好的方法是使用 `typeof` ，因为它可以跨 `iframe` 使用





## 数组检测

在没有 `isArray` 方法之前，一般会采用如下方式来进行判断

```js
var isArray = function (value) {
  return value && typeof value === 'object' && value.constructor === 'Array'
}
```

上面这个方法在 从不同的窗口（`window/iframe`）里构造的数组的时候会失败，所以我们不得不考虑更多

```js
var isArray = function (value) {
  return value && typeof value === 'object'
    && typeof value.length === 'number'
    && typeof value.slice === 'function'
    && !(value.propertyIsEnumerable('length'))
}
```

大致的流程如下

* 首先，我们要判断这个值是否为真，不接受 `null` 和其他为假的值
* 其次判断 `typeof` 运算的结果是否为 `Object`，对于对象，数组和 `null` 来说，返回的是 `true`（但是对于对象来说并非如此）
* 然后判断这个值是否包含一个 `splice` 的方法，对于数组来说，又将会得到 `true`
* 最后判断 `length` 属性是否是可枚举的，对于数组来说，将得到 `false`

但是在 `ES5` 之后，将 `Array.isArray()` 正式的引入，唯一的目的就是检测一个值是否为数组

```js
function isArray (value) {
  if (typeof Array.isArray === 'function') {
    return Array.isArray(value)
  } else {
    return Object.prototype.toString.call(value) === '[object Array]'
  }
}
```

关于使用 `Object.prototype.toString.call()` 有一些需要注意的地方，这种方法在识别内置对象的时候往往十分有用，但是对于自定义对象请不要使用这种方法，比如内置的 `JSON` 对象将返回 `'[object JSON]'`，关于这个方法的更多内容会在下面进行介绍



## 属性检测

另外一种用到 `null`（和 `Undefined`）的场景是当检测一个属性是否在对象中存在的时候，比如

```js
// 不推荐的写法，检测假值
if (object[prototype]) {
  // ...
}

// 不推荐的写法，与 null 比较
if (object[propertyName] !== null) {
  // ...
}

// 不推荐的写法，与 undefined 比较
if (object[propertyName] !== undefined) {
  // ...
}
```

以上代码的每个判断，实际上是通过给定的名字来检查属性的值，而非判断给定的名字的所指的属性是否存在，因为当这些属性值为假值（`false value`）的时候，结果会出错，比如 `0`， `null`， `Undefined`， `false`， `''`（空字符串）

判断属性是否存在的最好的方法是使用 `in` 运算符，`in` 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值，如果实例对象的属性存在，或者继承自对象的原型，`in` 运算符都会返回 `true`

```js
var object = {
  count: 0,
  related: null
}
 
// 推荐
if ('count' in object) {
  // ...
}
 
// 不推荐
if (object['count']) {
  // ...
}
```

如果你只想检查实例对象的某个属性是否存在，则使用 `hasOwnProperty()` 方法，所有继承自 `Object` 的对象都有这个方法，如果实例中存在这个属性则返回 `true`

> 需要注意的是，如果这个属性只存在原型里，则会返回 `false`

但是在 `IE8` 以及更早的版本中，`DOM` 对象并非继承自 `Object`，因此也不包含这个方法，也就是说，你在调用 `DOM` 对象的 `hasOwnProperty()` 方法之前应当先检测其是否存在（如果你已经知道对象不是`DOM`，则可以省略这一步）

```js
// 对于所有非 DOM 对象来说，这是好的写法
if (object.hasOwnProperty('count')) {
  // ...
}

// 如果你不确定是否为 DOM 对象，则可以这样写
if ('hasOwnProperty' in object && object.hasOwnProperty('count')) {
  // ...
}
```

在判断实例对象是否存在的时候，推荐使用 `in` 运算符，只有在需要判断实例属性的时候才会用到 `hasOwnProperty()`，不管你什么时候需要检测属性的存在性，请使用 `in` 运算符或者 `hasOwnProperty()`，这样可以避免很多错误



## instanceof

该「运算符」用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

```js
function Person(name, age) {
  this.name = name
  this.age = age
}

const man = new Person('zhangsan', 20)

man instanceof Person  // true
man instanceof Object  // true
```

但是需要注意的是，比如我们要检测对象不是某个构造函数的实例时，通常会这样做

```js
if (!(man instanceof Person)) {
  // ...
}
```

但是千万别省略掉了括号

```js
if (!man instanceof Person)
```

这段代码永远会得到 `false`，因为 `!man` 将在 `instanceof` 之前被处理，所以你总是在验证一个布尔值是否是 `Person` 的一个实例，所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`

```js
var fn = function () { }

console.log(fn instanceof Function)  // true
console.log(fn instanceof Object)    // true
```

最后我们再来看几个比较特殊的例子

```js
var str = 'string'
var newStr = new String()

var newObj = Object.create(null)

str instanceof String     // false ==> 因为检查原型链会找到 undefined
newStr instanceof String  // true
newStr instanceof Object  // true

({}) instanceof Object    // true  ==> 尽管原型没有定义
newObj instanceof Object  // false ==> 原型为 null
```


## Object.prototype.hasOwnProperty()

所有继承了 [Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 的对象都会继承到 `hasOwnProperty` 方法，该方法会返回一个布尔值，用来判断一个对象是否有你给出名称的属性或对象（也就是否有指定的键），即使属性的值是 `Null` 或 `Undefined`，只要属性存在，`hasOwnProperty` 依旧会返回 `true`，不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性

```js
const foo = new Object()
const bar = new Object()

foo.age = 22
bar.prop = null

foo.hasOwnProperty('age')       // true
foo.hasOwnProperty('toString')  // false
bar.hasOwnProperty('prop')      // true
```

比如我们遍历一个对象的所有自身属性的时候就可以使用 `hasOwnProperty` 来忽略掉继承属性

> 这里有个需要注意的地方，`for-in` 循环只会遍历可枚举属性，所以循环中没有不可枚举的属性不是依靠 `hasOwnProperty()` 得来的

```js
var obj = {
  name: 'zhangsan'
}

for (var name in obj) {
  if (obj.hasOwnProperty(name)) {
    console.log(obj.name)
  }
}
```

`JavaScript` 并没有将 `hasOwnProperty` 设为关键字，因此当某个对象可能自有一个占用该属性名的属性时，就需要使用外部的 `hasOwnProperty` 获得正确的结果

```js
var foo = {
  hasOwnProperty: function () {
    return false
  },
  bar: 'zhangsan'
}

foo.hasOwnProperty('bar')                         // false
({}).hasOwnProperty.call(foo, 'bar')              // true

// 也可以使用 Object 原型上的 hasOwnProperty 属性
Object.prototype.hasOwnProperty.call(foo, 'bar')  // true
```

比如上面这个例子，当我们调用 `foo.hasOwnProperty('bar')` 的时候始终会返回 `false`，在这种情况下，我们可以直接使用原型链或者 `Object` 原型上的 `hasOwnProperty` 方法，严格来讲，不使用 `hasOwnProperty()` 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度，但是当确认不了对象的内容（和原型链）的时候，最好还是加上 `hasOwnProperty()` 这样安全的检查






## Object.prototype.isPrototypeOf()

是用来判断要检查其原型链的对象是否存在于指定对象的原型链上（实例中），是则返回 `true`，否则返回 `false`，不过这个在平时的开发当中使用较少，这里也就只简单的介绍一下

```js
function A() { }
function B() { }
function C() { }

// B 继承于 A
B.prototype = Object.create(A.prototype)

// C 继承于 B
C.prototype = Object.create(B.prototype)

var c = new C()

C.prototype.isPrototypeOf(c)       // true
B.prototype.isPrototypeOf(c)       // true
A.prototype.isPrototypeOf(c)       // true
Object.prototype.isPrototypeOf(c)  // true
```



## Object.prototype.toString()

在介绍完上面一大堆东西以后，我们来看一个比较新奇的方法 `Object.prototype.toString()`，它的作用是返回一个表示该对象的字符串，每个对象都有一个 `toString()` 方法，默认情况下 `toString()` 方法被每个 `Object` 对象继承，如果此方法在自定义对象中未被覆盖，则 `toString()` 就返回 `[object type]`，其中 `type` 是对象的类型，我们可以根据规范 [15.2.4.2 Object.prototype.toString()](http://yanhaijing.com/es5/#304) 来进行了解

根据规范可知，当 `toString` 方法被调用的时候，下面的步骤会被执行

1. 如果 `this` 值是 `Undefined`，就返回 `[object Undefined]`
2. 如果 `this` 的值是 `Null`，就返回 `[object Null]`
3. 让 `O` 成为 `ToObject(this)` 的结果
4. 让 `class` 成为 `O` 的内部属性 `[[Class]]` 的值
5. 最后返回由 `"[object"`，`class` 和 `"]"` 三个部分组成的字符串

下面我们来看一些实际使用的结果

```js
Object.prototype.toString.call(1)                         // [object Number]
Object.prototype.toString.call('123')                     // [object String]
Object.prototype.toString.call(true)                      // [object Boolean]
Object.prototype.toString.call(undefined)                 // [object Undefined]
Object.prototype.toString.call(null)                      // [object Null]
Object.prototype.toString.call({ a: 1 })                  // [object Object]
Object.prototype.toString.call([1, 2, 3])                 // [object Array]
Object.prototype.toString.call(new Date())                // [object Date]
Object.prototype.toString.call(new Error())               // [object Error]
Object.prototype.toString.call(/a/g)                      // [object RegExp]
Object.prototype.toString.call(function a() { })          // [object Function]

// 检测 Math 和 JSON 在平常是一般不会遇到的
Object.prototype.toString.call(Math)                      // [object Math]
Object.prototype.toString.call(JSON)                      // [object JSON]

// 还有一种特殊的
+ function a() {
  console.log(Object.prototype.toString.call(arguments))  // [object Arguments]
}()
```

有了这个方法，我们也可以应对许多场景，下面我们再来看一些比较特殊的场景



## 空对象检测

一般有下面这几种方式，但是有一点需要注意的就是 `for-in`，`JSON.stringify()`，`Object.keys()`，`isEmptyObject()` 无法检测非枚举属性

#### for-in

返回所有可枚举属性，包括原型中的属性，不含 `Symbol` 属性，一般最为常见的思路就是使用 `for-in` 遍历属性，为真则为非空数组，否则为空数组

```js
// 如果不为空，则会执行到这一步，返回 true
for (var i in obj) {
  return true
}

// 如果为空，返回 false
return false 
```


#### JSON.stringify()

通过 `JSON` 自带的 `stringify()` 方法来判断，`JSON.stringify()` 方法用于将 `JavaScript` 值转换为 `JSON` 字符串，不过这里需要注意 `JSON.stringify()` 的一些使用中的坑，也就是 `Undefined`、任意的函数以及 `Symbol` 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 `Null`，即

```js
JSON.stringify({a: undefined})              // { }

JSON.stringify([1, undefined, undefined])   // [1, null, null]
```

所以一般可以直接与 `{}` 来进行比较

```js
if (JSON.stringify(data) === '{}') {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```

这里需要注意为什么不用 `toString()`，因为它返回的不是我们需要的

```js
var a = {}
a.toString() // [object Object]
```

#### Object.keys()

`ES6` 新增的 `Object.keys()` 方法会返回所有可枚举属性，不包括原型中属性，不含 `Symbol` 属性，如果我们的对象为空，他会返回一个空数组，如下

```js
var a = {}
Object.keys(a) // []
```

我们可以依靠 `Object.keys()` 这个方法通过判断它的长度来知道它是否为空

```js
if (Object.keys(object).length === 0) {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```



#### isEmptyObject()

`jQuery` 当中提供了 `isEmptyObject()` 方法用来判断空对象，但是其本质也是通过 `for-in` 循环来进行判断的，源码如下

```js
isEmptyObject: function(obj) {
  var name
  for (name in obj) {
    return false
  }
  return true
}
```

下面是一些使用示例

```js
$.isEmptyObject([0])                          // false
$.isEmptyObject({ name: 'zhangsan' })         // false
$.isEmptyObject({ sayHi: function () { } })   // false

$.isEmptyObject({ })             // true
$.isEmptyObject(new Object())    // true


// 自定义的原型对象上的属性也是可枚举的
function Foo() { }
Foo.prototype.word = 'hello'
$.isEmptyObject(User())          // false


// 尽管在没有为空数组、Function、Number 等内置对象添加自定义属性的情况下，它们也是不可枚举的，但是不推荐这么做
// 因为 isEmptyObject() 的参数应该始终是一个纯粹的 Object，比如如下示例，数组中没有元素，也无法通过 for-in 迭代出属性
$.isEmptyObject([])              // true


// Function、Number、String 等内置对象也无法通过 for-in 迭代出属性
$.isEmptyObject(function () { alert('xxx') })  // false
```


> 这里有个需要注意的地方，上面这几个方法均不能检测出非枚举属性，即严格意义上的不完美方法，比如如下示例

```js
var obj = {}

Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: '123'
})


for (var i in obj) {
  console.log(i)
}

JSON.stringify(obj) === '{}'  // true

Object.keys(obj)              // []

$.isEmptyObject(obj)          // true
```


#### Object.getOwnPropertyNames()

该方法会返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）组成的数组，需要注意的是，该方法不支持 `IE8` 及以下，并且在 `ES5` 版本当中，如果参数不是一个基本类型会抛出一个错误

```js
// 判断空对象
let obj = {}
Object.getOwnPropertyNames(obj)     // []

// ES5 版本当中参数不是基本类型会引起错误
Object.getOwnPropertyNames('foo')   // TypeError: 'foo' is not an object

// ES6 版本当中非对象参数会被强制转换为对象
Object.getOwnPropertyNames('foo')   // ['length', '0', '1', '2']
```

利用这个方法可以检测出非枚举属性

```js
var obj = {}

Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: '123'
})

Object.getOwnPropertyNames(obj)  // ['key']
```



#### Reflect.ownKeys(obj)

这个是个无敌的方法，返回所有的自身属性，不管是否可枚举，不管是不是 `Symbol`，一律返回

```js
var test = Symbol()
var obj = {
  [test]: 123
}

Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: '123'
})

Object.getOwnPropertyNames(obj)  // ['key']
Object.keys(obj)                 // []
Reflect.ownKeys(obj)             // ['key', Symbol()]
```

所以简单的总结一下，判断一个变量是不是空对象的比较完善的方法

```js
obj !== null
&& typeof obj === 'object'
&& !Array.isArray(obj)
&& (Object.getOwnPropertyNames(obj).length === 0)
&& (Object.getOwnPropertySymbols(obj).length === 0)

// or
(Object.prototype.toString.call(obj) === '[object Object]')
&& (Object.getOwnPropertyNames(obj).length === 0)
&& (Object.getOwnPropertySymbols(obj).length === 0)

// or
(String(obj) === '[object Object]') && (Reflect.ownKeys(obj).length === 0)
```




## window 对象检测

`window` 对象作为客户端 `JavaScript` 的全局对象，它有一个 `window` 属性指向自身，我们可以利用这个特性判断是否是 `window` 对象

```js
function isWindow(obj) {
  return obj != null && obj === obj.window
}
```




## 底层数据结构

最后的最后，我们再来看一个有些扩展性质的内容，那就是 `JavaScript` 对象的底层数据结构到底是什么呢？在后端语言当中，比如 `Java`，我们知道 `Java` 把内存分为两种形式，一种是栈内存，另一种是堆内存，`Java` 的基本类型（`int/short/long/byte/float/double/boolean/char`）在栈区分配空间，而对象都在堆中分配空间，那么在 `JavaScript` 中呢？要弄明白这个问题，我们就要先来看看在常见语言当中的底层存储方式是是什么，它们主要有以下这些

* 数组（`Array`）
  * 数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合，数组可以说是最基本的数据结构，在各种编程语言中都有对应，一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等，数组还可以有一维、二维以及多维等表现形式
* 堆（`Heap`）
  * 堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆，堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构
* 栈（`Stack`）
  * 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作，栈按照后进先出的原则来存储数据，也就是说先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出，栈在汇编语言程序中，经常用于重要数据的现场保护，栈中没有数据时，称为空栈
* 队列（`Queue`）
  * 队列和栈类似，也是一种特殊的线性表，和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作，一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头，队列中没有元素时，称为空队列
* 链表（`Linked List`）
  * 链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点，链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分，其中指针域保存了数据结构中下一个元素存放的地址，链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的
* 树（`Tree`）
  * 树是典型的非线性结构，它是包括 `2` 个结点的有穷集合 `K`，在树结构中，有且仅有一个根结点，该结点没有前驱结点，在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点（`m ≥ 0`）
* 图（`Graph`）
  * 图是另一种非线性数据结构，在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对，如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系
* 散列表（`Hash`）
  * 散列表源自于散列函数（`Hash function`），其思想是如果在结构中存在关键字和T相等的记录，那么必定在 `F(T)` 的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录

而在 `JavaScript` 当中使用的是「堆（`Heap`）」和「栈（`Stack`）」，`JavaScript` 的基本类型数据都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放，这样带来的好处就是，内存可以及时得到回收，相对于堆来说更加容易管理内存空间

`JavaScript` 引用类型数据被存储于堆中（如对象、数组、函数等），其实说存储于堆中也不太准确，因为引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后在通过地址指针找到堆中的所需要的数据



## 总结

大部分情况都可以使用 `Object.prototype.toString()` 来应对，当然也可以采用如下方式

* 基本类型（字符串，数字，布尔值，`undefined`，`Symbol`）使用 `typeof`
* 引用值（`Date`，`RegExp`，`Error`）使用 `instanceof`
* 函数使用 `typeof`
* 数组使用 `isArray`
* 属性检测（是否存在）使用 `in`/`hasOwnProperty()`



