---
title: 如何监听对象和数组的属性改变
date: 2017-08-29
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/39.webp
---

如何监听对象和数组的属性改变算是一个老生常谈的问题，一些现有框架当中也都有各自的实现方式，今天我们就来深入的了解一下具体的实现原理，先来看看如何监听对象的属性改变

<!--more-->


## 监听对象属性改变

在 `ES5` 当中新增了一个 `Object.defineProperty` 的方法，使用这个方法可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象

```js
Object.defineProperty(obj, prop, descriptor)
```

其接受的第三个参数可以取 `get/set` 并各自对应一个 `getter/setter` 的方法，这样一来在对象属性改变的时候我们就可以知道属性的值变化了

```js
var a = { obj: 0 }

Object.defineProperty(a, 'obj', {
  get: function () {
    console.log('get：' + obj)
    return obj
  },
  set: function (value) {
    obj = value
    console.log('set:' + obj)
  }
})

a.obj = 2          // set: 2
console.log(a.obj) // get：2
```

有个缺点就是在 `IE8` 及更低版本 `IE` 是无法使用的，因为这个特性是没有 `polyfill` 的，所以无法在不支持的平台实现



## Proxy

另外还可以使用 `ES6` 提供的 `Proxy` 代理来处理

```js
var user = {}

var proxy = new Proxy(user, {
  get(target, property) {
    return target[property]
  },
  set(target, property, value) {
    target[property] = value
  }
})

proxy.name = 'zhangsan'
console.log(user)
// {name: 'zhangsan'}
```

原理都是一样的，都是利用 `get/set` 来监听对象属性的变化



## 监听数组的变化

监听数组的变化相对来说就没有监听对象那么轻松了，因为没有对应的 `get/set` 方法来供我们使用，但是我们可以定义一个新的数组，然后让其继承原生的 `Array`，然后重写其中我们需要监听的方法即可（`pop`，`push` 等），如下是 `ES6` 当中的实现方式

```js
class NewArray extends Array {
  constructor(...args) {
    // 调用父类 Array 的 constructor
    super(...args)
  }

  push(...args) {
    console.log(`监听到数组变化`)
    // 调用父类方法
    return super.push(...args)
  }
}

let arr = [1, 2]
let newArr = new NewArray(...arr)
console.log(newArr)  // [1, 2]

newArr.push(3)       // 监听到数组变化
console.log(newArr)  // [1, 2, 3]
```



## 关于 ES5 以下实现

上面我们介绍了 `ES6` 当中的数组监听方法的实现，那么 `ES6` 以下还能实现吗？这里就需要注意了，在 `ES5` 及以下的 `JavaScript` 因为无法完美的继承数组，所以虽然可以实现，但是是存在一定缺陷的，因为 `Array` 构造函数执行时不会对传进去的 `this` 做任何处理，不止 `Array`，`String`，`Number`，`Regexp`，`Object` 等等 `JavaScript` 的内置类都不行

数组其响应式的 `length` 属性以及内部的 `[[class]]` 属性我们无法在 `JavaScript` 层面实现，这就导致我们无法去用任何一个对象来模仿一个数组，但是可以使用非标准属性 `__proto__` 来实现，如下

```js
// 首先获取 Array 原型
const oldMethod = Object.create(Array.prototype)
const newMethod = []

['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method => {
  // 在 newMethod 上进行方法的重写
  // 这里需要注意的是重写的方法是定义在 newMethod 的属性上而不是其原型属性（newMethod.__proto__ 没有改变）
  newMethod[method] = function () {
    console.log(`监听到数组的变化`)
    return oldMethod[method].apply(this, arguments)
  }
})

let list = [1, 2]
// 将需要监听的数组的原型指针指向我们重新定义的新对象
list.__proto__ = newMethod
list.push(3)

// 如果不设定指向，则默认使用原生的方法
let list2 = [1, 2]
list2.push(3)
```


