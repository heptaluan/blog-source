---
title: JavaScript 中的 || 和 &&
date: 2017-05-19
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/15.webp
---

逻辑运算符 `||`（或） 和 `&&`（与）应该不陌生，但是称为逻辑运算符不太准确，称之为选择器运算符或者操作数选择器运算符更恰当一些，因为在 `JavaScript` 中，它们返回的『并不是』布尔值，它们的返回值是两个操作数中的一个（且仅一个），即选择两个操作数中的一个，然后返回它的值（其定义可以参考 [二元逻辑运算符](http://lzw.me/pages/ecmascript/#208)）

<!--more-->

比如下面这个例子

```js
var a = '42'
var b = 'abc'
var c = null

a || b  // 42
a && b  // 'abc'

c || b  // 'abc'
c && b  // null
```

`||` 和 `&&` 首先会对『第一个操作数』执行条件判断，如果其值不是布尔，就先进行 `ToBoolean` 强制类型转换，然后在执行条件判断

* 对于 `||`，如果条件判断结果为 `true` 就返回第一个操作数的值，如果为 `false` 就返回第二个操作数的值
* `&&` 则相反，如果条件判断结果为 `true`，就返回第二个操作数的值，如果为 `false` 就返回第一个操作数的值




## ||


下面是一个十分常见的 `||` 用法

```js
function foo(a, b) {
  a = a || 'hello'
  b = b || 'world'
  console.log(a + ' ' + b)
}

foo()                  // hello world
foo('world', 'hello')  // world hello
```

`a = a || 'hello'` 检查变量 `a`，如果还未赋值（或者为假值），就赋予它一个默认值（`'hello'`），但是需要注意，如果传入的是 `foo('', '')`，这时会同样的返回 `hello world`，因为传入的是一个假值，`||` 判断不成立，会返回默认值 


## &&

如果第一个操作数为真值，则 `&&` 运算符会选择第二个操作数作为返回值，这也叫做守护运算符，即前面的表达式为后面的表达式把关

```js
function foo() {
  console.log(a)
}

var a = 42

a && foo()  // 42
```

`foo()` 只有在条件判断 `a` 通过时才会被调用，如果条件判断未通过，`a && foo()` 就会悄然终止（也叫做短路），`foo()` 不会被调用




## 短路

对于 `&&` 和 `||` 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数，这种现象称之为短路（即执行最短路径），以 `a && b` 为例，如果 `a` 是一个假值，足以决定 `&&` 的结果，就没有必要再判断 `b` 的值，同样对于 `a || b`，如果 `a` 是一个真值，也足以决定 `||` 的结果，就没有必要再判断 `b` 的值




## 隐式强制类型转换

既然返回的不是 `true` 和 `false`，那么为什么 `a && (b || c)` 这样的表达式在 `if` 或者 `for` 中没有出现问题，这是因为这些条件判断表达式最后还会执行布尔值的隐式强制类型转换

```js
var a = 42
var b = null
var c = 'foo'

if (a && (b || c)) {
  console.log('hello')  // hello
}
```

这里的 `a && (b || c)` 的结果实际上是 `'foo'` 而非 `true`，然后再由 `if` 将 `foo` 强制类型转换为布尔值，所以最后结果为 `true`，如果要避免隐式强制类型转换，可以采用下面的方式

```js
var a = 42
var b = null
var c = 'foo'

if (!!a && (!!b || !!c)) {
  console.log('hello')  // hello
}
```


## 运算符优先级

`JavaScript` 中的 `&&` 和 `||` 运算符返回它们其中一个操作数的值，而非 `true` 或 `false`，但是两个运算符三个操作数呢，比如下面这个例子

```js
var a = 42
var b = 'foo'
var c = [1, 2, 3]

a && b || c
a || b && c
```

这里就涉及到了运算符优先级，这里只列举一部分，完整的列表可以参考 [MDN - 运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)，不过需要注意的是，用 `','` 来连接一系列语句的时候，它的优先级最低，其他操作数的优先级都比它高

|优先级|运算类型| 运算符|
|-|-|-|
|20|圆括号| `()` |
|19|成员访问，`new`（带参数列表），函数调用| `. [] ()`|
|18|new（无参数列表）| `new …`|
|17|后置递增（运算符在后），后置递减（运算符在后）| `… ++ … --`|
|16|逻辑非，按位非，一元加法，一元减法，前置递增（运算符在前），前置递减（运算符在前）| `! ~ + - ++ … -- …` |
|14|乘法，除法，取模| `* / %` |
|13|加法，减法| `+ -`|
|11|小于，小于等于，大于，大于等于| `< <= > >=`|
|10|等号，非等号，全等号，非全等号| `== != === !==` |
|6|逻辑与| `&&` |
|5|逻辑或| `\|\|` |
|4|条件运算符| `… ? … : …` |
|3|赋值| `= += -= ……`|
|0|逗号| `,` |

在了解完大致的运算符优先级以后，我们可以来看看下面这个十分极端的例子，如果理清其中的逻辑之后，以后在遇到类似情况就都比较清晰了

```js
var a = 42
var b = 'foo'
var c = false

var d = a && b || c ? c || b ? a : c && b : a

d  // 42
```

根据上面的运算符优先级，上例可以分解为

```js
var d = ((a && b) || c) ? ((c || b) ? a : (c && b)) : a

// 换行以后更为清晰一些
var d = ((a && b) || c) 
  ? 
  ((c || b) ? a : (c && b)) 
  : 
  a
```

这样一来，就可以得出最后的结果为 `42`







## 总结

逻辑运算符 `||` 和 `&&` 都是遵行短路原则，只要确定符号前面的真假，既可确定返回值

* 只要 `||` 前面为 `false`，无论 `||` 后面是 `true` 还是 `false`，结果都返回 `||` 后面的值
* 只要 `||` 前面为 `true`，无论 `||` 后面是 `true` 还是 `false`，结果都返回 `||` 前面的值
* 只要 `&&` 前面是 `false`，无论 `&&` 后面是 `true` 还是 `false`，结果都将返 `&&` 前面的值
* 只要 `&&` 前面是 `true`，无论 `&&` 后面是 `true` 还是 `false`，结果都将返 `&&` 后面的值


