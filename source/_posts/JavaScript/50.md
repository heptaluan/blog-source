---
title: Async 和 Await
date: 2020-01-17
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/50.jpg
---

又是一个老生常谈的问题，不过本篇关于 `async` 的基本概念只会略带提及，主要介绍一些其他方面的内容

<!--more-->

基本使用方法可以参考阮一峰老师的 [async 函数](http://es6.ruanyifeng.com/#docs/async)

从字面意思上很好理解，`async` 是异步的意思，`await` 有等待的意思，而两者的用法上也是如此

`async` 用于申明一个 `function` 是异步的，而 `await` 用于等待一个异步方法执行完成，下面我们就一个一个来看




## Async

简单来说，`async` 其实就是一个函数的修饰符，它会返回一个 `promise`，在异步处理上就是 `Generator` 函数的语法糖

`async` 的语法很简单，就是在函数开头加一个关键字

```js
async function f() {
  return 1
}
```

我们直接调用一下

```js
f()  // Promise { <resolved>: 1 }
```

可以发现，输出的是一个 `promise` 对象，那么我们就可以推断出，如果在 `async` 函数中 `return` 一个直接量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `promise` 对象返回

那么针对上面的这个例子，如果在最外层不能用 `await` 获取其返回值的情况下，我们便可以使用针对 `promise` 标准的处理方式来进行处理，即使用 `then()` 方法，如下

```js
f().then((res) => {
  console.log(res)  // 1
})
```

但是我们思考一下，如果 `async` 函数没有返回值，那又会如何处理呢？其实很简单，它会返回 `Promise.resolve(undefined)`

通过上面我们已经了解到，在没有 `await` 的情况下执行 `async` 函数，它会立即执行返回一个 `promise` 对象，并且绝不会阻塞后面的语句，这和普通返回 `promise` 对象的函数并无二致

所以我们下面就需要来看看 `await` 这个关键字了




## Await

关键词 `await` 是等待的意思，那么它在等待什么呢？根据 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await) 可知

`await` 操作符用于等待一个 `promise` 对象或者任何要等待的值，它会返回 `promise` 对象的处理结果，如果等待的不是 `promise` 对象，`await` 会把该值转换为已正常处理的 `promise`，然后等待其处理结果，基本语法如下

```js
[return_value] = await expression
```

这里有一个重点，那就是 `await` 所要等待的并不一定要是 `promise` 对象，后面实际是可以接普通函数调用或者直接量的

```js
// 普通函数
function getSomething() {
  return 'hello'
}

// async 函数
async function testAsync() {
  return Promise.resolve('world')
}

async function test() {
  const v1 = await getSomething()
  const v2 = await testAsync()
  console.log(v1, v2)
}

test()  // hello world
```

那么这里就会存在一个问题，即 **为什么 await 关键词只能在 async 函数中使用呢？**

这是因为 `await` 操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了

但是在异步的情况下，`await` 会阻塞整一个流程，直到结果返回之后，才会继续下面的代码

> 所以在这里我们需要注意，`async` 函数会被包在一个 `promise` 中异步去执行，所以 `await` 只能在 `async` 函数中使用，如果在正常程序中使用，会造成整个程序阻塞，得不偿失



## 一个综合案例

如下

```js
async function setTime(time) {
  await setTimeout(() => { console.log(1) }, time)
}

async function log(val, time) {
  await setTime(time)
  console.log(val)
}

log(2, 3000)

// 2 ==> 立即输出
// 1 ==> 三秒后输出
```

通过观察可以发现，为何我们明明写了 `await setTimeout`，但是 `log` 函数却并没有等到 `setTimeout` 执行完毕后再打印？

带着这个疑问我们先来看下面这几个例子

```js
// 示例一
async function test() {
  await setTimeout(() => console.log(1), 3000)
  console.log(2)
}

test()

// 2 ==> 立即输出
// 1 ==> 三秒后输出
```

是不是和开头的示例类似，不急，我们接着往下看

```js
// 示例二
async function test() {
  await new Promise(resolve => setTimeout(() => console.log(1), 3000))
  console.log(2)
}

test()

// 1 ==> 三秒后输出
```

这一次我们使用一个 `new Promise()` 将 `setTimeout` 包裹了起来（但是并没有设置成功或者失败的回调），可以发现 `console.log(2)` 这一句并没有执行

```js
// 示例三
async function test() {
  await new Promise(resolve => setTimeout(() => resolve(console.log(1)), 3000))
  console.log(2)
}

test()

// 1 ==> 三秒后输出
// 2 ==> 三秒后输出
```

这一次我们将 `setTimeout` 的结果放入到 `resolve` 回调当中，发现是可以达到我们预期的输出

首先 `await` 后面如果跟的是一个 `promise`对象，所以它会去等该 `promise resolve` 后才会继续下面的执行

所以会在三秒后输出 `1` 和 `2`，以为这样就完了？我们接着往下看

```js
// 示例四
async function test() {
  await Promise.resolve(setTimeout(() => console.log(1), 3000))
  console.log(2)
}

test()

// 2 ==> 立即输出
// 1 ==> 三秒后输出
```

我们这次没有使用 `new Promise()` 将 `setTimeout` 包裹，而是直接使用 `Promise.resolve()`，发现结果又和开头部分的几个示例一样了

这是因为 `await` 后面是一个已经 `resolve` 的 `promise`，所以会直接进入到下一步

```js
// 示例五
async function test() {
  await Promise.all([setTimeout(() => console.log(1), 3000)])
  console.log(2)
}

test()

// 2 ==> 立即输出
// 1 ==> 三秒后输出
```

我们这一次换成了 `Promise.all`，可以发现，当 `all` 的数组元素不是 `promise` 的时候会调用 `Promise.resolve` 方法进行包装，所以产生的结果与示例四是一样的

通过上面连续的几个示例我们可以发现，`await` 后面跟着的函数是会被立即调用的（非 `promise`）

```js
async function test() {
  await setTimeout(() => console.log(1), 1000)
  await setTimeout(() => console.log(2), 3000)
  await console.log(3)
}

test()

// 3 ==> 立即输出
// 1 ==> 一秒后输出
// 2 ==> 三秒后输出
```

但是这并不代表它们执行全是同步的，请看下列代码的输出

```js
async function test() {
  console.log(1)
  await console.log(2)
  console.log(4)
}

test()
console.log(3)

// 1
// 2
// 3
// 4
```

为什么会造成这样的结果呢，我们来将其稍微调整一下，就成为了下面的这个样子

```js
async function foo() {
  console.log(1)
  await Promise.resolve(console.log(2))
  console.log(4)
}

foo()
console.log(3)
```

这样写的话看起来就好理解了，先输出 `1`，然后发现了 `await`，又发现等待的不是 `promise` 对象，所以就会调用 `Promise.resolve` 方法进行包装

然后就输出了 `2`，但是却会有个异步的过程，这样 `3` 就会被输出，最后在输出 `4`


## Async 和 Await 的优势

严谨的说，`async` 是一种语法，`promise` 是一个内置对象，两者并不具备可比性，更何况 `async` 函数实际上返回的也是一个 `promise` 对象

但是我们通过一个例子来看一下使用 `async` 相较于使用 `promise` 有哪些更为优势的地方，示例如下

我们假设有一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果，按照题目的逻辑可以按如下实现

```js
// 函数接收传入参数 n，表示这个函数执行的时间（毫秒）执行的结果是 n，但是这个值将用于下一步骤
function takeLongTime(n) {
  return new Promise(resolve => {
    setTimeout(() => resolve(n), n)
  })
}

function step1(n) {
  console.log(`step1 with ${n}`)
  return takeLongTime(n)
}

function step2(m, n) {
  console.log(`step2 with ${m} and ${n}`)
  return takeLongTime(m + n)
}

function step3(k, m, n) {
  console.log(`step3 with ${k}, ${m} and ${n}`)
  return takeLongTime(k + m + n)
}
```

下面我们来看一下分别使用 `async/await` 和 `promise` 来进行处理有什么不同

#### promise 版本

```js
function step() {
  const time1 = 300
  step1(time1)
    .then(time2 => {
      return step2(time1, time2)
        .then(time3 => [time1, time2, time3])
    })
    .then(times => {
      const [time1, time2, time3] = times
      return step3(time1, time2, time3)
    })
    .then(result => {
      console.log(`result is ${result}`)
    })
}

step()
```

#### async/await 版本

```js
async function step() {
  const time1 = 300
  const time2 = await step1(time1)
  const time3 = await step2(time1, time2)
  const result = await step3(time1, time2, time3)
  console.log(`result is ${result}`)
}

step()
```


可以明显的发现，在这种较为复杂逻辑中，`async/await` 比 `then` 链是有一定优势的



## 错误处理

`promise` 并不是只有一种 `resolve`，还有一种 `reject`的情况，而 `await` 只会等待一个结果，那么发生错误了该怎么处理呢？

一般有两种方式来进行处理，第一种就是用 `try-catch` 来做错误捕捉

```js
async function test() {
  try {
    await Promise.reject('1')
  } catch (err) {
    console.log(err)
  }
}

test()  // 1
```

第二种就是用 `promise` 的 `catch` 来做错误捕捉

```js
async function test() {
  await Promise.reject('1').catch((err) => {
    console.log(err)
  })
}
test()  // 1
```



## 继发与并发

也是一个在实际开发过程当中可能会遇到的问题，比如我们给定一个 `URL` 数组，要求实现接口的继发和并发

我们先来看看如何实现继发，有两种方式

```js
// 方式一
async function loadData() {
  var res1 = await fetch(url1)
  var res2 = await fetch(url2)
  var res3 = await fetch(url3)
  return 'done'
}

// 方式二
async function loadData(urls) {
  for (const url of urls) {
    const response = await fetch(url)
    console.log(await response.text())
  }
}
```

下面再来看看并发

```js
// 并发一
async function loadData() {
  var res = await Promise.all([fetch(url1), fetch(url2), fetch(url3)])
  return 'done'
}

// 并发二
async function loadData(urls) {
  const textPromises = urls.map(async url => {
    const response = await fetch(url)
    return response.text()
  })
  for (const textPromise of textPromises) {
    console.log(await textPromise)
  }
}
```




## 参考

[async 函数](http://es6.ruanyifeng.com/#docs/async)

[理解 JavaScript 的 async/await](https://segmentfault.com/a/1190000007535316)

[AsyncFunction](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)

[await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await)