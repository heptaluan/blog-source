---
title: 重温 TypeScript
date: 2020-12-26
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/56.webp
---

虽然之前一直项目当中使用 `Angular` 来进行业务开发，但是总感觉对于 `TypeScript` 这一块的内容还是只停留在比较浅的使用层面，而最近又开始涉及到 `React` 相关内容，发现 `React + TypeScript` 算是业界标配了，所以就打算抽些时间深入的学习一下 `TypeScript`，在这里记录记录，也算是查漏补缺吧

<!--more-->

针对于相关内容会分为两篇文章来进行梳理，本文当中主要梳理一些基础内容，也算是回顾一下 `TypeScript` 的基本用法，而在下一章 [深入 TypeScript](http://localhost:4000/2021/01/01/JavaScript/57/) 当中我们则会来看一些 `TypeScript` 当中的进阶内容

本文当中涉及到的内容可能比较零散，因为便于自己回顾，一些比较熟络的知识点可能会一笔带过，对于想了解整体流程的同学可以参考 [官方文档](https://www.tslang.cn/docs/home.html) 来了解更多


## 什么是 TypeScript

`TypeScript` 是 `JavaScript` 的一个超集，主要提供了「类型系统」和对 `ES6` 的支持，至于为什么选择 `TypeScript` 主要有以下几个原因

* `TypeScript` 增加了代码的可读性和可维护性
  * 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了
  * 可以在编译阶段就发现大部分错误，这总比在运行时候出错好
  * 增强了编辑器和 `IDE` 的功能，包括代码补全、接口提示、跳转到定义、代码重构等
* `TypeScript` 非常包容
  * `TypeScript` 是 `JavaScript` 的超集，文件可以直接重命名为 `.ts` 即可
  * 即使不显式的定义类型，也能够自动做出类型推论
  * `TypeScript` 的类型系统是图灵完备的，可以定义从简单到复杂的几乎一切类型
  * 即使 `TypeScript` 编译报错，也可以生成 `JavaScript` 文件
  * 兼容第三方库，即使第三方库不是用 `TypeScript` 写的，也可以编写单独的类型文件供 `TypeScript` 读取
* `TypeScript` 拥有活跃的社区
  * 大部分第三方库都有提供给 `TypeScript` 的类型定义文件
  * `Angular`、`Vue`、`VSCode`、`Ant Design` 等耳熟能详的项目都是使用 `TypeScript` 编写的

但是任何事物都是有两面性的，通常来说 `TypeScript` 的一些弊端在于

* 有一定的学习成本，需要理解接口（`Interfaces`）、泛型（`Generics`）、类（`Classes`）、枚举类型（`Enums`）等概念
* 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，`TypeScript` 能够减少其维护成本
* 集成到构建流程需要一些工作量
* 可能和一些库结合的不是很完美

另外，除了 `TypeScript` 还有一个 [Flow](https://flow.org/) 可供选择，`Flow` 是 `Facebook` 出品的 `JavaScript` 静态类型检查工具，它与 `Typescript` 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行，所以还是根据团队和项目的情况判断是否需要使用 `TypeScript`

下面我们就来看看 `TypeScript` 当中的常用类型和一些基本概念，主要包括

* 原始数据类型
* 内置对象
* 任意值
* 联合类型
* 对象的类型（接口）
* 数组的类型
* 函数的类型

> 另外需要注意一点，如果本文当中未特殊指明示例是错误示范的话，则默认是编译通过


## 原始数据类型

`JavaScript` 的类型分为两种，原始数据类型（`Primitive data types`）和对象类型（`Object types`），原始数据类型包括布尔值、数值、字符串、`null`、`undefined` 以及 `ES6` 中的新类型 `Symbol` 和 `BigInt`，在本节当中我们主要来看看原始数据类型在 `TypeScript` 中的应用


#### 布尔值

在 `TypeScript` 中，使用 `boolean` 定义布尔值类型（注意区分大小写）

```ts
let x: boolean = false
```

但是需要注意的是，如果使用的是构造函数 `Boolean` 创造的对象则不是布尔值

```ts
// ❌
let x: boolean = new Boolean(true)
```

事实上 `new Boolean()` 返回的是一个 `Boolean` 对象

```ts
// ✅
let x: Boolean = new Boolean(true)
```

在 `TypeScript` 中，`boolean` 是 `JavaScript` 中的基本类型，而 `Boolean` 是 `JavaScript` 中的构造函数，其他基本类型（除了 `null` 和 `undefined`）也是一样的


#### 数值

使用 `number` 可以来定义数值类型，并且二进制与八进制等均可以使用

```ts
let x: number = 6
let x: number = 0xf00d
let x: number = 0b1010   // ES6 中的二进制表示法
let x: number = 0o744    // ES6 中的八进制表示法
let x: number = NaN
let x: number = Infinity
```



#### 字符串

使用 `string` 来定义字符串类型

```ts
let x: string = 'zhangsan'

// 模板字符串
let y: string = `hello ${x}`
```

可以发现，对于 `ES6` 当中的模板字符串同样适用




#### 空值

在 `JavaScript` 当中并没有空值（`void`）的概念，但是在 `TypeScript` 中，可以用 `void` 表示没有任何返回值的函数

```ts
function alertName(): void {
  alert('zhangsan')
}
```

声明一个 `void` 类型的变量没有什么用，因为你只能将它赋值为 `undefined` 和 `null`，但是需要注意，在非严格模式下，变量的值可以为 `undefined` 或 `null`，而严格模式下，变量的值只能为  `undefined`，所以使用场景较多的还是针对于没有返回值的函数

```ts
let x: void = undefined
```

但是这里有一个需要注意的地方，即当定义的函数返回值为空值 `void` 的时候，虽然在该函数内部写 `return` 时编译会报错，但是依然可以编译成功


#### Null 和 Undefined

在 `TypeScript` 中，可以使用 `null` 和 `undefined` 来定义这两个原始数据类型

```ts
let u: undefined = undefined
let n: null = null
```

与 `void` 的区别是，`undefined` 和 `null` 是所有类型的子类型，也就是说 `undefined` 类型的变量，可以赋值给 `number` 或 `string` 类型的变量

```ts
// ✅
let x: undefined
let n: number = x
let s: string = x
```

而 `void` 类型的变量不能赋值给 `number` 或 `string` 类型的变量

```ts
// ❌
let x: void
let n: number = x
let s: string = x       
```


## 内置对象

其实在上面介绍的一些原始数据类型，本质上它们都是 `JavaScript` 当中的 [内置对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)，它们已经在 `TypeScript` 中定义好了对应的类型，直接进行使用就行，内置对象是指根据标准在全局作用域（`Global`）上存在的对象，这里的标准是指 `ECMAScript` 和其他环境（比如 `DOM`）的标准

`ECMAScript` 标准提供的内置对象有 `Boolean`、`Error`、`Date`、`RegExp` 等，我们可以在 `TypeScript` 中将变量定义为这些类型

```ts
let b: Boolean = new Boolean(1)
let e: Error = new Error('Err')
let d: Date = new Date()
let r: RegExp = /[a-z]/
```

而常见的 `DOM` 和 `BOM` 提供的内置对象有 `Document`、`HTMLElement`、`Event`、`NodeList` 等，我们在开发过程当中也会经常用到这些类型

```ts
let body: HTMLElement = document.body

let allDiv: NodeList = document.querySelectorAll('div')

document.addEventListener('click', function (e: MouseEvent) {
  // ...
})
```

而对于内置对象的定义文件，则在 [TypeScript 核心库](https://github.com/Microsoft/TypeScript/tree/master/src/lib) 的定义文件中，其中定义了所有浏览器环境需要用到的类型，并且是预置在 `TypeScript` 中的，当我们在使用一些常用的方法的时候，`TypeScript` 实际上已经帮我们做了很多类型判断的工作了，比如

```ts
// ✅
Math.pow(10, 2)

// ❌
Math.pow(10, '2')
```

在上面的例子中，`Math.pow()` 必须接受两个 `number` 类型的参数，它的类型定义如下

```ts
interface Math {
  /**
   * Returns the value of a base expression taken to a specified power.
   * @param x The base value of the expression.
   * @param y The exponent value of the expression.
   */
  pow(x: number, y: number): number
}
```

再来看一个 `DOM` 中的例子

```ts
// ❌
document.addEventListener('click', function (e) {
  console.log(e.targetCurrent)
})
```

在上面的例子中，`addEventListener` 方法是在 `TypeScript` 核心库中定义的

```ts
interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {
  addEventListener(type: string, listener: (ev: MouseEvent) => any, useCapture?: boolean): void
}
```

所以 `e` 被推断成了 `MouseEvent`，而 `MouseEvent` 是没有 `targetCurrent` 属性的，所以报错了

此外我们还需要需要注意一点，那就是 `TypeScript` 核心库的定义中是不包含 `Node.js` 部分的，如果想用 `TypeScript` 写 `Node.js`，则需要引入第三方声明文件

```ts
npm install @types/node --save-dev
```


## 任意值

任意值（`Any`）用来表示允许赋值为任意类型，与原始数据类型进行比对的话，如果是一个普通类型，在赋值过程中改变类型是不被允许的

```ts
// ❌
let x: string = 'zhangsan'
x = 7
```

但如果是 `any` 类型，则允许被赋值为任意类型

```ts
// ✅
let x: any = 'lisi'
x = 7
```

同时，在任意值上访问任何属性都是允许的

```ts
let x: any = 'zhangsan'

console.log(x.name)
console.log(x.name.firstName)
```

也允许调用任何方法

```ts
let x: any = 'lisi'

x.setName('wangwu')
x.setName('zhaoliu').sayHello()
x.name.setFirstName('zhangsan')
```

可以认为，「声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值」，但是如果变量在声明的时候，未指定其类型，那么它会被识别为任意值类型，比如下面示例当中的 `x` 等价于 `x: any`

```ts
let x

x = 'zhangsan'
x = 7

x.setName('lisi')
```


## 联合类型

联合类型（`Union Types`）表示取值可以为多种类型中的一种，使用 `|` 分隔每个类型

```ts
let x: string | number

x = 'zhangsan'  // ✅
x = 7           // ✅

x = true        // ❌
```

上面示例当中的 `let x: string | number` 含义是允许 `x` 的类型是 `string` 或者 `number`，但是不能是其他类型

当 `TypeScript` 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法

```ts
// ❌
function getLength(x: string | number): number {
  return x.length
}
```

因为 `length` 不是 `string` 和 `number` 类型的共有属性，所以会报错，但是访问两者的的共有属性是没问题的，比如 `toString()` 方法

```ts
// ✅
function getLength(x: string | number): string {
  return x.toString() 
}
```

并且联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型

```ts
let x: string | number

x = 'zhangsan'
console.log(x.length)  // 8

x = 7
console.log(x.length)  // ❌
```

上例中，在赋值为 `'zhangsan'` 的时候，`x` 被推断成了 `string`，所以可以访问它的 `length` 属性，但是赋值为 `7` 的时候 `x` 被推断成了 `number`，所以访问它的 `length` 属性时就会报错





## 对象的类型（接口）

在 `TypeScript` 中，我们使用接口（`Interfaces`）来定义对象的类型，接口（`Interfaces`）在面向对象语言中是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（`classes`）去实现（`implement`），我们先来看一个简单的示例

```ts
interface Person {
  name: string;
  age: number;
}

let user: Person = {
  name: 'zhangsan',
  age: 18
}
```

我们定义了一个接口 `Person`，接着定义了一个变量 `user`，它的类型是 `Person`，这样我们就约束了 `user` 的结构必须和接口 `Person` 一致，但是需要注意的是，定义的变量比接口多一些或是少了一些属性都是不允许的

```ts
// ❌
let user: Person = {
  name: 'zhangsan'
}

// ❌
let user: Person = {
  name: 'zhangsan',
  age: 18,
  sex: 0
}
```

所以说，在赋值的时候，变量的结构必须和接口的结构保持一致


#### 可选属性

有时候我们又希望不要完全匹配一个接口，那么这种情况下可以使用可选属性

```ts
interface Person {
  name: string;
  age?: number;
}

let user1: Person = {
  name: 'zhangsan'
}

let user2: Person = {
  name: 'zhangsan',
  age: 18
}
```

但是此时仍然不允许添加未定义的属性

```ts
interface Person {
  name: string;
  age?: number;
}

// ❌
let user: Person = {
  name: 'zhangsan',
  age: 18,
  sex: 0
}
```


#### 任意属性

有时候我们希望一个接口允许有任意的属性，可以使用 `[propName: type]` 的方式来来进行定义

```ts
interface Person {
  name: string;
  age?: number;
  [propName: string]: any;
}

let user: Person = {
  name: 'zhangsan',
  age: 18
}
```

但是这里有一个需要注意的地方，那就是「一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集」，比如下面这个示例就会报错

```ts
// ❌
interface Person {
  name: string;
  age?: number;
  [propName: string]: string;
}

let user: Person = {
  name: 'zhangsan',
  age: 18,
  sex: '0'
}
```

这里我们将任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了，通常来说一个接口中只能定义一个任意属性，如果接口中有多个类型的属性，则可以采用联合类型的方式

```ts
interface Person {
  name: string;
  age?: number;
  [propName: string]: string | number;
}

let user: Person = {
  name: 'zhangsan',
  age: 18,
  sex: 0
}
```

另外需要注意的一点就是「索引签名参数类型必须为 `string` 或 `number`」

```ts
// ❌
interface Person {
  name: string;
  age?: number;
  [propName: any]: any;
}
```

上面示例是会报错的，这是因为 `TypeScript` 只支持两种索引签名，那就是字符串和数字，虽然可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型，这是因为当使用 `number` 来索引时，`JavaScript` 会将它转换成 `string` 然后再去索引对象，比如下面这个示例就不会报错

```ts
// ✅
interface Person {
  name: string;
  age?: number;
  [propName: string]: string | number;
}

let user: Person = {
  name: 'zhangsan',
  age: 18,
  1: 1
}
```

其实在上面示例当中和写成 `'1': 1` 是完全一样的，即使我们定义的是 `[propName: number]`，这是因为 `JavaScript` 中对象的数字索引，最终会转成字符串来取值的，比如使用 `100`（`number`）去索引等同于使用 `'100'`（`string`）去索引，因此两者需要保持一致


#### 只读属性

有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性

```ts
interface Person {
  readonly id: number;
  name: string;
  age?: number;
  [propName: number]: string | number;
}

let user: Person = {
  id: 123,
  name: 'zhangsan',
  age: 18
}

// ❌
user.id = 456
```

在上面示例当中，我们使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了，但是这里特别需要注意的一点就是「只读的约束是存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候」，比如下面这个示例

```ts
interface Person {
  readonly id: number;
  name: string;
  age?: number;
  [propName: number]: string | number;
}

// ❌
let user: Person = {
  name: 'zhangsan',
  age: 18
}

// ❌
user.id = 456
```

上例中有两处报错，第一处是在对 `user` 进行赋值的时候，没有给 `id` 赋值，第二处是在给 `user.id` 赋值的时候，由于它是只读属性，所以报错了







## 数组的类型

在 TypeScript 中，数组类型有多种定义方式，比较灵活，最简单的方法是使用「类型 + 方括号」来表示数组

```ts
let x: number[] = [1, 2, 3, 4, 5]
```

并且定义以后，数组的一些方法的参数也会根据数组在定义时约定的类型进行限制

```ts
let x: number[] = [1, 2, 3, 4, 5]

// ✅
x.push(6)

// ❌
x.push('6')
```

在上面示例当中，由于 `push` 方法只允许传入 `number` 类型的参数，但是却传了一个字符串类型的 `6`，所以报错了，另外我们也可以使用数组泛型（`Array Generic`） `Array<elemType>` 来表示数组

```ts
let x: Array<number> = [1, 2, 3, 4, 5]
```

关于泛型的相关内容，我们会在后面章节当中详细来进行介绍，下面我们来看看如何使用接口来描述数组

```ts
interface NumberArray {
  [index: number]: number;
}

let x: NumberArray = [1, 2, 3, 4, 5]
```

虽然接口也可以用来描述数组，但是我们一般不会这么来使用，因为这种方式比前两种方式要复杂许多，不过有一种情况比较特殊，那就是它常用来表示类数组，类数组（`Array-like Object`）不是数组类型，比如 `arguments`

```ts
// ❌
function sum() {
  let args: number[] = arguments
}
```

由于 `arguments` 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口

```ts
interface Args {
  [index: number]: number;
  length: number;
  callee: Function;
}

function sum() {
  let args: Args = arguments
}
```

在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 `length` 和 `callee` 两个属性，事实上常用的类数组都有自己的接口定义，如 `IArguments`，`NodeList`，`HTMLCollection` 等

```ts
function sum() {
  let args: IArguments = arguments
}
```

其实也就是我们之前提到过的「内置对象」，其中 `IArguments` 是 `TypeScript` 中定义好了的类型，它实际上就是

```ts
interface IArguments {
  [index: number]: any;
  length: number;
  callee: Function;
}
```

对于数组当中既存在数字又含有字符串的情况，我们可以考虑使用联合类型

```ts
let x: (number | string)[] = [1, '2', 3]
```

另外还有一种比较复杂的情况，那就是对象类型的数组，偷懒的话当然可以直接使用 `any`，但是如若结构不算太过复杂的话可以使用下面这种方式

```ts
const x: { name: string, age: number }[] = [{ name: 'zhangsan', age: 18 }]
```

还可以将上面的写法简化一下，利用类型别名的方式

```ts
type User = { name: string, age: number }

const x: User[] = [{ name: 'zhangsan', age: 18 }]
```





## 函数的类型

在 `JavaScript` 中，有两种常见的定义函数的方式，即函数声明（`Function Declaration`）和函数表达式（`Function Expression`）

```ts
// 函数声明（Function Declaration）
function add(x, y) {
  return x + y
}

// 函数表达式（Function Expression）
let add = function (x, y) {
  return x + y
}
```

一个函数有输入和输出，要在 `TypeScript` 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单

```ts
function add(x: number, y: number): number {
  return x + y
}
```

但是输入多余的（或者少于要求的）参数，是不被允许的

```ts
add(1, 2, 3)  // ❌

add(1)        // ❌
```

但是如果我们要对一个函数表达式（`Function Expression`）来定义的话，可能会写成这样

```ts
let add = function (x: number, y: number): number {
  return x + y
}
```

虽然是可以通过编译的，但是上面的代码其实只对等号右侧的匿名函数进行了类型定义，而等号左边的 `add`，是通过赋值操作进行类型推论而推断出来的，如果需要我们手动给 `add` 添加类型，则应该是这样

```ts
let add: (x: number, y: number) => number = function (x: number, y: number): number {
  return x + y
}
```

但是这里注意不要混淆了 `TypeScript` 中的 `=>` 和 `ES6` 当中的箭头函数（`=>`），在 `TypeScript` 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型


#### 使用接口

我们也可以使用接口的方式来定义一个函数需要符合的结构

```ts
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc = function (source: string, subString: string): boolean {
  return source.search(subString) !== -1
}
```

采用函数表达式定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变


#### 可选参数

与接口中的可选属性类似，我们用 `?` 来表示可选的参数

```ts
function buildName(firstName: string, lastName?: string) {
  if (lastName) {
    return firstName + ' ' + lastName
  } else {
    return firstName
  }
}

let man1 = buildName('zhangsan', 'lisi')

let man2 = buildName('zhangsan')
```

不过需要注意的是，可选参数必须接在必需参数后面，也就是说可选参数后面不允许再出现必需参数了

```ts
// ❌
function buildName(firstName?: string, lastName: string) {
  if (lastName) {
    return firstName + ' ' + lastName
  } else {
    return firstName
  }
}
```




#### 默认值

在 `ES6` 中，我们允许给函数的参数添加默认值，`TypeScript` 会将添加了默认值的参数识别为可选参数

```ts
function buildName(firstName: string, lastName: string = 'lisi') {
  return firstName + ' ' + lastName
}

let man1 = buildName('zhangsan', 'wangwu')

let man2 = buildName('zhangsan')
```





#### 剩余参数

在 `ES6` 中，我们可以使用 `...rest` 的方式获取函数中的剩余参数（`rest` 参数）

```ts
function push(array, ...items) {
  items.forEach(function (item) {
    array.push(item)
  })
}

let arr = []

push(arr, 1, 2, 3)
```

事实上，`items` 是一个数组，所以我们可以用数组的类型来定义它

```ts
function push(array: number[], ...items: number[]) {
  items.forEach(function (item) {
    array.push(item)
  })
}

let arr = []

push(arr, 1, 2, 3)
```

这里需要注意的是，`rest` 参数同可选参数一样，只能是最后一个参数



#### 重载

重载允许一个函数接受不同数量或类型的参数时，作出不同的处理，但是在 `JavaScript` 当中并没有函数重载，通常是通过判断参数的个数，在函数内部实现方法重载，下面我们来看看 `TypeScript` 当中的重载

比如，我们需要实现一个函数 `reverse`，输入数字 `123` 的时候，输出反转的数字 `321`，输入字符串 `'hello'` 的时候，输出反转的字符串 `'olleh'`，我们可以利用联合类型来实现

```ts
function reverse(x: number | string): number | string {
  if (typeof x === 'number') {
    return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
    return x.split('').reverse().join('')
  }
}
```

然而这样有一个缺点，就是表达的不够精确，应该是输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串，这时我们可以使用重载定义多个 `reverse` 的函数类型

```ts
function reverse(x: number): number
function reverse(x: string): string
function reverse(x: number | string): number | string {
  if (typeof x === 'number') {
    return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
    return x.split('').reverse().join('')
  }
}
```

在上面的示例当中，我们重复定义了多次函数 `reverse`，前几次都是函数定义，最后一次是函数实现，而 `TypeScript` 则会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面

以上就是我们梳理的一些 `TypeScript` 当中的基础内容，在 [下一章](http://localhost:4000/2021/01/01/JavaScript/57/) 当中我们会接着来了解一些 `TypeScript` 当中的进阶内容，比如元祖，枚举，泛型等




## 参考

* [TypeScript](https://www.typescriptlang.org)