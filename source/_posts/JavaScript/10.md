---
title: parseInt() 与 parseFloat()
date: 2017-04-15
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/10.webp
---

在 `JavaScript` 中，`parseInt()` 和 `parseFloat()` 的函数功能都是将所谓的数字字符串转化为一个真正的数值，但是两者在使用之上还是存在一定的区别的，它们两者之间的区别如下

<!--more-->




* `parseFloat(string)`，`parseFloat()` 函数可解析一个字符串，并返回一个浮点数，指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串
* `parseInt(string, radix)`，`parseInt()` 函数可解析一个字符串，并返回一个整数，`radix` 为进制，如果省略该参数或其值为 `0`，则数字将以 `10` 为基础来解析

## 差异

`parseInt` 和 `parseFloat` 都是将字符串类型转换为 `number` 类型，两者区别在于 `parseFloat` 会将 `.` 号转换为浮点数，而 `parseInt` 直接忽略停止转换，比如当处理 `'5.12asc'` 时，`parseInt` 直接转换为 `5`，`parseFloat` 则会转换为 `5.12`，`parseInt` 还可以指定第二位参数来指定转换结果的进制（`2, 8, 16`）（范围为 `2 - 36`）




## parseFloat 与 NAN

`parseFloat` 会将它的字符串参数解析成为浮点数并返回，如果在解析过程中遇到了正负号（`+` 或 `-`）、数字（`0 - 9`）、小数点，或者科学记数法中的指数（`e` 或 `E`）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数

同时参数字符串首位的空白符会被忽略，如果参数字符串的第一个字符不能被解析成为数字，则 `parseFloat` 返回 `NaN`，根据 [#parseFloat](https://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#parseFloat_.28string.29) 可知，当调用 `parseFloat` 函数，是先转成字符串，再转为数字，如果不能转为数字，则返回 `NaN`，大体意思就是

1. 如果返回的是原始类型，则将此返回值转为字符串，再尝试将字符串转为数字，如果不能转成数字则返回 `NaN`
2. 如果 `toString` 方法返回的不是原始类型，则继续调用 `valueOf` 方法，如果返回的是原始类型，则将其转为字符串，再将字符串转为数字返回
3. 如果 `valueOf` 方法返回的也不是原始类型，则返回 `NaN`



## map(parseInt)

一个经典的问题

```js
// 下面的语句返回什么
['1', '2', '3'].map(parseInt)
```

你可能觉的会是 `[1, 2, 3]`，但实际的结果是 `[1, NaN, NaN]`，通常使用 `parseInt` 时，只需要传递一个参数，但实际上 `parseInt` 可以有两个参数，第二个参数是进制数，可以通过语句 `'alert(parseInt.length) === 2'` 来验证

`map` 方法在调用 `callback` 函数时，会给它传递三个参数，当前正在遍历的元素，元素索引，原数组本身，第三个参数 `parseInt` 会忽视，但第二个参数不会，也就是说 `parseInt` 把传过来的索引值当成进制数来使用，从而返回了 `NaN`，只需要稍微调整一下，正确的传递进制索引即可
 
```js
['1', '2', '3'].map(item => parseInt(item, 10))
// 返回 [1, 2, 3]
```


## parseFloat() 精度的问题

只有字符串中的第一个数字会被返回，开头和结尾的空格是允许的，提示，如果字符串的第一个字符不能被转换为数字，那么 `parseFloat()` 会返回 `NaN`，如果只想解析数字的整数部分，请使用 `parseInt()` 方法

```js
parseFloat('10')         // 10

parseFloat('10.00')      // 10

parseFloat('10.33')      // 10.33

parseFloat('34 45 66')   // 34

parseFloat(' 60 ')       // 60

parseFloat('40 years')   // 40

parseFloat('He was 40')  // NaN
```

通过以上一些实例，我们对 `parseFloat` 的基本用法大致应该了解一些了，下面我们来看一些平常可能会遇到的问题，如下

```js
var num = parseFloat('233333.9') - parseFloat('0.2')

// 233333.69999999998
console.log(num)
```

很明显结果并不是我们想要的样子，那么为什么会造成这种情况呢？其实最主要的原因就在于能被计算机读懂的是二进制，而不是十进制，我们来把 `0.2` 转换为二进制看一看

```js
0.2 ==> 0.0011 0011 0011 0011 …
```

这样一看问题就很明显了，因为它是一个无限循环的小数，所以我们在平常过程当中需要做的就是尽量避免这样的情况发生，如果无法避免的话，可以采用以下几种方式来进行处理

```js
// 第一种，四舍五入
Math.round(parseFloat('233333.9') - parseFloat(0.2))

// 第二种，保留几位小数
num.toFixed(2)  // toFixed(n) 中的 n 代表保留几位 

// 第三种，扩大一定的倍数，对结果在缩小这个倍数
var num1 = parseFloat('233333.9') * 1000000000000
var num2 = parseFloat('0.2') * 1000000000000
var num3 = (num1 - num2) / 1000000000000
```

> 另外还可以使用一些第三方库来进行解决，比如 [bignumber](https://github.com/MikeMcl/bignumber.js/)



## 为什么 0.1 + 0.2 === 0.3 返回 false

同上面的精度问题是一样的原因，但是为什么会造成这样的现象呢？在展开这个问题之前，我们需要先了解计算机内部是如何表示数的，在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数，看下面两个例子，首先是整数

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|10|13|1x10^1 + 3x10^0 = 10 + 3|
|13|2|1101|1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|

其次是浮点数

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|0.625|10|0.625|6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|2|0.101|1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

通过上面两个表我们可以发现，其实简单来说就是

* 十进制整数转二进制方法，除 `2` 取余
* 十进制小数转二进制方法，乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011 ...`，这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数，这里就会存在一个「在某个精度点直接舍弃」的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因，这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

结果是，两个有舍入误差的值在求和时，相互抵消了，类似于负负得正，相互抵消这样的效果，但这种结果不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消

另一个需要注意的是，二进制能精确地表示位数有限且分母是 `2` 的倍数的小数，比如 `0.5`，`0.5` 在计算机内部就没有舍入误差，所以 `0.5 + 0.5 === 1`，在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在，虽然允许误差存在，但是「永远不要直接比较两个浮点的大小」

一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差，如果非要计算一些浮点数，可以采用第三方库，比如之前提到过的 [bignumber](https://github.com/MikeMcl/bignumber.js) 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望

```js
{
  let x = new BigNumber(0.1)
  let y = new BigNumber(0.2)
  let z = new BigNumber(0.3)

  console.log(z.equals(x.add(y)))    // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y))  // true
  console.log(z.minus(y).equals(x))  // true
}

{
  let x = 0.2
  console.log(x * x === 0.04)  // false
  let y = new BigNumber(0.2)
  let r = y.mul(y)             // 0.04
  console.log(r.equals(new BigNumber(0.04)))  // true
}
```


## 总结

* 为什么 `0.1 + 0.2` 不等于 `0.3`，因为计算机不能精确表示 `0.1`， `0.2` 这样的浮点数，计算时使用的是带有舍入误差的数
* 并不是所有的浮点数在计算机内部都存在舍入误差，比如 `0.5` 就没有舍入误差
* 具有舍入误差的运算结可能会符合我们的期望，原因可能是负负得正，相互抵消这样的效果
* 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 [bignumber](https://github.com/MikeMcl/bignumber.js) 这样的浮点数运算库
