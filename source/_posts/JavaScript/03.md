---
title: JavaScript 中的作用域
date: 2017-01-18
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://raw.githubusercontent.com/heptaluan/blog/master/backups/cdn/cover/03.jpg
---

在看作用域之前，我们先来看看 `IIFE`（立即执行函数表达式），也就是所谓的立即执行函数，那么为什么需要 `IIFE`

* 传统的方法啰嗦，定义和执行分开写

* 传统的方法直接污染全局命名空间（浏览器里的 `global` 对象，如 `window`）

<!--more-->

转变表达式的办法有很多，最常见的办法是把函数声明用一对 `()` 包裹起来，于是就变成了立即执行函数

## IIFE

一个简单的 `IIFE`

```js
// 这里是故意换行，实际上可以和下面的括号连起来
(function foo() {...})
();
```

这就等价于：

```js
// 这就不是定义，而是表达式了
var foo = function () {...};

foo();
```

但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式

```js
(function foo(){...}());
```

另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如

```js
!function foo() {
  // ...
}();

// or

+function foo() {
  // ...
}();

// or

void function () {
  // ...
}();
```

所谓不去污染全局命名空间，是因为 `IIFE` 创建了一个新的函数作用域，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了

如果你需要全局对象，那就 `pass` 给 `IIFE`

```js
void function (global) {
  // 在这里，global 就是全局对象了
}(this)  // 在浏览器里，this 就是 window 对象
```



## 变量提升（Hoisting）

先看一个例子

```js
var a = 1;

function foo () {
  if (!a) {
    var a = 2;
  }
  alert(a);
};

foo();  // 输出 2
```

之所以输出 `2`，这就是所谓的变量提升了

所谓声明变量

```js
var a;
```

所谓定义变量

```js
var a = 1;
```

* 声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

* 定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

总结下来就是：

```js
var a;      // 这是声明
a = 1;      // 这是定义（赋值）
var a = 1;  // 合二为一，声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

可以把之前的例子稍微转换一下，就成了如下

```js
var a;
a = 1;

function foo() {
  var a;    // 关键在这里
  if (!a) {
    a = 2;
  }
  alert(a); // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



## 作用域（Scoping）

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> **JavaScript 只有函数作用域！**

所以在上文当中，若是想要 `alert(a)` 弹出那个 `1`，也可以创建有一个新的作用域，就是利用之前所说的 `IIFE`

```js
var a = 1;

function foo() {
  // 这个就是 IIFE，它会创建一个新的函数作用域
  // 并且该作用域在 foo() 的内部，所以 alert 访问不到
  // 不过这个作用域可以访问上层作用域，这就叫 闭包
  if (!a) {
    (function() {   
      var a = 2;  
    }());                
  };
  alert(a);
};

foo();
```

> 请始终保持作用域内所有变量的声明放置在作用域的顶部

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）


1. 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

2. 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

3. 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

4. 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的

> `Hosting` 只提升了命名，没有提升定义





## 函数声明与函数表达式的差别

先看两个例子

```js
// test1
function test () {
  foo();
  function foo() {
    alert('出现');
  }
}

test();

// test2
function test () {
  foo();
  var foo = function() {
    alert('不会出现');
  }
}

test();
```

在第一个例子里，函数 `foo` 是一个声明，既然是声明就会被提升（特意包裹了一个外层作用域，因为全局作用域需要你的想象，不是那么直观，但是道理是一样的），所以在执行 `foo()` 之前，作用域就知道函数 `foo` 的存在了

这叫做：函数声明（`Function Declaration`），函数声明会连通命名和函数体一起被提升至作用域顶部

然而在第二个例子里，被提升的仅仅是变量名 `foo`，至于它的定义依然停留在原处，因此在执行 `foo()` 之前，作用域只知道 `foo` 的命名，不知道它到底是什么，所以执行会报错（通常会是：`foo is not a function`）

这叫做：函数表达式（`Function Expression`），函数表达式只有命名会被提升，定义的函数体则不会



## 变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`VO`）

变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的对象，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


来看看以下几个实例，可以加深我们理解 `VO`

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo(x, y, z) {
  function fn() { };
  var fn;
  console.log(fn);    // function fn () {}
}

foo(100);

// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo(x, y, z) {
  function fn() { };
  var fn = 1;
  console.log(fn);    // 1
}

foo(100);

// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;

function a(num) {
  num = 100;
  console.log(num);
}

a();
console.log(num);
```

> 函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `VO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象






## 实战

先来看几个 `setTimeout` 相关的问题：

```js
// 第一个
var a = 6;

setTimeout(function () {
  alert(a); // 输出 66
  a = 666;
}, 1000);

a = 66;


// 第二个
var a = 6;

setTimeout(function () {
  var a = 666;
  alert(a); // 输出 666
}, 1000);

a = 66;


//第三个
var a = 6;

setTimeout(function () {
  alert(a); // 输出 undefined
  var a = 666;
}, 1000);

a = 66;


//第四个
var a = 6;

setTimeout(function () {    
  a = 666;
  alert(a); // 输出 666
}, 1000);

a = 66;


//第五个
var a = 6; 

setTimeout(function(){
  alert(a);
  var a = 66; 
}, 1000);

a = 666; 
alert(a); 

// 666, undefined; 
```

这几个问题涉及到了 `setTimeout` 的工作原理，执行环境与作用域还有函数的创建与调用

首先先说一下 `setTimeout(function(){ }, time)` 函数，现在在我们的 `JavaScript` 文件中有这么一段代码：`setTimeout(a(), 5000)`

在执行流执行到 `setTimeout` 代码时，**并不会**原地踏步地等待执行完毕后再向下执行，而是会告诉浏览器，我这段代码要等待 `5` 秒之后再执行，然后立即向下执行接下来的代码


现在可以先解决第一个问题了

首先定义了一个局部变量 `a`，并且 `a = 6` ，然后执行流遇到了 `setTimeout()`，告诉浏览器，我 `1` 秒之后再执行这段代码，此时 `a` 仍然为 `6`

然后跳过 `setTimeout()` 中的代码继续向下执行，就碰到了 `a = 66`，将 `a` 赋值为 `66` ，一秒过去了之后，浏览器开始调用 `setTimeout()` 函数中的匿名函数，遇到了 `alert(a)`，在此之前匿名函数中并没有创造局部变量 `a`，所以随着作用域链由内向外搜寻看看有没有变量 `a`，当搜寻到外部函数的作用域时，发现 `a` 已经被赋值成了 `66`，则返回结果，最终弹出窗口显示 `66`

第二个问题中，由于在 `setTimeout()` 的匿名函数中拥有了一个局部变量 `a`，所以最后 `alert(a)` 输出的是 `666`，（因为 `var a = 666;` 定义了局部变量 `a`，并且赋值为 `666`，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量）

至于第三个问题，涉及到了一个函数的创建与执行的区别，前面的运行同上面两个类似所以，直到执行流遇到 `alert(a)` 的时候，开始搜寻当前环境下有没有 `a` 变量，最终发现了一个 `a` 变量（被前置的，当前为 `undefined`），但是在未执行 `var a = 666` 之前，`a` 并没有被赋值，所以 `alert(a)` 的最终结果为 `undefined`，这也解释了为什么第四个最终会输出 `666`

至于最后一个，需要注意的是是先弹出 `666`，然后才是 `undefined`，（异步处理，声明提前）

再来看几个比较绕的：

```js
function test() {
  var a = 1;
  
  setTimeout(function () {
    alert(a);
    a = 3;
  }, 1000);

  a = 2;

  setTimeout(function () {
    alert(a);
    a = 4;
  }, 3000);

};

test();
alert(0);
```

首先 `setTimeout` 是一个异步延迟函数，上面说过了的，先弹出 `0` 是很明显的，因为 `test` 中的两个 `alert()` 都被延迟了，再弹出 `0` 之前 `test` 中的 `a` 是 `2`

所以在弹出 `0` 之后的第一个定时器中的 `alert` 就是 `2` 了，在弹 `2` 之后执行了赋值操作 `a = 3`，所以第二个定时器弹出的为 `3`



