---
title: 进程与线程
date: 2019-05-04
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://raw.githubusercontent.com/heptaluan/blog/master/backups/cdn/cover/54.jpg
---

最近在深入学习 `Node.js`，有涉及到这一部分内容，翻出来重新更新整理一下

> 最后更新于：`2019` 年 `10` 月 `18` 日

<!--more-->

对于操作系统来说，一个任务就是进程（`process`），比如打开一个浏览器就是启动了一个浏览器进程，打开一个记事本就启动了一个记事本进程

有些进程还不止同时干一件事，比如 `word`，它可以同时进行打字、拼写检查，打印等，在一个进程的内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程（`thread`）

由于每个进程至少要干一件事，所以，一个进程至少有一个线程，当然也可以有多个，也可以多个线程同时执行

> 简单来说就是，线程是最小的执行单元，而进程由至少一个线程组成



## 进程


进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器

`Node.js` 里通过命令行可以开启一个服务进程，多进程就是进程的复制（`fork`），`fork` 出来的每个进程都拥有自己的独立空间地址、数据栈

一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 `IPC` 通信，进程之间才可数据共享（关于 `IPC` 通信见下方）

我们可以通过一个简单的示例来验证一下

```js
const http = require('http');

http.createServer().listen(3000, () => {
  process.title = '测试进程'
  console.log(`process.pid: `, process.pid);
});
```

打开任务管理器，可以在进程选项当中发现我们刚开启的 `Node.js` 进程



## 线程

线程是操作系统能够进行运算调度的最小单位，**线程是隶属于进程的，被包含于进程之中**

**一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的**

同一块代码，可以根据系统 `CPU` 核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的

同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等

但同一进程中的多个线程有各自的调用栈（`call stack`），自己的寄存器环境（`register context`），自己的线程本地存储（`thread-local storage`）



#### 线程的好处

之所以设置线程这个单位

* 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型

* 线程较进程来讲，更轻

* 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 `CPU` 的利用率




## 两者的关系和共性

* 关系：进程中包含着至少一个线程

  * 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程
  
  * 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源

* 共性：都包含三个状态，就绪、阻塞、运行

  * 阻塞就是资源未到位，等待资源中
  
  * 就绪，就是资源到位了，但是 `CPU` 未到位，还在运行其他






## 单线程

单线程就是一个进程只开一个线程，所谓的单线程和多线程，本质上指在**一个进程内**的单线程和多线程

* 单线程：单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序

* 多线程：多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的



#### JavaScript 中的单线程执行机制

`JavaScript` 就是属于单线程，程序顺序执行，本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是**事件驱动的、异步的、多线程的**

浏览器内部有一个事件轮询（`event loop`），是一个大的内部消息循环，会轮询大的消息队列，并执行，也就是 `JavaScript` 要处理的事件队列，是浏览器维护的

浏览器至少有四个线程（不同浏览器会有差异）

* `JavaScript` 引擎线程

* 界面渲染线程

* 浏览器事件触发线程

* `http` 请求线程

再来看看 `setTimeout` 和 `Ajax`

* `setTimeout`：`JavaScript` 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 `JavaScript` 引擎执行，都是在浏览器空闲了才会执行

* `Ajax`：是真正的异步，在调用 `Ajax` 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 `JavaScript` 引擎执行


#### JavaScript 中的阻塞

浏览器虽然是多线程，但是由于 `JavaScript` 具有阻塞特性（比如 `alert`），无论外链还是内嵌脚本，在浏览器执行解释 `JavaScript` 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 `JavaScript` 下载并执行完毕

这样一来，`JavaScript` 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验

所以避免此类情况的话可以采用下面一些方式

* 将 `<script>` 内嵌和外链，在可以的情况下放在 `<body>` 底部（对于 `CSS`，浏览器是并行下载的）

* 在页面 `onload` 后再加载 `JavaScript`

* 可以使用 `html5` 的  `<script>` 标签的 `defer` 属性，在页面加载完成后下载

* 使用动态创建 `<script>` 标签的方式，在页面加载完成后添加进去（`createElement`）

简单来说就是一句话，先让页面渲染完，再加载 `JavaScript`

> `Node.js` 的运行机制也是基于事件轮询 （`event loop`）


来看下面这个 `Node.js` 的示例，我们实现一个计算耗时过长造成线程阻塞的例子，来了解阻塞所带来的后果

```js
const http = require('http');

const computation = () => {
  let sum = 0;
  console.info('计算开始');
  console.time('计算耗时');

  for (let i = 0; i < 10000000000; i++) {
    sum += i
  };

  console.info('计算结束');
  console.timeEnd('计算耗时');
  return sum;
};

const server = http.createServer((req, res) => {
  const sum = computation();
  res.end(`Sum is ${sum}`);
});

server.listen('3000', _ => {
  console.log(`app is running at port 3000.`);
});
```

运行完成后可以发现，计算耗时会有 `13554.335ms` 左右，不过不用担心，在后面我们会使用 `child_process.fork` 来实现多个进程来处理




## 多线程

多线程就是没有一个进程只开一个线程的限制，可以有效避免代码阻塞导致的后续请求无法处理

多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽

类似于上面单线程模型中例举的例子，需要一定的计算会造成当前线程阻塞的，还是推荐使用多线程来处理



#### 关于线程同步

线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步）

也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的


#### 方式和机制

可以配合这篇文章来进行理解，[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)，图文并茂，解释的很详细

主要有临界区（`Critical Section`）、互斥量（`Mutex`）、信号量（`Semaphore`）、事件（`Event`）四种方式

区别如下：

* 临界区

  * 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意时刻只允许一个线程对共享资源进行访问

  * 如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开
  
  * 临界区在被释放后，其他线程才可以抢占

* 互斥量

  * 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限
  
  * 因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问
  
  * 互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享

* 信号量

  * 它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

* 事件

  * 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作




<!-- ## Node.js 的线程与进程 -->

