---
title: JavaScript 中一些常用方法的实现
date: 2019-08-02
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/45.jpg
---

算是一些手写 `API`，常用方法的一些汇总，反正就是面试可能涉及到的一些手写功能可能都会有所涉及，不仅仅只是为了面试所用，也算是在这里做下汇总记录，方便以后可以快速查询（可以直接参考左边目录）

<!--more-->


## once/debounce/thorttle

`once` 方法实现比较简单，一般来说有两种实现方式，方法一，利用闭包的特性，传递参数，执行完一次以后就自动解除绑定

```js
function once(dom, event, callback) {
  var handle = function () {
    callback()
    dom.removeEventListener(event, handle)
  }
  dom.addEventListener(event, handle)
}
```

第二种方式是定义一个局部变量，用来标记函数是否已经调用

```js
const once = (fn) => {
  let done = false
  return function () {
    done ? undefined : ((done = true), fn.apply(this, arguments))
  }
}
```

防抖和节流可以使用一个现实中常见的例子来进行举例，比如使用电梯运送策略来说明这两个方法，比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 `throttle` 和 `debounce` ，超时设定为 `15` 秒，不考虑容量限制

* `throttle` 策略的电梯，保证如果电梯第一个人进来后，`15` 秒后准时运送一次，不等待，如果没有人，则待机
* `debounce` 策略的电梯，如果电梯里有人进来，等待 `15` 秒，如果有人进来，`15` 秒等待重新计时，直到 `15` 秒超时，开始运送

关于两者更为具体的应用和内部的一些原理可以参考 [函数防抖和节流](https://heptaluan.github.io/2020/01/05/JavaScript/49/)，下面是代码实现

```js
function debounce(fn, wait) {
  var timer
  return function () {
    var that = this, args = arguments
    clearTimeout(timer)
    timer = setTimeout(function() {
      fn.apply(that, args)
    }, wait)
  }
}

function throttle(fn, wait) {
  var timer
  var prev = 0
  return function () {
    var that = this, now = new Date(), args = arguments
    clearTimeout(timer)
    if (now - prev >= wait) {
      fn.apply(that, args)
      prev = now
    } else {
      timer = setTimeout(function () {
        fn.apply(that, args)
      }, wait)
    }
  }
}
```



## call/apply/bind

`call` 和 `apply` 更为具体的应用可以参考 [JavaScript 中的 call 和 apply](https://heptaluan.github.io/2018/04/16/JavaScript/27/)，主要包括

* 两者的区别
* `call` 和 `apply` 的第一个参数
* 原理
* 实现
* `call` 和 `apply` 哪个速度更快一些

实现如下

```js
Function.prototype.call = function (context, ...args) {
  if (context === null || context === undefined) {
    context = window
  } else {
    context = Object(context)
  }
  let fn = Symbol()
  context[fn] = this
  let result = context[fn](...args)
  delete context[fn]
  return result
}


Function.prototype.apply = function (context) {
  if (context === null || context === undefined) {
    context = window
  } else {
    context = Object(context)
  }
  let fn = Symbol()
  context[fn] = this
  let result = arguments[1] ? context[fn](...arguments[1]) : context[fn]()
  delete context[fn]
  return result
}

// 如果为了更为完善的话，可以针对 apply 的第二个参数（类数组对象）来进行判断一下
const args = arguments[1]
let result
if (args) {
  if (!Array.isArray(args) && !isArrayLike(args)) {
    throw new TypeError(`second parameter needs to be an array or class array object`)
  } else {
    args = Array.from(args)
    result = context[fn](...args)
  }
} else {
  result = context[fn]()
}

function isArrayLike(o) {
  if (o &&                                 // o 不是 null、undefined 等
    typeof o === 'object' &&               // o 是对象
    isFinite(o.length) &&                  // o.length 是有限数值
    o.length >= 0 &&                       // o.length 为非负值
    o.length === Math.floor(o.length) &&   // o.length 是整数
    o.length < 4294967296)                 // o.length < 2^32
    return true
  else
    return false
}
```

`bind` 更为详细的实现可见 [Function.prototype.bind()](https://heptaluan.github.io/2017/05/07/JavaScript/13/)，主要包括

* 基本语法
* 使用 `bind` 绑定参数表
* 理解 `bind`
* `bind` 与 `currying`
* `bind` 与 `new`
* `bind` 实现

`ES5` 当中实现

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
    }
    var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)))
      }
    fNOP.prototype = this.prototype
    fBound.prototype = new fNOP()
    return fBound
  }
}
```

`ES6` 当中实现

```js
Function.prototype.myBind = function (oThis, ...args) {
  const thisFn = this
  let fToBind = function (...params) {
    const context = this instanceof fToBind ? this : Object(oThis)
    return thisFn.apply(context, ...args, ...params)
  }
  fToBind.prototype = Object.create(thisFn.prototype)
  return fToBind
}
```



## new 的实现

要想手动实现 `new` 操作符，首先我们要知道 `new` 做了什么

1. 创建一个新对象，并继承其构造函数的 `prototype`，这一步是为了继承构造函数原型上的属性和方法
2. 执行构造函数，方法内的 `this` 被指定为该新实例，这一步是为了执行构造函数内的赋值操作
3. 返回新实例（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）

```js
/* new Constructor */
function new (f) {
  var n = { '__prop__': f.prototype }  /* step1 */
  return function () {
    f.apply(n, arguments)              /* step2 */
    return n                           /* step3 */
  }
}
```

但是 `__proto__` 这个属性是一个非标准属性，所以我们也可以采用下面这种方式

```js
function myNew(foo, ...args) {
  let obj = Object.create(foo.prototype)  // 创建一个新对象，并继承构造方法的 prototype 属性，这一步是为了把 obj 挂在原型链上，相当于 obj.__proto__ = Foo.prototype
  let result = foo.apply(obj, args)       // 执行构造方法，并为其绑定新 this，这一步是为了让构造方法能进行 this.name = name 之类的操作，args 是构造方法的入参

  // 如果构造方法已经 return 了一个对象，那么就返回该对象，否则返回我们新创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖 new 创建的对象）
  return Object.prototype.toString.call(result) === '[object Object]'
    ? result 
    : obj
}
```

我们可以来测试一下

```js
function Foo(name) {
  this.name = name
}
const newObj = myNew(Foo, 'zhangsan')

console.log(newObj)                 // Foo {name: 'zhangsan'}
console.log(newObj instanceof Foo)  // true
```





## promise 的实现

```js
const isFunction = variable => typeof variable === 'function'

// 定义 Promise 的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {

  constructor(handle) {
    if (!isFunction(handle)) throw new Error('MyPromise must accept a function as a parameter')

    this._status = PENDING      // 添加状态
    this._value = undefined     // 添加状态
    this._fulfilledQueues = []  // 添加成功回调函数队列
    this._rejectedQueues = []   // 添加失败回调函数队列

    try {
      handle(this._resolve.bind(this), this._reject.bind(this))
    } catch (err) {
      this._reject(err)
    }
  }

  _resolve(val) {
    const run = () => {
      if (this._status !== PENDING) return
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = (value) => {
        let cb
        while (cb = this._fulfilledQueues.shift()) {
          cb(value)
        }
      }
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = (error) => {
        let cb
        while (cb = this._rejectedQueues.shift()) {
          cb(error)
        }
      }

      // 如果 resolve 的参数为 Promise 对象，则必须等待该 Promise 对象状态改变后
      // 当前 Promsie 的状态才会改变，且状态取决于参数 Promsie 对象的状态
      if (val instanceof MyPromise) {
        val.then(value => {
          this._value = value
          this._status = FULFILLED
          runFulfilled(value)
        }, err => {
          this._value = err
          this._status = REJECTED
          runRejected(err)
        })
      } else {
        this._value = val
        this._status = FULFILLED
        runFulfilled(val)
      }
    }

    // 为了支持同步的 Promise，这里采用异步调用
    setTimeout(run, 0)
  }

  _reject(err) {
    if (this._status !== PENDING) return
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED
      this._value = err
      let cb
      while (cb = this._rejectedQueues.shift()) {
        cb(err)
      }
    }
    // 为了支持同步的 Promise，这里采用异步调用
    setTimeout(run, 0)
  }

  then(onFulfilled, onRejected) {
    const { _value, _status } = this
    // 返回一个新的 Promise 对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      let fulfilled = value => {
        try {
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value)
          } else {
            let res = onFulfilled(value)
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回 MyPromise 对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的 Promise 对象的状态为失败
          onRejectedNext(err)
        }
      }
      // 封装一个失败时执行的函数
      let rejected = error => {
        try {
          if (!isFunction(onRejected)) {
            onRejectedNext(error)
          } else {
            let res = onRejected(error)
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回 MyPromise 对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的 Promise 对象的状态为失败
          onRejectedNext(err)
        }
      }
      switch (_status) {
        // 当状态为 pending 时，将 then 方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled)
          this._rejectedQueues.push(rejected)
          break
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value)
          break
        case REJECTED:
          rejected(_value)
          break
      }
    })
  }

  catch(onRejected) {
    return this.then(undefined, onRejected)
  }

  static resolve(value) {
    // 如果参数是 MyPromise 实例，直接返回这个实例
    if (value instanceof MyPromise) return value
    return new MyPromise(resolve => resolve(value))
  }

  static reject(value) {
    return new MyPromise((resolve, reject) => reject(value))
  }

  static all(list) {
    return new MyPromise((resolve, reject) => {
      // 返回值的集合
      let values = []
      let count = 0
      for (let [i, p] of list.entries()) {
        // 数组参数如果不是 MyPromise 实例，先调用 MyPromise.resolve
        this.resolve(p).then(res => {
          values[i] = res
          count++
          // 所有状态都变成 fulfilled 时返回的 MyPromise 状态就变成 fulfilled
          if (count === list.length) resolve(values)
        }, err => {
          // 有一个被 rejected 时返回的 MyPromise 状态就变成 rejected
          reject(err)
        })
      }
    })
  }

  static race(list) {
    return new MyPromise((resolve, reject) => {
      for (let p of list) {
        // 只要有一个实例率先改变状态，新的 MyPromise 的状态就跟着改变
        this.resolve(p).then(res => {
          resolve(res)
        }, err => {
          reject(err)
        })
      }
    })
  }

  finally(cb) {
    return this.then(
      value => MyPromise.resolve(cb()).then(() => value),
      reason => MyPromise.resolve(cb()).then(() => { throw reason })
    )
  }
}
```




## Object.create() 的实现

关于 `Object.create()` 的详细用法可以参考 [Object.create()](https://heptaluan.github.io/2017/03/03/JavaScript/07/)，在了解过它的具体原理后，我们不难可以手动的来进行实现

```js
if (!Object.create) {
  Object.create = function (o) {
    function F() { }
    F.prototype = o
    return new F()
  }
}
```





## 节点遍历操作

#### prev

```js
// 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点
function getRealPrev(elem) {
  var o = elem
  // 循环遍历，将循环的结果再次赋予 o，依次向上查询
  while (o = o.previousSibling) {
    if (o.nodeType == 1) {
      return o
    }
    return null
  }
}
```


#### next

```js
// 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点
function getRealNext(elem) {
  var o = elem
  // 循环遍历，将循环的结果再次赋予 o，依次向下查询
  while (o = o.nextSibling) {
    if (o.nodeType == 1) {
      return o
    }
    return null
  }
}
```


#### prevAll

```js
// 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点
function getRealprevAll(elem) {
  var o = elem
  var result = []
  // 循环遍历，将循环的结果再次赋予 o，依次向上查询，如果不存在上一个节点，则会返回 null，便自动停止循环
  while (o = o.previousSibling) {
    if (o.nodeType == 1) {
      result.unshift(o)
    }
    return result
  }
}
```


#### nextAll

```js
// 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点
function getRealnextAll(elem) {
  var o = elem
  var result = []
  // 循环遍历，将循环的结果再次赋予 o，依次向下查询，如果不存在下一个节点，则会返回 null，便自动停止循环
  while (o = o.nextSibling) {
    if (o.nodeType == 1) {
      result.push(o)
    }
    return result
  }
}
```

## 数组原生方法的实现

#### Array.prototype.splice()

```js
Array.prototype.splice = function (start, deleteCount) {
  var max = Math.max,
    min = Math.min,
    delta,                                        // 偏移量
    element,
    insertCount = max(arguments.length - 2, 0),   // 排除掉 arguments 参数中 start 和 deleteCount，剩余是待插入元素
    k = 0,
    len = this.length,                            // 对 array 调用时，this 指向当前数组
    new_len,
    result = [],                                  // 返回数组
    shift_count                                   // 需移位的数量

  start = start || 0                              // start 默认值为 0
  if (start < 0) start += len                     // start < 0 时，从数组后端开始
  start = max(min(start, len), 0)                 // 经过处理，0 <= start <= len
  deleteCount = typeof deleteCount === 'number'   // deleteCount 默认值是 len
    ? deleteCount
    : len
  deleteCount = min(deleteCount, len - start)     // deleteCount <= 可删除数量
  deleteCount = max(deleteCount, 0)               // 0 <= deleteCount <= 可删除数量

  delta = insertCount - deleteCount
  new_len = len + delta

  // 获取删除元素
  while (k < deleteCount) {
    element = this[start + k]
    if (element != undefined) {
      result[k] = element
    }
    k += 1
  }

  shift_count = len - start - deleteCount

  // 待插入数量小于删除数量，原数组后续元素依次向左偏移
  if (delta < 0) {
    // 从 start 至 start + insertCount 留给待插入元素
    k = start + insertCount
    while (shift_count) {
      this[k] = this[k - delta]
      k += 1
      shift_count -= 1
    }
    this.length = new_len
  } else if (delta > 0) {
    // 待插入数量大于删除数量，原数组后续元素依次向右偏移，delta === 0 时，待插入数量等于删除数量，无需偏移
    k = 1
    while (shift_count) {
      this[new_len - k] = this[len - k]
      k + 1
      shift_count -= 1
    }
    // 非必须，因给一开始 this[new_len - k] 赋值时，length 属性已经自动设置为数组最后元素下标值（this.length = new_len）
  }

  // 最后将待插入元素插入原数组
  for (k = 0; k < insertCount; k += 1) {
    // 排除掉 arguments 参数中 start 和 deleteCount
    this[start + k] = arguments[k + 2]
  }

  return result
}
```



#### Array.prototype.push()

```js
Array.prototype.push = function () {

  // 对 arguments 对象通过 array.slice 方法转换成数组
  var args = Array.prototype.slice.apply(arguments)

  // 通过 array.concat 连接两个数组
  var params = [this.length, 0].concat(args)

  // 对数组调用 splice 方法
  // start = this.length
  // deleteCount = 0
  // insertItems = args
  this.splice.apply(this, params)

  // 返回新的数组 length
  return this.length
}

// 上述步骤合并，简写为下面方式（简单来说就是利用 concat 拼接两个数组）
Array.prototype.push = function () {
  this.splice.apply(this, [this.length, 0].concat(Array.prototype.slice.apply(arguments)))
  return this.length
}
```



#### Array.prototype.pop()

```js
// 删除并返回数组的最后一个元素，可以借用上面实现的 splice() 来进行实现
Array.prototype.pop = function () {
  return this.splice(this.length - 1, 1)[0]
}
```



#### Array.prototype.shift()

```js
// 和上面一样，但是删除并返回数组的第一个元素
Array.prototype.shift = function () {
  return this.splice(0, 1)[0]
}
```



#### Array.prototype.unshift()

```js
// 向数组的开头添加一个或更多元素，并返回新的长度
Array.prototype.unshift = function () {
  this.splice.apply(this, [0, 0].concat(Array.prototype.slice.apply(arguments)))
  return this.length
}
```



## 数组与字符串算法

#### 数组去重

> 默认传递的都是数组对象，所以在这里就省掉了针对入参的判断，我们只关心核心实现部分

第一种，也是最原始的方法，即双层循环（`while` 也可），其缺点是其复杂度为 `O(n^2)`，如果数组过大，将会影响性能，但是它也有好处，就是兼容性好，原理是先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组

```js
function unique(arr) {
  let res = [arr[0]]
  for (let i = 1; i < arr.length; i++) {
    let flag = true
    for (let j = 0; j < res.length; j++) {
      if (arr[i] === res[j]) {
        flag = false
        break
      }
    }
    if (flag) {
      res.push(arr[i])
    }
  }
  return res
}
```

第二种方法 `indexOf`，`indexOf` 用法也有两种使用方式

* 一种是首先定义一个空数组，然后调用 `indexOf` 方法对原来的数组进行遍历判断，如果元素不在新定义的数组中，则将其添加进去，最后将数组返回
* 第二种就是检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素

```js
// 第一种方式
function unique(arr) {
  let res = []
  for (let i = 0; i < arr.length; i++) {
    if (res.indexOf(arr[i]) === -1) {
      res.push(arr[i])
    }
  }
  return res
}

// 第二种方式
function unique(arr) {
  return Array.prototype.filter.call(arr, function (item, index) {
    return arr.indexOf(item) === index
  })
}
```

第三种方法，相邻元素去重，这种方法首先调用了数组的排序方法 `sort()`，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，但是这个方法存在缺陷，即 `sort()` 排序的结果并非十分准确

```js
function unique(arr) {
  arr = arr.sort()
  let res = []
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== arr[i - 1]) {
      res.push(arr[i])
    }
  }
  return res
}
```

第四种方法，利用对象属性去重，也就是所谓的对象键值对法，原理是遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值 `1`，每出现一次，对应的属性值增加 `1`，这样属性值对应的就是该元素出现的次数了（这个方法也可以用来统计字符串出现的次数）

```js
// 方式一
function unique(arr) {
  let res = [], obj = {}
  for (let i = 0; i < arr.length; i++) {
    if (!obj[arr[i]]) {
      res.push(arr[i])
      obj[arr[i]] = 1
    } else {
      obj[arr[i]]++
    }
  }
  return res
}

// 方式二，针对处理 [1, 2, 1, 1, '1'] 这样的数组，可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题
function unique(arr) {
  var obj = {}
  return arr.filter(function (item, index, array) {
    return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
  })
}
```

第五种方法，解构赋值去重，`ES6` 提供了新的数据结构 `Set`，它类似于数组，但是成员的值都是唯一的

```js
// 利用 Set
var unique = arr => [...new Set(arr)]

// 也可以使用 Map，原理也是利用对象属性
function unique(arr) {
  const map = new Map()
  return arr.filter((a) => !map.has(a) && map.set(a, 1))
}
```

最后来看一个特殊的数组处理

```js
var array = [1, 1, '1', '1', null, null, undefined, undefined, new String('1'), new String('1'), /a/, /a/, NaN, NaN]
```

针对上面的数组，上述去重方法结果如下，可以根据实际场景选择使用

| 方法 | 结果 | 说明 |
|-|-|-|
|双重 `for` 循环| `[1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN]` |对象和 `NaN` 不去重|
|单纯的 `indexOf`| `[1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN]` |对象和 `NaN` 不去重|
|`filter` + `indexOf`|  `[1, '1', null, undefined, String, String, /a/, /a/]` |对象不去重 `NaN` 会被忽略掉|
| 相邻元素去重（`sort`） |	`[/a/, /a/, '1', 1, String, 1, String, NaN, NaN, null, undefined]` |	对象和 `NaN` 不去重 数字 `1` 也不去重|
|对象键值对法| `[1, null, undefined, /a/, NaN]` | 无法区分数字 `1` 和 `'1'` |
|优化后的对象键值对法| `[1, '1', null, undefined, String, /a/, NaN]` |全部去重|
|`Set` 和 `Map`| `[1, '1', null, undefined, String, String, /a/, /a/, NaN]` |对象不去重 `NaN` 去重|

最后一种特殊情况，如果不是单纯的数组，而是数组对象的话，则可以使用 `reduce` 来进行处理

```js
function unique(arr, initialValue, id) {
  let hash = {}
  return arr.reduce((item, next) => {
    hash[next.id] ? '' : hash[next.id] = true && item.push(next)
    return item
  }, initialValue)
}

let arr = [{ 'id': 1 }, { 'id': 2 }, { 'id': 2 }, { 'id': 3 }]
newArr = unique(arr, [], 'id')
```



#### 数组降维（扁平化）

方法有很多种，我们一个一个来看，首先是一个比较局限的方法，就是 `toString`，如果数组的元素都是数字，那么我们可以考虑使用 `toString` 方法，然而这种方法使用的场景却非常有限，如果数组是 `[1, '1', 2, '2']` 的话，这种方法就会产生错误的结果

```js
// 将数组字符串化，然后在还原为数字数组
function flatten(arr) {
  return arr.toString().split(',').map(item => Number(item))
}
```

第二个方法也是比较容易想到的方法，就是递归展开，利用 `concat` 进行拼接，如果还是一个数组，就递归调用该方法

```js
// 方法一
function flatten(arr) {
  var result = []
  for (var i = 0, len = arr.length; i < len; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]))
    } else {
      result.push(arr[i])
    }
  }
  return result
}

// 方法二
function flatten(arr) {
  let ret = []
  let toArr = array => {
    array.forEach(item => {
      item instanceof Array ? toArr(item) : ret.push(item)
    })
  }
  toArr(arr)
  return ret
}
```

第三种方法，使用 `reducer`，原理跟第二种是一样的，不过使用了 `reduce` 来简化代码

```js
function flatten(arr) {
  return arr.reduce((prev, next) => {
    return prev.concat(Array.isArray(next) ? flatten(next) : next)
  }, [])
}
```

第四种，使用 `ES6` 提供的扩展运算符

```js
function flatten(arr) {
  while(arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr)
  }
  return arr
}
```

第五种，在 `ES6` 当中也提供了专门用于降维的方法 `flat()`

```js
[1, [1,2], [1,2,3]].flat()  // [1, 1, 2, 1, 2, 3]
```

第六种，使用正则进行匹配，简单来说就是将 `[` 和 `]` 替换成 `''`，然后在还原为数组

```js
const arr = [1, [1, 2], [1, 2, 3]]

JSON.parse(`[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`)  // [1, 1, 2, 1, 2, 3]
```


#### 字符串去重

第一种方式，常规的 `for` 遍历

```js
function unique1(str) {
  var newStr = ''
  var flag
  for (var i = 0; i < str.length; i++) {
    flag = 1
    for (var j = 0; j < newStr.length; j++) {
      if (str[i] == newStr[j]) {
        flag = 0
        break
      }
    }
    if (flag) newStr += str[i]
  }
  return newStr
}
```

第二种，使用 `indexOf`

```js
function unique2(str) {
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (newStr.indexOf(str[i]) == -1) {
      newStr += str[i]
    }
  }
  return newStr
}  
```

第三种，与上面第二种类似，不过判断方式换成了 `search`

```js
function unique3(str) {
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (newStr.search(str[i]) == -1)
      newStr += str[i]

  }
  return newStr
}
```

第四种方式，利用对象属性，推荐使用这种方式

```js
function unique4(str) {
  var obj = {}
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (!obj[str[i]]) {
      newStr += str[i]
      obj[str[i]] = 1
    }
  }
  return newStr
}
```

#### 生成区间随机数，并排序

```js
var arr = []

var randomNum = function (n, m) {
  return parseInt(Math.random() * (m - n) + n)
}

for (var i = 0; i < 20; i++) {
  arr.push(randomNum(40, 80))
}

// 排序
console.log(arr.sort(function (a, b) { return a - b }))

// 乱序
console.log(arr.sort(function () { return 0.5 - Math.random() }))
```

这里关于乱序需要说明一下，因为这里涉及到了 `sort()` 方法，所以上面的结果是存在一定误差的，我们可以来测试一下，比如下面这里例子，将 `[1, 2, 3, 4, 5]` 乱序 `10` 万次，计算乱序后的数组的最后一个元素是 `1、2、3、4、5` 的次数分别是多少

```js
var times = [0, 0, 0, 0, 0]

for (var i = 0; i < 100000; i++) {
  let arr = [1, 2, 3, 4, 5]
  arr.sort(() => Math.random() - 0.5)
  times[arr[4] - 1]++
}

console.log(times)  // [25028, 6975, 21233, 18538, 28226]
```

根据结果可以发现，这样的算法的确是有问题的，具体原因可以参考 [JavaScript专题之解读 v8 排序源码](https://juejin.im/post/59e80dc6f265da432a7aaf15)，但是在这里我们只考虑如何解决这样的问题，针对于乱序的问题，我们可以采用 [Fisher–Yates_shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)，比如如下两种方式，都是采用的「摸牌」方式

```js
// 方式一，随机抽选对换位置（余下的只在剩余位置交换）
function shuffle(arr) {
  for (var i = 0, len = arr.length; i < len; i++) {
    var randomIndex = i + Math.floor(Math.random() * (len - i))
    // randomIndex 需要在数组剩余当中挑选
    var temp = arr[i]
    arr[i] = arr[randomIndex]
    arr[randomIndex] = temp
  }
  return arr
}

// 方式二，随机抽选，抽到一个出列一个
function shuffle(arr) {
  var res = [], l = arr.length
  for (var i = 0; i < l; i++) {
    var randomIndex = Math.floor(Math.random() * arr.length)
    res[i] = arr[randomIndex]
    // 因为原数组项目会越来越少，因此上面的 randomIndex 需要实时获取 arr.length
    arr.splice(randomIndex, 1)
  }
  return res
}
```

我们可以来测试一下

```js
var times = 10000
var res = {}

for (var i = 0; i < times; i++) {
  var arr = shuffle([1, 2, 3])
  var key = JSON.stringify(arr)
  res[key] ? res[key]++ : res[key] = 1
}

// 转换成百分比
for (var key in res) {
  res[key] = res[key] / times * 100 + '%'
}

console.log(res)
```


#### 取数组的并集，交集和差集

```js
// 这里有一些需要注意的地方
// 如果两个数组 A 和 B 当中没有重复的元素，以下三种都是可以正常实现的
// 如果数组当中有重复的元素，需要使用 ES6 当中的 Set 数据结构
// 如果数组当中包含 NaN，可以考虑在结尾处添加 .filter(v => !isNaN(v)) 过滤掉即可
let a = [1, 2, 3, 4]
let b = [2, 3, 4, 5, 6]

// ES7 并集
a.concat(b.filter(v => !a.includes(v)))                                       // [1, 2, 3, 4]

// ES7 交集
a.filter(v => b.includes(v))                                                  // [2, 3]

// ES7 差集
a.concat(b).filter(v => !a.includes(v) || !b.includes(v))                     // [1, 4]

// ------------

let aSet = new Set(a)
let bSet = new Set(b)

// ES6 并集
Array.from(new Set(a.concat(b)))                                              // [1, 2, 3, 4]

// ES6 交集
Array.from(new Set(a.filter(v => bSet.has(v))))                               // [2, 3]

// ES6 差集
Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v))))    // [1, 4]

// ------------

// ES5 并集
a.concat(b.filter(v => a.indexOf(v) === -1))                                  // [1, 2, 3, 4]

// ES5 交集
a.filter(v => b.indexOf(v) !== -1)                                            // [2, 3]

// ES5 差集
a.filter(v => b.indexOf(v) === -1).concat(b.filter(v => a.indexOf(v) === -1))  // [1, 4]
```


#### 统计数组中每一项出现的次数

```js
[5, 5, 4, 3, 2, 1, 4, 5, 5, 4, 3, 2, 2, 1].reduce((ad, ap) => (ad[ap] = ++ad[ap] || 1, ad), {})
```


#### 寻找字符串中出现次数最少的、并且首次出现位置最前的字符

要求实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 `cbaacfdeaebb`，方法一，利用 `hash table`，缺点是 `Object.keys()` 不能保证顺序，所以存在风险

```js
var o = [].reduce.call('cbaacfdeaebb', function (p, n) {
  return p[n] = (p[n] || 0) + 1, p
}, {})

var s = Object.keys(o).reduce(function (p, n) {
  return o[p] <= o[n] ? p : n
})

console.log(s, o[s])
```

方法二，引入了 `index` 来解决顺序问题

```js
const all = 'cbaacfdeaebb'.split('')
  .reduce((all, ch, i) => {
    const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 })
    m.count++
    return all
  }, {})

const theOne = Object.keys(all)
  .map(ch => all[ch])
  .reduce((min, t) => min.count === t.count
    ? (min.index > t.index ? t : min)
    : (min.count > t.count ? t : min))

console.log(`${theOne.ch}: ${theOne.count}`)
```

方法三，利用数组代替 `hash table`，解决了顺序问题，但是 `Array.sort()` 并不一定是稳定的，风险可能更大

```js
function findFirstChar(string) {
  const desc = []

  [...string].forEach((char, index) => {
    const item = desc.find(item => item.char === char)
    item ? item.count++ : desc.push({ char, index, count: 1 })
  })

  return desc.sort((a, b) => a.count - b.count)[0]
}
```

方法四，使用 `Object.values`，但是目前还是草案

```js
const less = (x, y) => (x.count <= y.count && x.first < y.first) ? x : y

function firstSingle(string) {
  let map = {}

  string.split('')
    .forEach((char, index) => {
      map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char }
    })

  return Object.values(map).reduce(less).char
}
```

方法五，代码简短，但是执行效率不是很高

```js
var str = 'cbaacfdeaebb'

var result = [...new Set(str)]
  .map(el => ({ el, len: str.split(el).length }))
  .reduce((a, e) => (a.len > e.len ? e : a))
  .el
```


#### 生成指定长度数组

比如生成指定内容为 `[0, 1, 2, 3 ... N - 1]` 的数组

```js
// 方法一，ES5
Array.apply(null, { length: N }).map(function (value, index) {
  return index
})

// 方法二，ES6
Array.from(new Array(N), (v, i) => i)

// 方法三
Array.from(Array(N).keys())

// 方法四
[...Array(N).keys()]

// 方法五
Object.keys(Array(N).join().split(',')).map(v => Number(v))

// 方法六
Object.keys(Array(N).fill()).map(v => Number(v))

// 方法七
Object.keys(Array.apply(null, { length: 100 })).map(v => Number(v))

// 方法八
Array(N).fill().map((v, i) => i)

// 方法九
Array.prototype.recursion = function (length) {
  if (this.length === length) {
    return this
  }
  this.push(this.length)
  this.recursion(length)
}

arr = []
arr.recursion(100)
```


#### 计算最长递增子序列

所谓的最长递增子序列就是给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续，比如给定的序列是 `[0, 8, 4, 12, 2, 10]`，那么它的最长递增子序列就是 `[0, 2, 10]`（也可以是 `[0, 8, 10]` 或 `[0, 4, 12]` 等，并不是唯一）

针对于这种情况，我们可以利用动态规划思想来进行求解，可以参考下表，我们以该格子所对应的数字为开头的递增子序列的最大长度，至于如何计算一个格子中的值，规则很简单（假定从右往左），如下

* 1、拿该格子对应的数字 `a` 与其后面的所有格子对应的数字 `b` 进行比较，如果条件 `a < b` 成立，则用数字 `b` 对应格子中的值加 `1`，并将结果填充到数字 `a` 对应的格子中
* 2、只有当计算出来的值大于数字 `a` 所对应的格子中的值时，才需要更新格子中的数值

|0|8|4|12|2|10|
|-|-|-|-|-|-|
|3|2|2|1|2|1|

实现如下

```js
const seq = [0, 8, 4, 12, 2, 10]

function lis(seq) {

  // 构建索引表
  const valueToMax = {}
  let len = seq.length
  for (let i = 0; i < len; i++) {
    valueToMax[seq[i]] = 1
  }

  let i = len - 1
  let last = seq[i]
  let prev = seq[i - 1]
  while (typeof prev !== 'undefined') {
    let j = i
    while (j < len) {
      last = seq[j]
      if (prev < last) {
        const currentMax = valueToMax[last] + 1
        valueToMax[prev] = valueToMax[prev] !== 1
          ? (valueToMax[prev] > currentMax ? valueToMax[prev] : currentMax)
          : currentMax
      }
      j++
    }
    i--
    last = seq[i]
    prev = seq[i - 1]
  }

  const lis = []
  i = 1
  while (--len >= 0) {
    const n = seq[len]
    if (valueToMax[n] === i) {
      i++
      lis.unshift(len)
    }
  }

  return lis
}

// 注意，结果是序列中的位置索引，比如下列输出结果是 [0, 4, 5]，对应到 seq 当中则为 [0, 2, 10]
console.log(lis(seq))
```




#### BF 和 KMP 算法

这两个算法也是数据结构当中涉及比较多的算法，更为具体的原理跟实现方式可见 [BF 和 KMP 算法](https://heptaluan.github.io/2020/03/07/Essay/14/)，我们在这里简单的总结一下，两者的区别如下

`BF` 算法，即暴力（`Brute Force`）算法，是普通的模式匹配算法，`BF` 算法的思想就是将目标串 `S` 的第一个字符与模式串 `T` 的第一个字符进行匹配

* 若相等，则继续比较 `S` 的第二个字符和 `T` 的第二个字符
* 若不相等，则比较 `S` 的第二个字符和 `T` 的第一个字符，依次比较下去，直到得出最后的匹配结果

```js
function indexOf(str, key) {
  let i = 0, j = 0

  // 为了简洁，没有判断当 str 剩余的字符少于 key 应该终止循环，因为这样会用到 length
  // 原理和上方是一样的，即 str[j] 和 key[i] 对比，如果一样那么 i 和 j 都加 1，否则 j 恢复到匹配时的下一个，i 恢复到 0
  while (key[i] !== undefined && str[j] !== undefined) {
    if (key[i] === str[j]) {
      i++
      j++
    } else {
      j = j - i + 1
      i = 0
    }
  }
  if (i === 0) return -1;
  return j - i
}

s = 'ABCDABCDABDE'
t = 'ABCDABD'
indexOf(s, t)
```

相较于 `BF` 算法，`KMP` 算法的主旨是尽量的减少指针的回溯从而使得性能得到提高（主要是文本串的指针，下面可以发现），我们先来看一下 `KMP` 算法 的操作流程

* 假设现在文本串 `S` 匹配到 `i` 位置，模式串 `P` 匹配到 `j` 位置
* 如果 `j = -1`，或者当前字符匹配成功（即 `S[i] == P[j]` ），都令 `i++` 和 `j++`，然后继续匹配下一个字符
* 如果 `j != -1`，且当前字符匹配失败（即 `S[i] != P[j]` ），则令 `i` 不变，`j = next[j]`（此举意味着失配时，模式串 `P` 相对于文本串 `S` 向右移动了 `j - next[j]`  位）
* 换言之，将模式串 `P` 失配位置的 `next` 数组的值对应的模式串 `P` 的索引位置移动到失配处

```js
function getNext(p) {
  let k = -1
  let j = 0
  let next = [-1]
  let pLen = p.length

  while (j < pLen - 1) {
    // p[k] 表示前缀，p[j] 表示后缀
    if (k == -1 || p[j] == p[k]) {
      ++j
      ++k
      // 在这里直接进行赋值操作也是可以的，但是保持一致，还是同 C 语言版本，在这里进行一下优化
      if (p[j] != p[k]) {
        next[j] = k
      } else {
        // 因为不能出现 p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]
        next[j] = next[k]
      }
    } else {
      k = next[k]
    }
  }
  return next
}

function KMP(s, p) {
  let i = 0
  let j = 0

  let sLen = s.length
  let pLen = p.length

  let next = getNext(p)

  while (i < sLen && j < pLen) {
    // 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++
    if (j === -1 || s[i] === p[j]) {
      i++
      j++
    } else {
      // 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]
      // 这里就是与 BF 算法不同的地方，这里仅仅只用回退 j，而不用回退 i
      j = next[j]
    }
  }

  return j === pLen ? i - j : -1
}

s = 'ABCDABCDABDE'
t = 'ABCDABD'
KMP(s, t)  // 4
```


## 深浅拷贝 && Mixin

详细可见 [JavaScript 中的深浅拷贝](https://heptaluan.github.io/2018/01/14/JavaScript/24/)

#### 浅拷贝

```js
function shallowCopy(obj) {
  var newObj = {}
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      newObj[prop] = obj[prop]
    }
  }
  return dst
}
```


#### 深拷贝

```js
let deepCopy = function (obj) {
  if (typeof obj !== 'object') return             // 只拷贝对象
  let newObj = obj instanceof Array ? [] : {}     // 根据 obj 的类型判断是新建一个数组还是对象
  for (let key in obj) {                          // 遍历 obj，并且判断是 obj 的属性才拷贝
    if (obj.hasOwnProperty(key)) {
      newObj[key] = typeof obj[key] === 'object'  // 如果 obj 的子属性是对象，则进行递归操作,否则直接赋值
        ? deepCopy(obj[key])
        : obj[key]
    }
  }
  return newObj
}
```


#### Mixin

```js
function mixin(destClass, srcClass) {
  var destProto = destClass.prototype
  var srcProto = srcClass.prototype
  for (var method in srcProto) {
    if (!destProto[method]) {
      destProto[method] = srcProto[method]
    }
  }
}

function Parent() { }
Parent.prototype.say = function () {
  console.log('hello')
}

function Child() { }

mixin(Child, Parent)

var child = new Child()
child.say()  // hello
```


#### Mixin 多继承

```js
function mixin(destClass) {
  var classes = Array.prototype.slice.call(arguments, 1)
  for (var i = 0; i < classes.length; i++) {
    var srcClass = classes[i]
    var srcProto = srcClass.prototype
    var destProto = destClass.prototype
    for (var method in srcProto) {
      if (!destProto[method]) {
        destProto[method] = srcProto[method]
      }
    }
  }
}

function Parent() { }
Parent.prototype.getName = function () { }
Parent.prototype.setName = function () { }

function Child() { }
Child.prototype.showName = function () { }

function Man() { }

mixin(Man, Child, Parent)
var man = new Man()

console.log(man.__proto__)
// {
//   getName: ƒ ()
//   setName: ƒ ()
//   showName: ƒ ()
//   constructor: ƒ Man()
// }
```

## 常用设计模式的实现

#### 单例模式

简单来说，任意对象都是单例，无须特别处理

```js
var obj = { name: 'zhangsan', age: 20 }
```

一个通用的惰性单例

```js
var getSingle = function (fn) {
  var result
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
```

#### 工厂模式

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类，该模式使一个类的实例化延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型

```js
var Car = (function () {
  var Car = function (name, age) {
    this.name = name
    this.age = age
  }
  return function (name, age) {
    return new Car(name, age)
  }
})()

var zhangsan = new Car('zhangsan', 20)
var lisi = new Car('lisi', 22)
```

#### 代理模式

简单来说，就是新建个类调用老类的接口，包装一下

```js
// ES6 之前
function Person() { }

Person.prototype.sayName = function () {
  console.log('zhangsan')
}

Person.prototype.sayAge = function () {
  console.log(20)
}

function PersonProxy() {
  this.person = new Person()
  var that = this
  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName)
    // 代理
    that.person[functionName]()
    console.log('after proxy:', functionName)
  }
}

var p = new PersonProxy()

p.callMethod('sayName')  // 代理调用 Person 的方法 sayName()
p.callMethod('sayAge')   // 代理调用 Person 的方法 sayAge()
```

另外在 `ES6` 当中提供了 `Proxy` 对象也可以用来实现代理，基本语法为

```js
let x = new Proxy(target, handler)
```

* `target` 是你要代理的对象，它可以是任何合法对象(数组，对象，函数等等)
* `handler` 是你要自定义操作方法的一个集合
* `x` 是一个被代理后的新对象，它拥有 `target` 的一切属性和方法，只不过其行为和结果是在 `handler` 中自定义的

```js
// ES6 之后
let obj = {
  a: 1,
  b: 2,
}

const p = new Proxy(obj, {
  get(target, key, value) {
    if (key === 'c') {
      return '我是自定义的一个结果'
    } else {
      return target[key]
    }
  },

  set(target, key, value) {
    if (value === 4) {
      target[key] = '我是自定义的一个结果'
    } else {
      target[key] = value
    }
  }
})

console.log(obj.a)    // 1
console.log(obj.c)    // undefined

console.log(p.a)      // 1
console.log(p.c)      // 我是自定义的一个结果

obj.name = 'zhangsan'
console.log(obj.name) // zhangsan

obj.age = 4
console.log(obj.age)  // 4

p.name = 'zhangsan'
console.log(p.name)   // zhangsan

p.age = 4
console.log(p.age)    // 我是自定义的一个结果
```


#### 观察者模式

本质上也就是事件模式

```js
// 被观察者
class Subject {
  constructor() {
    this.list = []
  }

  addListener(target) {
    this.list.push(target)
  }

  notify() {
    this.list.forEach(el => {
      el.say()
    })
  }
}

// 观察者
class Observer {
  constructor(name) {
    this.name = name
  }
  say() {
    console.log(this.name)
  }
}

const target = new Subject()
const person1 = new Observer('zhangsan')
const person2 = new Observer('lisi')

target.addListener(person1)
target.addListener(person2)

target.notify()
```


#### 发布订阅模式

```js
class Target {
  constructor() {
    this.list = {}
  }

  // 订阅
  lister(type, fn) {
    if (this.list[type]) {
      this.list[type].push(fn)
    }
    this.list[type] = [fn]
  }

  // 发布
  trigger(type, ...args) {
    this.list[type].forEach(list => {
      list(...args)
    })
  }

  // 删除
  remove(type, fn) {
    let fns = this.list[type]
    if (!fns) return false
    if (fn) {
      for (let i = 0; i < fns.length; i++) {
        let _fn = fns[i]
        if (_fn === fn) {
          fns.splice(i, 1)
        }
      }
    }
  }
}

const target = new Target()

const clickHandle = function(e) { console.log(`click, ${e}`) }
const dbClickHandle = function(e) { console.log(`dbClick, ${e}`) }

target.lister('click', clickHandle)
target.lister('dbclick', dbClickHandle)
target.remove('click', clickHandle)

target.trigger('click', 'zhangsan')
target.trigger('click', 'lisi')
target.trigger('dbclick', 'wangwu')
```




#### 适配器模式

适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题

```js
class Adaptee {
  test() {
    return '旧接口'
  }
}

class Target {
  constructor() {
    this.adaptee = new Adaptee()
  }
  test() {
    let info = this.adaptee.test()
    return `适配${info}`
  }
}

let target = new Target()
console.log(target.test())
```




## 装饰器模式

装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，`ES7` 的装饰器语法以及 `React` 中的高阶组件（`HoC`）都是这一模式的实现，`react-redux` 的 `connect()` 也运用了装饰器模式，这里以 `ES7` 的装饰器为例

```js
function info(target) {
  target.prototype.name = '张三'
  target.prototype.age = 10
}

@info
class Man { }

let man = new Man()
man.name // 张三
```




----

----

----


























## 正则表达式

#### 短横变驼峰

```js
function strToCamel(str) {
  return str.replace(/(^\w)|-(\w)/g, (m, $1, $2) => $1 ? $1.toUpperCase() : $2.toUpperCase())
}

strToCamel('border-right-color')
```

#### 千位分隔符

```js
function commafy(num) {
  return num && num
    .toString()
    // 也可以使用 /\B(?=(\d{3})+$)/g
    .replace(/(\d)(?=(\d{3})+\.)/g, function ($0, $1) {
      return $1 + ','
    })
}

commafy(1234567.90)
```

#### 解析 url

```js
function urlParam(url) {
  const param = {}
  url.replace(/[?&](.*?)=([^&]*)/g, (m, $1, $2) => param[$1] = $2)
  return param
}

urlParam('https://www.baidu.com?id=123&name=zhangsan')
```

#### 字符串大小写切换

```js
function caseConvert(str) {
  return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2) => {
    return `${s1.toUpperCase()}${s2.toLowerCase()}`
  })
}

caseConvert('abcdefg')
caseConvert('ABCDEFG')
```

#### 去空格

```js
str.replace(/\s*/g, '')        //去除字符串内所有的空格
str.replace(/^\s*|\s*$/g, '')  //去除字符串内两头的空格
str.replace(/^\s*/, '')        //去除字符串内左侧的空格
str.replace(/(\s*$)/g, '')     //去除字符串内右侧的空格
```

#### 去除所有的 html

```js
var con = content.replace(/<[^>]+>/g,'')
```

#### 提取括号中的数值

```js
/\(([^()]+)\)/g.exec('add(18)')
```


#### 匹配空行

```js
^[\s]*\n
```


#### 验证邮政编码

```js
// 共六位数，第一位不能为 0
const pattern = /^[1-9]{1}[0-9]{5}$/
const str = '430000'

console.log(pattern.test(str))  // true
```


#### 验证压缩包后缀名

```js
// 文件名（字母_数字）.zip|gz|rar
const pattern = /^[\w]+\.(zip|gz|rar)$/
const str = 'a12_.zip'

console.log(pattern.test(str))  // true
```


## 常用方法 && 函数

#### 事件模型

```js
var Emitter = function () {
  this._listeners = {}
}

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || []
  listeners.push(callback)
  this._listeners[eventName] = listeners
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName]
  if (!Array.isArray(listeners)) return
  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args)
    } catch (e) {
      console.error(e)
    }
  })
}

// 实例对象
var emitter = new Emitter()

emitter.on('event2', function (arg1, arg2) {
  console.log('get event2', arg1, arg2)
})

emitter.on('event1', function (arg1, arg2) {
  console.log('get event1', arg1, arg2)
})

console.log('emit event')

emitter.emit('event2', 'arg1', 'arg2')
emitter.emit('event1', 'arg1', 'arg2')
```


#### Ajax

```js
var xhr = new XMLHttpRequest()

if (xhr) {
  xhr.open('GET', url)
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200) {
      console.log(xhr.responseText)
    }
  }
  xhr.send()
}

// ---------------------------------------------------

// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 http 头
// 然后在 send() 方法中添加需要发送的数据

// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型

// 下面是三种常用的设置方式
// application/x-www-form-urlencoded   窗体数据被编码为 名称/值 对，这是标准的编码格式
// multipart/form-data                 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分
// text/plain                          窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 

xhr.open('POST', url, true)
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
xhr.send(data)
```

#### Promise 版本 Ajax

```js
function getJSON(url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText, this)
        } else {
          var resJson = { code: this.status, response: this.response }
          reject(resJson, this)
        }
      }
    }
    xhr.send()
  })
}

// 使用
getJSON(url).then(function (data) {
  console.log(data)
}).catch(function (status) {
  console.log(`Error: ${status}`)
})
```


#### 终止请求

我们在上面提到了 `Ajax`，所以在这里我们就来多看一点，那就是如何终止请求，目前来说，使用较多的请求数据有两种方式，一种是 `Ajax`，另一种就是 `fetch`，我们先来看看在 `Ajax` 当中终止请求的方式，方法很简单，当我们由于某种原因（比如重复请求）想要终止它的时候，我们只需要调用 `abort()` 即可

```js
xhr.abort()
```

但是对于 `fetch` 来说，我们主要使用的是 [AbortSignal](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal) 这个接口，在 `MDN` 上的介绍是，`AbortSignal` 接口表示一个信号对象（`signal object`），它允许通过 `AbortController` 对象与 `DOM` 请求（如 `Fetch`）进行通信并在需要时将其中止

看到这里是不是有一些眉目了，我们只需要使用 `AbortController()` 构造函数创建一个控制器，然后使用 `AbortController.signal` 属性就可以了，当获取请求被启动时，我们在请求的选项对象中传递 `AbortSignal` 作为一个选项，这将信号和控制器与获取请求相关联，并允许我们通过调用 `AbortController.abort()` 来中止它，代码如下

```js
const controller = new AbortController()
const signal = controller.signal
console.log(signal, `signal 的初始状态`)

signal.addEventListener('abort', function (e) {
  console.log(signal, `signal 的中断状态`)
})

setTimeout(function () {
  controller.abort()
}, 2000)

fetch('/api', { signal })
  .then((res) => {
    console.log(res, '请求成功')
  })
```

但是也有一个需要注意的地方，那就是虽然 `AbortController` 已经诞生很长时间了，但是目前在 `MDN` 上还是被标注为实验性技术，所以还是需要根据实际使用场景来考虑是否使用



#### getElementsByClassName()

```js
function getElementsByClassName(classname) {
  if (document.querySelectorAll) {
    return document.querySelectorAll('.' + classname)
  } else {
    var elements = document.getElementsByTagName('*')
    var reg = new RegExp('(^|\\s)' + classname + '(\\s|$)')
    var results = []
    for (let i = 0, length = elements.length; i < length; i++) {
      if (reg.test(elements[i].className)) {
        results.push(elements[i])
      }
    }
  }
  return results
}
```


