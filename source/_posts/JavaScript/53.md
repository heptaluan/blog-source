---
title: JavaScript 知识梳理
date: 2020-08-02
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/53.jpg
---

之前我们整理了 [HTML 知识梳理](https://heptaluan.github.io/2020/07/25/HTML/01/) 和 [CSS 知识梳理](https://heptaluan.github.io/2020/07/29/CSS/19/)，本章我们就开始梳理最为重要的 `JavaScript` 部分，内容可能比较多，但是不要着急，我们会分章节来慢慢进行介绍，更多详细内容可见 [前端知识体系整理](https://heptaluan.github.io/target/)

<!--more-->

本章当中主要内容包括以下这些

* `ECMAScript`
  * `ES5`
    * 基本数据类型
    * 运算符
    * 对象
    * 函数
    * `this`
    * 闭包
    * 深浅拷贝
    * 高阶函数
    * 防抖和节流
    * 模块加载
  * `ES6+`
    * 块级作用域/模板字符串
    * `Class/Reflect/Symbol/Set/Map/Generator/Iterator/Arrow Function`
* `BOM` 和 `DOM`
  * `DOM`（节点类型/节点类型/节点操作）
  * `BOM`（`Window/Navigator/Screen/History/Location`）
* 相关 `API`
  * `XHR API`
    * 跨域（同源策略/解决方式）
    * `XHR Level 2`
  * 原生 API
    * `call/apply/bind`
    * `parseInt/parseFloat/JSON.parse/JSON.stringify`
    * `IntersectionObserver`
    * `requestAnimationFrame`
* 异步（`Callback/Promise/Generator/Async/Await`）
* `V8` 引擎工作原理
  * 内存回收
  * 并发模型（`EventLoop/MacroTask/MicroTask`）
  * `V8` 优化
* 设计模式
  * 单例模式，工厂模式，代理模式，观察者模式，发布订阅模式
* `TypeScript`
  * 常用语法（基础类型/枚举/元祖等）
  * 类型断言/变量声明
  * 接口/泛型/类型判断/高级类型
* 正则表达式



## 基本数据类型（类型转换与类型判断）

在 `JavaScript` 规范中，共定义了八种数据类型，分为 **基本类型** 和 **引用类型** 两大类，如下所示

* 基本类型：`Number`、`String`、`Boolean`、`Undefined`、`Null`，`BigInt`、`Symbol`（`ES6` 新增）
* 引用类型：`Object`

关于类型之间的判断相关的内容可以参考 [JavaScript 中的类型判断](https://heptaluan.github.io/2018/03/17/JavaScript/25/)，类型判断内容包括

* 基本类型
* 引用类型
* 函数检测
* 数组检测
* 属性检测
* `instanceof`
* `Object.prototype.hasOwnProperty()`
* `Object.prototype.isPrototypeOf()`
* `Object.prototype.toString()`
* 空对象检测
* `window` 对象检测

关于类型之间的转换，这里直接放结果了，如果想要了解更多，可以参考 [JavaScript 中的 == 和 ===](https://heptaluan.github.io/2017/03/17/JavaScript/08/) 这篇文章，类型转换规则如下

* 字符串 和 数字 之间的比较（字符串 `x` ==> `ToNumber(x)`）
  * 如果 `type(x)` 是数字，`type(y)` 是字符串，则返回 `x == ToNumber(y)` 的结果
  * 如果 `type(x)` 是字符串，`type(y)` 是数字，则返回 `ToNumber(x) == y` 的结果
* 其他类型 和 布尔类型 之间的比较（布尔 x ==> `ToNumber(x)`）
  * 如果 `type(x)` 是布尔类型，则返回 `ToNumber(x) == y` 的结果
  * 如果 `type(y)` 是布尔类型，则返回 `x == ToNumber(y)` 的结果
* `null` 和 `undefined` 之间的比较
  * 如果 `x` 是 `null`，`y` 是 `undefined`，则结果为 `true`
  * 如果 `x` 是 `undefined`，`y` 是 `null`，则结果为 `true`
* 对象 和 非对象 之间的比较（对象 ==> `ToPrimitive(obj)`）
  * 如果 `type(x)` 是字符串或数字，`type(y)` 是对象，则返回 `x == ToPrimitive(y)` 的结果
  * 如果 `type(x)` 是对象，`type(y)` 是字符串或数字，则返回 `ToPrimitive(x) == y` 的结果



## 运算符

`JavaScript` 当中的运算符我们这里暂且分为两类，一类是比较常见的 `===`，`||` 等，另一类是平常使用较少但是多见于各种类库当中的位运算符，`==` 和 `===` 我们在上面的类型之间的转换当中已经介绍过了，下面我们来看剩余的一些内容

* [JavaScript 中的 || 和 &&](https://heptaluan.github.io/2017/05/19/JavaScript/15/)
  * `||`
  * `&&`
  * 短路
  * 隐式强制类型转换
  * 运算符优先级
* [JavaScript 中的位运算符](https://heptaluan.github.io/2020/07/17/JavaScript/52/)
  * `!!`
  * `~~`
  * `&`（按位与）
  * `|`（按位或）
  * `^`（按位异或）
  * `<<`（左移运算符）
  * `>>`（有符号右移）
  * `>>>`（无符号右移）


## 对象

`JavaScript` 中的所有事物都是对象，比如字符串、数值、数组、函数等等，对象只是带有属性和方法的特殊数据类型，创建方式有以下这些

* 使用 `new object()` 来创建对象，在 `JavaScript` 中并不存在类，所以可以直接通过 `Objeact` 来创建对象，比如 `var person = new object()`
* 使用 `JSON` 来创建对象，也就是比较常见的 `var obj = { }`
* 使用工厂模式来创建对象，就是在函数当中创建一个对象，然后为这个对象设置相应的属性和方法，之后在返回这个对象
* 使用构造函数来创建对象，同工厂模式，不过在使用构造函数创建的时候，函数内部是通过 `this` 关键字来完成属性的定义
* 使用原型模式来创建对象，在函数的 `prototype` 上去定义属性和方法（这里重写了原型，会存在 `constructor` 丢失的问题）
* 基于组合和动态原型创建，属性在构造函数中定义，将方法在原型中定义，比较常用的一种

创建了对象以后，我们就可以进行遍历的操作，这部分可以参考 [遍历对象的几种方法](https://heptaluan.github.io/2019/06/28/JavaScript/35/)，主要包括

* `Object.keys(obj)`
* `for-in`
* `Object.getOwnPropertyNames(obj)`
* `Reflect.ownKeys`
* `for-of`
* `Object.getOwnPropertySymbols()`

但是在使用 `Object.keys(obj)` 的过程当中可能会遇到排序的问题，这个可以参考 [为什么 Object.keys 的返回值会自动排序](https://heptaluan.github.io/2019/03/16/JavaScript/32/)

在了解完对象的创建与遍历以后，就可以来深入的了解一下原型和原型对象，也就是 `prototype`、`__proto__` 和 `constructor` 三者之间的关系，这部分内容可以参考 [JavaScript 中的原型和原型对象](https://heptaluan.github.io/2017/04/08/JavaScript/09/)，主要包括

* 实例对象
* `prototype`
* `proto`
* `constructor`
* 实例与原型
* 原型的原型
* 自定义对象

最后再来看看 `JavaScript` 当中的继承相关内容，关于这部分可以参考 [JavaScript 中的继承](https://heptaluan.github.io/2017/06/15/JavaScript/20/)，主要包括

* 类式继承（构造函数继承）
* 原型继承
* 组合式继承
* 寄生式组合继承


## 函数

`JavaScript` 中函数的定义以及一些基本内容可以参考 [JavaScript 中的函数](https://heptaluan.github.io/2017/10/08/JavaScript/21/)，主要包括

* 函数的定义
* 函数对象
* 函数调用
* 函数没有重载
* 函数的值传递
* 函数中的 `arguments`
* `arguments.callee()`
* 函数中的 `this`
* 函数的返回值

事件相关内容可以参考 [JavaScript 中的事件](https://heptaluan.github.io/2016/12/12/JavaScript/01/)，主要包括

* `HTML` 事件处理程序
* `DOM 0` 级事件处理程序
* `DOM 2` 级事件处理程序
* `IE` 事件处理程序
* 跨浏览器的事件处理程序
* 关于 `event`
* 事件委托
* 事件流，冒泡与捕获

值和引用相关内容可以参考 [JavaScript 中的值和引用](https://heptaluan.github.io/2017/02/22/JavaScript/06/)，主要包括

* 引用类型值的传递
* 基本类型值的传递

函数当中的作用域相关内容，这部分可以参考 [JavaScript 中的作用域](https://heptaluan.github.io/2017/01/18/JavaScript/03/)，主要包括

* 变量提升（`Hoisting`）
* 作用域（`Scoping`）
* 执行上下文环境
* 全局执行上下文环境
* 函数体上下文环境（也就是所谓的局部）
* 变量对象
* 活动对象
* 执行上下文栈
* 作用域链




## this

`this` 是 `JavaScript` 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，`this` 的值会发生变化，但是有一个总的原则，那就是 `this` 指向的是，调用函数的那个对象

更多关于 `this` 的内容可以参考 [JavaScript 中的 this](http://localhost:4000/2017/10/09/JavaScript/22/) 这篇文章，主要内容包括

* `this` 的调用方式
  * 为对象方法调用
  * 作为函数调用
  * 作为构造函数调用
  * 使用 `apply` 或 `call` 调用
* 箭头函数中的 `this`
* 如何确定 `this` 的值（可见规范当中的 [11.2.3 函数调用](http://yanhaijing.com/es5/#164)）
  * 计算 `MemberExpression` 的结果赋值给 `ref`
  * 判断 `ref` 是不是一个 `Reference` 类型
    * 如果 `ref` 是 `Reference`，并且 `IsPropertyReference(ref)` 是 `true`，那么 `this` 的值为 `GetBase(ref)`
    * 如果 `ref` 是 `Reference`，并且 `base value` 值是 `Environment Record`，那么 `this` 的值为 `ImplicitThisValue(ref)`
    * 如果 `ref` 不是 `Reference`，那么 `this` 的值为 `undefined`

## 闭包

闭包简单来说就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在，更为详细的内容可以参考 [JavaScript 中的闭包](http://localhost:4000/2017/05/12/JavaScript/14/) 这篇文章（可以配合 [作用域与执行上下文栈](https://heptaluan.github.io/2017/01/18/JavaScript/03/) 进行了解），主要内容包括

* 什么是闭包
* 闭包模型
* 闭包中 `this` 的指向
* 柯里化
* 偏函数


## 深浅拷贝