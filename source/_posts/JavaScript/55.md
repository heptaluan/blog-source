---
title: JavaScript 中常用算法
date: 2020-08-09
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/55.jpg
---

最近在梳理 `JavaScript` 相关知识，发现博客当中关于 `JavaScript` 当中的一些常用算法记录的比较零散，所以就抽些时间出来，在这里大致的整理一下，关于 `JavaScript` 的其他内容可以参考 [JavaScript 知识梳理](http://localhost:4000/2020/08/02/JavaScript/00/) 和 [前端知识体系整理](https://heptaluan.github.io/target/)

本文当中涉及比较多的都是一些数组与字符串之间的算法，另外还包含一些数据结构当中的，比如二叉树之类的算法和一些在刷 `LeetCode` 过程当中记录的一些相关内容

<!--more-->


## 数组与字符串算法

#### 数组去重

> 默认传递的都是数组对象，所以在这里就省掉了针对入参的判断，我们只关心核心实现部分

第一种，也是最原始的方法，即双层循环（`while` 也可），其缺点是其复杂度为 `O(n^2)`，如果数组过大，将会影响性能，但是它也有好处，就是兼容性好，原理是先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组

```js
function unique(arr) {
  let res = [arr[0]]
  for (let i = 1; i < arr.length; i++) {
    let flag = true
    for (let j = 0; j < res.length; j++) {
      if (arr[i] === res[j]) {
        flag = false
        break
      }
    }
    if (flag) {
      res.push(arr[i])
    }
  }
  return res
}
```

第二种方法 `indexOf`，`indexOf` 用法也有两种使用方式

* 一种是首先定义一个空数组，然后调用 `indexOf` 方法对原来的数组进行遍历判断，如果元素不在新定义的数组中，则将其添加进去，最后将数组返回
* 第二种就是检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素

```js
// 第一种方式
function unique(arr) {
  let res = []
  for (let i = 0; i < arr.length; i++) {
    if (res.indexOf(arr[i]) === -1) {
      res.push(arr[i])
    }
  }
  return res
}

// 第二种方式
function unique(arr) {
  return Array.prototype.filter.call(arr, function (item, index) {
    return arr.indexOf(item) === index
  })
}
```

第三种方法，相邻元素去重，这种方法首先调用了数组的排序方法 `sort()`，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，但是这个方法存在缺陷，即 `sort()` 排序的结果并非十分准确

```js
function unique(arr) {
  arr = arr.sort()
  let res = []
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== arr[i - 1]) {
      res.push(arr[i])
    }
  }
  return res
}
```

第四种方法，利用对象属性去重，也就是所谓的对象键值对法，原理是遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值 `1`，每出现一次，对应的属性值增加 `1`，这样属性值对应的就是该元素出现的次数了（这个方法也可以用来统计字符串出现的次数）

```js
// 方式一
function unique(arr) {
  let res = [], obj = {}
  for (let i = 0; i < arr.length; i++) {
    if (!obj[arr[i]]) {
      res.push(arr[i])
      obj[arr[i]] = 1
    } else {
      obj[arr[i]]++
    }
  }
  return res
}

// 方式二，针对处理 [1, 2, 1, 1, '1'] 这样的数组，可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题
function unique(arr) {
  var obj = {}
  return arr.filter(function (item, index, array) {
    return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
  })
}
```

第五种方法，解构赋值去重，`ES6` 提供了新的数据结构 `Set`，它类似于数组，但是成员的值都是唯一的

```js
// 利用 Set
var unique = arr => [...new Set(arr)]

// 也可以使用 Map，原理也是利用对象属性
function unique(arr) {
  const map = new Map()
  return arr.filter((a) => !map.has(a) && map.set(a, 1))
}
```

最后来看一个特殊的数组处理

```js
var array = [1, 1, '1', '1', null, null, undefined, undefined, new String('1'), new String('1'), /a/, /a/, NaN, NaN]
```

针对上面的数组，上述去重方法结果如下，可以根据实际场景选择使用

| 方法 | 结果 | 说明 |
|-|-|-|
|双重 `for` 循环| `[1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN]` |对象和 `NaN` 不去重|
|单纯的 `indexOf`| `[1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN]` |对象和 `NaN` 不去重|
|`filter` + `indexOf`|  `[1, '1', null, undefined, String, String, /a/, /a/]` |对象不去重 `NaN` 会被忽略掉|
| 相邻元素去重（`sort`） |	`[/a/, /a/, '1', 1, String, 1, String, NaN, NaN, null, undefined]` |	对象和 `NaN` 不去重 数字 `1` 也不去重|
|对象键值对法| `[1, null, undefined, /a/, NaN]` | 无法区分数字 `1` 和 `'1'` |
|优化后的对象键值对法| `[1, '1', null, undefined, String, /a/, NaN]` |全部去重|
|`Set` 和 `Map`| `[1, '1', null, undefined, String, String, /a/, /a/, NaN]` |对象不去重 `NaN` 去重|

最后一种特殊情况，如果不是单纯的数组，而是数组对象的话，则可以使用 `reduce` 来进行处理

```js
function unique(arr, initialValue, id) {
  let hash = {}
  return arr.reduce((item, next) => {
    hash[next.id] ? '' : hash[next.id] = true && item.push(next)
    return item
  }, initialValue)
}

let arr = [{ 'id': 1 }, { 'id': 2 }, { 'id': 2 }, { 'id': 3 }]
newArr = unique(arr, [], 'id')
```



#### 数组降维（扁平化）

方法有很多种，我们一个一个来看，首先是一个比较局限的方法，就是 `toString`，如果数组的元素都是数字，那么我们可以考虑使用 `toString` 方法，然而这种方法使用的场景却非常有限，如果数组是 `[1, '1', 2, '2']` 的话，这种方法就会产生错误的结果

```js
// 将数组字符串化，然后在还原为数字数组
function flatten(arr) {
  return arr.toString().split(',').map(item => Number(item))
}
```

第二个方法也是比较容易想到的方法，就是递归展开，利用 `concat` 进行拼接，如果还是一个数组，就递归调用该方法

```js
// 方法一
function flatten(arr) {
  var result = []
  for (var i = 0, len = arr.length; i < len; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]))
    } else {
      result.push(arr[i])
    }
  }
  return result
}

// 方法二
function flatten(arr) {
  let ret = []
  let toArr = array => {
    array.forEach(item => {
      item instanceof Array ? toArr(item) : ret.push(item)
    })
  }
  toArr(arr)
  return ret
}
```

第三种方法，使用 `reducer`，原理跟第二种是一样的，不过使用了 `reduce` 来简化代码

```js
function flatten(arr) {
  return arr.reduce((prev, next) => {
    return prev.concat(Array.isArray(next) ? flatten(next) : next)
  }, [])
}
```

第四种，使用 `ES6` 提供的扩展运算符

```js
function flatten(arr) {
  while(arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr)
  }
  return arr
}
```

第五种，在 `ES6` 当中也提供了专门用于降维的方法 `flat()`

```js
[1, [1,2], [1,2,3]].flat()  // [1, 1, 2, 1, 2, 3]
```

第六种，使用正则进行匹配，简单来说就是将 `[` 和 `]` 替换成 `''`，然后在还原为数组

```js
const arr = [1, [1, 2], [1, 2, 3]]

JSON.parse(`[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`)  // [1, 1, 2, 1, 2, 3]
```


#### 字符串去重

第一种方式，常规的 `for` 遍历

```js
function unique1(str) {
  var newStr = ''
  var flag
  for (var i = 0; i < str.length; i++) {
    flag = 1
    for (var j = 0; j < newStr.length; j++) {
      if (str[i] == newStr[j]) {
        flag = 0
        break
      }
    }
    if (flag) newStr += str[i]
  }
  return newStr
}
```

第二种，使用 `indexOf`

```js
function unique2(str) {
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (newStr.indexOf(str[i]) == -1) {
      newStr += str[i]
    }
  }
  return newStr
}  
```

第三种，与上面第二种类似，不过判断方式换成了 `search`

```js
function unique3(str) {
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (newStr.search(str[i]) == -1)
      newStr += str[i]

  }
  return newStr
}
```

第四种方式，利用对象属性，推荐使用这种方式

```js
function unique4(str) {
  var obj = {}
  var newStr = ''
  for (var i = 0; i < str.length; i++) {
    if (!obj[str[i]]) {
      newStr += str[i]
      obj[str[i]] = 1
    }
  }
  return newStr
}
```

#### 生成区间随机数，并排序

```js
var arr = []

var randomNum = function (n, m) {
  return parseInt(Math.random() * (m - n) + n)
}

for (var i = 0; i < 20; i++) {
  arr.push(randomNum(40, 80))
}

// 排序
console.log(arr.sort(function (a, b) { return a - b }))

// 乱序
console.log(arr.sort(function () { return 0.5 - Math.random() }))
```

这里关于乱序需要说明一下，因为这里涉及到了 `sort()` 方法，所以上面的结果是存在一定误差的，我们可以来测试一下，比如下面这里例子，将 `[1, 2, 3, 4, 5]` 乱序 `10` 万次，计算乱序后的数组的最后一个元素是 `1、2、3、4、5` 的次数分别是多少

```js
var times = [0, 0, 0, 0, 0]

for (var i = 0; i < 100000; i++) {
  let arr = [1, 2, 3, 4, 5]
  arr.sort(() => Math.random() - 0.5)
  times[arr[4] - 1]++
}

console.log(times)  // [25028, 6975, 21233, 18538, 28226]
```

根据结果可以发现，这样的算法的确是有问题的，具体原因可以参考 [JavaScript专题之解读 v8 排序源码](https://juejin.im/post/59e80dc6f265da432a7aaf15)，但是在这里我们只考虑如何解决这样的问题，针对于乱序的问题，我们可以采用 [Fisher–Yates_shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)，比如如下两种方式，都是采用的「摸牌」方式

```js
// 方式一，随机抽选对换位置（余下的只在剩余位置交换）
function shuffle(arr) {
  for (var i = 0, len = arr.length; i < len; i++) {
    var randomIndex = i + Math.floor(Math.random() * (len - i))
    // randomIndex 需要在数组剩余当中挑选
    var temp = arr[i]
    arr[i] = arr[randomIndex]
    arr[randomIndex] = temp
  }
  return arr
}

// 方式二，随机抽选，抽到一个出列一个
function shuffle(arr) {
  var res = [], l = arr.length
  for (var i = 0; i < l; i++) {
    var randomIndex = Math.floor(Math.random() * arr.length)
    res[i] = arr[randomIndex]
    // 因为原数组项目会越来越少，因此上面的 randomIndex 需要实时获取 arr.length
    arr.splice(randomIndex, 1)
  }
  return res
}
```

我们可以来测试一下

```js
var times = 10000
var res = {}

for (var i = 0; i < times; i++) {
  var arr = shuffle([1, 2, 3])
  var key = JSON.stringify(arr)
  res[key] ? res[key]++ : res[key] = 1
}

// 转换成百分比
for (var key in res) {
  res[key] = res[key] / times * 100 + '%'
}

console.log(res)
```


#### 取数组的并集，交集和差集

```js
// 这里有一些需要注意的地方
// 如果两个数组 A 和 B 当中没有重复的元素，以下三种都是可以正常实现的
// 如果数组当中有重复的元素，需要使用 ES6 当中的 Set 数据结构
// 如果数组当中包含 NaN，可以考虑在结尾处添加 .filter(v => !isNaN(v)) 过滤掉即可
let a = [1, 2, 3, 4]
let b = [2, 3, 4, 5, 6]

// ES7 并集
a.concat(b.filter(v => !a.includes(v)))                                       // [1, 2, 3, 4]

// ES7 交集
a.filter(v => b.includes(v))                                                  // [2, 3]

// ES7 差集
a.concat(b).filter(v => !a.includes(v) || !b.includes(v))                     // [1, 4]

// ------------

let aSet = new Set(a)
let bSet = new Set(b)

// ES6 并集
Array.from(new Set(a.concat(b)))                                              // [1, 2, 3, 4]

// ES6 交集
Array.from(new Set(a.filter(v => bSet.has(v))))                               // [2, 3]

// ES6 差集
Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v))))    // [1, 4]

// ------------

// ES5 并集
a.concat(b.filter(v => a.indexOf(v) === -1))                                  // [1, 2, 3, 4]

// ES5 交集
a.filter(v => b.indexOf(v) !== -1)                                            // [2, 3]

// ES5 差集
a.filter(v => b.indexOf(v) === -1).concat(b.filter(v => a.indexOf(v) === -1))  // [1, 4]
```


#### 统计数组中每一项出现的次数

```js
[5, 5, 4, 3, 2, 1, 4, 5, 5, 4, 3, 2, 2, 1].reduce((ad, ap) => (ad[ap] = ++ad[ap] || 1, ad), {})
```


#### 寻找字符串中出现次数最少的、并且首次出现位置最前的字符

要求实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 `cbaacfdeaebb`，方法一，利用 `hash table`，缺点是 `Object.keys()` 不能保证顺序，所以存在风险

```js
var o = [].reduce.call('cbaacfdeaebb', function (p, n) {
  return p[n] = (p[n] || 0) + 1, p
}, {})

var s = Object.keys(o).reduce(function (p, n) {
  return o[p] <= o[n] ? p : n
})

console.log(s, o[s])
```

方法二，引入了 `index` 来解决顺序问题

```js
const all = 'cbaacfdeaebb'.split('')
  .reduce((all, ch, i) => {
    const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 })
    m.count++
    return all
  }, {})

const theOne = Object.keys(all)
  .map(ch => all[ch])
  .reduce((min, t) => min.count === t.count
    ? (min.index > t.index ? t : min)
    : (min.count > t.count ? t : min))

console.log(`${theOne.ch}: ${theOne.count}`)
```

方法三，利用数组代替 `hash table`，解决了顺序问题，但是 `Array.sort()` 并不一定是稳定的，风险可能更大

```js
function findFirstChar(string) {
  const desc = []

  [...string].forEach((char, index) => {
    const item = desc.find(item => item.char === char)
    item ? item.count++ : desc.push({ char, index, count: 1 })
  })

  return desc.sort((a, b) => a.count - b.count)[0]
}
```

方法四，使用 `Object.values`，但是目前还是草案

```js
const less = (x, y) => (x.count <= y.count && x.first < y.first) ? x : y

function firstSingle(string) {
  let map = {}

  string.split('')
    .forEach((char, index) => {
      map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char }
    })

  return Object.values(map).reduce(less).char
}
```

方法五，代码简短，但是执行效率不是很高

```js
var str = 'cbaacfdeaebb'

var result = [...new Set(str)]
  .map(el => ({ el, len: str.split(el).length }))
  .reduce((a, e) => (a.len > e.len ? e : a))
  .el
```


#### 生成指定长度数组

比如生成指定内容为 `[0, 1, 2, 3 ... N - 1]` 的数组

```js
// 方法一，ES5
Array.apply(null, { length: N }).map(function (value, index) {
  return index
})

// 方法二，ES6
Array.from(new Array(N), (v, i) => i)

// 方法三
Array.from(Array(N).keys())

// 方法四
[...Array(N).keys()]

// 方法五
Object.keys(Array(N).join().split(',')).map(v => Number(v))

// 方法六
Object.keys(Array(N).fill()).map(v => Number(v))

// 方法七
Object.keys(Array.apply(null, { length: 100 })).map(v => Number(v))

// 方法八
Array(N).fill().map((v, i) => i)

// 方法九
Array.prototype.recursion = function (length) {
  if (this.length === length) {
    return this
  }
  this.push(this.length)
  this.recursion(length)
}

arr = []
arr.recursion(100)
```


#### 计算最长递增子序列

所谓的最长递增子序列就是给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续，比如给定的序列是 `[0, 8, 4, 12, 2, 10]`，那么它的最长递增子序列就是 `[0, 2, 10]`（也可以是 `[0, 8, 10]` 或 `[0, 4, 12]` 等，并不是唯一）

针对于这种情况，我们可以利用动态规划思想来进行求解，可以参考下表，我们以该格子所对应的数字为开头的递增子序列的最大长度，至于如何计算一个格子中的值，规则很简单（假定从右往左），如下

* 1、拿该格子对应的数字 `a` 与其后面的所有格子对应的数字 `b` 进行比较，如果条件 `a < b` 成立，则用数字 `b` 对应格子中的值加 `1`，并将结果填充到数字 `a` 对应的格子中
* 2、只有当计算出来的值大于数字 `a` 所对应的格子中的值时，才需要更新格子中的数值

|0|8|4|12|2|10|
|-|-|-|-|-|-|
|3|2|2|1|2|1|

实现如下

```js
const seq = [0, 8, 4, 12, 2, 10]

function lis(seq) {

  // 构建索引表
  const valueToMax = {}
  let len = seq.length
  for (let i = 0; i < len; i++) {
    valueToMax[seq[i]] = 1
  }

  let i = len - 1
  let last = seq[i]
  let prev = seq[i - 1]
  while (typeof prev !== 'undefined') {
    let j = i
    while (j < len) {
      last = seq[j]
      if (prev < last) {
        const currentMax = valueToMax[last] + 1
        valueToMax[prev] = valueToMax[prev] !== 1
          ? (valueToMax[prev] > currentMax ? valueToMax[prev] : currentMax)
          : currentMax
      }
      j++
    }
    i--
    last = seq[i]
    prev = seq[i - 1]
  }

  const lis = []
  i = 1
  while (--len >= 0) {
    const n = seq[len]
    if (valueToMax[n] === i) {
      i++
      lis.unshift(len)
    }
  }

  return lis
}

// 注意，结果是序列中的位置索引，比如下列输出结果是 [0, 4, 5]，对应到 seq 当中则为 [0, 2, 10]
console.log(lis(seq))
```




## 数据结构与算法

主要是一些数据结构与算法当中涉及到的一些内容，比如线性表，栈和队列，递归，二叉树，查找算法，排序算法等

#### 计算阶乘

```js
function factorial(n) {
  return n === 1 ? 1 : n * factorial(n - 1)
}

factorial(5)     // 120

// 可以使用箭头函数来进行简化
const factorial = (x) => (x == 0 ? 1 : x * factorial(x - 1))
```

可以使用 [尾调用](https://zh.wikipedia.org/zh-hans/尾调用)（某个函数的最后一步是调用另一个函数）来进行优化，我们需要做的就是把所有用到的内部变量改写成函数的参数

```js
function factorial(n, total) {
  return n === 1 ? total : factorial(n - 1, n * total)
}

factorial(5, 1)  // 120
```

#### 斐波纳契数列（fibonacci）

```js
function fibonacci(n) {
  return n <= 1 ? 1 : fibonacci(n - 1) + fibonacci(n - 2)
}

for (let i = 0; i <= 10; i++) {
  console.log(fibonacci(i))
}
```

同样的，也可以使用尾调用来进行优化

```js
function fibonacci(n, n1 = 1, n2 = 1) {
  return n <= 1 ? n2 : fibonacci(n - 1, n2, n1 + n2)
}

for (let i = 0; i <= 10; i++) {
  console.log(fibonacci(i))
}
```