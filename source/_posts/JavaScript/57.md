---
title: 深入 TypeScript
date: 2021-01-01
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/57.webp
---

接上回 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/)，在之前的章节当中，我们简单的梳理一下 `TypeScript` 的基础内容和基本用法，本章当中我们就来看一些 `TypeScript` 当中的进阶内容，也算是针对于 `TypeScript` 做一个比较深入的学习记录吧，主要包括以下内容


<!--more-->


* 类型别名
* 字面量类型
* 元组
* 枚举
* 类
* 类与接口
* 泛型

我们就先从比较简单的类型别名和字符串字面量类型开始看起


## 类型别名

这个很好理解，就是用来给一个类型起个新名字，方式是使用 `type` 来创建类型别名

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;

function getName(n: NameOrResolver): Name {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}
```

关于首字母大写的问题，通常来说在语法上没有限制，不过参考 [TypeScript 官方](https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts#L1439) 的写法，一般建议首字母大写



## 字面量类型

同类型别名一样，字面量类型也是使用 `type` 来进行定义，它的作用简单来说就是用来约束取值只能是某几个字段当中的一个，比如下面这个示例

```ts
type EventNames = 'click' | 'scroll' | 'mousemove'
function handleEvent(ele: Element, event: EventNames) {
  // ...
}

const el = document.getElementById('el')
handleEvent(el, 'click')     // ✅
handleEvent(el, 'dblclick')  // ❌
```

在上面的示例当中，我们使用 `type` 定义了一个字符串字面量类型 `EventNames`，它规定只能取三种事件名当中的一种，如果定义了约定以外的字段，就会报错

当然除了字符串字面量类型，数值类型也是可以的

```ts
type Nums = 1 | 2 | 3

let x: Nums = 1  // ✅
let y: Nums = 4  // ❌
```




## 元组

我们在之前的章节当中介绍了数组的类型，众所周知，数组一般由同种类型的值组成，也就是合并了相同类型的对象，但有时我们需要在单个变量中存储不同类型的值，在这种情况下我们就可以使用元组，它可以理解为是合并了不同类型的对象

在 `JavaScript` 中是没有元组的，元组是 `TypeScript` 中特有的类型，其工作方式类似于数组，
元组可用于定义具有有限数量的未命名属性的类型，每个属性都有一个关联的类型，使用元组时必须提供每个属性的值

为了更直观地理解元组的概念，我们来看一个具体的例子

```ts
let x: [string, number] = ['zhangsan', 18]
```

在上面代码中，我们定义了一个名为 `x` 的变量，它的类型是一个类型数组 `[string, number]`，然后我们按照正确的类型依次初始化 `x` 变量，与数组一样，我们可以通过下标来访问元组中的元素并且操作它们

```ts
let x: [string, number] = ['zhangsan', 18]

x[0] = 'lisi'
x[1] = 20

x[0].slice(1)
x[1].toFixed()
```

但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，否则会报错

```ts
let x: [string, number]

x = ['zhangsan', 18]  // ✅
x = ['zhangsan']      // ❌
```

另外需要注意的是，如果当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型

```ts
let x: [string, number] = ['zhangsan', 18]

x.push('lisi')  // ✅
x.push(true)    // ❌
```

但是通常不建议超出范围，因为使用元祖可以确定元素数据类型，可以把元祖理解为固定长度，但是超出范围不能保证其类型


## 枚举

枚举（`Enum`）类型在某些方面与我们之前介绍的元组有一些类似的地方，它主要用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等等，使用 `enum` 关键字来定义

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }
```

枚举成员会被赋值为从 `0` 开始递增的数字，同时也会对枚举值到枚举名进行反向映射

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days[0])      // Sun
console.log(Days['Sun'])  // 0
```

我们也可以给枚举项手动赋值

```ts
enum Days { Sun = 7, Mon, Tue = 1, Wed, Thu, Fri, Sat }

console.log(Days['Sun'])  // 7
console.log(Days['Mon'])  // 8
console.log(Days['Wed'])  // 2
```

运行后可以发现，未手动赋值的枚举项会接着上一个枚举项依次递增，但是需要注意的是，如果未手动赋值的枚举项与手动赋值的重复了，`TypeScript` 是不会察觉到这一点的

```ts
enum Days { Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Sun'] === 3)  // true
console.log(Days['Wed'] === 3)  // true
```

在上面的示例当中，递增到 `3` 的时候与我们前面手动赋值的 `Sun` 的取值重复了，但是 `TypeScript` 并没有报错，导致 `Days[3]` 的值先是 `'Sun'`，而后又被 `'Wed'` 覆盖了，但是我们在实际应用场景当中需要注意，最好不要出现这种覆盖的情况

当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 `1`

```ts
enum Days { Sun = 1.2, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Mon'])  // 2.2
console.log(Days['Tue'])  // 3.2
console.log(Days['Wed'])  // 4.2
```

关于枚举的相关内容就介绍到这里，因为发现平常很少会去使用它，所以暂时就总结这么多，如果后续工作当中有遇到相关内容的话再来进行完善，枚举的其他一些用法可以参考文档当中的 [枚举](https://www.tslang.cn/docs/handbook/enums.html)




## 类

传统方法中，`JavaScript` 通过构造函数实现类的概念，通过原型链实现继承，而在 `ES6` 中，我们终于迎来了 `class`，`TypeScript` 除了实现了所有 `ES6` 中的类的功能以外，还添加了一些新的用法，下面就让我们就来看看 `TypeScript` 中类的用法

`TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected`

* `public`，修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
* `private`，修饰的属性或方法是私有的，不能在声明它的类的外部访问
* `protected`，修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的

下面我们来看几个示例

```ts
class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')
console.log(a.name)  // zhangsan

a.name = 'lisi'
console.log(a.name)  // lisi
```

在上面示例当中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的，如果我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')

// ❌，因为属性 name 为私有属性，只能在类 Person 中访问
console.log(a.name)
```

但是需要注意的是，在 `TypeScript` 编译之后的代码中，其实并没有限制 `private` 属性在外部的可访问性

```ts
var Person = (function () {
  function Person(name) {
    this.name = name
  }
  return Person
})()

var a = new Person('zhangsan')

console.log(a.name)  // zhangsan
```

同时，使用 `private` 修饰的属性或方法，在子类中也是不允许访问的

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ❌
    console.log(this.name)
  }
}
```

而如果是用 `protected` 修饰，则允许在子类中访问

```ts
class Person {
  protected name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ✅
    console.log(this.name)
  }
}
```

如果我们不想让该类被继承或者实例化，那么可以在构造函数上设置 `private` 修饰

```ts
class Person {
  public name
  private constructor(name) {
    this.name = name
  }
}

// ❌
class Man extends Person {
  // ...
}
```

当构造函数修饰为 `protected` 时，该类只允许被继承

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}


// ✅
class Man extends Person {
  // ...
}

// ❌
let man = new Person()
```

同样的，上面介绍到的修饰符和下面提到的 `readonly` 都可以使用在构造函数的参数当中，等同于类中定义该属性的同时给该属性赋值

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}

// 等同于 ==>

class Person {
  protected constructor(public name) {
    
  }
}
```



#### readonly

只读属性关键字，表示只允许出现在属性声明或索引签名或构造函数中

```ts
class Person {
  readonly name
  public constructor(name) {
    this.name = name
  }
}

// ✅
let man = new Person('zhangsan')

// ❌
man.name = 'list'
```

不过需要注意的是，如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面

```ts
class Person {
  // ✅
  public readonly name

  // ❌
  readonly public name
  
  public constructor(name) {
    this.name = name
  }
}
```


#### 抽象类

使用 `abstract` 来定义抽象类和其中的抽象方法，那么什么是抽象类呢？首先抽象类是不允许被实例化的

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

// ❌
let man = new Person('zhangsan')
```

在上面的例子当中，我们定义了一个抽象类 `Person`，可以发现在实例化抽象类的时候报错了，另外如果抽象类当中存在抽象方法（指不包含具体实现的方法），如下

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}
```

其中的抽象方法必须被子类实现

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}

class Man extends Person {
  // 这里需要实现父类当中的抽象方法，否则会报错
  public say() {
    console.log(this.name)
  }
}

let man = new Man('zhangsan')

man.say()
```



#### 私有字段

在 `TypeScript 3.8` 版本就开始支持 `ECMAScript` 私有字段，使用方式如下

```ts
class Person {
  #name: string

  constructor(name: string) {
    this.#name = name
  }

  greet() {
    console.log(`${this.#name}`)
  }
}

let man = new Person('zhangsan')

// ❌
man.#name
```

可以发现，会有报错信息，提示我们属性 `#name` 在类 `Person` 外部不可访问，另外，私有字段与常规属性（甚至使用 `private` 修饰符声明的属性）不同，私有字段需要约定以下几点规则

* 私有字段以 `#` 字符开头，有时候我们称其为「私有名称」
* 每个私有字段名称都唯一地限定于其包含的类
* 不能在私有字段上使用 `TypeScript` 可访问性修饰符（如 `public` 或 `private`）
* 私有字段不能在包含的类之外访问，甚至不能被检测到

在使用私有字段的过程当中，不得不让我们想起另外一个与其十分类似的东西，那就是 `private` 修饰符，那么使用 `#` 定义的私有字段与 `private` 修饰符定义字段有什么区别呢？先让我们来看一个 `private` 的示例

```ts
class Person {
  constructor(private name: string) { }
}

let person = new Person('zhangsan')

// ❌
console.log(person.name)
```

在上面代码中，我们创建了一个 `Person` 类，该类中使用 `private` 修饰符定义了一个私有属性 `name`，接着使用该类创建一个 `person` 对象，然后通过 `person.name` 来访问 `person` 对象的私有属性，这时 `TypeScript` 编译器会提示我们有以下异常

```ts
Property 'name' is private and only accessible within class 'Person'.(2341)
```

那如何解决这个异常呢？当然我们可以使用类型断言把 `person` 转为 `any` 类型

```ts
console.log((<any>person).name)

// or

console.log((person as any).name)
```

通过这种方式虽然解决了 `TypeScript` 编译器的异常提示，但是在运行时我们依然可以发现还是可以访问到 `Person` 类内部的私有属性，至于为什么会这样，我们来看一下编译生成的 `ES5` 代码就知道答案了

```ts
var Person = /** @class */ (function () {
  function Person(name) {
    this.name = name
  }
  return Person
}())

var person = new Person('zhangsan')

console.log(person.name)
```

下面我们再来看看在 `TypeScript 3.8` 以上版本通过 `#` 号定义的私有字段编译后会生成什么代码，这里还是以上面的代码为例

```ts
class Person {
  #name: string

  constructor(name: string) {
    this.#name = name
  }

  greet() {
    console.log(`${this.#name}`)
  }
}
```

我们将编译的目标设置为 `ES2015`，会编译生成以下代码

```ts
'use strict'
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet)
  || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError('attempted to set private field on non-instance')
    }
    privateMap.set(receiver, value)
    return value
  }

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet)
  || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError('attempted to get private field on non-instance')
    }
    return privateMap.get(receiver)
  }

var _name
class Person {
  constructor(name) {
    _name.set(this, void 0)
    __classPrivateFieldSet(this, _name, name)
  }
  greet() {
    console.log(`${__classPrivateFieldGet(this, _name)}`)
  }
}
_name = new WeakMap()
```

通过观察我们可以发现，在使用 `#` 号定义的私有字段当中，会通过 `WeakMap` 对象来存储，同时编译器会生成 `__classPrivateFieldSet` 和 `__classPrivateFieldGet` 这两个方法用于设置值和获取值，这样一来我们就无法在外部进行 `name` 属性的访问了













## 类与接口

实现（`implements`）是面向对象中的一个重要概念，一般来说一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（`interfaces`），用 `implements` 关键字来实现，这个特性大大提高了面向对象的灵活性

```ts
interface SayName {
  sayName(): void
}

class Animal { }

class Cat extends Animal implements SayName {
  sayName() {
    console.log(`cat`)
  }
}

class Dog extends Animal implements SayName {
  sayName() {
    console.log(`dog`)
  }
}
```

同样的，一个类可以实现多个接口

```ts
interface SayName {
  sayName(): void
}

interface SayAge {
  sayAge(): void
}

class Rabbit implements SayName, SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

但是需要注意一点，接口与接口之间也是可以是继承关系的

```ts
interface SayName {
  sayName(): void
}

interface SayAge extends SayName {
  sayAge(): void
}

class Rabbit implements SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

最后我们再来看一种比较有趣的情况，但是也是平常使用较少的一种情况，那就是接口继承类，在常见的面向对象语言中，接口是不能继承类的，但是在 `TypeScript` 中却是可以的

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

但是为什么 `TypeScript` 会支持接口继承类呢？实际上当我们在声明 `class Point` 的时候，除了会创建一个名为 `Point` 的类之外，同时也创建了一个名为 `Point` 的类型（实例的类型）

所以我们既可以将 `Point` 当做一个类来用（使用 `new Point` 创建它的实例）

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

const p = new Point(1, 2)
```

也可以将 `Point` 当做一个类型来用

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

function printPoint(p: Point) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

上面这个例子实际上可以等价于

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

function printPoint(p: PointInstanceType) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

在上面示例当中我们新声明了一个 `PointInstanceType` 的类型，其实本质上与声明 `class Point` 时创建的 `Point` 类型是等价的，所以在回过头来看我们之前的示例，就很容易的理解为什么 `TypeScript` 会支持接口继承类了

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

// 其实等价于 interface Point3d extends PointInstanceType
interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

当我们声明 `interface Point3d extends Point` 的时候，本质上 `Point3d` 继承的是类 `Point` 的实例的类型，我们可以理解为定义了一个接口 `Point3d` 继承另一个接口 `PointInstanceType`，所以「接口继承类」和「接口继承接口」没有什么本质的区别

但是需要注意的是，那就是 `PointInstanceType` 相比于 `Point` 缺少了 `constructor` 方法，这是因为声明 `Point` 类时创建的 `Point` 类型是不包含构造函数的，另外除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）

换句话说，声明 `Point` 类时创建的 `Point` 类型只包含其中的实例属性和实例方法

```ts
class Point {
  static origin = new Point(0, 0)       // 静态属性，坐标系原点
  static distanceToOrigin(p: Point) {   // 静态方法，计算与原点距离
    return Math.sqrt(p.x * p.x + p.y * p.y)
  }
  x: number       // 实例属性 x 轴的值
  y: number       // 实例属性 y 轴的值
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
  printPoint() {  // 实例方法
    console.log(this.x, this.y)
  }
}

interface PointInstanceType {
  x: number
  y: number
  printPoint(): void
}

let p1: Point
let p2: PointInstanceType
```

上例中最后的类型 `Point` 和类型 `PointInstanceType` 本质上是等价的，所以我们可以发现，在接口继承类的时候，只会继承它的实例属性和实例方法



## 泛型

软件工程中，我们不仅要创建一致的定义良好的 `API`，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能

在像 `C#` 和 `Java` 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件，设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是类的实例成员、类的方法、函数参数和函数返回值等

泛型允许我们同一个函数接受不同类型参数，相比于使用 `any` 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型


#### 泛型语法

泛型（`Generics`）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性，其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/57-01.png)

参考上面的图片可以发现，当我们调用 `identity<Number>(1)` 的时候，`Number` 类型就像参数 `1` 一样，它将在出现 `T` 的任何位置填充该类型，图中 `<T>` 内部的 `T` 被称为类型变量，它是我们希望传递给 `identity` 函数的类型占位符，同时它被分配给 `value` 参数用来代替它的类型（此时 `T` 充当的是类型，而不是特定的 `Number` 类型）

我们把这个版本的函数叫做「泛型」，因为它可以适用于多个类型，不同于使用 `any`，它不会丢失信息，并且可以保持准确性，即我们如果传入的是数值类型的话，那么返回的也会是数值类型

其中函数当中的 `T` 代表着 `Type`，在定义泛型时通常用作第一个类型变量名称，但实际上 `T` 可以用任何有效名称代替，除了 `T` 之外，以下是常见泛型变量代表的意思

* `K`（`Key`），表示对象中的键类型
* `V`（`Value`），表示对象中的值类型
* `E`（`Element`），表示元素类型

其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量，比如我们引入一个新的类型变量 `U`，用于扩展我们定义的 `identity` 函数

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}

console.log(identity<Number, string>(18, 'zhangsan'))
```

这里我们在使用的时候明确的指定了 `T` 和 `U` 是 `Number` 和 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`

但是另外一种更为普遍的做法是使用「类型推论」，我们可以完全省略尖括号，也就是说让编译器来根据我们传入的参数自动地来确定 `T` 或者 `U` 的类型，从而使代码更简洁

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}

console.log(identity(18, 'zhangsan'))
```

这一点我们可以也通过编辑器的代码提示功能来进行发现

```ts
// function identity<18, number>(value: 18, message: number): 18
console.log(identity(18, 18))

// function identity<'abc', number>(value: 'abc', message: number): 'abc'
console.log(identity('abc', 18))

// function identity<'abc', string>(value: 'abc', message: string): 'abc'
console.log(identity('abc', 'abc'))
```

另外，我们还可以为泛型中的类型参数指定默认类型，因为当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用

```ts
function identity<T = string, U = number>(value: T, message: U): T {
  console.log(message)
  return value
}
```


#### 使用泛型

例如当我们想创建一个字符串的队列时，我们需要的是一种无论什么类型被推入队列，被推出的类型都与推入类型一样，而针对这种情况使用泛型，就十分容易

```ts
class Queue<T> {
  private data: T[] = []
  push = (item: T) => this.data.push(item)
  pop = (): T | undefined => this.data.shift()
}

const queue = new Queue<number>()

queue.push(0)     // ✅
queue.push('abc') // ❌
```

通过上面的示例我们可以发现，当我们尝试推入一个字符类型的参数的时候，编辑器会给我们错误的提示，因为只有 `number` 类型才被允许推入



#### 多个类型参数

我们在定义泛型的时候，可以一次定义多个类型参数

```ts
function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}

// ['zhangsan', 18]
swap([18, 'zhangsan'])
```

在上面的示例当中，我们定义了一个 `swap` 函数，它主要用来交换输入的元组


#### 泛型约束

我们在上面的使用过程当中，也只是使用泛型来定义函数的输入输出以及变量的类型，但是在函数内部使用泛型变量的时候需要注意了，由于我们事先不知道它是哪种类型，所以不能随意的操作它的属性或方法

```ts
function loggingIdentity<T>(arg: T): T {
  // ❌
  console.log(arg.length)
  return arg
}
```

在上面的示例当中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了，在这种情况下，我们可以对泛型进行约束，只允许这个函数传入那些包含 `length` 属性的变量，这也被称为「泛型约束」

针对于上面这种情况，我们可以假设我们想操作的是 `T` 类型的数组而不是 `T`，这样一来由于我们操作的是数组，所以 `.length` 属性是应该存在的，这样我们就可以像创建其它数组一样来进行操作

```ts
function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length)
  return arg
}
```

也可以这样实现上面的例子

```ts
function loggingIdentity<T>(arg: Array<T>): Array<T> {
  console.log(arg.length)
  return arg
}
```

或者使用接口也是可以的

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length)
  return arg
}
```

在上面的示例当中，我们使用了 `extends` 约束了泛型 `T`，所以它可以访问 `arg.length`，但是此时如果传入的 `arg` 不包含 `length` 的话，那么编译也会出错

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  // ❌
  console.log(arg.length)
  return arg
}

loggingIdentity('zhangsan')  // ✅

loggingIdentity(1234567890)  // ❌
```

也就是说，现在这个泛型函数已经被定义了约束，因此它不再是适用于任意类型，所以我们需要传入符合约束类型的值，当然具有 `length` 属性的对象也是可以的

```ts
// ✅
loggingIdentity({ length: 10, value: 3 })
```

另外，多个类型参数之间也是可以互相约束的

```ts
function copyFields<T extends U, U>(target: T, source: U): T {
  for (let id in source) {
    target[id] = (<T>source)[id]
  }
  return target
}

let x = { a: 1, b: 2, c: 3, d: 4 }

copyFields(x, { b: 10, d: 20 })
```

在上面的示例当中，我们使用了两个类型参数，其中要求 `T` 继承 `U`，这样就保证了 `U` 上不会出现 `T` 中不存在的字段，其中 `<T>source` 的写法等同于 `source as T`，其实就是把 `source` 断言成 `T` 类型



#### 泛型接口

我们在之前函数的章节部分介绍了接口相关内容，也知道了函数可以使用接口的方式来定义一个函数需要符合的结构，如下

```ts
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc = function (source: string, subString: string): boolean {
  return source.search(subString) !== -1
}
```

所以我们也可以使用含有泛型的接口来定义函数的结构

```ts
interface CreateArrayFunc {
  <T>(length: number, value: T): Array<T>
}

let createArray: CreateArrayFunc = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

// [5, 5, 5]
console.log(createArray(3, 5))
```

再进一步的话，我们可以将泛型参数提前到接口名上，然后在使用的时候在来定义类型

```ts
interface CreateArrayFunc<T> {
  (length: number, value: T): Array<T>
}

let createArray: CreateArrayFunc<string> = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

createArray(3, 'x') // ✅

createArray(3, 123) // ❌
```



#### 泛型类

与泛型接口类似，泛型也可以用于类的类型定义中

```ts
// strict = false
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>()

myGenericNumber.zeroValue = 0

myGenericNumber.add = function (x, y) { return x + y }
```

也可以使用字符串或其它更复杂的类型

```ts
class GenericNumber<T> {
  zeroValue: T
  add: (x: T, y: T) => T
}

let stringNumeric = new GenericNumber<string>()
stringNumeric.zeroValue = ''
stringNumeric.add = function (x, y) { return x + y }

stringNumeric.add(stringNumeric.zeroValue, 'test')
```

与接口一样，我们可以直接把泛型类型放在类后面，这样可以帮助我们确认类的所有属性都是使用的相同类型




#### 泛型工具类型

为了方便开发者，`TypeScript` 内置了一些常用的工具类型，比如 `Partial`、`Required`、`Readonly`、`Record` 和 `ReturnType` 等，出于篇幅考虑，这里我们只简单介绍 `Partial` 工具类型，不过在具体介绍之前，我们得先介绍一些相关的基础知识

* `typeof`，可以用来获取一个变量声明或对象的类型

```ts
interface Person {
  name: string
  age: number
}

const sem: Person = { name: 'zhangsan', age: 18 }

function toArray(x: number): Array<number> {
  return [x]
}

type Sem = typeof sem       // -> Person
type Func = typeof toArray  // -> (x: number) => Array<number>
```

* `keyof`，`TypeScript 2.1` 版本当中引入，可以用于获取某种类型的所有键，其返回类型是联合类型

```ts
interface Person {
  name: string
  age: number
}

type K3 = keyof { [x: string]: Person }  // string | number
type K2 = keyof Person[]                 // number | 'length' | 'push' ...
type K1 = keyof Person                   // 'name' | 'age'
```

我们之前的章节当中曾经提到过，在 `TypeScript` 中支持两种索引签名，数字索引和字符串索引

```ts
interface StringArray {
  // 字符串索引 -> keyof StringArray => string | number
  [index: string]: string;
}

interface StringArray1 {
  // 数字索引 -> keyof StringArray1 => number
  [index: number]: string;
}
```

为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类，其中的原因就是当使用数值索引时，`JavaScript` 在执行索引操作时，会先把数值索引先转换为字符串索引，所以 `keyof { [x: string]: Person }` 的结果会返回 `string | number`

* `in`，可以用来遍历枚举类型

```ts
type Keys = 'a' | 'b' | 'c'

// -> { a: any, b: any, c: any }
type Obj = {
  [p in Keys]: any
}
```

* `infer`，在条件类型语句中，可以用 `infer` 声明一个类型变量并且对它进行使用

```ts
type ReturnType<T> = T extends (
  ...args: any[]
) => infer R ? R : any
```

以上代码中 `infer R` 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用

* `extends`，这个我们之前提到过，有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 `extends` 关键字添加泛型约束

```ts
interface Lengthwise {
  length: number
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length)
  return arg
}
```

现在这个泛型函数被定义了约束，因此它不再是适用于任意类型

```ts
// -> 类型 `number` 的参数不能赋给类型 `Lengthwise` 的参数
loggingIdentity(3)
```

这时我们需要传入符合约束类型的值，必须包含必须的属性

```ts
// ❌
loggingIdentity({ value: 3 })

// ✅
loggingIdentity({ length: 10, value: 3 })
```

* `Partial`，它的作用就是将某个类型里的属性全部变为可选项 `?`，定义如下

```ts
// node_modules/typescript/lib/lib.es5.d.ts
type Partial<T> = {
  [P in keyof T]?: T[P]
}
```

在以上代码中，首先通过 `keyof T` 拿到 `T` 的所有属性名，然后使用 `in` 进行遍历，将值赋给 `P`，最后通过 `T[P]` 取得相应的属性值，中间的 `?` 号，用于将所有属性变为可选，比如下面这个示例

```ts
interface Todo {
  title: string
  description: string
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate }
}

const todo1 = {
  title: 'title',
  description: 'description',
}

const todo2 = updateTodo(todo1, {
  description: 'update-description',
})
```

在上面的 `updateTodo `方法中，我们利用 `Partial<T>` 工具类型，定义 `fieldsToUpdate` 的类型为 `Partial<Todo>`，即

```ts
{
  title?: string | undefined
  description?: string | undefined
}
```




## tsconfig.json

最后的最后，我们再来简单的了解一下 `tsconfig.json` 这个配置文件和它的一些比较重要的字段，我们先来看看 `tsconfig.json` 的作用，总的来说，`tsconfig.json` 的作用主要有以下几点

* 用于标识 `TypeScript` 项目的根路径
* 用于配置 `TypeScript` 编译器
* 用于指定编译的文件

而其中涉及到的字段较多，我们这里只是挑选几个比较重要的简单介绍一下，如下

* `files`，设置要编译的文件的名称
* `include`，设置需要进行编译的文件，支持路径模式匹配
* `exclude`，设置无需进行编译的文件，支持路径模式匹配
* `compilerOptions`，设置与编译流程相关的选项

这里我们重点关注一下 `compilerOptions` 这个字段，`compilerOptions` 支持很多选项，常见的有 `baseUrl`、`target`、`baseUrl`、`moduleResolution` 和 `lib` 等，每个选项的详细说明如下所示

```ts
{
  "compilerOptions": {

    /* 基本选项 */
    "target": "es5",                      // 指定 ECMAScript 目标版本，包括 ES3（默认）/ES5/ES6/ES2016/ES2017/ESNEXT
    "module": "commonjs",                 // 指定使用模块，包括 commonjs/amd/system/umd/es2015
    "lib": [],                            // 指定要包含在编译中的库文件
    "allowJs": true,                      // 允许编译 JavaScript 文件
    "checkJs": true,                      // 报告 JavaScript 文件中的错误
    "jsx": "preserve",                    // 指定 jsx 代码的生成，包括 preserve/react-native/react
    "declaration": true,                  // 生成相应的 .d.ts 文件
    "sourceMap": true,                    // 生成相应的 .map 文件
    "outFile": "./",                      // 将输出文件合并为一个文件
    "outDir": "./",                       // 指定输出目录
    "rootDir": "./",                      // 用来控制输出目录结构（--outDir）
    "removeComments": true,               // 删除编译后的所有的注释
    "noEmit": true,                       // 不生成输出文件
    "importHelpers": true,                // 从 tslib 导入辅助工具函数
    "isolatedModules": true,              // 将每个文件做为单独的模块（与 ts.transpileModule 类似）

    /* 严格的类型检查选项 */    
    "strict": true,                       // 启用所有严格类型检查选项
    "noImplicitAny": true,                // 在表达式和声明上有隐含的 any 类型时报错
    "strictNullChecks": true,             // 启用严格的 null 检查
    "noImplicitThis": true,               // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                 // 以严格模式检查每个模块，并在每个文件里加入 use strict

    /* 额外的检查 */  
    "noUnusedLocals": true,               // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,           // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,            // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,   // 报告 switch 语句的 fallthrough 错误（即不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",           // 选择模块解析策略，包括 node（Node.js） 和 classic（TypeScript pre-1.6）
    "baseUrl": "./",                      // 用于解析非相对模块名称的基目录
    "paths": {},                          // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                       // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                      // 包含类型声明的文件列表
    "types": [],                          // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入

    /* Source Map Options */
    "sourceRoot": "./",                   // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                      // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,              // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                // 将代码与 sourcemaps 生成到一个文件中，要求同时设置 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,       // 启用装饰器
    "emitDecoratorMetadata": true         // 为装饰器提供元数据的支持
    
  }
}
```

## 总结

我们在 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/) 一节当中梳理了一些 `TypeScript` 的基础内容，也算是回顾一下 `TypeScript` 的基本用法，而在本章当中则是简单的介绍了一些比较常用的姑且算是进阶的内容

但是 `TypeScript` 当中所涉及到的内容并不仅仅只有我们介绍到的这些，其它一些相关内容比如 [函数输入的类型推论](https://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-type) 或是 [多态](https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types) 等平常很少涉及到的内容，我们也就没有多做提及，不过以后如果在工作当中遇到相关内容的话会再来完善这两章的相关内容

更多相关内容可以参考 [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html) 来了解更多，中文版可见 [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)




## 参考

* [The unknown Type in TypeScript](https://mariusschulz.com/blog/the-unknown-type-in-typescript)
* [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)
* [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)
* [TypeScript](https://www.typescriptlang.org)
* [一份不可多得的 TS 学习指南](https://juejin.cn/post/6872111128135073806)



