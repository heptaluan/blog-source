---
title: 深入 TypeScript
date: 2021-01-01
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/57.webp
---

接上回 [重温 TypeScript](http://localhost:4000/2020/12/26/JavaScript/56/)，在之前的章节当中，我们简单的梳理一下 `TypeScript` 的基础内容和基本用法，本章当中我们就来看一些 `TypeScript` 当中的进阶内容，也算是针对于 `TypeScript` 做一个比较深入的学习记录吧，主要包括以下内容

* 类型别名
* 字面量类型
* 元组
* 枚举
* 类
* 类与接口
* 泛型

我们就先从比较简单的类型别名和字符串字面量类型开始看起


<!--more-->


## 类型别名

这个很好理解，就是用来给一个类型起个新名字，方式是使用 `type` 来创建类型别名

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;

function getName(n: NameOrResolver): Name {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}
```

关于首字母大写的问题，通常来说在语法上没有限制，不过参考 [TypeScript 官方](https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts#L1439) 的写法，一般建议首字母大写



## 字面量类型

同类型别名一样，字面量类型也是使用 `type` 来进行定义，它的作用简单来说就是用来约束取值只能是某几个字段当中的一个，比如下面这个示例

```ts
type EventNames = 'click' | 'scroll' | 'mousemove'
function handleEvent(ele: Element, event: EventNames) {
  // ...
}

const el = document.getElementById('el')
handleEvent(el, 'click')     // ✅
handleEvent(el, 'dblclick')  // ❌ 
```

在上面的示例当中，我们使用 `type` 定义了一个字符串字面量类型 `EventNames`，它规定只能取三种事件名当中的一种，如果定义了约定以外的字段，就会报错

当然除了字符串字面量类型，数值类型也是可以的

```ts
type Nums = 1 | 2 | 3

let x: Nums = 1  // ✅
let y: Nums = 4  // ❌ 
```




## 元组

我们在之前的章节当中介绍了数组的类型，简单来说，数组就是合并了相同类型的对象，而元组（`Tuple`）则可以理解为是合并了不同类型的对象，下面我们就来看看如何使用元祖来进行定义，比如下面这个示例，我们定义了一对值分别为 `string` 和 `number` 的元组

```ts
let x: [string, number] = ['zhangsan', 18]
```

当赋值或访问一个已知索引的元素时，会得到正确的类型

```ts
let x: [string, number] = ['zhangsan', 18]

x[0] = 'lisi'
x[1] = 20

x[0].slice(1)
x[1].toFixed()
```

但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，否则会报错

```ts
let x: [string, number]

x = ['zhangsan', 18]  // ✅
x = ['zhangsan']      // ❌ 
```

另外需要注意的是，如果当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型

```ts
let x: [string, number] = ['zhangsan', 18]

x.push('lisi')  // ✅
x.push(true)    // ❌ 
```

但是通常不建议超出范围，因为使用元祖可以确定元素数据类型，可以把元祖理解为固定长度，但是超出范围不能保证其类型


## 枚举

枚举（`Enum`）类型在某些方面与我们之前介绍的元组有一些类似的地方，它主要用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等等，使用 `enum` 关键字来定义

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }
```

枚举成员会被赋值为从 `0` 开始递增的数字，同时也会对枚举值到枚举名进行反向映射

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days[0])      // Sun
console.log(Days['Sun'])  // 0
```

我们也可以给枚举项手动赋值

```ts
enum Days { Sun = 7, Mon, Tue = 1, Wed, Thu, Fri, Sat }

console.log(Days['Sun'])  // 7
console.log(Days['Mon'])  // 8
console.log(Days['Wed'])  // 2
```

运行后可以发现，未手动赋值的枚举项会接着上一个枚举项依次递增，但是需要注意的是，如果未手动赋值的枚举项与手动赋值的重复了，`TypeScript` 是不会察觉到这一点的

```ts
enum Days { Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Sun'] === 3)  // true
console.log(Days['Wed'] === 3)  // true
```

在上面的示例当中，递增到 `3` 的时候与我们前面手动赋值的 `Sun` 的取值重复了，但是 `TypeScript` 并没有报错，导致 `Days[3]` 的值先是 `'Sun'`，而后又被 `'Wed'` 覆盖了，但是我们在实际应用场景当中需要注意，最好不要出现这种覆盖的情况

当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 `1`

```ts
enum Days { Sun = 1.2, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Mon'])  // 2.2
console.log(Days['Tue'])  // 3.2
console.log(Days['Wed'])  // 4.2
```

关于枚举的相关内容就介绍到这里，因为发现平常很少会去使用它，所以暂时就总结这么多，如果后续工作当中有遇到相关内容的话再来进行完善，枚举的其他一些用法可以参考文档当中的 [枚举](https://www.tslang.cn/docs/handbook/enums.html)




## 类

传统方法中，`JavaScript` 通过构造函数实现类的概念，通过原型链实现继承，而在 `ES6` 中，我们终于迎来了 `class`，`TypeScript` 除了实现了所有 `ES6` 中的类的功能以外，还添加了一些新的用法，下面就让我们就来看看 `TypeScript` 中类的用法

`TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected`

* `public`，修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
* `private`，修饰的属性或方法是私有的，不能在声明它的类的外部访问
* `protected`，修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的

下面我们来看几个示例

```ts
class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')
console.log(a.name)  // zhangsan

a.name = 'lisi'
console.log(a.name)  // lisi
```

在上面示例当中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的，如果我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')

// ❌，因为属性 name 为私有属性，只能在类 Person 中访问
console.log(a.name)
```

但是需要注意的是，在 `TypeScript` 编译之后的代码中，其实并没有限制 `private` 属性在外部的可访问性

```js
var Person = (function () {
  function Person(name) {
    this.name = name
  }
  return Person
})()

var a = new Person('zhangsan')

console.log(a.name)  // zhangsan
```

同时，使用 `private` 修饰的属性或方法，在子类中也是不允许访问的

```js
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ❌
    console.log(this.name)
  }
}
```

而如果是用 `protected` 修饰，则允许在子类中访问

```js
class Person {
  protected name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ✅
    console.log(this.name)
  }
}
```

如果我们不想让该类被继承或者实例化，那么可以在构造函数上设置 `private` 修饰

```js
class Person {
  public name
  private constructor(name) {
    this.name = name
  }
}

// ❌
class Man extends Person {
  // ...
}
```

当构造函数修饰为 `protected` 时，该类只允许被继承

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}


// ✅
class Man extends Person {
  // ...
}

// ❌
let man = new Person()
```

同样的，上面介绍到的修饰符和下面提到的 `readonly` 都可以使用在构造函数的参数当中，等同于类中定义该属性的同时给该属性赋值

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}

// 等同于 ==>

class Person {
  protected constructor(public name) {
    
  }
}
```



#### readonly

只读属性关键字，表示只允许出现在属性声明或索引签名或构造函数中

```ts
class Person {
  readonly name
  public constructor(name) {
    this.name = name
  }
}

// ✅
let man = new Person('zhangsan')

// ❌
man.name = 'list'
```

不过需要注意的是，如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面

```ts
class Person {
  // ✅
  public readonly name

  // ❌
  readonly public name
  
  public constructor(name) {
    this.name = name
  }
}
```


#### 抽象类

使用 `abstract` 来定义抽象类和其中的抽象方法，那么什么是抽象类呢？首先抽象类是不允许被实例化的

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

// ❌
let man = new Person('zhangsan')
```

在上面的例子当中，我们定义了一个抽象类 `Person`，可以发现在实例化抽象类的时候报错了，另外如果抽象类当中存在抽象方法，如下

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}
```

其中的抽象方法必须被子类实现

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}

class Man extends Person {
  // 这里需要实现父类当中的抽象方法，否则会报错
  public say() {
    console.log(this.name)
  }
}

let man = new Man('zhangsan')

man.say()
```



## 类与接口

实现（`implements`）是面向对象中的一个重要概念，一般来说一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（`interfaces`），用 `implements` 关键字来实现，这个特性大大提高了面向对象的灵活性

```ts
interface SayName {
  sayName(): void
}

class Animal { }

class Cat extends Animal implements SayName {
  sayName() {
    console.log(`cat`)
  }
}

class Dog extends Animal implements SayName {
  sayName() {
    console.log(`dog`)
  }
}
```

同样的，一个类可以实现多个接口

```ts
interface SayName {
  sayName(): void
}

interface SayAge {
  sayAge(): void
}

class Rabbit implements SayName, SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

但是需要注意一点，接口与接口之间也是可以是继承关系的

```ts
interface SayName {
  sayName(): void
}

interface SayAge extends SayName {
  sayAge(): void
}

class Rabbit implements SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

最后我们再来看一种比较有趣的情况，但是也是平常使用较少的一种情况，那就是接口继承类，在常见的面向对象语言中，接口是不能继承类的，但是在 `TypeScript` 中却是可以的

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

但是为什么 `TypeScript` 会支持接口继承类呢？实际上当我们在声明 `class Point` 的时候，除了会创建一个名为 `Point` 的类之外，同时也创建了一个名为 `Point` 的类型（实例的类型）

所以我们既可以将 `Point` 当做一个类来用（使用 `new Point` 创建它的实例）

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

const p = new Point(1, 2)
```

也可以将 `Point` 当做一个类型来用

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

function printPoint(p: Point) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

上面这个例子实际上可以等价于

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

function printPoint(p: PointInstanceType) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

在上面示例当中我们新声明了一个 `PointInstanceType` 的类型，其实本质上与声明 `class Point` 时创建的 `Point` 类型是等价的，所以在回过头来看我们之前的示例，就很容易的理解为什么 `TypeScript` 会支持接口继承类了

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

// 其实等价于 interface Point3d extends PointInstanceType
interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

当我们声明 `interface Point3d extends Point` 的时候，本质上 `Point3d` 继承的是类 `Point` 的实例的类型，我们可以理解为定义了一个接口 `Point3d` 继承另一个接口 `PointInstanceType`，所以「接口继承类」和「接口继承接口」没有什么本质的区别

但是需要注意的是，那就是 `PointInstanceType` 相比于 `Point` 缺少了 `constructor` 方法，这是因为声明 `Point` 类时创建的 `Point` 类型是不包含构造函数的，另外除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）

换句话说，声明 `Point` 类时创建的 `Point` 类型只包含其中的实例属性和实例方法

```ts
class Point {
  static origin = new Point(0, 0)       // 静态属性，坐标系原点
  static distanceToOrigin(p: Point) {   // 静态方法，计算与原点距离
    return Math.sqrt(p.x * p.x + p.y * p.y)
  }
  x: number       // 实例属性 x 轴的值
  y: number       // 实例属性 y 轴的值
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
  printPoint() {  // 实例方法
    console.log(this.x, this.y)
  }
}

interface PointInstanceType {
  x: number
  y: number
  printPoint(): void
}

let p1: Point
let p2: PointInstanceType
```

上例中最后的类型 `Point` 和类型 `PointInstanceType` 本质上是等价的，所以我们可以发现，在接口继承类的时候，只会继承它的实例属性和实例方法



## 泛型

待续



## 参考

* [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)


