---
title: 深入 TypeScript
date: 2021-01-01
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/57.webp
---

接上回 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/)，在之前的章节当中，我们简单的梳理一下 `TypeScript` 的基础内容和基本用法，本章当中我们就来看一些 `TypeScript` 当中的进阶内容，也算是针对于 `TypeScript` 做一个比较深入的学习记录吧，主要包括以下内容


<!--more-->


* 类型别名
* 字面量类型
* 元组
* 枚举
* 类
* 类与接口
* 泛型

我们就先从比较简单的类型别名和字符串字面量类型开始看起


## 类型别名

这个很好理解，就是用来给一个类型起个新名字，方式是使用 `type` 来创建类型别名

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;

function getName(n: NameOrResolver): Name {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}
```

关于首字母大写的问题，通常来说在语法上没有限制，不过参考 [TypeScript 官方](https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts#L1439) 的写法，一般建议首字母大写



## 字面量类型

同类型别名一样，字面量类型也是使用 `type` 来进行定义，它的作用简单来说就是用来约束取值只能是某几个字段当中的一个，比如下面这个示例

```ts
type EventNames = 'click' | 'scroll' | 'mousemove'
function handleEvent(ele: Element, event: EventNames) {
  // ...
}

const el = document.getElementById('el')
handleEvent(el, 'click')     // ✅
handleEvent(el, 'dblclick')  // ❌
```

在上面的示例当中，我们使用 `type` 定义了一个字符串字面量类型 `EventNames`，它规定只能取三种事件名当中的一种，如果定义了约定以外的字段，就会报错

当然除了字符串字面量类型，数值类型也是可以的

```ts
type Nums = 1 | 2 | 3

let x: Nums = 1  // ✅
let y: Nums = 4  // ❌
```




## 元组

我们在之前的章节当中介绍了数组的类型，众所周知，数组一般由同种类型的值组成，也就是合并了相同类型的对象，但有时我们需要在单个变量中存储不同类型的值，在这种情况下我们就可以使用元组，它可以理解为是合并了不同类型的对象

在 `JavaScript` 中是没有元组的，元组是 `TypeScript` 中特有的类型，其工作方式类似于数组，
元组可用于定义具有有限数量的未命名属性的类型，每个属性都有一个关联的类型，使用元组时必须提供每个属性的值

为了更直观地理解元组的概念，我们来看一个具体的例子

```ts
let x: [string, number] = ['zhangsan', 18]
```

在上面代码中，我们定义了一个名为 `x` 的变量，它的类型是一个类型数组 `[string, number]`，然后我们按照正确的类型依次初始化 `x` 变量，与数组一样，我们可以通过下标来访问元组中的元素并且操作它们

```ts
let x: [string, number] = ['zhangsan', 18]

x[0] = 'lisi'
x[1] = 20

x[0].slice(1)
x[1].toFixed()
```

但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，否则会报错

```ts
let x: [string, number]

x = ['zhangsan', 18]  // ✅
x = ['zhangsan']      // ❌
```

另外需要注意的是，如果当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型

```ts
let x: [string, number] = ['zhangsan', 18]

x.push('lisi')  // ✅
x.push(true)    // ❌
```

但是通常不建议超出范围，因为使用元祖可以确定元素数据类型，可以把元祖理解为固定长度，但是超出范围不能保证其类型


## 枚举

枚举（`Enum`）类型在某些方面与我们之前介绍的元组有一些类似的地方，它主要用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等等，使用 `enum` 关键字来定义

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }
```

枚举成员会被赋值为从 `0` 开始递增的数字，同时也会对枚举值到枚举名进行反向映射

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days[0])      // Sun
console.log(Days['Sun'])  // 0
```

我们也可以给枚举项手动赋值

```ts
enum Days { Sun = 7, Mon, Tue = 1, Wed, Thu, Fri, Sat }

console.log(Days['Sun'])  // 7
console.log(Days['Mon'])  // 8
console.log(Days['Wed'])  // 2
```

运行后可以发现，未手动赋值的枚举项会接着上一个枚举项依次递增，但是需要注意的是，如果未手动赋值的枚举项与手动赋值的重复了，`TypeScript` 是不会察觉到这一点的

```ts
enum Days { Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Sun'] === 3)  // true
console.log(Days['Wed'] === 3)  // true
```

在上面的示例当中，递增到 `3` 的时候与我们前面手动赋值的 `Sun` 的取值重复了，但是 `TypeScript` 并没有报错，导致 `Days[3]` 的值先是 `'Sun'`，而后又被 `'Wed'` 覆盖了，但是我们在实际应用场景当中需要注意，最好不要出现这种覆盖的情况

当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 `1`

```ts
enum Days { Sun = 1.2, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Mon'])  // 2.2
console.log(Days['Tue'])  // 3.2
console.log(Days['Wed'])  // 4.2
```

关于枚举的相关内容就介绍到这里，因为发现平常很少会去使用它，所以暂时就总结这么多，如果后续工作当中有遇到相关内容的话再来进行完善，枚举的其他一些用法可以参考文档当中的 [枚举](https://www.tslang.cn/docs/handbook/enums.html)




## 类

传统方法中，`JavaScript` 通过构造函数实现类的概念，通过原型链实现继承，而在 `ES6` 中，我们终于迎来了 `class`，`TypeScript` 除了实现了所有 `ES6` 中的类的功能以外，还添加了一些新的用法，下面就让我们就来看看 `TypeScript` 中类的用法

`TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected`

* `public`，修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
* `private`，修饰的属性或方法是私有的，不能在声明它的类的外部访问
* `protected`，修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的

下面我们来看几个示例

```ts
class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')
console.log(a.name)  // zhangsan

a.name = 'lisi'
console.log(a.name)  // lisi
```

在上面示例当中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的，如果我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')

// ❌，因为属性 name 为私有属性，只能在类 Person 中访问
console.log(a.name)
```

但是需要注意的是，在 `TypeScript` 编译之后的代码中，其实并没有限制 `private` 属性在外部的可访问性

```ts
var Person = (function () {
  function Person(name) {
    this.name = name
  }
  return Person
})()

var a = new Person('zhangsan')

console.log(a.name)  // zhangsan
```

同时，使用 `private` 修饰的属性或方法，在子类中也是不允许访问的

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ❌
    console.log(this.name)
  }
}
```

而如果是用 `protected` 修饰，则允许在子类中访问

```ts
class Person {
  protected name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ✅
    console.log(this.name)
  }
}
```

如果我们不想让该类被继承或者实例化，那么可以在构造函数上设置 `private` 修饰

```ts
class Person {
  public name
  private constructor(name) {
    this.name = name
  }
}

// ❌
class Man extends Person {
  // ...
}
```

当构造函数修饰为 `protected` 时，该类只允许被继承

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}


// ✅
class Man extends Person {
  // ...
}

// ❌
let man = new Person()
```

同样的，上面介绍到的修饰符和下面提到的 `readonly` 都可以使用在构造函数的参数当中，等同于类中定义该属性的同时给该属性赋值

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}

// 等同于 ==>

class Person {
  protected constructor(public name) {
    
  }
}
```



#### readonly

只读属性关键字，表示只允许出现在属性声明或索引签名或构造函数中

```ts
class Person {
  readonly name
  public constructor(name) {
    this.name = name
  }
}

// ✅
let man = new Person('zhangsan')

// ❌
man.name = 'list'
```

不过需要注意的是，如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面

```ts
class Person {
  // ✅
  public readonly name

  // ❌
  readonly public name
  
  public constructor(name) {
    this.name = name
  }
}
```


#### 抽象类

使用 `abstract` 来定义抽象类和其中的抽象方法，那么什么是抽象类呢？首先抽象类是不允许被实例化的

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

// ❌
let man = new Person('zhangsan')
```

在上面的例子当中，我们定义了一个抽象类 `Person`，可以发现在实例化抽象类的时候报错了，另外如果抽象类当中存在抽象方法，如下

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}
```

其中的抽象方法必须被子类实现

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}

class Man extends Person {
  // 这里需要实现父类当中的抽象方法，否则会报错
  public say() {
    console.log(this.name)
  }
}

let man = new Man('zhangsan')

man.say()
```



## 类与接口

实现（`implements`）是面向对象中的一个重要概念，一般来说一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（`interfaces`），用 `implements` 关键字来实现，这个特性大大提高了面向对象的灵活性

```ts
interface SayName {
  sayName(): void
}

class Animal { }

class Cat extends Animal implements SayName {
  sayName() {
    console.log(`cat`)
  }
}

class Dog extends Animal implements SayName {
  sayName() {
    console.log(`dog`)
  }
}
```

同样的，一个类可以实现多个接口

```ts
interface SayName {
  sayName(): void
}

interface SayAge {
  sayAge(): void
}

class Rabbit implements SayName, SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

但是需要注意一点，接口与接口之间也是可以是继承关系的

```ts
interface SayName {
  sayName(): void
}

interface SayAge extends SayName {
  sayAge(): void
}

class Rabbit implements SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

最后我们再来看一种比较有趣的情况，但是也是平常使用较少的一种情况，那就是接口继承类，在常见的面向对象语言中，接口是不能继承类的，但是在 `TypeScript` 中却是可以的

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

但是为什么 `TypeScript` 会支持接口继承类呢？实际上当我们在声明 `class Point` 的时候，除了会创建一个名为 `Point` 的类之外，同时也创建了一个名为 `Point` 的类型（实例的类型）

所以我们既可以将 `Point` 当做一个类来用（使用 `new Point` 创建它的实例）

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

const p = new Point(1, 2)
```

也可以将 `Point` 当做一个类型来用

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

function printPoint(p: Point) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

上面这个例子实际上可以等价于

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

function printPoint(p: PointInstanceType) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

在上面示例当中我们新声明了一个 `PointInstanceType` 的类型，其实本质上与声明 `class Point` 时创建的 `Point` 类型是等价的，所以在回过头来看我们之前的示例，就很容易的理解为什么 `TypeScript` 会支持接口继承类了

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

// 其实等价于 interface Point3d extends PointInstanceType
interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

当我们声明 `interface Point3d extends Point` 的时候，本质上 `Point3d` 继承的是类 `Point` 的实例的类型，我们可以理解为定义了一个接口 `Point3d` 继承另一个接口 `PointInstanceType`，所以「接口继承类」和「接口继承接口」没有什么本质的区别

但是需要注意的是，那就是 `PointInstanceType` 相比于 `Point` 缺少了 `constructor` 方法，这是因为声明 `Point` 类时创建的 `Point` 类型是不包含构造函数的，另外除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）

换句话说，声明 `Point` 类时创建的 `Point` 类型只包含其中的实例属性和实例方法

```ts
class Point {
  static origin = new Point(0, 0)       // 静态属性，坐标系原点
  static distanceToOrigin(p: Point) {   // 静态方法，计算与原点距离
    return Math.sqrt(p.x * p.x + p.y * p.y)
  }
  x: number       // 实例属性 x 轴的值
  y: number       // 实例属性 y 轴的值
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
  printPoint() {  // 实例方法
    console.log(this.x, this.y)
  }
}

interface PointInstanceType {
  x: number
  y: number
  printPoint(): void
}

let p1: Point
let p2: PointInstanceType
```

上例中最后的类型 `Point` 和类型 `PointInstanceType` 本质上是等价的，所以我们可以发现，在接口继承类的时候，只会继承它的实例属性和实例方法



## 泛型

泛型（`Generics`）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性，下面我们从一个示例开始看起，比如我们要实现一个函数 `createArray`，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值

```ts
function createArray(length: number, value: any): Array<any> {
  let result = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

// ['x', 'x', 'x']
createArray(3, 'x')
```

上面这个示例虽然运行起来不会报错，但是我们仔细观察的话可以发现其实是存在一些缺陷的，那就是它并没有能够准确的定义返回值的类型，我们定义的 `Array<any>` 类型是允许数组的每一项都为任意类型，但是我们希望的是，数组中每一项都应该是输入的 `value` 的类型

在这种情况下，泛型就可以派上用场了

```ts
function createArray<T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

// ['x', 'x', 'x']
createArray<string>(3, 'x')
```

在上面的示例当中，我们给函数添加了类型变量 `T`，其中 `T` 可以帮助我们捕获用户传入的类型（比如 `number` 或者 `string`），之后我们就可以使用这个类型，并且可以使用 `T` 来当做返回值类型，现在我们可以知道参数类型与返回值类型是相同的了，这样一来就可以让我们跟踪函数里使用的类型的信息

我们把这个版本的函数叫做「泛型」，因为它可以适用于多个类型，不同于使用 `any`，它不会丢失信息，并且可以保持准确性，即我们如果传入的是数值类型的话，那么返回的也会是数值类型

当我们定义好了泛型函数后，可以用两种方式来进行使用，第一种方式是传入所有的参数，包含类型参数，也就是上面示例当中的使用方式

```ts
createArray<string>(3, 'x')
```

这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`

第二种方法的使用更为普遍，即利用「类型推论」，也就是让编译器来根据我们传入的参数自动地来确定 `T` 的类型，这一点我们可以通过编辑器的代码提示功能来发现

```ts
// function createArray<string>(length: number, value: string): string[]
createArray(3, 'x')

// function createArray<number>(length: number, value: number): number[]
createArray(3, 5)
```

另外，我们还可以为泛型中的类型参数指定默认类型，因为当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用

```ts
function createArray<T = string>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}
```



#### 多个类型参数

我们在定义泛型的时候，可以一次定义多个类型参数

```ts
function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}

// ['zhangsan', 18]
swap([18, 'zhangsan'])
```

在上面的示例当中，我们定义了一个 `swap` 函数，它主要用来交换输入的元组


#### 泛型约束

我们在上面的使用过程当中，也只是使用泛型来定义函数的输入输出以及变量的类型，但是在函数内部使用泛型变量的时候需要注意了，由于我们事先不知道它是哪种类型，所以不能随意的操作它的属性或方法

```ts
function loggingIdentity<T>(arg: T): T {
  // ❌
  console.log(arg.length)
  return arg
}
```

在上面的示例当中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了，在这种情况下，我们可以对泛型进行约束，只允许这个函数传入那些包含 `length` 属性的变量，这也被称为「泛型约束」

针对于上面这种情况，我们可以假设我们想操作的是 `T` 类型的数组而不是 `T`，这样一来由于我们操作的是数组，所以 `.length` 属性是应该存在的，这样我们就可以像创建其它数组一样来进行操作

```ts
function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length)
  return arg
}
```

也可以这样实现上面的例子

```ts
function loggingIdentity<T>(arg: Array<T>): Array<T> {
  console.log(arg.length)
  return arg
}
```

或者使用接口也是可以的

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length)
  return arg
}
```

在上面的示例当中，我们使用了 `extends` 约束了泛型 `T`，所以它可以访问 `arg.length`，但是此时如果传入的 `arg` 不包含 `length` 的话，那么编译也会出错

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  // ❌
  console.log(arg.length)
  return arg
}

loggingIdentity('zhangsan')  // ✅

loggingIdentity(1234567890)  // ❌
```

也就是说，现在这个泛型函数已经被定义了约束，因此它不再是适用于任意类型，所以我们需要传入符合约束类型的值，当然具有 `length` 属性的对象也是可以的

```ts
// ✅
loggingIdentity({ length: 10, value: 3 })
```

另外，多个类型参数之间也是可以互相约束的

```ts
function copyFields<T extends U, U>(target: T, source: U): T {
  for (let id in source) {
    target[id] = (<T>source)[id]
  }
  return target
}

let x = { a: 1, b: 2, c: 3, d: 4 }

copyFields(x, { b: 10, d: 20 })
```

在上面的示例当中，我们使用了两个类型参数，其中要求 `T` 继承 `U`，这样就保证了 `U` 上不会出现 `T` 中不存在的字段，其中 `<T>source` 的写法等同于 `source as T`，其实就是把 `source` 断言成 `T` 类型



#### 泛型接口

我们在之前函数的章节部分介绍了接口相关内容，也知道了函数可以使用接口的方式来定义一个函数需要符合的结构，如下

```ts
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc = function (source: string, subString: string): boolean {
  return source.search(subString) !== -1
}
```

所以我们也可以使用含有泛型的接口来定义函数的结构

```ts
interface CreateArrayFunc {
  <T>(length: number, value: T): Array<T>
}

let createArray: CreateArrayFunc = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

// [5, 5, 5]
console.log(createArray(3, 5))
```

再进一步的话，我们可以将泛型参数提前到接口名上，然后在使用的时候在来定义类型

```ts
interface CreateArrayFunc<T> {
  (length: number, value: T): Array<T>
}

let createArray: CreateArrayFunc<string> = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}

createArray(3, 'x') // ✅

createArray(3, 123) // ❌
```



#### 泛型类

与泛型接口类似，泛型也可以用于类的类型定义中

```ts
// strict = false
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>()

myGenericNumber.zeroValue = 0

myGenericNumber.add = function (x, y) { return x + y }
```

也可以使用字符串或其它更复杂的类型

```ts
class GenericNumber<T> {
  zeroValue: T
  add: (x: T, y: T) => T
}

let stringNumeric = new GenericNumber<string>()
stringNumeric.zeroValue = ''
stringNumeric.add = function (x, y) { return x + y }

stringNumeric.add(stringNumeric.zeroValue, 'test')
```

与接口一样，我们可以直接把泛型类型放在类后面，这样可以帮助我们确认类的所有属性都是使用的相同类型




## 总结

我们在 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/) 一节当中梳理了一些 `TypeScript` 的基础内容，也算是回顾一下 `TypeScript` 的基本用法，而在本章当中则是简单的介绍了一些比较常用的姑且算是进阶的内容

但是 `TypeScript` 当中所涉及到的内容并不仅仅只有我们介绍到的这些，其它一些相关内容比如 [函数输入的类型推论](https://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-type) 或是 [多态](https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types) 等平常很少涉及到的内容，我们也就没有多做提及，不过以后如果在工作当中遇到相关内容的话会再来完善这两章的相关内容

更多相关内容可以参考 [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html) 来了解更多，中文版可见 [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)




## 参考

* [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)
* [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)
* [TypeScript](https://www.typescriptlang.org)



