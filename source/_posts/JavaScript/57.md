---
title: 深入 TypeScript
date: 2021-01-01
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/57.webp
---

接上回 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/)，在之前的章节当中，我们简单的梳理一下 `TypeScript` 的基础内容和基本用法，本章当中我们就来看一些 `TypeScript` 当中的进阶内容，也算是针对于 `TypeScript` 做一个比较深入的学习记录吧，主要包括以下内容


<!--more-->


* 类型别名
* 字面量类型
* 元组
* 枚举
* 类
* 类与接口
* [泛型](http://localhost:4000/2021/01/01/JavaScript/58/)（因为泛型涉及的相关内容较多，所以另起篇幅来进行介绍）

下面我们就先从比较简单的类型别名和字符串字面量类型开始看起


## 类型别名

这个很好理解，就是用来给一个类型起个新名字，方式是使用 `type` 来创建类型别名

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;

function getName(n: NameOrResolver): Name {
  if (typeof n === 'string') {
    return n
  } else {
    return n()
  }
}
```

关于首字母大写的问题，通常来说在语法上没有限制，不过参考 [TypeScript 官方](https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts#L1439) 的写法，一般建议首字母大写



## 字面量类型

同类型别名一样，字面量类型也是使用 `type` 来进行定义，它的作用简单来说就是用来约束取值只能是某几个字段当中的一个，比如下面这个示例

```ts
type EventNames = 'click' | 'scroll' | 'mousemove'
function handleEvent(ele: Element, event: EventNames) {
  // ...
}

const el = document.getElementById('el')
handleEvent(el, 'click')     // ✅
handleEvent(el, 'dblclick')  // ❌
```

在上面的示例当中，我们使用 `type` 定义了一个字符串字面量类型 `EventNames`，它规定只能取三种事件名当中的一种，如果定义了约定以外的字段，就会报错

当然除了字符串字面量类型，数值类型也是可以的

```ts
type Nums = 1 | 2 | 3

let x: Nums = 1  // ✅
let y: Nums = 4  // ❌
```




## 元组

我们在之前的章节当中介绍了数组的类型，众所周知，数组一般由同种类型的值组成，也就是合并了相同类型的对象，但有时我们需要在单个变量中存储不同类型的值，在这种情况下我们就可以使用元组，它可以理解为是合并了不同类型的对象

在 `JavaScript` 中是没有元组的，元组是 `TypeScript` 中特有的类型，其工作方式类似于数组，
元组可用于定义具有有限数量的未命名属性的类型，每个属性都有一个关联的类型，使用元组时必须提供每个属性的值

为了更直观地理解元组的概念，我们来看一个具体的例子

```ts
let x: [string, number] = ['zhangsan', 18]
```

在上面代码中，我们定义了一个名为 `x` 的变量，它的类型是一个类型数组 `[string, number]`，然后我们按照正确的类型依次初始化 `x` 变量，与数组一样，我们可以通过下标来访问元组中的元素并且操作它们

```ts
let x: [string, number] = ['zhangsan', 18]

x[0] = 'lisi'
x[1] = 20

x[0].slice(1)
x[1].toFixed()
```

但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，否则会报错

```ts
let x: [string, number]

x = ['zhangsan', 18]  // ✅
x = ['zhangsan']      // ❌
```

另外需要注意的是，如果当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型

```ts
let x: [string, number] = ['zhangsan', 18]

x.push('lisi')  // ✅
x.push(true)    // ❌
```

但是通常不建议超出范围，因为使用元祖可以确定元素数据类型，可以把元祖理解为固定长度，但是超出范围不能保证其类型


## 枚举

枚举（`Enum`）类型在某些方面与我们之前介绍的元组有一些类似的地方，它主要用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等等，使用 `enum` 关键字来定义

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }
```

枚举成员会被赋值为从 `0` 开始递增的数字，同时也会对枚举值到枚举名进行反向映射

```ts
enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days[0])      // Sun
console.log(Days['Sun'])  // 0
```

我们也可以给枚举项手动赋值

```ts
enum Days { Sun = 7, Mon, Tue = 1, Wed, Thu, Fri, Sat }

console.log(Days['Sun'])  // 7
console.log(Days['Mon'])  // 8
console.log(Days['Wed'])  // 2
```

运行后可以发现，未手动赋值的枚举项会接着上一个枚举项依次递增，但是需要注意的是，如果未手动赋值的枚举项与手动赋值的重复了，`TypeScript` 是不会察觉到这一点的

```ts
enum Days { Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Sun'] === 3)  // true
console.log(Days['Wed'] === 3)  // true
```

在上面的示例当中，递增到 `3` 的时候与我们前面手动赋值的 `Sun` 的取值重复了，但是 `TypeScript` 并没有报错，导致 `Days[3]` 的值先是 `'Sun'`，而后又被 `'Wed'` 覆盖了，但是我们在实际应用场景当中需要注意，最好不要出现这种覆盖的情况

当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 `1`

```ts
enum Days { Sun = 1.2, Mon, Tue, Wed, Thu, Fri, Sat }

console.log(Days['Mon'])  // 2.2
console.log(Days['Tue'])  // 3.2
console.log(Days['Wed'])  // 4.2
```

关于枚举的相关内容就介绍到这里，因为发现平常很少会去使用它，所以暂时就总结这么多，如果后续工作当中有遇到相关内容的话再来进行完善，枚举的其他一些用法可以参考文档当中的 [枚举](https://www.tslang.cn/docs/handbook/enums.html)




## 类

传统方法中，`JavaScript` 通过构造函数实现类的概念，通过原型链实现继承，而在 `ES6` 中，我们终于迎来了 `class`，`TypeScript` 除了实现了所有 `ES6` 中的类的功能以外，还添加了一些新的用法，下面就让我们就来看看 `TypeScript` 中类的用法

`TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected`

* `public`，修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
* `private`，修饰的属性或方法是私有的，不能在声明它的类的外部访问
* `protected`，修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的

下面我们来看几个示例

```ts
class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')
console.log(a.name)  // zhangsan

a.name = 'lisi'
console.log(a.name)  // lisi
```

在上面示例当中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的，如果我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

let a = new Person('zhangsan')

// ❌，因为属性 name 为私有属性，只能在类 Person 中访问
console.log(a.name)
```

但是需要注意的是，在 `TypeScript` 编译之后的代码中，其实并没有限制 `private` 属性在外部的可访问性

```ts
var Person = (function () {
  function Person(name) {
    this.name = name
  }
  return Person
})()

var a = new Person('zhangsan')

console.log(a.name)  // zhangsan
```

同时，使用 `private` 修饰的属性或方法，在子类中也是不允许访问的

```ts
class Person {
  private name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ❌
    console.log(this.name)
  }
}
```

而如果是用 `protected` 修饰，则允许在子类中访问

```ts
class Person {
  protected name
  public constructor(name) {
    this.name = name
  }
}

class Man extends Person {
  constructor(name) {
    super(name)
    // ✅
    console.log(this.name)
  }
}
```

如果我们不想让该类被继承或者实例化，那么可以在构造函数上设置 `private` 修饰

```ts
class Person {
  public name
  private constructor(name) {
    this.name = name
  }
}

// ❌
class Man extends Person {
  // ...
}
```

当构造函数修饰为 `protected` 时，该类只允许被继承

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}


// ✅
class Man extends Person {
  // ...
}

// ❌
let man = new Person()
```

同样的，上面介绍到的修饰符和下面提到的 `readonly` 都可以使用在构造函数的参数当中，等同于类中定义该属性的同时给该属性赋值

```ts
class Person {
  public name
  protected constructor(name) {
    this.name = name
  }
}

// 等同于 ==>

class Person {
  protected constructor(public name) {
    
  }
}
```



#### readonly

只读属性关键字，表示只允许出现在属性声明或索引签名或构造函数中

```ts
class Person {
  readonly name
  public constructor(name) {
    this.name = name
  }
}

// ✅
let man = new Person('zhangsan')

// ❌
man.name = 'list'
```

不过需要注意的是，如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面

```ts
class Person {
  // ✅
  public readonly name

  // ❌
  readonly public name
  
  public constructor(name) {
    this.name = name
  }
}
```


#### 抽象类

使用 `abstract` 来定义抽象类和其中的抽象方法，那么什么是抽象类呢？首先抽象类是不允许被实例化的

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
}

// ❌
let man = new Person('zhangsan')
```

在上面的例子当中，我们定义了一个抽象类 `Person`，可以发现在实例化抽象类的时候报错了，另外如果抽象类当中存在抽象方法（指不包含具体实现的方法），如下

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}
```

其中的抽象方法必须被子类实现

```ts
abstract class Person {
  public name
  public constructor(name) {
    this.name = name
  }
  public abstract say()
}

class Man extends Person {
  // 这里需要实现父类当中的抽象方法，否则会报错
  public say() {
    console.log(this.name)
  }
}

let man = new Man('zhangsan')

man.say()
```



#### 私有字段

在 `TypeScript 3.8` 版本就开始支持 `ECMAScript` 私有字段，使用方式如下

```ts
class Person {
  #name: string

  constructor(name: string) {
    this.#name = name
  }

  greet() {
    console.log(`${this.#name}`)
  }
}

let man = new Person('zhangsan')

// ❌
man.#name
```

可以发现，会有报错信息，提示我们属性 `#name` 在类 `Person` 外部不可访问，另外，私有字段与常规属性（甚至使用 `private` 修饰符声明的属性）不同，私有字段需要约定以下几点规则

* 私有字段以 `#` 字符开头，有时候我们称其为「私有名称」
* 每个私有字段名称都唯一地限定于其包含的类
* 不能在私有字段上使用 `TypeScript` 可访问性修饰符（如 `public` 或 `private`）
* 私有字段不能在包含的类之外访问，甚至不能被检测到

在使用私有字段的过程当中，不得不让我们想起另外一个与其十分类似的东西，那就是 `private` 修饰符，那么使用 `#` 定义的私有字段与 `private` 修饰符定义字段有什么区别呢？先让我们来看一个 `private` 的示例

```ts
class Person {
  constructor(private name: string) { }
}

let person = new Person('zhangsan')

// ❌
console.log(person.name)
```

在上面代码中，我们创建了一个 `Person` 类，该类中使用 `private` 修饰符定义了一个私有属性 `name`，接着使用该类创建一个 `person` 对象，然后通过 `person.name` 来访问 `person` 对象的私有属性，这时 `TypeScript` 编译器会提示我们有以下异常

```ts
Property 'name' is private and only accessible within class 'Person'.(2341)
```

那如何解决这个异常呢？当然我们可以使用类型断言把 `person` 转为 `any` 类型

```ts
console.log((<any>person).name)

// or

console.log((person as any).name)
```

通过这种方式虽然解决了 `TypeScript` 编译器的异常提示，但是在运行时我们依然可以发现还是可以访问到 `Person` 类内部的私有属性，至于为什么会这样，我们来看一下编译生成的 `ES5` 代码就知道答案了

```ts
var Person = /** @class */ (function () {
  function Person(name) {
    this.name = name
  }
  return Person
}())

var person = new Person('zhangsan')

console.log(person.name)
```

下面我们再来看看在 `TypeScript 3.8` 以上版本通过 `#` 号定义的私有字段编译后会生成什么代码，这里还是以上面的代码为例

```ts
class Person {
  #name: string

  constructor(name: string) {
    this.#name = name
  }

  greet() {
    console.log(`${this.#name}`)
  }
}
```

我们将编译的目标设置为 `ES2015`，会编译生成以下代码

```ts
'use strict'
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet)
  || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError('attempted to set private field on non-instance')
    }
    privateMap.set(receiver, value)
    return value
  }

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet)
  || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError('attempted to get private field on non-instance')
    }
    return privateMap.get(receiver)
  }

var _name
class Person {
  constructor(name) {
    _name.set(this, void 0)
    __classPrivateFieldSet(this, _name, name)
  }
  greet() {
    console.log(`${__classPrivateFieldGet(this, _name)}`)
  }
}
_name = new WeakMap()
```

通过观察我们可以发现，在使用 `#` 号定义的私有字段当中，会通过 `WeakMap` 对象来存储，同时编译器会生成 `__classPrivateFieldSet` 和 `__classPrivateFieldGet` 这两个方法用于设置值和获取值，这样一来我们就无法在外部进行 `name` 属性的访问了













## 类与接口

实现（`implements`）是面向对象中的一个重要概念，一般来说一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（`interfaces`），用 `implements` 关键字来实现，这个特性大大提高了面向对象的灵活性

```ts
interface SayName {
  sayName(): void
}

class Animal { }

class Cat extends Animal implements SayName {
  sayName() {
    console.log(`cat`)
  }
}

class Dog extends Animal implements SayName {
  sayName() {
    console.log(`dog`)
  }
}
```

同样的，一个类可以实现多个接口

```ts
interface SayName {
  sayName(): void
}

interface SayAge {
  sayAge(): void
}

class Rabbit implements SayName, SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

但是需要注意一点，接口与接口之间也是可以是继承关系的

```ts
interface SayName {
  sayName(): void
}

interface SayAge extends SayName {
  sayAge(): void
}

class Rabbit implements SayAge {
  sayName() {
    console.log(`cat`)
  }
  sayAge() {
    console.log(`3`)
  }
}
```

最后我们再来看一种比较有趣的情况，但是也是平常使用较少的一种情况，那就是接口继承类，在常见的面向对象语言中，接口是不能继承类的，但是在 `TypeScript` 中却是可以的

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

但是为什么 `TypeScript` 会支持接口继承类呢？实际上当我们在声明 `class Point` 的时候，除了会创建一个名为 `Point` 的类之外，同时也创建了一个名为 `Point` 的类型（实例的类型）

所以我们既可以将 `Point` 当做一个类来用（使用 `new Point` 创建它的实例）

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

const p = new Point(1, 2)
```

也可以将 `Point` 当做一个类型来用

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

function printPoint(p: Point) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

上面这个例子实际上可以等价于

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

function printPoint(p: PointInstanceType) {
  console.log(p.x, p.y)
}

printPoint(new Point(1, 2))
```

在上面示例当中我们新声明了一个 `PointInstanceType` 的类型，其实本质上与声明 `class Point` 时创建的 `Point` 类型是等价的，所以在回过头来看我们之前的示例，就很容易的理解为什么 `TypeScript` 会支持接口继承类了

```ts
class Point {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}

interface PointInstanceType {
  x: number
  y: number
}

// 其实等价于 interface Point3d extends PointInstanceType
interface Point3d extends Point {
  z: number
}

let point3d: Point3d = { x: 1, y: 2, z: 3 }
```

当我们声明 `interface Point3d extends Point` 的时候，本质上 `Point3d` 继承的是类 `Point` 的实例的类型，我们可以理解为定义了一个接口 `Point3d` 继承另一个接口 `PointInstanceType`，所以「接口继承类」和「接口继承接口」没有什么本质的区别

但是需要注意的是，那就是 `PointInstanceType` 相比于 `Point` 缺少了 `constructor` 方法，这是因为声明 `Point` 类时创建的 `Point` 类型是不包含构造函数的，另外除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）

换句话说，声明 `Point` 类时创建的 `Point` 类型只包含其中的实例属性和实例方法

```ts
class Point {
  static origin = new Point(0, 0)       // 静态属性，坐标系原点
  static distanceToOrigin(p: Point) {   // 静态方法，计算与原点距离
    return Math.sqrt(p.x * p.x + p.y * p.y)
  }
  x: number       // 实例属性 x 轴的值
  y: number       // 实例属性 y 轴的值
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
  printPoint() {  // 实例方法
    console.log(this.x, this.y)
  }
}

interface PointInstanceType {
  x: number
  y: number
  printPoint(): void
}

let p1: Point
let p2: PointInstanceType
```

上例中最后的类型 `Point` 和类型 `PointInstanceType` 本质上是等价的，所以我们可以发现，在接口继承类的时候，只会继承它的实例属性和实例方法





## tsconfig.json

最后的最后，我们再来简单的了解一下 `tsconfig.json` 这个配置文件和它的一些比较重要的字段，我们先来看看 `tsconfig.json` 的作用，总的来说，`tsconfig.json` 的作用主要有以下几点

* 用于标识 `TypeScript` 项目的根路径
* 用于配置 `TypeScript` 编译器
* 用于指定编译的文件

而其中涉及到的字段较多，我们这里只是挑选几个比较重要的简单介绍一下，如下

* `files`，设置要编译的文件的名称
* `include`，设置需要进行编译的文件，支持路径模式匹配
* `exclude`，设置无需进行编译的文件，支持路径模式匹配
* `compilerOptions`，设置与编译流程相关的选项

这里我们重点关注一下 `compilerOptions` 这个字段，`compilerOptions` 支持很多选项，常见的有 `baseUrl`、`target`、`baseUrl`、`moduleResolution` 和 `lib` 等，每个选项的详细说明如下所示

```ts
{
  "compilerOptions": {

    /* 基本选项 */
    "target": "es5",                      // 指定 ECMAScript 目标版本，包括 ES3（默认）/ES5/ES6/ES2016/ES2017/ESNEXT
    "module": "commonjs",                 // 指定使用模块，包括 commonjs/amd/system/umd/es2015
    "lib": [],                            // 指定要包含在编译中的库文件
    "allowJs": true,                      // 允许编译 JavaScript 文件
    "checkJs": true,                      // 报告 JavaScript 文件中的错误
    "jsx": "preserve",                    // 指定 jsx 代码的生成，包括 preserve/react-native/react
    "declaration": true,                  // 生成相应的 .d.ts 文件
    "sourceMap": true,                    // 生成相应的 .map 文件
    "outFile": "./",                      // 将输出文件合并为一个文件
    "outDir": "./",                       // 指定输出目录
    "rootDir": "./",                      // 用来控制输出目录结构（--outDir）
    "removeComments": true,               // 删除编译后的所有的注释
    "noEmit": true,                       // 不生成输出文件
    "importHelpers": true,                // 从 tslib 导入辅助工具函数
    "isolatedModules": true,              // 将每个文件做为单独的模块（与 ts.transpileModule 类似）

    /* 严格的类型检查选项 */    
    "strict": true,                       // 启用所有严格类型检查选项
    "noImplicitAny": true,                // 在表达式和声明上有隐含的 any 类型时报错
    "strictNullChecks": true,             // 启用严格的 null 检查
    "noImplicitThis": true,               // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                 // 以严格模式检查每个模块，并在每个文件里加入 use strict

    /* 额外的检查 */  
    "noUnusedLocals": true,               // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,           // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,            // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,   // 报告 switch 语句的 fallthrough 错误（即不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",           // 选择模块解析策略，包括 node（Node.js） 和 classic（TypeScript pre-1.6）
    "baseUrl": "./",                      // 用于解析非相对模块名称的基目录
    "paths": {},                          // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                       // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                      // 包含类型声明的文件列表
    "types": [],                          // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入

    /* Source Map Options */
    "sourceRoot": "./",                   // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                      // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,              // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                // 将代码与 sourcemaps 生成到一个文件中，要求同时设置 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,       // 启用装饰器
    "emitDecoratorMetadata": true         // 为装饰器提供元数据的支持
    
  }
}
```

## 总结

我们在 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/) 一节当中梳理了一些 `TypeScript` 的基础内容，也算是回顾一下 `TypeScript` 的基本用法，而在本章当中则是简单的介绍了一些比较常用的姑且算是进阶的内容

但是 `TypeScript` 当中所涉及到的内容并不仅仅只有我们介绍到的这些，其它一些相关内容比如 [函数输入的类型推论](https://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-type) 或是 [多态](https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types) 等平常很少涉及到的内容，我们也就没有多做提及，不过以后如果在工作当中遇到相关内容的话会再来完善这两章的相关内容

更多相关内容可以参考 [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html) 来了解更多，中文版可见 [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)




## 参考

* [The unknown Type in TypeScript](https://mariusschulz.com/blog/the-unknown-type-in-typescript)
* [官方手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)
* [TypeScript 中文](https://www.tslang.cn/docs/handbook/basic-types.html)
* [TypeScript](https://www.typescriptlang.org)
* [一份不可多得的 TS 学习指南](https://juejin.cn/post/6872111128135073806)



