---
title: 深入 TypeScript 当中的泛型
date: 2021-01-01
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/58.webp
---

我们在之前的 [重温 TypeScript](https://heptaluan.github.io/2020/12/26/JavaScript/56/) 与 [深入 TypeScript](http://localhost:4000/2021/01/01/JavaScript/57/) 的章节当中介绍了一些 `TypeScript` 的基本使用方式和一些进阶内容，本来是打算将泛型相关内容一同整理到其中的，但是梳理下来发现泛型涉及到的内容还是比较多的，所以就另起篇幅来单独介绍介绍泛型的相关内容，主要参考的是 [Typescript Generics](https://medium.com/better-programming/typescript-generics-90be93d8c292) 这篇文章，在文章的基础之上有所调整，主要是方便自己理解，想要了解更为详细的内容可以参考原文

下面就让我们从头开始看起，其中主要包括以下相关内容

* 泛型是什么
* 泛型接口
* 泛型类
* 泛型约束
* 泛型参数默认类型
* 泛型条件类型
* 泛型工具类型
* 使用泛型创建对象

<!--more-->



## 泛型是什么

其实简单来说，设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是类的实例成员、类的方法、函数参数和函数返回值等

也就是说，泛型允许我们同一个函数接受不同类型参数，相比于使用 `any` 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型，下面我们来一步一步揭示泛型的作用，就从一个通用的 `identity` 函数开始看起，该函数接收一个参数并直接返回它

```ts
function identity(value) {
  return value
}

identity(1)
```

现在，我们将 `identity` 函数做适当的调整，以支持 `TypeScript` 的 `Number` 类型的参数

```ts
function identity(value: Number): Number {
  return value
}

identity(1)   // ✅

identity('1') // ❌
```

这里 `identity` 的问题是我们将 `Number` 类型分配给参数和返回类型，使该函数仅可用于该原始类型，此时如果我们传入一个字符串类型的参数，编辑器会提示我们有错误存在，也就是说该函数并不是可扩展或通用的，很明显这并不是我们所希望的

我们确实可以把 `Number` 换成联合类型又或是 `any`，但是我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用，我们的目标是让 `identity` 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下

```ts
function identity<T>(value: T): T {
  return value
}

identity<Number>(1)   // 1

identity<string>('1') // '1'
```

看上去是不是很轻松，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/57-01.png)

参考上面的图片可以发现，当我们调用 `identity<Number>(1)` 的时候，`Number` 类型就像参数 `1` 一样，它将在出现 `T` 的任何位置填充该类型，图中 `<T>` 内部的 `T` 被称为类型变量，它是我们希望传递给 `identity` 函数的类型占位符，同时它被分配给 `value` 参数用来代替它的类型（此时 `T` 充当的是类型，而不是特定的 `Number` 类型）

其中函数当中的 `T` 代表着 `Type`，在定义泛型时通常用作第一个类型变量名称，但实际上 `T` 可以用任何有效名称代替，除了 `T` 之外，以下是常见泛型变量代表的意思

* `K`（`Key`），表示对象中的键类型
* `V`（`Value`），表示对象中的值类型
* `E`（`Element`），表示元素类型

其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量，比如我们引入一个新的类型变量 `U`，用于扩展我们定义的 `identity` 函数

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}

identity<Number, string>(18, 'zhangsan')
```

这里我们在使用的时候明确的指定了 `T` 和 `U` 是 `Number` 和 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`，但是另外一种更为普遍的做法是使用「类型推论」，我们可以完全省略尖括号，也就是说让编译器来根据我们传入的参数自动地来确定 `T` 或者 `U` 的类型，从而使代码更简洁

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}

identity(18, 'zhangsan')
```

这一点我们可以也通过编辑器的代码提示功能来进行发现

```ts
// function identity<18, number>(value: 18, message: number): 18
identity(18, 18)

// function identity<'abc', number>(value: 'abc', message: number): 'abc'
identity('abc', 18)

// function identity<'abc', string>(value: 'abc', message: string): 'abc'
identity('abc', 'abc')
```

另外，我们还可以为泛型中的类型参数指定默认类型，因为当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用

```ts
function identity<T = string, U = number>(value: T, message: U): T {
  console.log(message)
  return value
}
```

以上过程，我们可以参考下面这张动图，来直观地感受一下类型传递的过程

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/57-02.gif)

如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件，现在我们再回过头来看一下我们的 `identity` 函数

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}
```

相比之前定义的 `identity` 函数，新的 `identity` 函数增加了一个类型变量 `U`，但是该函数的返回类型我们仍然使用 `T`，如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型

```ts
function identity<T, U>(value: T, message: U): [T, U] {
  return [value, message]
}
```

虽然使用元组可以解决上述的问题，但是有没有其它更好的解决方案呢？答案是有的，那就是我们可以使用「泛型接口」






## 泛型接口

为了解决上面提到的问题，首先让我们创建一个用于的 `identity` 函数通用 `Identities` 接口

```ts
interface Identities<V, M> {
  value: V,
  message: M
}
```

在上述的 `Identities` 接口中，我们引入了类型变量 `V` 和 `M`，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 `Identities` 接口作为 `identity` 函数的返回类型

```ts
function identity<T, U>(value: T, message: U): Identities<T, U> {
  let identities: Identities<T, U> = {
    value,
    message
  }
  return identities
}

identity(68, 'zhangsan')
```

运行后可以发现，是可以正常运行的，当然泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型




## 泛型类

在类中使用泛型也很简单，我们只需要在类名后面，使用 `<T, ...>` 的语法定义任意多个类型变量，具体示例如下

```ts
interface GenericInterface<U> {
  value: U
  getIdentity: () => U
}

class IdentityClass<T> implements GenericInterface<T> {
  value: T
  constructor(value: T) {
    this.value = value
  }
  getIdentity(): T {
    return this.value
  }

}

const myNumberClass = new IdentityClass<Number>(18)
myNumberClass.getIdentity() // 18

const myStringClass = new IdentityClass<string>('zhangsan')
myStringClass.getIdentity() // zhangsan
```

接下来我们以实例化 `myNumberClass` 为例，来分析一下其调用过程

* 在实例化 `IdentityClass` 对象时，我们传入 `Number` 类型和构造函数参数值 `18`，之后在 `IdentityClass` 类中，类型变量 `T` 的值变成 `Number` 类型
* `IdentityClass` 类实现了 `GenericInterface<T>`，而此时 `T` 表示 `Number` 类型，因此等价于该类实现了 `GenericInterface<Number>` 接口
* 而对于 `GenericInterface<U>` 接口来说，类型变量 `U` 也变成了 `Number`

所以说，使用泛型类可确保在整个类中一致地使用指定的数据类型，通常在决定是否使用泛型时，我们有以下两个参考标准

* 当函数、接口或类将处理多种数据类型时
* 当函数、接口或类在多个地方使用该数据类型时

通常而言，但是随着项目的发展，组件的功能通常会被扩展，这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下引入泛型将比复制组件来满足一系列数据类型更干净，下面我们再来看看 `Typescript` 泛型提供的一些其他功能


