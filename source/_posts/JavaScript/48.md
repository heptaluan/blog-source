---
title: ES6 中的 Symbol，Set 和 Map
date: 2019-11-07
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/48.jpg
---

在平常的开发当中，我们会经常用到 `ES6` 相关语法，大致总结一下，`ES6` 更新的内容可以分为以下几点

* 表达式：声明、解构赋值

* 内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、`Symbol`、`Set`、`Map`、`Proxy`、`Reflect`

* 语句与运算：`Class`、`Module`、`Iterator`

* 异步编程：`Promise`、`Generator`、`Async`

有一些是我们经常会遇到和用到的，比如 `let`，`const`，扩展运算，`promise` 等，之前也单独整理过一些，比如 [Class](https://heptaluan.github.io/2017/09/20/JavaScript/24/)，[Iterator，Generator](https://heptaluan.github.io/2019/07/13/JavaScript/56/) 和 [Reflect](https://heptaluan.github.io/2017/09/21/JavaScript/53/) 等

今天我们就来看看剩下的几个可能是平常用的不太多的 `Symbol`，`Set` 和 `Map`

主要参考的是阮一峰老师的 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/symbol)

<!--more-->



## Symbol

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 语言的第七种数据类型

比如如下代码，变量 `s` 就是一个独一无二的值，通过 `Symbol` 函数生成，使用 `typeof` 结果为 `'symbol'`

```js
const s = Symbol();

typeof s;  // 'symbol'
```

> 但是需要注意，`Symbol` 函数前不能使用 `new` 命令，否则会报错，这是因为生成的 `Symbol` 是一个原始类型的值，不是对象

下面我们就来看看 `Symbol` 具备哪些特性

#### instanceof 的结果为 false

```js
var s = Symbol('foo')

s instanceof Symbol  // false
```

#### 接受字符串作为参数

`Symbol` 函数可以接受一个字符串作为参数，表示对 `Symbol` 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分

比如如下示例，如果不加参数，它们在控制台的输出都是 `Symbol()`，不利于区分

```js
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // 'Symbol(foo)'
s2.toString() // 'Symbol(bar)'
```

#### 如果参数是一个对象，就会调用该对象的 toString() 方法，将其转为字符串

如果 `Symbol` 的参数是一个对象，就会调用该对象的 `toString()` 方法，将其转为字符串，然后才生成一个 `Symbol` 值

```js
const obj = {
  value: 'abc',
  toString() {
    return 'def';
  }
};

const sym = Symbol(obj);

sym // Symbol(def)
```

#### 相同参数的 Symbol 函数的返回值是不相等的

`Symbol` 函数的参数只是表示对当前 `Symbol` 值的描述，因此相同参数的 `Symbol` 函数的返回值是不相等的

```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2  // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2  // false
```

#### Symbol 值可以转为布尔值，但是不能转为数值，也不能与其他类型的值进行运算

另外需要注意的是，虽然 `Symbol` 值也可以转为布尔值，但是不能转为数值，并且不能与其他类型的值进行运算，会报错

```js
let sym = Symbol();

Boolean(sym)  // true
!sym          // false

Number(sym)   // TypeError
```






#### 作为属性名的 Symbol

由于每一个 `Symbol` 值都是不相等的，这意味着 `Symbol` 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性

```js
let s = Symbol();

// 第一种写法
let a = { };
a[s] = 'hello!';

// 第二种写法
let a = {
  [s]: 'hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, s, { value: 'hello!' });

// 以上写法都得到同样结果
a[s]  // 'hello!'

// 但是这里需要注意，不能使用点运算符
a.s   // undefined
```

还有一点需要注意，`Symbol` 值作为属性名时，该属性还是**公开属性，不是私有属性**




#### 属性名的遍历

`Symbol` 作为属性名，遍历对象的时候，该属性不会出现在 `for...in`、`for...of` 循环中，也不会被 `Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()` 返回

但是可以使用 `Object.getOwnPropertySymbols()` 方法来获取指定对象的所有 `Symbol` 属性名，该方法返回一个数组

```js
const obj = {};
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'hello';
obj[b] = 'world';

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols         // [Symbol(a), Symbol(b)]
```

另外也可以使用 `Reflect.ownKeys()` 方法来获取

```js
Reflect.ownKeys(obj)  // [Symbol(a), Symbol(b)]
```

所以可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法

```js
let size = Symbol('size');

class Collection {
  constructor() {
    this[size] = 0;
  }

  add(item) {
    this[this[size]] = item;
    this[size]++;
  }

  static sizeOf(instance) {
    return instance[size];
  }
}

let x = new Collection();
Collection.sizeOf(x)  // 0

x.add('foo');
Collection.sizeOf(x)  // 1

Object.keys(x)        // ['0']
Object.getOwnPropertyNames(x)    // ['0']
Object.getOwnPropertySymbols(x)  // [Symbol(size)]
```



#### Symbol.for() && Symbol.keyFor()

`Symbol.for()` 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 `Symbol` 值

如果有就返回这个 `Symbol` 值，否则就新建一个以该字符串为名称的 `Symbol` 值，**并将其注册到全局**

也就是说尽管是在函数内部运行的，但是生成的 `Symbol` 值是登记在全局环境的

```js
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

s1 === s2  // true
```

注意与 `Symbol('foo')` 区分开来，`Symbol('foo')` 每次调用都会返回不同的 `Symbol` 值

而 `Symbol.keyFor()` 则是用于返回已登记的 `Symbol` 类型值的 `key`，但是需要注意，只能返回 `Symbol.for()` 的 `key`

```js
let s1 = Symbol.for('foo');
Symbol.keyFor(s1)  // 'foo'

let s2 = Symbol('foo');
Symbol.keyFor(s2)  // undefined
```



## Set

`ES6` 提供了新的数据结构 `Set`，它类似于数组，但是成员的值都是唯一的，没有重复的值

在平常开发当中，使用较多的就是用来进行去重，如下数组去重

```js
[...new Set(array)]
```

也可以用于字符串去重

```js
[...new Set('ababbc')].join('')  // abc
```

但是除了去重之外，`Set` 还有许多其他的方法，因为 `Set` 本身是一个构造函数，可以用来生成 `Set` 数据结构

```js
const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

for (let i of s) {
  console.log(i);  // 2 3 5 4
}
```


#### Set 实例的属性和方法

我们先来看看 `Set` 当中的操作方法，主要有以下这些

* `add()` -- 添加值，返回实例

* `delete()` -- 删除值，返回布尔值

* `has()` -- 检查值，返回布尔值

* `clear()` -- 清除所有成员

```js
let s = new Set();

s.add(1).add(2).add(2);

s.size    // 2

s.has(1)  // true
s.has(2)  // true
s.has(3)  // false

s.delete(2);
s.has(2)  // false

s.clear()
s.size    // 0
```

除了操作方法之外，还有遍历方法

* `keys()` -- 返回以属性值为遍历器的对象

* `values()` -- 返回以属性值为遍历器的对象

* `entries()` -- 返回以属性值和属性值为遍历器的对象

* `forEach()` -- 使用回调函数遍历每个成员

`keys` 方法、`values` 方法、`entries` 方法返回的都是遍历器对象

由于 `Set` 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 `keys` 方法和 `values` 方法的行为完全一致

```js
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ['red', 'red']
// ['green', 'green']
// ['blue', 'blue']
```

`Set` 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 `values` 方法，所以可以省略 `values` 方法，直接用 `for...of` 循环遍历 `Set`

```js
let set = new Set(['red', 'green', 'blue']);

for (let x of set) {
  console.log(x);
}
// red
// green
// blue
```

`Set` 结构的实例与数组一样，也拥有 `forEach` 方法，用于对每个成员执行某种操作，**没有返回值**

```js
let set = new Set([1, 4, 9]);
set.forEach((v, k) => {
  console.log(k + ' : ' + v)
})

// 1 : 1
// 4 : 4
// 9 : 9
```

而且，数组的 `map` 和 `filter` 方法也可以间接用于 `Set`

```js
let set = new Set([1, 2, 3]);
new Set([...set].map(x => x * 2))            // Set {2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
new Set([...set].filter(x => (x % 2) == 0))  // Set {2, 4}
```

因此使用 `Set` 可以很容易地实现并集、交集和差集

```js
let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])

// 并集
let union = new Set([...a, ...b])                        // Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)))    // set {2, 3}

// 差集
let difference = new Set([...a].filter(x => !b.has(x)))  // Set {1}
```



## WeakSet

`WeakSet` 结构与 `Set` 类似，也是不重复的值的集合，但是 `WeakSet` 的成员**只能是对象，而不能是其他类型的值**

`WeakSet` 中的对象都是弱引用，即垃圾回收机制不考虑 `WeakSet` 对该对象的引用

也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 `WeakSet` 之中

并且 `WeakSet` 结构是**不可遍历**的

```js
const a = [[1, 2], [3, 4]]
const ws = new WeakSet(a)  // WeakSet {[1, 2], [3, 4]}

const b = [1, 2]
const ws = new WeakSet(b)  // Uncaught TypeError
```

`WeakSet` 结构有以下三个方法

* `add()` -- 添加值，返回实例

* `delete()` -- 删除值，返回布尔值

* `has()` -- 检查值，返回布尔值

```js
const ws = new WeakSet()
const obj = {}
const foo = {}

ws.add(window)
ws.add(obj)

ws.has(window)     // true
ws.has(foo)        // false

ws.delete(window)
ws.has(window)     // false
```

> `WeakSet` 的一个用处，是储存 `DOM` 节点，而不用担心这些节点从文档移除时，会引发内存泄漏




## Map

`Map` 数据结构类似于对象的数据结构，成员键可以是任何类型的值

也就是说，`Object` 结构提供了字符串与值的对应，而 `Map` 结构提供了值与值的对应，是一种更完善的 `hash` 结构实现

如果你需要键值对的数据结构，`Map` 比 `Object` 更合适

```js
const m = new Map();
const o = { p: 'hello world' };

m.set(o, 'test')
m.get(o)     // 'test'

m.has(o)     // true
m.delete(o)  // true
m.has(o)     // false
```

`Map` 也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组

```js
const map = new Map([
  ['name', 'zhangsan'],
  ['name', 'lisi'],
  ['age', '18']
]);

map.size          // 2
map.has('name')   // true
map.get('name')   // 'lisi'
map.has('age')    // true
map.get('age')    // '18'
```

可以发现，如果对同一个键多次赋值，后面的值将覆盖前面的值

有一个需要注意的地方，只有对同一个对象的引用，`Map` 结构才将其视为同一个键

```js
const m1 = new Map();

m1.set(['a'], 555);
m1.get(['a'])  // undefined


const m2 = new Map()
const a = {}

m2.set(a, 555)
m2.get(a)      // 555
```

`Map` 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键


#### 与其他数据结构的互相转换

关于 `Map` 数据结构的方法，和 `Set` 方法使用是类似的，这里就不详细展开了，我们来看看与其他数据结构的互相转换

* `Map` 转为数组

`Map` 转为数组最方便的方法，就是使用扩展运算符（`...`）

```js
const m = new Map()
  .set(true, 7)
  .set({foo: 3}, ['abc']);

[...m]  // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```


* 数组转为 `Map`

将数组传入 `Map` 构造函数，就可以转为 `Map`

```js
new Map([
  [true, 7],
  [{ foo: 3 }, ['abc']]
])
// Map {
//   true => 7,
//   Object { foo: 3 } => ['abc']
// }
```


* `Map` 转为对象

如果所有 `Map` 的键都是字符串，它可以无损地转为对象，如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名

```js
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k, v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const m = new Map()
  .set('yes', true)
  .set('no', false);

strMapToObj(m)  // { yes: true, no: false }
```


* 对象转为 `Map`

```js
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({ yes: true, no: false })  // Map {'yes' => true, 'no' => false}
```

* `Map` 转为 `JSON`

`Map` 转为 `JSON` 要区分两种情况，一种情况是 `Map` 的键名都是字符串，在这种情况下可以先将其转换为对象（使用之前的 `strMapToObj()` 方法），然后在转换为对象 `JSON`

```js
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)   // '{ "yes": true, "no": false }'
```

另一种情况是 `Map` 的键名有非字符串，这时可以选择转为数组 `JSON`，这时可以选择转为数组 `JSON`

```js
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']).set('yes', true)
mapToArrayJson(myMap)  // '[[true, 7], [{ "foo": 3 }, ["abc"]], ["yes", true]]'
```


* `JSON` 转为 `Map`

`JSON` 转为 `Map`，正常情况下，所有键名都是字符串，也是使用之前的 `objToStrMap()` 方法

```js
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}')  // Map {'yes' => true, 'no' => false}
```

但是有一种特殊情况，整个 `JSON` 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组

```js
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true, 7], [{"foo": 3}, ["abc"]]]')  // Map { true => 7, Object { foo: 3 } => ['abc'] }
```





## WeakMap

`WeakMap` 结构与 `Map` 结构类似，也是用于生成键值对的集合

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap()
const key = { foo: 1 }
wm1.set(key, 2)
wm1.get(key)  // 2

// WeakMap 也可以接受一个数组，作为构造函数的参数
const k1 = [1, 2, 3]
const k2 = [4, 5, 6]
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']])
wm2.get(k2)   // 'bar'
```

`WeakMap` 与 `Map` 的区别有两点

* `WeakMap` 只接受对象作为键名（`null` 除外），不接受其他类型的值作为键名

* `WeakMap` 的键名所指向的对象，不计入垃圾回收机制

同 `WeakSet` 一致，`WeakMap` 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内

`WeakMap` 与 `Map` 在 `API` 上的区别主要是两个

一是没有遍历操作（即没有 `keys()`、`values()` 和 `entries()` 方法），也没有 `size` 属性，因为没有办法列出所有键名

二是无法清空，即不支持 `clear()` 方法

因此，`WeakMap` 只有四个方法可用 `get()`、`set()`、`has()`、`delete()`

* `get()` -- 返回键值对

* `set()` -- 添加键值对，返回实例

* `delete()` -- 删除键值对，返回布尔值

* `has()` -- 检查键值对，返回布尔值

`WeakMap` 应用的典型场合就是 `DOM` 节点作为键名

```js
let myElement = document.getElementById('logo');
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, { timesClicked: 0 });

myElement.addEventListener('click', function () {
  let logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
}, false);
```

另一个用处是部署私有属性

```js
const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter < 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

const c = new Countdown(2, () => console.log('DONE'));

c.dec()
c.dec()  // DONE
```

`Countdown` 类的两个内部属性 `_counter` 和 `_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏



## 结论 && 区别

* `Set`、`Map`、`WeakSet`、`WeakMap`、都是一种集合的数据结构

* `Set` 和 `WeakSet` 是一种值-值的集合，且元素唯一不重复

* `Map` 和 `WeakMap` 是一种键-值对的集合，`Map` 的键可以是任意类型，`WeakMap` 的键只能是对象类型

* `Set` 添加值使用 `add()`，`Map` 添加值和返回键值对使用 `set()`/`get()`

* `Set` 和 `Map` 可遍历，`WeakSet` 和 `WeakMap` 不可遍历

* `WeakSet` 和 `WeakMap` 键名所指向的对象，不计入垃圾回收机制
