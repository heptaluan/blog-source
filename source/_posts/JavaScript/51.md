---
title: Object 上的原生 API
date: 2020-01-17
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/51.jpg
---

在平常开发过程当中，类似于 `Object.freeze()`，`Object.isFrozen()` 这样的方法一般都是涉及比较少的

而一些长的比较像的，比如 `setPrototypeOf()`，`isPrototypeOf()` 之类的又是傻傻分不清楚，更别说具体是做什么用的

所以今天就打算将其汇总一下，将 `Object` 上涉及到的平常可能会遇到的 `API` 整体的学习记录一下，免得下次再次遇到又是一头雾水

<!--more-->

其实简单来说，`Object` 上的原生 `API` 主要分为两部分，一部分是 `Object` 上面的方法，而另一部分则是 `Object.prototype` 上面的方法

下面我们就一个一个来看

## Object 上的方法

`Object` 上面涉及到的方法其实不算很多，见下表

|方法|描述|兼容性（非特别指出表示兼容性良好）|
|-|-|-|
| `Object.assign()` | 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，一般克隆场景使用较多，详细可见 [对象的浅拷贝](http://localhost:4000/2018/01/14/JavaScript/24/#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D) | `IE` 不支持，`Edge` 可用 |
| `Object.create()` | 创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__`，详细可见 [Object.create()](http://localhost:4000/2017/03/03/JavaScript/07/) | - |
| `Object.defineProperty()` | 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象，详细可见 [Object.defineProperty()](http://localhost:4000/2017/05/02/JavaScript/12/) | - |
| `Object.defineProperties()` | 这个同上面那个类似，但是可以同时定义和修改多个属性 | - |
| `Object.entries()` | 返回一个给定对象自身可枚举属性的键值对数组，详细可见 [Object.entries(obj)](http://localhost:4000/2019/06/28/JavaScript/35/#for%E2%80%A6of) | `IE` 不支持，`Edge` 可用 |
| `Object.fromEntries()` | 可以把把键值对列表转换为一个对象 | `IE`，`Edge` 均不支持 |
| `Object.getOwnPropertyDescriptor()` | 返回指定对象上一个自有属性对应的属性描述符（直接赋予的，不需要从原型链上进行查找的属性） | - |
| `Object.getOwnPropertyDescriptors()` | 获取一个对象的所有自身属性的描述符 | `IE` 不支持 |
| `Object.getPrototypeOf()` | 返回指定对象的原型（内部 `[[Prototype]]` 属性的值） | - |
| `Object.getOwnPropertyNames()` | 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组 | - |
| `Object.getOwnPropertySymbols()` | 返回一个给定对象自身的所有 Symbol 属性的数组 | `IE` 不支持 |
| `Object.is()` | 判断两个值是否是 [相同的值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)，注意与 `===` 区分 | `IE` 不支持 |
| `Object.keys()` | 返回一个由一个给定对象的自身可枚举属性组成的数组，详细可见 [Object.keys()](http://localhost:4000/2019/06/28/JavaScript/35/#Object-keys-obj) | - |
| `Object.isExtensible()` | 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性） | - |
| `Object.freeze()` | 冻结一个对象，一个被冻结的对象再也不能被修改 | - |
| `Object.isFrozen()` | 判断一个对象是否被冻结 | - |
| `Object.isSealed()` | 判断一个对象是否被密封 | - |
| `Object.preventExtensions()` | 让一个对象变的不可扩展，也就是永远不能再添加新的属性 | - |

大致浏览一遍可以发现，其有一些耳熟能详的我们在之前的章节当中已经介绍过了，后面也给出了链接，所以这里就不详细展开了

然后其他的一些，有一些相互之间都是关联的，或者说是类似的方法，在这里我们就统一进行介绍



## Object.defineProperty() 和 Object.defineProperties()

`Object.defineProperty()` 这个属性在之前我们已经介绍过了，该方法允许精确添加或修改对象的属性，比如 `enumerable`，`configurable` 和 `writable` 等

也可以用其来实现数据双向绑定，可谓是用处多多，不过我们今天主要来看这个跟它长的十分相像的 `Object.defineProperties()`

其实它俩是一个东西，不过当定义或修改对象的多个属性时，使用 `Object.defineProperty()` 就会比较麻烦了，在这种情况下我们可以考虑使用 `Object.defineProperties()`

```js
var man = {}

Object.defineProperties(man, {
  name: {
    value: 'zhangsan',
    writable: true
  },
  age: {
    value: 20,
    writable: true
  }
})

console.log(man.name)  // zhangsan
console.log(man.age)   // 20
```



## Object.entries() 和 Object.fromEntries()

`Object.entries()` 在迭代器相关章节曾经介绍过，它 **接收** 一个可以返回其可枚举属性的键值对的对象，**返回** 给定对象自身可枚举属性的键值对数组

`Object` 之所以不能被 `for...of` 遍历，主要是因为它没有部署 `Iterator` 接口

在这种情况下我们可以使用 `Object.entries()` 将其包裹一下，利用其返回的键值对数组再来进行遍历（会存在一定问题，以实际使用场景来决定是否这样使用）

看两个例子

```js
const obj = {
  100: 'a',
  2: 'b',
  7: 'c'
}

console.log(Object.entries(obj)) // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]
```

这里需要注意，上面例子的返回结果的排序是改变过的，至于为什么可以参考 [为什么 Object.keys 的返回值会自动排序](http://localhost:4000/2019/03/16/JavaScript/32/)

另外一个例子就是将 `Object` 转换为 `Map`

`new Map()` 函数接受一个可迭代的 `entries`，借助 `Object.entries` 方法可以很容易的将 `Object` 转换为 `Map`

```js
var obj = { foo: 'bar', baz: 42 }
console.log(new Map(Object.entries(obj)))  // Map(2) { 'foo' => 'bar', 'baz' => 42 }
```

下面我们再来看看 `Object.fromEntries()` 这个方法，其实简单来说，就是 `Object.entries` 的反转

> 但是需要注意的是，这个 `API` 现在的兼容性还不是很好，可以考虑使用 [polyfill](https://github.com/facebook/create-react-app/issues/6929)

该方法接收一个键值对的列表参数（可迭代对象，类似 `Array`，`Map` 或者其它实现了可迭代协议的对象）并返回一个由该迭代对象条目提供对应属性的新对象

生成的是一个具有两个元素的类数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值

来看几个例子，比如将 `Map` 转化为 `Object`

```js
const map = new Map([['foo', 'bar'], ['baz', 42]])
console.log(Object.fromEntries(map))  // { foo: 'bar', baz: 42 }
```

也可以将 `Array` 转化为 `Object`

```js
const arr = [['0', 'a'], ['1', 'b'], ['2', 'c']]
console.log(Object.fromEntries(arr))  // { 0: 'a', 1: 'b', 2: 'c' }
```




## Object.getOwnPropertyDescriptor() 和 Object.getOwnPropertyDescriptors()

这两个方法的作用也是一样的，都是返回指定对象 **自有属性** 对应的属性描述符，不过一个是返回指定的，一个是返回全部的

> 需要注意，这里指的是自有属性，意思是直接赋予该对象的属性，而不需要从原型链上进行查找的属性

两者的语法如下

```js
Object.getOwnPropertyDescriptor(obj, prop)

Object.getOwnPropertyDescriptors(obj)
```

下面我们通过一个例子来了解它们如何使用

```js
var obj = {}

Object.defineProperty(obj, 'age', {
  value: 20,
  writable: false,
  enumerable: false
})

Object.getOwnPropertyDescriptor(obj, 'age')

// {
//   configurable: false
//   enumerable: false
//   value: 20
//   writable: false
// }

Object.getOwnPropertyDescriptors(obj)

// age: {
//   configurable: false
//   enumerable: false
//   value: 20
//   writable: false
// }
```

关于 `Object.getOwnPropertyDescriptor(obj, prop)` 方法有一个需要注意的地方

* 在 `ES5` 中，如果该方法的第一个参数不是对象（而是原始类型），那么就会产生出现 `TypeError`

* 而在 `ES6` 中，第一个的参数不是对象的话就会被强制转换为对象

但是 `Object.getOwnPropertyDescriptors(obj)` 这个方法的作用不仅仅只是用于查看对象的属性描述符，比如还可以用来 **浅拷贝** 对象

```js
var obj = {
  a: 1,
  b: {
    name: 'zhangsan'
  }
}

var newObj = Object.create(
  Object.getPrototypeOf(obj), 
  Object.getOwnPropertyDescriptors(obj) 
)

console.log(newObj)  // { a: 1, b: { name: 'zhangsan' } }

newObj.a = 2
newObj.b.name = 'lisi'

console.log(obj)     // { a: 1, b: { name: 'lisi' } }
```

还可以用来创建子类，创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性，其实就是我们常说的继承，也就是原来经常使用的

```js
father.call(this)
child.prototype = new father()

// 但是推荐使用下面这种方式
child.prototype = Object.create(father.prototype)
child.prototype.constructor = child
```

但是现在我们可以通过 `Object.getOwnPropertyDescriptors()` 更为优雅的来实现

```js
function Foo() { }

Foo.prototype = {
  // 在这里定义方法和属性
}

function Bar() { }

Bar.prototype = Object.create(Foo.prototype, Object.getOwnPropertyDescriptors({
  // 在这里定义方法和属性
}))
```

在上面浅拷贝的例子当中涉及到一个方法 `Object.getPrototypeOf(obj)`，它的作用是返回指定对象的原型（内部 `[[Prototype]]` 属性的值）

```js
var reg = /^\s/
Object.getPrototypeOf(reg) === RegExp.prototype  // true

var obj = { }
Object.getPrototypeOf(obj) === Object.prototype  // true
```

但是这里特别需要注意了，**Object.getPrototypeOf(Object) 返回的并不是 Object.prototype**，我们来看下面这个特殊的例子

```js
Object.prototype === Function.prototype.__proto__ // true
Object.prototype === Function.prototype           // false

Object.getPrototypeOf(Object)    // ƒ () { [native code] }
Object.getPrototypeOf(Function)  // ƒ () { [native code] }

Object.getPrototypeOf(Object) === Function.prototype  // true
```

在 `JavaScript` 中的 `Object` 其实是构造函数，即是创建对象的包装器，所以我们一般用法是

```js
var obj = new Object()
```

而 `Object.getPrototypeOf(Object)` 的意思是把 `Object` 这一 **构造函数** 看作对象，返回的当然是函数对象的原型，也就是 `Function.prototype`，所以结果是 `true`

所以正确的方法应该是，Object.prototype 是 **构造出来的对象的原型**

```js
var obj = new Object()
Object.getPrototypeOf(obj) === Object.prototype  // true
Object.getPrototypeOf({})  === Object.prototype  // true
```

同样的，`Object.getPrototypeOf(obj)` 方法在 `ES5` 中的参数如果不是对象，也会出现 `TypeError`，而 `ES6` 中会被强制转换为对象