---
title: JavaScript 中的值和引用
date: 2017-02-22
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/06.jpg
---

`ECMAScirpt` 当中的变量有两种不同的数据类型，它们是「基本类型」和「引用类型」，引用就像一种特殊的指针，是来指向变量的指针（别名），如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此

<!--more-->

所以在 `JavaScript` 当中，我们可以简单的总结如下

* 没有指针，引用的工作机制也不尽相同，在 `JavaScript` 中变量不可能成为指向另一个变量的引用
* 引用指向的是值，如果一个值有多个引用，这些引用指向的都是同一个值，它们是没有引用关系
* 对值和引用的赋值和传递在语法上没有区别，完全根据值的类型来决定

先来看一个例子

```js
var a = 2
var b = a  // b 是 a 的值的一个副本

b++

a  // 2
b  // 3

// ==>

var c = [1, 2, 3]
var d = c

d.push(4)

c  // [1, 2, 3, 4]
d  // [1, 2, 3, 4]
```

上例中的 `2` 是一个标量基本类型值，所以变量 `a` 持有该值的一个副本，`b` 持有它的另一个复本，所以 `b` 更改时，`a` 的值保持不变，而 `c` 和 `d` 则分别指向同一个复合值 `[1, 2, 3]` 的两个不同引用，请注意，`c` 和 `d` 仅仅是指向值 `[1, 2, 3]`，并非持有，所以它们更改的是同一个值（比如调用 `push()` 方法），随后它们都指向了更改后的新值 `[1, 2, 3, 4]`

* 简单值（即标量基本类型值，`scalar primitive`），总是通过值复制的方式来赋值（传递），包括 `Number`，`Boolean`，`String`，`undefined`，`Null` 和 `ES6` 中的 `Symbol`
* 复合值（`compound value`），对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值（传递）

由上可知，由于引用指向的是值本身而非变量，所以一个引用无法更改另外一个引用的指向

```js
var a = [1, 2, 3]
var b = a

a  // [1, 2, 3]
b  // [1, 2, 3]

// ==>

b = [4, 5, 6]
a  // [1, 2, 3]
b  // [4, 5, 6]
```

从上面例子可以看出 `b = [4, 5, 6]` 并不影响 `a` 指向 `[1, 2, 3]`






## 引用类型值的传递

首先需要明确一点

> 其实严格来说，在 `JavaScript` 中没有「引用传递」，比较严谨的说法是，如果传递的参数是一个值，是按值传递，如果传递的是一个对象，则传递的是一个对象的引用
>
> `JavaScript` 不允许直接访问内存中的位置，不能直接操作对象的内存空间，实际上操作的是对象的引用，所以引用类型的值是按引用访问的
>
> 准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址

但是函数的参数就经常让人产生这样的疑惑，比如看下面这个例子

```js
function foo (x) {
  x.push(4)
  x  // [1, 2, 3, 4]

  // ==>

  x = [4, 5, 6]
  x.push(7)
  x  // [4, 5, 6, 7]
}

var a = [1, 2, 3]
foo(a)

a  // [1, 2, 3, 4]
```

我们向函数传递 `a` 的时候，实际是将引用 `a` 的一个复本赋值给 `x`，而 `a` 仍然指向 `[1, 2, 3]`，在函数中我们可以通过引用 `x` 来更改数组的值（如上，数组在 `push(4)` 后变为了 `[1, 2, 3, 4]`）

但 `x = [4, 5, 6]` 并不影响 `a` 的指向，所以 `a` 仍然指向 `[1, 2, 3, 4]`，我们不能通过引用 `x` 来更改引用 `a` 的指向，只能更改 `a` 和 `x` 共同指向的值，如果要将 `a` 的值变为 `[4, 5, 6, 7]`，那么就必须更改 `x` 指向的数组，而不是为 `x` 赋值一个新的数组

```js
function foo (x) {
  x.push(4)
  x  // [1, 2, 3, 4]

  // ==>

  x.length = 0
  x.push(4, 5, 6, 7)
  x  // [4, 5, 6, 7]
}

var a = [1, 2, 3]
foo(a)

a  // [4, 5, 6, 7]
```

这样一来，在不创建新数组，而只是更改了当前的数组的情况下，`a` 的指向就变成了 `[4, 5, 6, 7]`

> 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定

如果通过值复制的方式来传递复合值（数组），那么就需要为其创建一个复本，这样传递的就不再是原始值，比如

```js
// slice() 方法不传参数的情况会返回当前数组的一个浅副本（shallow copy）
foo(a.slice())
```

这样一来，由于传递给函数的是指向该副本的引用，所以 `foo()` 中的操作不会再影响 `a` 指向的数组（但是需要注意，这里仅仅只是浅复制，请酌情使用）


## 基本类型值的传递

相反，如果要将标量基本类型值传递到函数内并进行更改，这时候就需要将该值封装到一个复合值（对象，数组等）中，然后通过引用复制的方式传递

```js
function foo (wrap) {
  wrap.a = 22
}

var obj = {
  a: 2
}

foo(obj) 

obj.a  // 22
```

这里的 `obj` 是一个封装了标量基本类型值 `a` 的封装对象，`obj` 引用的一个复本作为参数 `wrap` 被传递到 `foo()` 中，这样我们就可以通过 `wrap` 来访问该对象并更改它的属性，函数执行结束后 `obj.a` 的值就变为了 `22`，与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值

```js
function foo (x) {
  x = x + 1
  x  // 3
}

var a = 2
var b = new Number(a)  // Objeact(a) 也是一样

foo(b)
b  // 2，而不是 3
```

这是因为标量基本类型的值是不可更改的（字符串和布尔也是如此），如果一个数字对象的标量基本类型值是 `2`，那么该值就不能更改，除非创建一个包含新值的数字对象，`x = x + 1` 中，`x` 中的标量基本类型值 `2` 从数字对象中拆封（提取）出来以后，`x` 就从引用变成了数字对象，它的值为 `2 + 1` 等于 `3`，然而函数外的 `b` 仍然指向原来那个值为 `2` 的数字对象

最后再来看两个小小的案例

```js
// 第一个
var o1 = new Object()
var o2 = o1

o2.name = 'a'
console.log(o1.name)  // a

// 第二个
function changeObjectProperty (o) {
  o.name = 'a'
  o = new Object()
  o.name = 'b'
  console.log(o.name)
}

var o = new Object()

changeObjectProperty(o)
console.log(o.name) 
```

第一个就不用多说了，看了上面的内容以后应该会很清晰的得出 `o1.name` 也是为 `a` 的（引用的同一个地址），至于第二个，如果传递的是 `o` 的引用，那么结果应该是 `'b'`，但实际结果却仍是 `'a'`，因为在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存  

> 内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境
>
> 每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能

如何引用一个对象，但是不改变原有对象的值（解决方法就是在一个函数中去引用），所以

* 对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值
* 对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象

