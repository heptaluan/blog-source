---
title: 在列表中插入 3 个，30 个，300 个 li，并绑定事件
date: 2018-06-11
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/38.webp
---

今天在网上看到的一道面试题，感觉可以从中引申出不少问题，所以在此特意记录一下

<!--more-->


## 动态插入 3 个 li，并且绑定事件

题目如标题一样，第一感觉，我们可以直接使用循环创建三个 `li` 元素，并且绑定事件之后插入到 `body` 当中

```js
for (var i = 0; i < 3; i++) {
  var item = document.createElement('li')
  item.innerText = i + 1
  item.addEventListener('click', function () {
    alert(this.innerText)
  }, false)
  document.body.appendChild(item)
}
```

## 动态插入 30 个 li，并且绑定事件

现在变成了插入 `30` 个 `li`，数据量不算太大，用 `for` 循环直接生成勉强也可以完成任务，这个时候我们可以针对绑定事件的方式稍微优化一下，即将绑定方式换成使用事件委托的方式，而不是在绑定到 `li` 之上

```js
const el = document.body

for (var i = 0; i < 30; i++) {
  var item = document.createElement('li')
  item.innerText = i + 1
  el.appendChild(item)
}

el.addEventListener('click', function (e) {
  if (e.target.tagName === 'LI') {
    alert(e.target.innerHTML)
  }
}, false)
```

## 动态插入 300 个 li，并且绑定事件

当数据量变的很大的时候，如果依然使用 `for` 循环一次性生成的话，可能会引起性能上面的问题，这个时候就可以采用 `documentFragment + requestAnimationFrame` 的方式来分批次插入数据，主要目的是减少 `DOM` 操作次数、缩短循环时间，每次插入的时机是在页面重新渲染之前

```js
// 获取容器元素
const el = document.body

// 生成总数
const total = 300

// 每次插入多少
const listSize = 4

// 分多少次插入
const listCount = total / listSize

// 已经完成的批次
let listDone = 0

function appendItems() {
  let fragment = document.createDocumentFragment()

  for (let i = 0; i < listSize; i++) {
    const item = document.createElement('li')
    item.innerText = (listSize * listDone + i) + 1
    fragment.appendChild(item)
  }

  // 每批次只修改一次 DOM
  el.appendChild(fragment)

  listDone += 1
  listAppend()
}

function listAppend() {
  if (listDone < listCount) {
    // 这个的作用可以见文章下方
    window.requestAnimationFrame(appendItems)
  }
}

// 初始化
listAppend()

// 事件绑定
el.addEventListener('click', function (e) {
  if (e.target.tagName.toUpperCase() === 'LI') {
    alert(e.target.innerHTML)
  }
}, false)
```

## window.requestAnimationFrame()

`requestAnimationFrame` 是浏览器用于定时循环操作的一个接口，类似于 `setTimeout`，主要用途是按帧对网页进行重绘，设置这个 `API` 的目的是为了让各种网页动画效果（`DOM` 动画、`Canvas` 动画、`SVG` 动画、`WebGL` 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果，代码中使用这个 `API`，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘，它主要有两个特点

1. 按帧对网页进行重绘，该方法告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画
2. 由系统来决定回调函数的执行时机，在运行时浏览器会自动优化方法的调用

关于第二点，显示器有固定的刷新频率（`60Hz` 或 `75Hz`），也就是说每秒最多只能重绘 `60` 次或 `75` 次，`requestAnimationFrame` 的基本思想让页面重绘的频率与这个刷新频率保持同步，比如显示器屏幕刷新率为 `60Hz`，使用 `requestAnimationFrame API`，那么回调函数就每 `1000ms / 60 ≈ 16.7ms` 执行一次，如果显示器屏幕的刷新率为 `75Hz`，那么回调函数就每 `1000ms / 75 ≈ 13.3ms` 执行一次

另外，一旦页面不处于浏览器的当前标签，就会自动停止刷新

* 当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 `visibilitychange` 事件，并设置 `document.hidden` 属性为 `true`
* 当页面切换到显示状态，页面变为可见，同时触发一个 `visibilitychange` 事件，设置 `document.hidden` 属性为 `false`

不过有一点需要注意是 `requestAnimationFrame` 是在主线程上完成，这意味着如果主线程非常繁忙，`requestAnimationFrame` 的动画效果会大打折扣，`requestAnimationFrame` 使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用

```js
id = window.requestAnimationFrame(callback)
```

它会返回一个 `id` 结果，主要是用于传递给 `window.cancelAnimationFrame(id)` 来取消重绘，在浏览器当中的执行过程大致如下

* 首先判断 `document.hidden` 属性是否为 `true`（页面是否可见），页面处于可见状态才会执行后面步骤
* 浏览器清空上一轮的动画函数
* `requestAnimationFrame` 将回调函数追加到动画帧请求回调函数列表的末尾，当执行 `requestAnimationFrame(callback)` 的时候，不会立即调用 `callback` 函数，只是将其放入队列，每个回调函数都有一个布尔标识 `cancelled`，该标识初始值为 `false`，并且对外不可见
* 当浏览器再执行列表中的回调函数的时候，判断每个元组的 `callback` 的 `cancelled`，如果为 `false` 则执行 `callback`，当页面可见并且动画帧请求回调函数列表不为空，浏览器会定期将这些回调函数加入到浏览器 `UI` 线程的队列中
* 当调用 `cancelAnimationFrame(handle)` 时，浏览器会设置该 `handle` 指向的回调函数的 `cancelled` 为 `true`（无论该回调函数是否在动画帧请求回调函数列表中），如果该 `handle` 没有指向任何回调函数，则什么也不会发生

更为底层的原理可以参考 [深入理解 requestAnimationFrame](https://www.cnblogs.com/chaogex/p/3960175.html)，这里就不详细展开了，但是在这里我们多提及两点，第一个就是递归调用，要想实现一个完整的动画，应该在回调函数中递归调用回调函数

```js
let count = 0
let rafId = null
function requestAnimation(time) {                     // requestAnimationFrame 调用该函数时，自动传入的一个时间
  console.log(time)
  if (count < 50) {                                   // 动画没有执行完，则递归渲染
    count++
    rafId = requestAnimationFrame(requestAnimation)   // 渲染下一帧
  }
}
requestAnimationFrame(requestAnimation)               // 渲染第一帧
```

另外如果如果在执行回调函数或者 `Document` 的动画帧请求回调函数列表被清空之前多次调用 `requestAnimationFrame` 调用同一个回调函数，那么列表中会有多个元组指向该回调函数（它们的 `handle` 不同，但 `callback` 都为该回调函数），采集所有动画任务操作会执行多次该回调函数（类比定时器 `setTimeout`）

```js
function counter() {
  let count = 0
  function animate(time) {
    if (count < 50) {
      count++
      console.log(count)
      requestAnimationFrame(animate)
    }
  }
  requestAnimationFrame(animate)
}
btn.addEventListener('click', counter, false)
```

例如上面这个示例，多次点击按钮，会发现打印出来多个序列数值


## 参考

* [window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)
* [深入理解 requestAnimationFrame](https://www.cnblogs.com/chaogex/p/3960175.html)

