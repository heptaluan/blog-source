---
title: JavaScript 并发模型
date: 2018-08-12
categories: JavaScript
tags: JavaScript
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/30.jpg
---

> 最后更新于 `2020-02-01`

`JavaScript` 的一大特点就是单线程，这意味着在任何时候只能有一段代码执行，`JavaScript` 主线程在运行时，会建立一个执行同步代码的栈和执行异步代码的队列，在深入展开之前，我们先来了解一些前置知识，包括单线程执行机制和 `JavaScript` 中堆和栈的相关概念（堆和栈的相关概念可以参考 [体系结构与操作系统](https://heptaluan.github.io/2020/01/01/Essay/06/) 当中的相关章节）

<!--more-->


## 单线程执行机制

`JavaScript` 属于单线程，程序按顺序执行，本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是「事件驱动的、异步的、多线程的」

浏览器内部有一个事件轮询（`Event Loop`），是一个大的内部消息循环，会轮询大的消息队列并执行，也就是 `JavaScript` 要处理的事件队列，是浏览器维护的，浏览器至少有四个线程（不同浏览器会有差异）

* `JavaScript` 引擎线程
* 界面渲染线程
* 浏览器事件触发线程
* `HTTP` 请求线程

而在 `JavaScript` 当中我们一般比较熟悉的的异步操作有 `setTimeout` 和 `Ajax`，来看看它们之间的区别

* `setTimeout`，`JavaScript` 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 `JavaScript` 引擎执行，都是在浏览器空闲了才会执行
* `Ajax`，是真正的异步，在调用 `Ajax` 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 `JavaScript` 引擎执行




## 阻塞

浏览器虽然是多线程，但是由于 `JavaScript` 具有阻塞特性（比如 `alert()`），无论外链还是内嵌脚本，在浏览器执行解释 `JavaScript` 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 `JavaScript` 下载并执行完毕，这样一来 `JavaScript` 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验，所以避免此类情况的话可以采用下面一些方式

* 将 `<script>` 内嵌和外链，在可以的情况下放在 `<body>` 底部（对于 `CSS`，浏览器是并行下载的）
* 在页面 `onload` 后再加载 `JavaScript`
* 可以使用 `html5` 的  `<script>` 标签的 `defer` 属性，在页面加载完成后下载
* 使用动态创建 `<script>` 标签的方式，在页面加载完成后添加进去（`createElement`）

简单来说就是一句话，先让页面渲染完，再加载 `JavaScript`





## JavaScript 中的栈和堆

首先要先说一下耳熟能详的「堆栈」，要区分数据结构和内存中各自「堆栈」的含义，数据结构中的堆和栈是两种不同的数据项按序排列的数据结构，但是在这里我们主要介绍的是内存中的堆区与栈区

#### 内存中的堆区与栈区

在 `C` 语言中，各个区别如下

* 栈区是分配局部变量的空间
* 堆区是地址向上增长的用于分配我们申请的内存空间
* 另外还有静态区是分配静态变量、全局变量空间的
* 只读区是分配常量和程序代码空间的

一个简单的例子

```c
int a = 0;                  // 全局初始化区
char *p1;                   // 全局未初始化区

main() {
  int b;                    // 栈
  char s[] = "abc";         // 栈
  char *p2;                 // 栈
  char *p3 = "123";         // 在常量区，p3 在栈上
  static int c =0，         // 全局（静态）初始化区
  p1 = (char *)malloc(10);  // 堆
  p2 = (char *)malloc(20);  // 堆
}
```

而 `JavaScript` 是高级语言，底层依靠 `C/C++` 来编译实现，其变量划分为基本数据类型和引用数据类型

* 基本数据类型包括 `Undefined`，`Null`，`Boolean`，`Number`，`BigInt`，`String`，`Symbol`，这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较
* 引用类型包括 `Object`，`Array`，`Function`，`Error`，`Date`，这些类型大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的（和 `C` 语言的指针类似）

对于引用类型的变量，栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存在栈内存中，但是内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中，这样一来，当查询引用类型的变量的时候，就会先从栈中读取堆内存地址，然后在根据地址取出对应的值，显而易见的是，`JavaScript` 中所有引用类型创建实例的时候，都是显式或者隐式的 `new` 出对应类型的实例，实际上就是对应 `C` 语言的 `malloc()` 分配内存函数


#### 栈和队列的区别

* 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的
* 队列先进先出，栈先进后出

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除，有一个比较好的记忆方式

* 队列相当我们去银行柜台排队，大家依次鱼贯而行，先进去排队的最先出来
* 栈比较像我们在家中洗碗，最后洗好的碗叠在最上面的，而下次拿的时候是最先拿到最后叠上去的碗


#### 栈和堆的区别

* 栈区（`stack`），由编译器自动分配释放，存放函数的参数值，局部变量的值等
* 堆区（`heap`），一般由程序员分配释放，若程序员不释放，程序结束时可能由 `OS` 回收
* 堆（数据结构），堆可以被看成是一棵树，如堆排序
* 栈（数据结构），一种先进后出的数据结构

在了解完相关前置知识之后，下面我们就正式来看看 `JavaScript` 当中的并发模型


## 并发模型

`JavaScript` 当中的并发模型可以参考下面这个理论模型

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/13.png)

`JavaScript` 执行引擎的主线程运行的时候，产生堆（`heap`）和栈（`stack`），程序中代码依次进入栈中等待执行，若执行时遇到异步方法，该异步方法会被添加到用于回调的队列（`queue`）中，即 `JavaScript` 执行引擎的主线程拥有一个执行栈（或者堆）和一个任务队列

* 栈（`stack`），函数调用会形成了一个堆栈帧
* 堆（`heap`），对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域
* 队列（`queue`），一个 `JavaScript` 运行时包含了一个待处理的消息队列
  * 每一个消息都与一个函数相关联
  * 当栈为空时，则从队列中取出一个消息进行处理
  * 这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）
  * 当栈再次为空的时候，也就意味着该消息处理结束


## Event Loop

![](https://gitee.com/heptaluan/backups/raw/master/cdn/js/14.png)

关于上图当中的内容，这里我们主要看两个点，即 `queue` 和 `callback`

* 关于 `queue` 值得注意的是，除了 `IO` 设备的事件（比如 `load`）会被添加到 `queue` 中，用户操作产生的事件（比如 `click`，`touchmove`）同样也会被添加到 `queue` 中，队列中的这些事件会在主线程的执行栈被清空时被依次读取（队列先进先出，即先被压入队列中的事件会被先执行）
* 关于 `callback` 则是被主线程挂起来的代码，等主线程执行队列中的事件时，事件对应的 `callback` 代码就会被执行

针对上面的并发模型和 `JavaScript` 的同步异步运行机制，我们可以看到整个流程大致是这样的

1. 所有同步任务都在主线程上执行，形成一个执行栈（并发模型的 `stack`）
2. 主线程之外，还存在一个任务队列（并发模型的 `queue`），只要异步任务有了运行结果，就在任务队列中放置一个事件
3. 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件和那些对应的异步任务，于是等待结束状态，进入执行栈开始执行
4. 主线程不断重复上面的第三步

因为主线程从任务队列中读取事件的过程是循环不断的，因此这种运行机制又称为 `Event Loop`（事件循环），简单总结就是，主线程运行的时候，产生堆（`heap`）和栈（`stack`），栈中的代码调用各种外部 `API`，它们在任务队列中加入各种事件（`click`，`load`，`done`），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些事件所对应的回调函数

下面我们就简单的结合规范，来看一下官方当中针对 `Event Loop` 是如何进行介绍的


## 任务队列

我们在之前提到过，事件循环是通过 [任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#task-queues) 的机制来进行协调的，在一个 `Event Loop` 中可以有一个或者多个任务队列（`task queue`），一个任务队列便是一系列有序任务（`task`）的集合，每个任务都有一个任务源（`task source`），源自同一个任务源的 `task` 必须放到同一个任务队列，从不同源来的则被添加到不同队列

在事件循环中，每进行一次循环操作称为 `tick`，每一次 `tick` 的 [任务处理模型](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops-processing-model) 是比较复杂的，但关键步骤如下

* 在此次 `tick` 中选择最先进入队列的任务（`oldest task`），如果有则执行（一次）
* 检查是否存在 `Microtasks`，如果存在则不停地执行，直至清空 `Microtasks Queue`
* 更新 `render`
* 主线程重复执行上述步骤

我们仔细查阅规范可知，异步任务可分为 `task` 和 `Microtask` 两类，不同的 `API` 注册的异步任务会依次进入自身对应的队列中，然后等待 `Event Loop` 将它们依次压入执行栈中执行（也就是如上面章节中的图片所示那样）

> 在网上比较常见的说法是分为是分为 `Macrotask`（`宏任务`） 和 `Microtask`（`微任务`） 两个概念，但规范中并没有提到 `Macrotask`，因而一个比较合理的解释是 `task` 即为其它文章中的 `Macrotask`，另外在 `ES2015` 规范中将 `Microtask` 又称为 `Job`

但是在这里我们为了统一，干脆就称为 `Macrotask`（`宏任务`） 和 `Microtask`（`微任务`），知道它们各自具体代表的是什么即可，下面我们来看看它们两者之间的区别

* `Macrotask`（`宏任务`） 主要包含 `setTimeout`、`setInterval`、`I/O`、`UI` 交互事件、`postMessage`、`MessageChannel`、`setImmediate`（`Node.js`）
* `Microtask`（`微任务`） 主要包含 `Promise.then`、`MutaionObserver`、`process.nextTick`（`Node.js`）、`Object.observe`（已废弃）

这里有几个需要注意的地方

* 在有些地方会列出来 `UI Rendering`，说这个也是宏任务，可是在 [规范文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) 当中可以发现这很显然是和微任务平行的一个操作步骤
* 在 `Node.js` 中，会优先清空 `next tick queue`，即通过 `process.nextTick` 注册的函数，再清空 `other queue`，常见的如 `Promise`，此外，`timers`（`setTimeout/setInterval`） 会优先于 `setImmediate` 执行，因为前者在 `timer` 阶段执行，后者在 `check` 阶段执行（下面我们会进行介绍）
* 还有一个比较特殊的 `requestAnimationFrame`，有的将其归纳到宏任务当中，但是这里是存在一定争议的，关于这个我们会在后面来详细进行介绍



## 执行顺序

我们下面就通过几个例子来深入的理解一下，先来看一个 `setTimeout()` 相关示例，如下

```js
console.log(1)

setTimeout(function () {
  console.log(2)
}, 5000)

console.log(3)
```

这里需要注意的是，定时器只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数，我们结合之前提到过的 `Event Loop` 来看看单线程的 `JavaScript` 执行引擎是如何来执行该方法的

1. `JavaScript` 执行引擎主线程运行，产生 `heap` 和 `stack`
2. 从上往下执行同步代码，`console.log(1)` 被压入执行栈，因为 `console.log()` 方法是 `webkit` 内核支持的普通方法而非 `WebAPIs` 的方法，因此立即出栈被引擎执行，输出 `1`
3. `JavaScript` 执行引擎继续往下，遇到 `setTimeout()` 异步方法（如上图，`setTimeout()` 属于 `WebAPIs`），将 `setTimeout(callback, 5000)` 添加到执行栈
4. 因为 `setTimeout()` 属于 `WebAPIs` 中的方法，`JavaScript` 执行引擎在将 `setTimeout()` 出栈执行时，注册 `setTimeout()` 延时方法交由浏览器内核其他模块（以 `webkit` 为例，是 `webcore` 模块）处理
5. 继续运行 `setTimeout()` 下面的 `console.log(3)` 代码，原理同步骤 `2`
6. 当延时方法到达触发条件，即到达设置的延时时间时（`5` 秒后），该延时方法就会被添加至任务队列里，这一过程由浏览器内核其他模块处理，与执行引擎主线程独立
7. `JavaScript` 执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行
8. 将队列的第一个回调函数重新压入执行栈，执行回调函数中的代码 `console.log(2)`，原理同步骤 `2`，回调函数的代码执行完毕，清空执行栈
9. `JavaScript` 执行引擎继续轮循队列，直到队列为空
10. 执行完毕

看完了 `setTimeout()`，下面再来看一个 `Promise` 的示例

```js
new Promise(resolve => {
  resolve(1)
  Promise.resolve().then(() => {
    // t2
    console.log(2)
  })
  console.log(4)
}).then(t => {
  // t1
  console.log(t)
})
console.log(3)
```

同样的，我们也简单的梳理一下这段代码的流程

1. 程序运行，首先遇到 `Promise` 实例，构造函数首先执行，所以首先输出了 `4`，此时 `Microtask` 的任务有 `t2` 和 `t1`
1. 代码继续运行，输出 `3`，至此，第一个宏任务执行完成，
1. 执行所有的微任务，先后取出 `t2` 和 `t1`，分别输出 `2` 和 `1`
1. 代码执行完毕

所以综上所述，最后的输出结果是 `4321`，但是这里可能会有一些疑惑，那就是为什么 `t2` 会先执行呢？我们根据 [Promises/A+](https://www.ituring.com.cn/article/66566) 规范可知

> 实践中要确保 `onFulfilled` 和 `onRejected` 方法异步执行，且应该在 `then` 方法被调用的那一轮事件循环之后的新执行栈中执行

所以我们可以推断出，`Promise.resolve` 方法允许调用时不带参数，直接返回一个 `resolved` 状态的 `Promise` 对象，也就是立即 `resolved` 的 `Promise` 对象，是在本轮事件循环（`Event Loop`）的结束时，而不是在下一轮事件循环的开始时（详细可以参考 [Promise-resolve](https://es6.ruanyifeng.com/#docs/promise#Promise-resolve)），所以 `t2` 比 `t1` 会先进入 `Microtask` 的 `Promise` 队列

最后，我们再来看一个综合两者的示例，如下

```js
console.log('script start')

setTimeout(function () {
  console.log('timeout1')
}, 10)

new Promise(resolve => {
  console.log('promise1')
  resolve()
  setTimeout(() => console.log('timeout2'), 10)
}).then(function () {
  console.log('then1')
})

console.log('script end')
```

1. 首先，事件循环从宏任务（`Macrotask`）队列开始，当遇到任务源（`task source`）时，则会先分发任务到对应的任务队列中去，然后遇到了 `console` 语句，直接输出 `script start`，输出之后，任务继续往下执行，遇到 `setTimeout`，其作为一个宏任务源，则会先将其任务分发到对应的队列中
2. 任务继续往下执行，遇到 `Promise` 实例，`Promise` 构造函数中的第一个参数，是在 `new` 的时候执行，构造函数执行时，里面的参数进入执行栈执行，而后续的 `.then` 则会被分发到 `Microtask` 的 `Promise` 队列中去，所以会先输出 `promise1`，然后执行 `resolve`，将 `then1` 分配到对应队列
3. 构造函数继续往下执行，又碰到 `setTimeout`，然后将对应的任务分配到对应队列
4. 任务继续往下执行，最后只有一句输出，所以输出 `script end`，至此，全局任务就执行完毕了

根据上述，每次执行完一个宏任务之后，会去检查是否存在 `Microtasks`，如果有，则执行 `Microtasks` 直至清空 `Microtask Queue`，因而在任务执行完毕之后，开始查找清空微任务队列，此时，微任务中只有 `Promise` 队列中的一个任务 `then1`，因此直接执行就行了，执行结果输出 `then1`，当所有的 `microtast` 执行完毕之后，表示第一轮的循环就结束了

5. 这个时候就得开始第二轮的循环，第二轮循环仍然从宏任务 `Macrotask` 开始，此时有两个宏任务 `timeout1` 和 `timeout2`，取出 `timeout1` 执行，输出 `timeout1`，此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环
6. 第三轮循环依旧从宏任务队列开始，此时宏任务中只有一个 `timeout2`，取出直接输出即可

这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了，那么例子的输出结果就显而易见

```js
script start
promise1
script end
then1
timeout1
timeout2
```



## 关于 requestAnimationFrame

先说结论，`requestAnimationFrame` 其实不属于 `task`，它只是浏览器渲染过程的一步，和 `task/microtask` 的执行是分离的，至于为什么会这样，我们则需要深入的去了解一下 `requestAnimationFrame` 这个接口，详细可以参考 [requestAnimationFrame 知多少](https://www.cnblogs.com/onepixel/p/7078617.html) 和 [When will requestAnimationFrame be executed](https://stackoverflow.com/questions/43050448/when-will-requestanimationframe-be-executed)，我们在这里只简单的总结一下

* `setTimeout` 的执行时间并不是确定的，在 `JavaScript` 中，`setTimeout` 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 `setTimeout` 的实际执行时机一般要比其设定的时间晚一些
* 与 `setTimeout` 相比，`requestAnimationFrame` 最大的优势是「由系统来决定回调函数的执行时机」，系统每次绘制之前会主动调用 `requestAnimationFrame` 中的回调函数，如果系统绘制率是 `60Hz`，那么回调函数就每 `16.7ms` 被执行一次，如果绘制频率是 `75Hz`，那么这个间隔时间就变成了 `1000 / 75 = 13.3ms`，换句话说就是 `requestAnimationFrame` 的执行步伐跟着系统的绘制频率走，它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题

至于具体是什么样的流程，我们可以参考规范当中的 [事件循环处理模型](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)，简化后的流程是下面这样

* 执行最早的（宏）任务
* 微任务
* 如果这是渲染的好时机
  * 准备工作
  * 运行 `requestAnimationFrame` 回调
  * 渲染

但是这里也会存在一个问题，就是如果你在不同的浏览器上进行测试，结果可能会有所不同，但是现在 `Chrome/Firefox/iOS Safari/Legacy Edge` 等都在向着规范靠拢，所以我们还是以规范为准吧




## Node.js 中的表现

`Node.js` 也是单线程，但是在处理 `Event Loop` 上与浏览器稍微有些不同，就单从 `API` 层面上来理解，`Node.js` 新增了两个方法可以用来使用，微任务的 `process.nextTick` 以及宏任务的 `setImmediate`

> `Node.js` 的运行机制也是基于事件轮询（`Event Loop`）的，详细见 [Node.js 中的事件轮询机制](https://heptaluan.github.io/2019/07/05/Node/04/)

#### setImmediate 与 setTimeout 的区别

在官方文档中的定义，`setImmediate` 为一次 `Event Loop` 执行完毕后调用，`setTimeout` 则是通过计算一个延迟时间后进行执行，但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发

因为如果主进程中先注册了两个任务，然后执行的代码耗时超过设定的期限，而这时定时器已经处于可执行回调的状态了，所以会先执行定时器，而执行完定时器以后才是结束了一次 `Event Loop`，这时才会执行 `setImmediate`

```js
setTimeout(_ => console.log('setTimeout'))
setImmediate(_ => console.log('setImmediate'))
```

比如上面的代码，可以试验一下，执行多次的话会得到不同的结果，但是如果后续添加一些代码以后，就可以保证 `setTimeout` 一定会在 `setImmediate` 之前触发了

```js
setTimeout(_ => console.log('setTimeout'))
setImmediate(_ => console.log('setImmediate'))

let countdown = 1e9

// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout 已经可以执行回调了
// 所以会先执行 setTimeout 然后再结束这一轮循环，也就是说开始执行 setImmediate 
while (countdown--) { } 
```

如果在另一个宏任务中，必然是 `setImmediate` 先执行

```js
// 如果使用一个设置了延迟的 setTimeout 也可以实现相同的效果
require('fs').readFile(__dirname, _ => {
  setTimeout(_ => console.log('timeout'))
  setImmediate(_ => console.log('immediate'))
})
```

#### process.nextTick

就像上边说的，这个可以认为是一个类似于 `Promise` 和 `MutationObserver` 的微任务实现，在代码执行的过程中可以随时插入 `nextTick`，并且会保证在下一个宏任务开始之前所执行，在使用方面的一个最常见的例子就是一些事件绑定类的操作

```js
class Lib extends require('events').EventEmitter {
  constructor() {
    super()

    this.emit('init')
  }
}

const lib = new Lib()

lib.on('init', _ => {
  // 这里将永远不会执行
  console.log('init!')
})
```

因为上述的代码在实例化 `Lib` 对象时是同步执行的，在实例化完成以后就立马发送了 `init` 事件，而这时在外层的主程序还没有开始执行到 `lib.on('init')` 监听事件的这一步，所以会导致发送事件时没有回调，回调注册后事件不会再次发送，我们可以很轻松的使用 `process.nextTick` 来解决这个问题

```js
class Lib extends require('events').EventEmitter {
  constructor() {
    super()

    process.nextTick(_ => {
      this.emit('init')
    })

    // 同理使用其他的微任务
    // 比如 Promise.resolve().then(_ => this.emit('init'))
    // 也可以实现相同的效果
  }
}
```

这样会在主进程的代码执行完毕后，程序空闲时触发 `Event Loop` 流程查找有没有微任务，然后再发送 `init` 事件

> 但是这里也需要注意，循环调用 `process.nextTick` 会导致报警，后续的代码永远不会被执行




## Async/Await

因为 `Async/Await` 本质上还是基于 `Promise` 的一些封装，而 `Promise` 是属于微任务的一种，所以在使用 `await` 关键字与 `Promise.then` 效果类似

```js
setTimeout(_ => console.log(4))

async function main() {
  console.log(1)
  await Promise.resolve()
  console.log(3)
}

main()

console.log(2)
```

`async` 函数在 `await` 之前的代码都是同步执行的，可以理解为 `await` 之前的代码属于 `new Promise` 时传入的代码，`await` 之后的所有代码都是在 `Promise.then` 中的回调








## 参考

* [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
* [JavaScript 的并发模型](https://www.jianshu.com/p/c38bd2b1bb43)
* [事件循环处理模型](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)
* [从一道题浅说 JavaScript 的事件循环](https://github.com/dwqs/blog/issues/61)
* [Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
* [window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)
* [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
* [What is the Event Loop?](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)