---
title: 为什么要使用依赖注入
date: 2018-12-14
categories: Angular
tags: Angular
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/02.jpg
---

依赖注入是一种设计模式，也是 `Angular` 当中比较重要的一部分，但是在展开之前我们先来看看为什么要使用依赖注入，它有哪些优缺点

<!--more-->

## 为什么要使用依赖注入

下面是一个简单的示例，一个 `Person` 类，然后它依赖与 `Id` 和 `Address` 两个类

```js
class Id {
  static getId(type: string): Id {
    return new Id()
  }
}

class Address {
  constructor(city, street) { }
}

class Person {
  id: Id
  address: Address
  constructor() {
    this.id = Id.getId('123')
    this.address = new Address('北京', '北京')
  }
}
```

在上面这种情况下，我们可以发现 `Person` 显性的依赖于 `Id` 和 `Address` 两个类，因为它需要知道 `Id` 和 `Address` 两个类的具体构成，所以耦合性较高，我们来稍微的重构一下，也就成了下面这样

```js
class Id {
  static getId(type: string): Id {
    return new Id()
  }
}

class Address {
  constructor(city, street) { }
}

class Person {
  id: Id
  address: Address
  constructor(id: Id, address: Address) {
    this.id = id
    this.address = address
  }
}

// 在某个类当中调用的时候
main() {
  const id = Id.getId('123')
  const address = new Address('北京', '北京')
  const person = new Person(id, address)
}
```

我们调整成不在 `Person` 内部来进行获取 `Id` 和 `Address` 两个类，而是在入口位置的 `main()` 函数当中来进行获取，但是重构完成以后可以发现，相对于之前的示例，依赖性已经不再是那么强烈，但是依然存在之前提到的问题，那就是在 `main()` 方法中依然需要知道 `Id` 和 `Address` 两个类的具体构成

如果按照我们上面的流程，手动来进行解决的话，可以一级一级的往上推，直到入口函数当中统一处理，但是可想而知有多复杂，稍微一不注意就有可能出错，所以我们可以考虑借住框架来帮助我们完成这样的任务



## 实现原理

我们下面就来看看如何在 `Angular` 当中完成上面的任务，其实在 `Angular` 的依赖注入中主要有三个概念

* `Injector`，注入者，利用其提供的 `API` 去创建依赖的实例
* `Provider`，告诉 `Injector` 如何去创建一个实例（构造这个对象）
* `Object`，创建好的对象，也就是当前所处的模块或者组件需要的依赖（某种类型的对象，依赖本身也是一种类型）

在这里我们先不利用 `Angular` 提供的现成方法，而是借住框架手动的来完善整个依赖注入的流程，最后再来和 `Angular` 当中提供的原生方法来做一个对比

话不多说，先来改写上面的例子

```js
import { Component, ReflectiveInjector, Inject } from '@angular/core'
import { environment } from '../environments/environment'

export class AppComponent {

  constructor() {
    // resolveAndCreate() 方法接收一个 provider 数组
    // ReflectiveInjector 利用 resolveAndCreate() 方法会根据输入的一个 provider 数组来构建一个可以提供依赖性的池子
    // 池子当中含有多个 provider 对象，该对象有两个属性
    // 一个为 provide，可以简单的理解为 key/令牌 等，作用是唯一性的一个标识
    // 另外一个为类型，类型有多种，比如 useClass, useFactory 等
    // 简单来说，池子的作用就是把在这个类中所有想使用的依赖都存放到里面
    const injector = ReflectiveInjector.resolveAndCreate([

      // 针对于 { provide: Person, useClass: Person }, 这种 useClass 的方式可以直接简写为 Person
      // 可以直接使用类来去代替，因为本质上就是提供了这个类的构造，key/令牌 也是这个类的本身
      Person,
      { 
        provide: Address, useFactory: () => {
          if (environment.production) {
            return new Address('北京', '北京')
          } else {
            return new Address('西藏', '拉萨')
          }
        }
      },
      { provide: Id, useFactory: () => {
        return Id.getId('123')
      }}
    ])

    // 注入之后就可以来进行使用了，利用 injector 的 get() 方法来获取 Person 对象
    const person = injector.get(Person)
    console.log(JSON.stringify(person))
  }
}

class Id {
  static getId(type: string): Id {
    return new Id()
  }
}

class Address {
  city: string
  street: string
  constructor(city, street) {
    this.city = city
    this.street = street
  }
}

// 依赖 Id 和 Address 两个类
class Person {
  id: Id
  address: Address
  // 需要两个依赖性，一个是 Id，一个是 Address
  // 这里执行的流程就是会去上面的池子当中进行寻找
  constructor(@Inject(Id) id, @Inject(Address) address) {
    this.id = id
    this.address = address
  }
}
```

上面就是我们手动的来实现 `Angular` 当中的依赖注入的流程，但是在绝大部分的情况下，我们并不需要显性的去手写这么一个 `provider` 对象，因为 `Angular` 已经帮我们都已经封装好了，并且提供给了我们一些便利，而我们就可以直接利用这些便利来完成上面这样复杂的操作




## 使用依赖注入

下面我们就来看看如何在项目当中使用 `Angular` 提供的 `provider`

```js
// 一个公共模块
// 在 @NgModule 当中注入 BASE_CONFIG 这个静态变量
@NgModule({
  // ...
  providers: [
    { provide: 'BASE_CONFIG', useValue: 'http://localhost:3000'}
  ]
})

// 使用
import { Inject } from '@angular/core'

constructor(@Inject('BASE_CONFIG') config) {
  console.log(config)
}
```

我们在 `Module` 或者 `Component` 当中，只需要在 `providers` 数组当中提供这个 `provide` 对象，`Angular` 便会自动的帮我们注册到 `Inject` 这个池子当中

所以在我们使用过程当中，只需要在 `constructor` 当中使用 `@Inject()` 注入进来即可，但是需要注意的一点就是，我们这样操作的话，在池子当中取的数据都是单例的，如果想要每次取的都是一个新的实例的话，比如之前的实例，只需在此基础上稍作调整，让其返回一个函数即可

```js
export class AppComponent {
  constructor() {
    const injector = ReflectiveInjector.resolveAndCreate([
      Person,
      { 
        provide: Address, useFactory: () => {
          // 修改这里
          return () => {
            if (environment.production) {
              return new Address('北京', '北京')
            } else {
              return new Address('西藏', '拉萨')
            }
          }
        }
      },
      { provide: Id, useFactory: () => {
        return Id.getId('123')
      }}
    ])

    const person = injector.get(Person)
    console.log(JSON.stringify(person))
  }
}
```

这是一种方式，另外一种方式就是利用父子传递的概念，这种情况一般使用较少，可以考虑使用返回一个函数的方式

```js
constructor() {

  const injector = ReflectiveInjector.resolveAndCreate([
    Person,
    { 
      provide: Address, useFactory: () => {
        if (environment.production) {
          return new Address('北京', '北京')
        } else {
          return new Address('西藏', '拉萨')
        }
      }
    },
    { provide: Id, useFactory: () => {
      return Id.getId('123')
    }}
  ])

  // 创建一个子注入者，传入 Person
  // 这里有一点需要注意，在创建子注入者的时候，我们仅仅只传入了 Person，并没有传入 Id 和 Address
  // 这里的情况是 当在子池子中找不到的情况下就回去父池子当中进行查找
  const childInjector = injector.resolveAndCreateChild([Person])

  const personFromChild = childInjector.get(Person)
  const person = injector.get(Person)
  
  console.log(person === personFromChild)  // false
}
```

以上就是 `Angular` 当中的依赖注入简单的使用方式，我们通过一个基本的示例了解了为什么要使用依赖注入，再到引出 `Angular` 当中的依赖注入

但是 `Angular` 当中的依赖注入的内容远远不止上文介绍到的这些，所以我们会在下一部分 [Angular 中的依赖注入](https://heptaluan.github.io/2018/12/26/Angular/03/) 来深入的了解 `Angular` 当中的依赖注入