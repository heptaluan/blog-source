---
title: 常用中间件的实现
date: 2019-10-25
categories: Node.js
tags: Node.js
toc: true
thumbnail: https://raw.githubusercontent.com/heptaluan/blog/master/backups/cdn/cover/16.jpg
---

接上回 [中间件](http://https://heptaluan.github.io/2019/10/24/Node/15/)

在前面一章，我们介绍了中间件的基本概念，以及洋葱模型，最后我们也手动实现了一个简单的 `compose()` 方法

这一章我们主要手动的来实现一个最基本的 `Koa.js` 框架以及 `Koa.js` 当中一些比较常用的中间件的简单实现，比如 `koa-logger` 和 `koa-static` 等


<!--more-->

## ctx

在实现基本的框架之前，我们先来看看 `Koa.js` 当中的 `ctx` 这个对象，一般我们使用的话是这么用的

```js
app.use(async (ctx, next) => {
  ctx.body = 'hello world';
});
```

上面示例当中的 `ctx`，其实就是 `context`，大多数人称之为上下文对象，这个对象下有四个主要的属性，它们分别是

* `ctx.req` -- 原生的 `req` 对象

* `ctx.res` -- 原生的 `res` 对象

* `ctx.request` -- `Koa.js` 自己封装的 `request` 对象

* `ctx.response` -- `Koa.js` 自己封装的 `response` 对象

其中 `Koa.js` 自己封装的和原生的最大的区别在于：`Koa.js` 自己封装的请求和响应对象的内容不仅囊括原生的还添加了一些额外的东西

除此之外，`ctx` 本身还代理了 `ctx.request` 和 `ctx.response` 身上的属性，比如下面的示例

```js
// 如果是在原生当中，则是需要经过 url.parse(p, true).query 才能得到的 query 对象
console.log(ctx.query);

// 如果是在原生当中，则是需要经过 url.parse(p).pathname 才能得到的路径（url 去除 query 部分）
console.log(ctx.path);
```


## 框架的实现

我们先来简单的总结一下 `Koa.js` 的一些基本特点

* 有一个可以注册使用中间件的 `use()` 方法

* 还有一个服务事件监听事件 `listen()` 方法，并且可以接收回调函数

我们先来使用最简单的回调方法来实现

```js
const http = require('http')
const Emitter = require('events')

class WebServer extends Emitter {

  constructor() {
    super()
    this.middleware = []
    this.context = Object.create(null)
  }

  // 服务事件监听
  listen(...args) {
    const server = http.createServer(this.callback())
    return server.listen(...args)
  }

  // 注册使用中间件
  use(fn) {
    if (typeof fn === 'function') {
      this.middleware.push(fn)
    }
  }

  // 回调方法
  callback() {
    let that = this;

    if (this.listeners('error').length === 0) {
      this.on('error', this.onerror)
    }

    const henadleRequest = (req, res) => {
      let context = that.createContext(req, res)
      this.middleware.forEach((cb, idx) => {
        try {
          cb(context)
        } catch (err) {
          that.onerror(err)
        }

        if (idx + 1 >= this.middleware.length) {
          if (res && typeof res.end === 'function') {
            res.end()
          }
        }
      })
    }
    return henadleRequest
  }

  // 异常监听处理
  onerror(err) {
    console.log(err)
  }

  // 创建通用上下文
  createContext(req, res) {
    let content = Object.create(this.context)
    content.req = req;
    content.res = res;
    return content;
  }
}

module.exports = WebServer
```

然后来稍微的测试一下我们上面定义的服务

```js
const WebServer = require('./index')
const app = new WebServer()

app.use(ctx => {
  ctx.res.write('hello world 1 \n')
})

app.use(ctx => {
  ctx.res.write('hello world 2 \n')
})

app.use(ctx => {
  ctx.res.write('hello world 3 \n')
})

app.listen(3000, _ => {
  console.log(`app is running at port 3000`)
})
```

发现是可以正常使用的，但是这里面有一个问题，就是我们在处理中间件队列的时候，底层使用的是回调嵌套去处理的

但是中间件越多，回调嵌套越深，代码的可读性和可扩展性就很差，所以我们就可以考虑将我们的 `handleRequest` 方法调整为 `async/await` 方式

所以在这种情况下，我们就可以使用我们之前已经定义过的 `compose()` 方法，如下

```js
const handleRequest = (req, res) => {
  let context = this.createContext(req, res);
  let middleware = this.middleware;
  // 执行中间件
  compose(middleware)(context).catch(err => this.onerror(err))
};

return handleRequest;
```

下面是整合后的代码

```js
const http = require('http');
const Emitter = require('events');
const compose = require('./compose');

// 通用上下文
const context = {
  _body: null,

  get body() {
    return this._body;
  },

  set body(val) {
    this._body = val;
    this.res.end(this._body);
  }
};

class SimpleKoa extends Emitter {
  constructor() {
    super();
    this.middleware = [];
    this.context = Object.create(context);
  }

  // 服务事件监听
  listen(...args) {
    const server = http.createServer(this.callback());
    return server.listen(...args);
  }

  // 注册使用中间件
  use(fn) {
    if (typeof fn === 'function') {
      this.middleware.push(fn);
    }
  }

  // 中间件总回调方法
  callback() {

    if (this.listeners('error').length === 0) {
      this.on('error', this.onerror);
    }

    const handleRequest = (req, res) => {
      let context = this.createContext(req, res);
      let middleware = this.middleware;
      // 执行中间件
      compose(middleware)(context).catch(err => this.onerror(err))
    };

    return handleRequest;
  }

  // 异常处理监听
  onerror(err) {
    console.log(err);
  }

  // 创建通用上下文
  createContext(req, res) {
    let context = Object.create(this.context);
    context.req = req;
    context.res = res;
    return context;
  }
}

module.exports = SimpleKoa;
```

测试一下

```js
const SimpleKoa = require('./index');

const app = new SimpleKoa();

app.use(async ctx => {
  ctx.body = '<p>SimpleKoa</p>';
});

app.listen(3000, () => {
  console.log(`app is running at port 3000`);
});
```

发现是可以正常使用的，下面我们再来看看 `Koa.js` 当中的一些比较常用的中间件的实现



## koa-logger

我们先来看一个比较简单的 `koa-logger` 的实现，我们这里只实现简单的拦截请求，打印请求的 `url`，以及操作响应并且打印出响应的 `url`

通过实现可以发现，这里就用到了我们之前提到过的洋葱模型

```js
const logger = async (ctx, next) => {
  let res = ctx.res;

  // 拦截操作请求 request
  console.log(`<== 请求的方式和地址为 ${ctx.method} ${ctx.url}`);

  await next();

  // 拦截操作响应 request
  res.on('finish', _ => {
    console.log(`==> 响应的方式和地址为 ${ctx.method} ${ctx.url}`);
  })
}

module.exports = logger;
```

直接引入使用即可

```js
const Koa = require('koa')
const logger = require('./log')
const app = new Koa()

app.use(logger)

app.use(async (ctx, next) => {
  ctx.body = `hello world`
})

app.listen(3000)
```





## koa-send

主要参考的是官方的 [koajs/send](https://github.com/koajs/send/blob/master/index.js)，主要流程如下

* 拦截请求，判断该请求是否请求本地静态资源文件

* 操作响应，返回对应的静态文件文本内容或出错提示

简单的梳理一下，可以分为以下几个步骤

* 配置静态资源绝对目录地址

* 判断是否支持隐藏文件

* 获取文件或者目录信息

* 判断是否需要压缩

* 设置 `http` 头信息

* 静态文件读取

```js
const fs = require('fs');
const path = require('path');
const {
  basename,
  extname
} = path;

const defaultOpts = {
  root: '',
  maxage: 0,
  immutable: false,
  extensions: false,
  hidden: false,
  brotli: false,
  gzip: false,
  setHeaders: () => { }
};

async function send(ctx, urlPath, opts = defaultOpts) {
  const { root, hidden, immutable, maxage, brotli, gzip, setHeaders } = opts;
  let filePath = urlPath;

  // 配置静态资源绝对目录地址
  try {
    filePath = decodeURIComponent(filePath);
    if (/[\.]{2,}/ig.test(filePath)) {
      ctx.throw(403, 'Forbidden');
    }
  } catch (err) {
    ctx.throw(400, 'failed to decode');
  }

  filePath = path.join(root, urlPath);
  const fileBasename = basename(filePath);

  // 判断是否支持隐藏文件
  if (hidden !== true && fileBasename.startsWith('.')) {
    ctx.throw(404, '404 Not Found');
    return;
  }

  // 获取文件或者目录信息
  let stats;
  try {
    stats = fs.statSync(filePath);
    if (stats.isDirectory()) {
      ctx.throw(404, '404 Not Found');
    }
  } catch (err) {
    const notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR']
    if (notfound.includes(err.code)) {
      ctx.throw(404, '404 Not Found');
      return;
    }
    err.status = 500
    throw err
  }

  let encodingExt = '';
  // 判断是否需要压缩
  if (ctx.acceptsEncodings('br', 'identity') === 'br' && brotli && (fs.existsSync(filePath + '.br'))) {
    filePath = filePath + '.br';
    ctx.set('Content-Encoding', 'br');
    ctx.res.removeHeader('Content-Length');
    encodingExt = '.br';
  } else if (ctx.acceptsEncodings('gzip', 'identity') === 'gzip' && gzip && (fs.existsSync(filePath + '.gz'))) {
    filePath = filePath + '.gz';
    ctx.set('Content-Encoding', 'gzip');
    ctx.res.removeHeader('Content-Length');
    encodingExt = '.gz';
  }

  // 设置 http 头信息
  if (typeof setHeaders === 'function') {
    setHeaders(ctx.res, filePath, stats);
  }

  ctx.set('Content-Length', stats.size);
  if (!ctx.response.get('Last-Modified')) {
    ctx.set('Last-Modified', stats.mtime.toUTCString());
  }
  if (!ctx.response.get('Cache-Control')) {
    const directives = ['max-age=' + (maxage / 1000 | 0)];
    if (immutable) {
      directives.push('immutable');
    }
    ctx.set('Cache-Control', directives.join(','));
  }

  const ctxType = encodingExt !== '' ? extname(basename(filePath, encodingExt)) : extname(filePath);
  ctx.type = ctxType;

  // 静态文件读取
  ctx.body = fs.createReadStream(filePath);
}

module.exports = send;
```

使用如下

```js
const send = require('./send');
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {
  await send(ctx, ctx.path, { root: `${__dirname}/public` });
});

app.listen(3000);
```







## koa-static





























参考

[koajs/send](https://github.com/koajs/send/blob/master/index.js)

[Koa：核心探秘与入坑指北](https://juejin.im/post/5ad466d25188253edd4d898a#heading-12)

