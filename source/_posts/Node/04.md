---
title: Node.js 中的事件轮询机制
date: 2019-07-05
categories: Node.js
tags: Node.js
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/04.webp
---

本文主要借助 `libuv` 来简单的了解一下 `Node.js` 中的事件轮询机制相关概念，注意与浏览器中的 `event loop` 区分开来，下面我们就先来看看什么是 `libuv`

> 关于浏览器中的 `event loop` 详细可见 [JavaScript 并发模型](https://heptaluan.github.io/2018/08/12/JavaScript/30/)

<!--more-->


## libuv

`libuv` 是一个高性能的，事件驱动的 `I/O` 库，并且提供了跨平台（如 `windows`, `linux`）的 `API`，如果想要参考更为详细的内容可以参考 [An Introduction to libuv](https://github.com/nikhilm/uvbook)，中文教程可以参考 [Libuv 的中文教程](https://github.com/luohaha/Chinese-uvbook)，下面我们就正式的来看看 `libuv`，`libuv` 的 [官方文档](http://docs.libuv.org/en/v1.x/design.html) 在阐述其架构的时候有这么一张图，如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/node/04.png)

仅仅凭着这么一张图并不能让我们对其内部机制理解得透彻，简单来说，在 `Node.js` 里面 `V8` 充当的角色更多的是语法解析层面，另外它还充当了 `JavaScript` 和 `C/C++` 的桥梁，但是我们都知道 `Node.js` 中一切皆可异步，但这并不是通过 `V8` 来实现的，充当这个角色的其实就是 `libuv`，比如一个简单的 `JavaScript` 异步代码，使用 `setTimeout` 就可以实现

```js
setTimeout(function () { console.log('timeout 0') }, 0)

console.log('outter')

// outter

// timeout 0
```

想要深挖为什么会出现这样的结果，要首先来研究一下 `libuv` 的事件轮询机制



## 事件轮询机制

事件轮询机制是一个执行模型，在不同的地方有不同的实现，浏览器和 `Node.js` 基于不同的技术实现了各自的 `event loop`，但是不要混淆 `Node.js` 和浏览器中的 `event loop`

> 再次强调，`Node.js` 和浏览器的 `event loop` 是两个有明确区分的事物，不能混为一谈

简单来讲，`Node.js` 的 `event` 是基于 `libuv`，而浏览器的 `event loop` 则在 [HTML 5](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 的规范中明确定义，`libuv` 已经对 `event loop` 作出了实现，而 `HTML 5` 规范中只是定义了浏览器中 `event loop` 的模型，具体实现留给了浏览器厂商

在 `libuv` 中，有一个句柄（`handle`）的概念，每个句柄中存储数据和回调函数之类的信息，句柄在使用前要添加到对应的队列（`queue`）或者堆（`heap`）中，其实只有定时器句柄使用了 [最小堆](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86) 的数据结构，其他句柄使用队列的数据结构进行存储，`libuv` 在进行每一次事件轮询的时候都会从每个类型的句柄中，取出关联的队列或者堆结构进行处理，流程图如下所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/node/05.png)

`Node.js` 的 `event loop` 分为六个阶段，每个阶段的作用如下

* `timers`，执行 `setTimeout()` 和 `setInterval()` 中到期的 `callback`
* `I/O callbacks`，上一轮循环中有少数的 `I/O callback` 会被延迟到这一轮的这一阶段执行
* `idle, prepare`，仅内部使用
* `poll`，最为重要的阶段，执行 `I/O callback`，在适当的条件下会阻塞在这个阶段
* `check`，执行 `setImmediate` 的 `callback`
* `close callbacks`，执行 `close` 事件的 `callback`，例如 `socket.on('close',func)`

如果想要具体了解其内部执行流程，可以参考这篇文章中的 [源码解析部分](https://cnodejs.org/topic/5a9108d78d6e16e56bb80882)，我们这里只是简单介绍一下其执行的流程，上面的图片可以简化成下面的流程

```js
   ┌───────────────────────┐
┌─>│        timers       │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks   │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare   │
│  └──────────┬────────────┘      ┌────────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll        │<──────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └────────────────┘
│  │        check        │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks  │
   └───────────────────────┘
```

`event loop` 的每一次循环都需要依次经过上述的阶段，每个阶段都有自己的 `callback` 队列，每当进入某个阶段，都会从所属的队列中取出 `callback` 来执行，当队列为空或者被执行 `callback` 的数量达到系统的最大数量时，进入下一阶段，这六个阶段都执行完毕称为一轮循环，下面我们来分类查看


#### timers 阶段

在 `timer` 阶段其实使用一个最小堆而不是队列来保存所有元素（其实也可以理解，因为 `timeout` 的 `callback` 是按照超时时间的顺序来调用的，并不是先进先出的队列逻辑），然后循环取出所有到期的 `callback` 执行


#### I/O callbacks 阶段

根据 `libuv` 的文档，一些应该在上轮循环 `poll` 阶段执行的 `callback`，因为某些原因不能执行，就会被延迟到这一轮的循环的 `I/O callbacks` 阶段执行，换句话说这个阶段执行的 `callbacks` 是上轮残留的


#### idle 和 prepare 阶段

`idle` 和 `prepare` 回调，仅仅在内部使用


#### poll 阶段

`poll` 阶段的任务就是阻塞等待监听的事件来临，然后执行对应的 `callback`，其中阻塞是带有超时时间的，以下几种情况都会使得超时时间为 `0`

* `uv_run` 处于 `UV_RUN_NOWAIT` 模式下
* `uv_stop()` 被调用
* 没有活跃的 `handles` 和 `request`
* 有活跃的 `idle handles`
* 有等待关闭的 `handles`

如果上述都不符合，则超时时间为距离现在最近的 `timer`，如果没有 `timer` 则 `poll` 阶段会一直阻塞下去


#### check 阶段

`check` 回调，在 `Node.js` 中被用作运行 `setImmediate` 回调


#### close 阶段

循环关闭所有的 `closing handles`


## 线程模型

接下来我们可以了解一下 `libuv` 的线程模型，因为要想实现一个无堵塞的事件轮询必须依靠线程，`libuv` 中大体上可以把线程分为两类，一类是事件轮询线程，一类是文件 `IO` 处理线程

第一类事件轮询线程是单线程，另外一类称其为文件 `IO` 处理线程多少有些不准确，因为它不仅能处理文件 `IO`，还能处理 `DNS` 解析，也能处理用户自己编写的 `Node.js` 扩展中的逻辑，它是一个线程池，如果你想自己编写一个 `C++` 扩展来处理耗时业务的话，也会用上它，我们这里就以文件 `IO` 处理来作为示例，来描述这两类线程之前是怎么通信的

`libuv` 在处理完一个文件 `IO` 操作后，会把处理后的结果发送到 `pending` 队列中，事件轮询线程读取 `pending` 队列，执行回调函数

```js
var fs = require('fs')

fs.exists(__filename, function (exists) {
  console.log(exists)
})
```

> 需要注意的是 `fs.exists()` 已经不再推荐使用，可以使用 `fs.stat()` 或者 `fs.access()` 来替代，这里我们仅仅使用它来讲解原理

该函数在调用的时候传了两个参数，第一个 `__filename` 是 `Node.js` 中的一个全局变量，它的值其实是当前执行文件的所在路径，第二个参数是一个回调函数，回调函数中 `exists` 用来表示当前是否存在，很明显当前这段代码最终打印的结果肯定是 `true`，当然我们这里更关心的是整个流程处理，下面用一副数据流向图来将上面流程总结一下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/node/06.png)







## 参考

* [Linux IO 概览](http://blog.lucode.net/linux/linux-io-overview.html)
* [Libuv 源码阅读](https://zhuanlan.zhihu.com/p/35039878)
* [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)
* [不要混淆 Node.js 和浏览器中的 event loop](https://cnodejs.org/topic/5a9108d78d6e16e56bb80882)