---
title: EventEmitter
date: 2019-10-01
categories: Node.js
tags: Node.js
toc: true
thumbnail: https://raw.githubusercontent.com/heptaluan/blog/master/backups/cdn/cover/09.jpg
---


在 `Node.js` 当中许多对象都会分发事件，比如一个 [net.Server](http://nodejs.cn/api/net.html#net_class_net_server) 对象会在每次有新连接时触发一个事件，一个 [fs.readStream](http://nodejs.cn/api/fs.html#fs_class_fs_readstream) 对象会在文件被打开的时候触发一个事件，然而所有这些产生事件的对象都是 `events.EventEmitter` 的实例

<!--more-->

## EventEmitter 类

`events` 模块只提供了一个对象：`events.EventEmitter`，`EventEmitter` 的核心就是事件触发与事件监听器功能的封装

你可以通过 `require('events')` 来访问该模块，如下

```js
// 引入 events 模块
var events = require('events')

// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter()
```

`EventEmitter` 对象如果在实例化时发生错误，会触发 `error` 事件，关于 `EventEmitter` 里面的 `error` 事件有一点需要注意的地方

> `EventEmitter` 即使绑定了 `error` 事件也是不会输出的，而是会在控制台打印该异常的堆栈信息，并结束进程，获取异常只能通过 try catch，如下

```js
eventEmitter.on('error', function (err) {
  console.error('Error:', err);
});
```
经过测试可以发现，绑定 `error` 事件只能自己触发，比如使用 `eventEmitter.emit('error')`

当没有错误时，会在控制台打印 `Error：undefined`，而当有错误时不会打印而是直接打印该异常的堆栈信息，并结束进程

当添加新的监听器时，`newListener` 事件会触发，当监听器被移除时，`removeListener` 事件被触发

以上就是 `EventEmitter` 的简单使用方式，本文的主要构成主要分为两部分，首先先简单的过一遍源码，然后在自己动手来实现一个简单的 `EventEmitter` 模块

但是在深入展开之前，我们先来了解一些前置知识


## 观察者模式

本章主要参考 [深入 EventEmitter](https://github.com/semlinker/node-deep/blob/master/event/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%20Node.js%20EventEmitter.md)

> 观察者模式是[软件设计模式](https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA))的一种，在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知，这通常透过呼叫各观察者所提供的方法来实现，此种模式通常被用来实时事件处理系统 —— [维基百科](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)

`EventEmitter` 本质上是一个观察者模式的实现，所谓观察者模式

它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己

我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念，期刊订阅包含两个主要的角色：期刊出版方和订阅者，它们之间的关系如下

* 期刊出版方 - 负责期刊的出版和发行工作

* 订阅者 - 只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知

在观察者模式中也有两个主要角色：主题和观察者，分别对应期刊订阅例子中的期刊出版方和订阅者，它们之间的关系图如下

![](https://raw.githubusercontent.com/semlinker/node-deep/master/event/observer-pattern.png)



#### 观察者模式优缺点

观察者模式的优点：

* 支持简单的广播通信，自动通知所有已经订阅过的对象

* 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用

观察者模式的缺点：

* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间

* 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃


#### 观察者模式的应用

最常见的例子就是为 `DOM` 对象添加事件监听

```html
<button id="btn">确认</button>
```

```js
function clickHandler(event) {
  console.log('用户已点击确认按钮!');
}

document.getElementById('btn').addEventListener('click', clickHandler);
```

当按钮在点击当同时会触发我们事先绑定好的事件 `clickHandler`



## 发布/订阅模式

> 在[软件架构](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84)中，**发布-订阅**是一种[消息](https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF)[范式](https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BC%8F)，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者），而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在，同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在，—— [维基百科](https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85)

发布/订阅模式与观察者模式非常类似，它们最大的区别是：

* 发布者和订阅者不知道对方的存在

* 它们之间需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息

* 发布/订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在

那么信息中介是如何过滤消息呢？在发布/订阅模型中，订阅者通常接收所有发布的消息的一个子集，选择接受和处理的消息的过程被称作过滤，有两种常用的过滤形式：基于主题的和基于内容的

* 在**基于主题**的系统中，消息被发布到主题或命名通道上，订阅者将收到其订阅的主题上的所有消息，并且所有订阅同一主题的订阅者将接收到同样的消息，发布者负责定义订阅者所订阅的消息类别，
* 在**基于内容**的系统中，订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者，订阅者需要负责对消息进行分类，

一些系统支持两者的混合：发布者发布消息到主题上，而订阅者将基于内容的订阅注册到一个或多个主题上，基于主题的通信基础结构图如下：

![](https://raw.githubusercontent.com/semlinker/node-deep/master/event/pubsub-pattern.png)

最后我们再来总结一下观察者模式与发布/订阅模式之间的区别



## 观察者模式 vs 发布/订阅模式

![observer-vs-pubsub](https://raw.githubusercontent.com/semlinker/node-deep/master/event/observer-vs-pubsub.jpg)

观察者模式与发布/订阅模式之间的区别：

* 在观察者模式中，观察者知道 `Subject` 的存在，`Subject` 一直保持对观察者进行记录，然而，在发布/订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过信息中介进行通信

* 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反

* 观察者模式大多数时候是同步的，比如当事件触发 `Subject` 就会去调用观察者的方法，而发布/订阅模式大多数时候是异步的（使用消息队列）







<!-- 
## EventEmitter

在 node.js 当中，大多数的核心 API 都采用惯用的异步事件驱动架构，所有能触发事件的对象都是 EventEmitter 类的实例

这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上

当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用， 监听器的返回值会被丢弃

本文主要介绍以下几个核心方法

* on(event, listener)
为指定事件添加一个监听器到监听器数组的尾部（还有一个 addListener 方法，本质与 on 是一致的，见下方）

* once(event, listener)
为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器

* removeListener(event, listener)
移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，

它接受两个参数，第一个是事件名称，第二个是回调函数名称

* emit(event, [arg1], [arg2], [...])
按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false，

下面我们就一个一个来看


## EventEmitter 基本使用

我们首先先来看一个最基本的EventEmitter功能，包含了一个观察者和一个被监听的对象，对应的实现就是EventEmitter中的on和emit

const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('触发了一个事件！');
});

myEmitter.emit('event');

我们自定义 MyEmitter 类，该类继承于 EventEmitter 类，接着我们通过使用 new 关键字创建了 myEmitter 实例，然后使用 on() 方法监听 event 事件，最后利用 emit() 方法触发 event 事件



## EventEmitter 构造函数

如下

function EventEmitter() {
  EventEmitter.init.call(this);
}

EventEmitter.usingDomains = false;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0; // 事件数
EventEmitter.prototype._maxListeners = undefined; // 最大的监听器数

在 EventEmitter 构造函数内部，会调用 EventEmitter.init 方法执行初始化操作，EventEmitter.init 的具体实现如下

EventEmitter.init = function() {
  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

在 EventEmitter.init 内部，会根据条件执行初始化操作，这里有一个比较重要的操作 this._events = Object.create(null)

那么问题来了，为什么要使用 Object.create(null) 来初始化一个新对象而不用更简洁的 {} 呢？

简单来说，两者的区别如下

18.png

对比可以发现，使用create创建的对象，没有任何属性，可以把它当作一个非常纯净的map来使用，可以自己定义hasOwnProperty、toString方法而不必担心会将原型链上的同名方法覆盖掉

下面我们再来看看 on 方法

## EventEmitter on() 方法




































## ES6 中的使用方式

const EventEmitter = require('events');

class MyStream extends EventEmitter {
  write(data) {
    this.emit('data', data);
  }
}

const stream = new MyStream();

stream.on('data', (data) => {
  console.log(`Received data: "${data}"`);
});
stream.write('With ES6');




参考

[深入 EventEmitter](https://github.com/semlinker/node-deep/blob/master/event/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%20Node.js%20EventEmitter.md) -->