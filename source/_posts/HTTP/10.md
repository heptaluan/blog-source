---
title: HTTP 协议梳理
date: 2020-09-01
categories: HTTP
tags: HTTP
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/10.jpg
---

最近打算从新的梳理一下 `HTTP` 的相关内容，因为在复习过程中发现博客当中很多关于 `HTTP` 的内容都是东一块西一块的混杂在一起，没有形成体系，所以就将之前的内容全都提取出来，然后重新的整理一遍，在借助一些书籍从 `HTTP` 诞生之时开始重新的梳理一遍其相关内容，也算是从零开始从新学习 `HTTP`，其实主要目的还是了解一下 `HTTP`、`TCP/IP`、`HTTPS` 等相关概念到底是什么，又是用来做什么的，更多相关内容可以参考 [前端知识体系整理](https://heptaluan.github.io/target/)，由于篇幅较长，我们使用一张思维导图梳理一下，如下

<!--more-->

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-01.png)

主要内容包括

* `HTTP` 概述
  * 诞生与发展
  * 网络基础 `TCP/IP`
  * 网络模型划分/分层管理/通信传输流
  * `IP`、`TCP` 和 `DNS`
* `HTTP` 协议
  * 工作流程
  * 协议基础
* `HTTP` 报文结构
  * 请求报文
  * 响应报文
* `HTTP` 首部字段
  * 通用首部字段
  * 请求首部字段
  * 响应首部字段
* 代理、缓存、网关、隧道
* `HTTP` 状态码
* `HTTPS`
* 用户认证
* 追加协议
* 安全

> 这里需要注意，因为 `TCP/IP` 内容较多，所以在本章当中我们只简单的介绍一下 `TCP/IP` 相关基本内容，更为详细的内容会在后续深入学习后再来进行补充


## 概述

`1989` 年 `3` 月，当时的互联网还只属于少数人，在这一互联网的黎明期，`HTTP` 诞生了，`CERN`（欧洲核子研究组织）的蒂姆·伯纳斯博士提出了一种能让远隔两地的研究者们共享知识的设想，
最初设想的基本理念是借助多文档之间相互关联形成的超文本（`HyperText`），连成可相互参阅的 `WWW`（`World Wide Web`，万维网），针对于此提出了三项 `WWW` 构建技术，分别是

* 把 `SGML`（`Standard Generalized Markup Language`，标准通用标记语言）作为页面的文本标记语言的 `HTML`（`HyperText Markup Language`，超文本标记语言）
* 作为文档传递协议的 `HTTP`
* 指定文档所在地址的 `URL`（`Uniform Resource Locator`，统一资源定位符）

`WWW` 这一名称，是 `Web` 浏览器当年用来浏览超文本的客户端应用程序时的名称，现在则用来表示这一系列的集合，也可简称为 `Web`


#### 发展

`1990` 年 `11` 月，`CERN` 成功研发了世界上第一台 `Web` 服务器和 `Web` 浏览器，`1990` 年，大家针对 `HTML/1.0` 草案进行了讨论，因 `HTML/1.0` 中存在多处模糊不清的部分，草案被直接废弃了，接着从 `1993` 年开始，各公司之间爆发的浏览器大战就没有停息过，在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种 `Web` 标准化视而不见，还屡次出现新增功能没有对应说明文档的情况，而在此过程当中，`HTTP` 的发展则是驻足不前的，各版本情况如下

**HTTP/0.9**

`HTTP` 于 `1990` 年问世，那时的 `HTTP` 并没有作为正式的标准被建立，现在的 `HTTP` 其实含有 `HTTP/1.0` 之前版本的意思，因此被称为 `HTTP/0.9`

**HTTP/1.0**

`HTTP` 正式作为标准被公布是在 `1996` 年的 `5` 月，版本被命名为 `HTTP/1.0`，并记载于 `RFC1945`，虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端，地址如下

> RFC1945 - Hypertext Transfer Protocol - HTTP/1.0
>
> https://www.ietf.org/rfc/rfc1945.txt

**HTTP/1.1**

`1997` 年 `1` 月公布的 `HTTP/1.1` 是目前主流的 `HTTP` 协议版本，当初的标准是 `RFC2068`，之后发布的修订版 `RFC2616` 就是当前的最新版本，地址如下

> RFC2616 - Hypertext Transfer Protocol - HTTP/1.1
>
> https://www.ietf.org/rfc/rfc2616.txt

可见，作为 `Web` 文档传输协议的 `HTTP`，它的版本几乎没有更新（关于 `HTTP/2.0`，`HTTP/3.0` 相关知识我们会在后面进行介绍）


#### 网络基础 TCP/IP

为了理解 `HTTP`，我们有必要事先了解一下 `TCP/IP` 协议族，通常使用的网络（包括互联网）是在 `TCP/IP` 协议族的基础上运作的，而 `HTTP` 属于它内部的一个子集

计算机与网络设备要相互通信，双方就必须基于相同的方法，比如如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，而我们就把这种规则称为协议（`protocol`），协议中存在各式各样的内容，从电缆的规格到 `IP` 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 `Web` 页面显示需要处理的步骤，等等

像这样把与互联网相关联的协议集合起来总称为 `TCP/IP`，`TCP/IP` 协议不仅仅指的是 `TCP` 和 `IP` 两个协议，而是指一个由 `FTP`、`SMTP`、`TCP`、`UDP`、`IP` 等协议构成的协议簇，只是因为在 `TCP/IP` 协议中 `TCP` 协议和 `IP` 协议最具代表性，所以被称为 `TCP/IP` 协议


#### 网络模型划分

我们在做开发的过程当中，常常会听说到各种协议，当前存在三种比较流行的划分网络模型的方式，如下

* `OSI` 七层模型
* `TCP/IP` 四层模型
* 五层模型

> 但是这里我们主要介绍 `TCP/IP` 四层模型，关于其他部分只做简单介绍，如果想要了解更多可以另行查阅相关书籍或文章

**OSI 七层模型**

`OSI`（`Open System Interconnection`，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了七层，每一层都有相关、相对应的物理设备，比如路由器，交换机等，`OSI` 七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其主要的功能使就是帮助不同类型的主机实现数据传输，它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/08-01.png)


**TCP/IP 四层模型**

`TCP/IP` 和 `OSI` 模型组并不能精确的匹配，但是我们可以尽可能的参考 `OSI` 模型并在其中找到 `TCP/IP` 的对应位置，`OSI` 模型到 `TCP/IP` 模型映射关系，通常人们认为 `OSI` 模型最上面三层（应用层、表示层、会话层）在 `TCP/IP` 中是一个应用层，由于 `TCP/IP` 有一个相对比较弱的会话层，由 `TCP` 和 `RTP` 下的打开和关闭连接组成，并在 `TCP/UDP` 下的各种应用提供不同的端口号，这些功能被单个的应用程序添加

那么 `TCP/IP` 四层模型跟 `OSI` 模型有什么不一样呢？

`OSI` 是一个完整的、完善的宏观理论模型，而 `TCP/IP` 模型，更加侧重的是互联网通信核心（也是就是围绕 `TCP/IP` 协议展开的一系列通信协议）的分层，因此它不包括物理层，以及其他一些不想干的协议，其次之所以说他是参考模型，是因为他本身也是 `OSI` 模型中的一部分，因此参考 `OSI` 模型对其进行分层


**五层模型**

五层体系结构包括应用层、运输层、网络层、数据链路层和物理层，五层协议只是 `OSI` 和 `TCP/IP` 的综合，实际应用还是 `TCP/IP` 的四层结构，它的意义其实是为了方便学习计算机网络原理而采用的，综合了 `OSI` 七层模型和 `TCP/IP` 的四层模型而得到的五层模型


#### TCP/IP 的分层管理

`TCP/IP` 协议族里重要的一点就是分层，`TCP/IP` 协议族按层次分别分为以下四层，即应用层、传输层、网络层和数据链路层，把 `TCP/IP` 层次化是有好处的，比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉，而分层之后只需把变动的层替换掉即可，把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了

值得一提的是，层次化之后，设计也变得相对简单了，处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题，`TCP/IP` 协议族各层的作用如下

名称|释义
-|-
应用层 | 应用层决定了向用户提供应用服务时通信的活动，`TCP/IP` 协议族内预存了各类通用的应用服务，比如 `FTP` 和 `DNS` 服务就是其中两类，`HTTP` 协议也处于该层
传输层 | 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议 `TCP` 和 `UDP`
网络层（又名网络互连层） | 网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位，该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方，与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线
链路层（又名数据链路层，网络接口层） | 用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、`NIC`（网络适配器），及光纤等物理可见部分（还包括连接器等一切传输媒介），硬件上的范畴均在链路层的作用范围之内



#### TCP/IP 通信传输流

利用 `TCP/IP` 协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则往应用层往上走

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-02.png)

我们用 `HTTP` 举例来说明，首先作为发送端的客户端在应用层（`HTTP` 协议）发出一个想看某个 `Web` 页面的 `HTTP` 请求，接着为了传输方便，在传输层（`TCP` 协议）把从应用层处收到的数据（`HTTP` 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层

在网络层（`IP` 协议）增加作为通信目的地的 `MAC` 地址后转发给链路层，这样一来发往网络的通信请求就准备齐全了，接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接收到由客户端发送过来的 `HTTP` 请求

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-03.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装（`encapsulate`）



#### IP、TCP 和 DNS

下面我们来看看在 `TCP/IP` 协议族中与 `HTTP` 密不可分的三个协议 `IP`、`TCP` 和 `DNS`


**负责传输的 IP 协议**

按层次分，`IP`（`Internet Protocol`）网际协议位于网络层，它的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是 `IP` 地址和 `MAC` 地址（`Media Access Control Address`）（需要注意别把 `IP` 和 `IP` 地址搞混淆，`IP` 其实是一种协议的名称）

* `IP` 地址指明了节点被分配到的地址，它可以和 `MAC` 地址进行配对，并且是可以变换的，而且 `IP` 间的通信依赖 `MAC` 地址
* `MAC` 地址是指网卡所属的固定地址，但 `MAC` 地址基本上不会更改

在网络上，通常是经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的 `MAC` 地址来搜索下一个中转目标，这时会采用 `ARP` 协议（`Address Resolution Protocol`），`ARP` 是一种用以解析地址的协议，根据通信方的 `IP` 地址就可以反查出对应的 `MAC` 地址

> 其实简单来说就是需要借助 `ARP` 协议将目标主机的 `IP` 地址转换为对应主机的 `MAC` 地址才能进行通信


**确保可靠性的 TCP 协议**

按层次分，`TCP` 位于传输层，提供可靠的字节流服务，所谓的字节流服务（`Byte Stream Service`）是指为了方便传输，将大块数据分割成以报文段（`segment`）为单位的数据包进行管理，而可靠的传输服务是指，能够把数据准确可靠地传给对方

`TCP` 协议为了更容易传送大数据才把数据分割，而且 `TCP` 协议能够确认数据最终是否送达到对方，为了准确无误地将数据送达目标处，`TCP` 协议采用了三次握手（`three way handshaking`）策略，用 `TCP` 协议把数据包送出去后，`TCP` 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达

握手过程中使用了 `TCP` 的标志 `SYN`（`synchronize`）和 `ACK`（`acknowledgement`），发送端首先发送一个带 `SYN` 标志的数据包给对方，接收端收到后，回传一个带有 `SYN/ACK` 标志的数据包以示传达确认信息，最后发送端再回传一个带 `ACK` 标志的数据包代表握手结束，若在握手过程中某个阶段莫名中断，`TCP` 协议会再次以相同的顺序发送相同的数据包


**负责域名解析的DNS服务**

`DNS`（`Domain Name System`）服务是和 `HTTP` 协议一样位于应用层的协议，它提供域名到 `IP` 地址之间的解析服务，用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 `IP` 地址访问，但要让计算机去理解名称，相对而言就变得困难了，因为计算机更擅长处理一长串数字，为了解决上述的问题，`DNS` 服务应运而生，`DNS` 协议提供通过域名查找 `IP` 地址，或逆向从 `IP` 地址反查域名的服务




## HTTP 协议

`HTTP` 协议（`HyperText Transfer Protocol`，超文本传输协议）是用于从 `WWW` 服务器传输超文本到本地浏览器的传输协议，它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示（如文本先于图形）等

`HTTP` 是客户端浏览器或其他程序与 `Web` 服务器之间的应用层通信协议，客户机需要通过 `HTTP` 协议传输所要访问的超文本信息，`HTTP` 包含命令和传输信息，不仅可用于 `Web` 访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成

我们在浏览器的地址栏里输入的网站地址叫做 `URL`（`Uniform Resource Locator`，统一资源定位符），当你在浏览器的地址框中输入一个 `URL` 或是单击一个超级链接时，`URL` 就确定了要浏览的地址，浏览器通过超文本传输协议（`HTTP`），将 `Web` 服务器上站点的网页代码提取出来，并翻译成我们最终所见到的网页

#### HTTP 工作流程

我们以下图为例，先来简单的梳理一下 `HTTP` 的整个工作流程，其实简单来说，就是请求与响应的过程

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-04.png)

`HTTP` 通信机制是在一次完整的 `HTTP` 通信过程中，客户端与服务器之间将完成下列七个步骤

1. 建立 `TCP` 连接

在 `HTTP` 工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 `TCP` 来完成的（即著名的 `TCP/IP` 协议族），`HTTP` 是比 `TCP` 更高层次的应用层协议（可以参考上面的网络模型划分），根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此首先要建立 `TCP` 连接，一般 `TCP` 连接的端口号是 `80`

2. 客户端向服务器发送请求命令

一旦建立了 `TCP` 连接，客户端就会向服务器发送请求命令，例如

```js
GET /index.html HTTP/1.1
Host: baidu.com
```

起始行开头的 `GET` 表示请求访问服务器的类型，称为方法（`method`），随后的字符串 `/index.htm` 指明了请求访问的资源对象，也叫做请求 `URI`（`request-URI`），最后的 `HTTP/1.1`，即 `HTTP` 的版本号，用来提示客户端使用的 `HTTP` 协议功能

请求报文是由请求方法、请求 `URI`、协议版本、可选的请求首部字段和内容实体构成的

3. 客户端发送请求头信息

客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送

4. 服务器应答

客户端向服务器发出请求后，服务器会客户端返回响应，例如

```js
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2019 20:50:15 GMT
Content -Length: 362
Content-Type: text/html

<html>
...
```

在起始行开头的 `HTTP/1.1` 表示服务器对应的 `HTTP` 版本，紧挨着的 `200 OK` 表示请求的处理结果的状态码（`status code`）和原因短语（`reason-phrase`），下一行显示了创建响应的日期时间，是首部字段（`header field`）内的一个属性，接着以一空行分隔，之后的内容称为资源实体的主体（`entity body`）

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

5. 服务器返回响应头信息

正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档

6. 服务器向客户端发送数据

服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着它就以 `Content-Type` 响应头信息所描述的格式发送用户所请求的实际数据

7. 服务器关闭 `TCP` 连接

一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 `TCP` 连接，然后如果客户端或者服务器在其头信息加入了 `Connection: keep-alive`，`TCP` 连接在发送后将仍然保持打开状态，于是客户端可以继续通过相同的连接发送请求，保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽


#### 协议基础

* 待整理


## HTTP 报文结构

* 待整理