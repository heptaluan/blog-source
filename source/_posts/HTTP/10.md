---
title: HTTP 协议梳理
date: 2020-09-01
categories: HTTP
tags: HTTP
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/10.jpg
---

最近打算从新的梳理一下 `HTTP` 的相关内容，因为在复习过程中发现博客当中很多关于 `HTTP` 的内容都是东一块西一块的混杂在一起，没有形成体系，所以就将之前的内容全都提取出来，然后重新的整理一遍，在借助一些书籍从 `HTTP` 诞生之时开始重新的梳理一遍其相关内容，也算是从零开始从新学习 `HTTP`，其实主要目的还是了解一下 `HTTP`、`TCP/IP`、`HTTPS` 等相关概念到底是什么，又是用来做什么的，更多相关内容可以参考 [前端知识体系整理](https://heptaluan.github.io/target/)，由于篇幅较长，我们使用一张思维导图梳理一下，如下

<!--more-->

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-01.png)

主要内容包括

* `HTTP` 概述
  * 发展历程
  * 网络基础 `TCP/IP`
  * 网络模型划分/分层管理/通信传输流
  * `IP`、`TCP` 和 `DNS`
* `HTTP` 协议
  * `HTTP` 工作流程
  * `HTTP` 协议特点
* `HTTP` 报文
  * 请求报文
  * 响应报文
* `HTTP` 首部字段
* `HTTP` 报文实体
* `HTTP` 状态码
* 代理、缓存、网关、隧道
* `HTTPS`
* 用户认证
* 追加协议
* 安全

> 这里需要注意，因为 `TCP/IP` 内容较多，所以在本章当中我们只简单的介绍一下 `TCP/IP` 相关基本内容，更为详细的内容会在后续深入学习后再来进行补充


## HTTP 概述

`1989` 年 `3` 月，当时的互联网还只属于少数人，在这一互联网的黎明期，`HTTP` 诞生了，`CERN`（欧洲核子研究组织）的蒂姆·伯纳斯博士提出了一种能让远隔两地的研究者们共享知识的设想，
最初设想的基本理念是借助多文档之间相互关联形成的超文本（`HyperText`），连成可相互参阅的 `WWW`（`World Wide Web`，万维网），针对于此提出了三项 `WWW` 构建技术，分别是

* 把 `SGML`（`Standard Generalized Markup Language`，标准通用标记语言）作为页面的文本标记语言的 `HTML`（`HyperText Markup Language`，超文本标记语言）
* 作为文档传递协议的 `HTTP`
* 指定文档所在地址的 `URL`（`Uniform Resource Locator`，统一资源定位符）

`WWW` 这一名称，是 `Web` 浏览器当年用来浏览超文本的客户端应用程序时的名称，现在则用来表示这一系列的集合，也可简称为 `Web`


#### 发展

`1990` 年 `11` 月，`CERN` 成功研发了世界上第一台 `Web` 服务器和 `Web` 浏览器，`1990` 年，大家针对 `HTML/1.0` 草案进行了讨论，因 `HTML/1.0` 中存在多处模糊不清的部分，草案被直接废弃了，接着从 `1993` 年开始，各公司之间爆发的浏览器大战就没有停息过，在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种 `Web` 标准化视而不见，还屡次出现新增功能没有对应说明文档的情况，而在此过程当中，`HTTP` 的发展则是驻足不前的，各版本情况如下

###### HTTP/0.9

`HTTP` 于 `1990` 年问世，那时的 `HTTP` 并没有作为正式的标准被建立，现在的 `HTTP` 其实含有 `HTTP/1.0` 之前版本的意思，因此被称为 `HTTP/0.9`

###### HTTP/1.0

`HTTP` 正式作为标准被公布是在 `1996` 年的 `5` 月，版本被命名为 `HTTP/1.0`，并记载于 `RFC1945`，虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端，地址如下

> RFC1945 - Hypertext Transfer Protocol - HTTP/1.0
>
> https://www.ietf.org/rfc/rfc1945.txt

###### HTTP/1.1

`1997` 年 `1` 月公布的 `HTTP/1.1` 是目前主流的 `HTTP` 协议版本，当初的标准是 `RFC2068`，之后发布的修订版 `RFC2616` 就是当前的最新版本，地址如下

> RFC2616 - Hypertext Transfer Protocol - HTTP/1.1
>
> https://www.ietf.org/rfc/rfc2616.txt

可见，作为 `Web` 文档传输协议的 `HTTP`，它的版本几乎没有更新（关于 `HTTP/2.0`，`HTTP/3.0` 相关知识我们会在后面进行介绍）




#### 网络基础 TCP/IP

为了理解 `HTTP`，我们有必要事先了解一下 `TCP/IP` 协议族，通常使用的网络（包括互联网）是在 `TCP/IP` 协议族的基础上运作的，而 `HTTP` 属于它内部的一个子集

计算机与网络设备要相互通信，双方就必须基于相同的方法，比如如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，而我们就把这种规则称为协议（`protocol`），协议中存在各式各样的内容，从电缆的规格到 `IP` 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 `Web` 页面显示需要处理的步骤，等等

像这样把与互联网相关联的协议集合起来总称为 `TCP/IP`，`TCP/IP` 协议不仅仅指的是 `TCP` 和 `IP` 两个协议，而是指一个由 `FTP`、`SMTP`、`TCP`、`UDP`、`IP` 等协议构成的协议簇，只是因为在 `TCP/IP` 协议中 `TCP` 协议和 `IP` 协议最具代表性，所以被称为 `TCP/IP` 协议


#### 网络模型划分

我们在做开发的过程当中，常常会听说到各种协议，当前存在三种比较流行的划分网络模型的方式，如下

* `OSI` 七层模型
* `TCP/IP` 四层模型
* 五层模型

> 但是这里我们主要介绍 `TCP/IP` 四层模型，关于其他部分只做简单介绍，如果想要了解更多可以另行查阅相关书籍或文章


###### OSI 七层模型

`OSI`（`Open System Interconnection`，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了七层，每一层都有相关、相对应的物理设备，比如路由器，交换机等，`OSI` 七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其主要的功能使就是帮助不同类型的主机实现数据传输，它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/08-01.png)


###### TCP/IP 四层模型

`TCP/IP` 和 `OSI` 模型组并不能精确的匹配，但是我们可以尽可能的参考 `OSI` 模型并在其中找到 `TCP/IP` 的对应位置，`OSI` 模型到 `TCP/IP` 模型映射关系，通常人们认为 `OSI` 模型最上面三层（应用层、表示层、会话层）在 `TCP/IP` 中是一个应用层，由于 `TCP/IP` 有一个相对比较弱的会话层，由 `TCP` 和 `RTP` 下的打开和关闭连接组成，并在 `TCP/UDP` 下的各种应用提供不同的端口号，这些功能被单个的应用程序添加

那么 `TCP/IP` 四层模型跟 `OSI` 模型有什么不一样呢？

`OSI` 是一个完整的、完善的宏观理论模型，而 `TCP/IP` 模型，更加侧重的是互联网通信核心（也是就是围绕 `TCP/IP` 协议展开的一系列通信协议）的分层，因此它不包括物理层，以及其他一些不想干的协议，其次之所以说他是参考模型，是因为他本身也是 `OSI` 模型中的一部分，因此参考 `OSI` 模型对其进行分层


###### 五层模型

五层体系结构包括应用层、运输层、网络层、数据链路层和物理层，五层协议只是 `OSI` 和 `TCP/IP` 的综合，实际应用还是 `TCP/IP` 的四层结构，它的意义其实是为了方便学习计算机网络原理而采用的，综合了 `OSI` 七层模型和 `TCP/IP` 的四层模型而得到的五层模型




#### TCP/IP 的分层管理

`TCP/IP` 协议族里重要的一点就是分层，`TCP/IP` 协议族按层次分别分为以下四层，即应用层、传输层、网络层和数据链路层，把 `TCP/IP` 层次化是有好处的，比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉，而分层之后只需把变动的层替换掉即可，把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了

值得一提的是，层次化之后，设计也变得相对简单了，处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题，`TCP/IP` 协议族各层的作用如下

名称|释义
-|-
应用层 | 应用层决定了向用户提供应用服务时通信的活动，`TCP/IP` 协议族内预存了各类通用的应用服务，比如 `FTP` 和 `DNS` 服务就是其中两类，`HTTP` 协议也处于该层
传输层 | 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议 `TCP` 和 `UDP`
网络层（又名网络互连层） | 网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位，该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方，与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线
链路层（又名数据链路层，网络接口层） | 用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、`NIC`（网络适配器），及光纤等物理可见部分（还包括连接器等一切传输媒介），硬件上的范畴均在链路层的作用范围之内



#### TCP/IP 通信传输流

利用 `TCP/IP` 协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则往应用层往上走

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-02.png)

我们用 `HTTP` 举例来说明，首先作为发送端的客户端在应用层（`HTTP` 协议）发出一个想看某个 `Web` 页面的 `HTTP` 请求，接着为了传输方便，在传输层（`TCP` 协议）把从应用层处收到的数据（`HTTP` 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层

在网络层（`IP` 协议）增加作为通信目的地的 `MAC` 地址后转发给链路层，这样一来发往网络的通信请求就准备齐全了，接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接收到由客户端发送过来的 `HTTP` 请求

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-03.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装（`encapsulate`）



#### IP、TCP 和 DNS

下面我们来看看在 `TCP/IP` 协议族中与 `HTTP` 密不可分的三个协议 `IP`、`TCP` 和 `DNS`


###### 负责传输的 IP 协议

按层次分，`IP`（`Internet Protocol`）网际协议位于网络层，它的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是 `IP` 地址和 `MAC` 地址（`Media Access Control Address`）（需要注意别把 `IP` 和 `IP` 地址搞混淆，`IP` 其实是一种协议的名称）

* `IP` 地址指明了节点被分配到的地址，它可以和 `MAC` 地址进行配对，并且是可以变换的，而且 `IP` 间的通信依赖 `MAC` 地址
* `MAC` 地址是指网卡所属的固定地址，但 `MAC` 地址基本上不会更改

在网络上，通常是经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的 `MAC` 地址来搜索下一个中转目标，这时会采用 `ARP` 协议（`Address Resolution Protocol`），`ARP` 是一种用以解析地址的协议，根据通信方的 `IP` 地址就可以反查出对应的 `MAC` 地址

> 其实简单来说就是需要借助 `ARP` 协议将目标主机的 `IP` 地址转换为对应主机的 `MAC` 地址才能进行通信


###### 确保可靠性的 TCP 协议

按层次分，`TCP` 位于传输层，提供可靠的字节流服务，所谓的字节流服务（`Byte Stream Service`）是指为了方便传输，将大块数据分割成以报文段（`segment`）为单位的数据包进行管理，而可靠的传输服务是指，能够把数据准确可靠地传给对方

`TCP` 协议为了更容易传送大数据才把数据分割，而且 `TCP` 协议能够确认数据最终是否送达到对方，为了准确无误地将数据送达目标处，`TCP` 协议采用了三次握手（`three way handshaking`）策略，用 `TCP` 协议把数据包送出去后，`TCP` 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达

握手过程中使用了 `TCP` 的标志 `SYN`（`synchronize`）和 `ACK`（`acknowledgement`），发送端首先发送一个带 `SYN` 标志的数据包给对方，接收端收到后，回传一个带有 `SYN/ACK` 标志的数据包以示传达确认信息，最后发送端再回传一个带 `ACK` 标志的数据包代表握手结束，若在握手过程中某个阶段莫名中断，`TCP` 协议会再次以相同的顺序发送相同的数据包


###### 负责域名解析的 DNS 服务

`DNS`（`Domain Name System`）服务是和 `HTTP` 协议一样位于应用层的协议，它提供域名到 `IP` 地址之间的解析服务，用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 `IP` 地址访问，但要让计算机去理解名称，相对而言就变得困难了，因为计算机更擅长处理一长串数字，为了解决上述的问题，`DNS` 服务应运而生，`DNS` 协议提供通过域名查找 `IP` 地址，或逆向从 `IP` 地址反查域名的服务







## HTTP 协议

`HTTP` 协议（`HyperText Transfer Protocol`，超文本传输协议）定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器，从层次的角度看，`HTTP` 是面向（`transaction-oriented`）应用层协议，它是万维网上能够可靠地交换文件（包括文本，声音，图像等各种多媒体文件）的重要基础，也是 `Web` 联网的基础

客户机需要通过 `HTTP` 协议传输所要访问的超文本信息，`HTTP` 包含命令和传输信息，不仅可用于 `Web` 访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成

我们在浏览器的地址栏里输入的网站地址叫做 `URL`（`Uniform Resource Locator`，统一资源定位符），当你在浏览器的地址框中输入一个 `URL` 或是单击一个超级链接时，`URL` 就确定了要浏览的地址，浏览器通过超文本传输协议（`HTTP`），将 `Web` 服务器上站点的网页代码提取出来，并翻译成我们最终所见到的网页

#### HTTP 工作流程

我们以下图为例，先来简单的梳理一下 `HTTP` 的整个工作流程，其实简单来说，就是请求与响应的过程

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-04.png)

`HTTP` 通信机制是在一次完整的 `HTTP` 通信过程中，客户端与服务器之间将完成下列七个步骤

###### 1、建立 TCP 连接

在 `HTTP` 工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 `TCP` 来完成的（即著名的 `TCP/IP` 协议族），`HTTP` 是比 `TCP` 更高层次的应用层协议（可以参考上面的网络模型划分），根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此首先要建立 `TCP` 连接，一般 `TCP` 连接的端口号是 `80`

###### 2、客户端向服务器发送请求命令

一旦建立了 `TCP` 连接，客户端就会向服务器发送请求命令，例如

```js
GET /index.html HTTP/1.1
Host: baidu.com
```

###### 3、客户端发送请求头信息

客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送

###### 4、服务器应答

客户端向服务器发出请求后，服务器会客户端返回响应，例如

```js
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2019 20:50:15 GMT
```

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

###### 5、服务器返回响应头信息

正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档

###### 6、服务器向客户端发送数据

服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着它就以 `Content-Type` 响应头信息所描述的格式发送用户所请求的实际数据

###### 7、服务器关闭 TCP 连接

一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 `TCP` 连接，然后如果客户端或者服务器在其头信息加入了 `Connection: keep-alive`，`TCP` 连接在发送后将仍然保持打开状态，于是客户端可以继续通过相同的连接发送请求，保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽


#### HTTP 协议特点

这里主要涉及到的是一些关于 `HTTP` 协议特点的基础知识

###### 通过请求和响应的交换达成通信

应用 `HTTP` 协议时，必定是一端担任客户端角色，另一端担任服务器端角色，仅从一条通信线路来说，服务器端和客服端的角色是确定的，`HTTP` 协议规定，请求从客户端发出，最后服务器端响应该请求并返回，换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应


###### HTTP 是不保存状态的协议

`HTTP` 是一种无状态协议，协议自身不对请求和响应之间的通信状态进行保存，也就是说在 `HTTP` 这个级别，协议对于发送过的请求或响应都不做持久化处理，这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 `HTTP` 协议设计成如此简单的

可是随着 `Web` 的不断发展，我们的很多业务都需要对通信状态进行保存，于是我们引入了 `Cookie` 技术，有了 `Cookie` 再用 `HTTP` 协议通信，就可以管理状态了


###### 使用 Cookie 的状态管理

`Cookie` 技术通过在请求和响应报文中写入 `Cookie` 信息来控制客户端的状态，`Cookie` 会根据从服务器端发送的响应报文内的一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存`Cookie`，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 `Cookie` 值后发送出去，服务器端发现客户端发送过来的 `Cookie` 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-05.png)



###### 请求 URI 定位资源

`HTTP` 协议使用 `URI` 定位互联网上的资源，正是因为 `URI` 的特定功能，在互联网上任意位置的资源都能访问到，但是我们在平时听到或者见到更多的应该是 `URL`（`Uniform Resource Locator`，统一资源定位符），那么这两者有什么区别呢？

用大白话来说就是，`URI` 是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫 `URI`，本来设想的的使用两种方法定位，`URL`（地址定位）和 `URN`（名称定位），只是后来 `URN` 没流行起来，导致几乎目前所有的 `URI` 都是 `URL`，所以这里我们就以 `URL` 为例，如下所示

```js                      
 协议      IP 地址     资源的具体位置
  |          |              |
  |          |              |
-----  ----------------  -------
http://192.168.1.1:8888/index.html
```

* 第一部分是协议（或称为服务方式）
* 第二部分是存有该资源的主机 `IP` 地址（有时也包括端口号）
* 第三部分是主机资源的具体位置（如目录和文件名等）
* 第一部分和第三部分之间用 `'：//'` 符号隔开，第二部分和第三部分用 `'/'` 符号分隔，第一部分和第二部分是不可缺少的，第三部分有时也可以省略





###### 告知服务器意图的 HTTP 方法

也就是 `HTTP/1.1` 当中可使用的方法，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-06.png)

这里有几个需要注意的地方

* `HTTP/1.1` 的 `DELETE` 方法本身和 `PUT` 方法一样不带验证机制，所以一般的 `Web` 网站也不使用 `DELETE` 方法，当配合 `Web` 应用程序的验证机制，或遵守 `REST` 标准时还是有可能会开放使用的
* 客户端通过 `TRACE` 方法可以查询发送出去的请求是怎样被加工修改/篡改的，这是因为请求想要连接到源目标服务器可能会通过代理中转，`TRACE` 方法就是用来确认连接过程中发生的一系列操作，但是 `TRACE` 方法本来就不怎么常用，再加上它容易引发 `XST`（`Cross-Site Tracing`，跨站追踪）攻击，通常就更不会用到了


###### 持久连接

`HTTP` 协议的初始版本中，每进行一个 `HTTP` 通信都要断开一次 `TCP` 连接，比如使用浏览器浏览一个包含多张图片的 `HTML` 页面时，在发送请求访问 `HTML` 页面资源的同时，也会请求该 `HTML` 页面里包含的其他资源，因此每次的请求都会造成无谓的 `TCP` 连接建立和断开，增加通信量的开销

为了解决上述 `TCP` 连接的问题，`HTTP/1.1` 和部分 `HTTP/1.0` 想出了持久连接的方法，其特点是只要任意一端没有明确提出断开连接，则保持 `TCP` 连接状态，旨在建立一次 `TCP` 连接后进行多次请求和响应的交互，在 `HTTP/1.1` 中，所有的连接默认都是持久连接


###### 管线化

持久连接使得多数请求以管线化方式发送成为可能，以前发送请求后需等待并接收到响应，才能发送下一个请求，管线化技术出现后，不用等待亦可发送下一个请求，这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了

比如当请求一个包含多张图片的 `HTML` 页面时，与挨个连接相比，用持久连接可以让请求更快结束，而管线化技术要比持久连接速度更快，请求数越多，时间差就越明显









## HTTP 报文

用于 `HTTP` 协议交互的信息被称为 `HTTP` 报文，请求端（客户端）的 `HTTP` 报文叫做请求报文，响应端（服务器端）的叫做响应报文，在规范当中把 `HTTP` 请求分为三个部分，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/07-01.png)

每条报文都包含一条来客户端的请求，或者一条来自客户端的响应，它们由三个部分组成，对报文进行描述的请求行（`start line`）、包含属性的请求头（`header`）以及可选的包含数据的请求体（`body`），请求行与请求头就是由行分隔的 `ASCII` 文本，每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符，这个行终止符可以写作 `CRLF`（空行）

> 注意，尽管 `HTTP` 规范中说明应该用 `CRLF` 来表示行终止，但稳健的做法也应该接受单个换行符作为行的终止

#### 请求报文

`HTTP` 请求报文由 **请求行**、**请求头**、**空行**（有时会忽略掉这一部分）和 **请求体**（请求数据）四个部分组成，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/07-02.png)

我们可以针对上图当中的内容简化一下，就变成了下面这样

```html
<method> <request-URL> <version>
<header>
 
<entity-body>
```

与其相对应的 `HTTP` 请求的报文如下

```html
GET /index.html HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.110 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,id;q=0.4
Cookie: PSTM=1490844191; BIDUPSID=2145FF54639208435F60E1E165379255;
这里是空行（CRLF）
```

###### 请求行

其中，下面的这行就是请求行

```js
GET /index.html HTTP/1.1
```

* 开头的 `GET` 表示请求访问服务器的类型，称为方法，[HTTP/1.1 协议](https://www.ietf.org/rfc/rfc2616.txt) 规定的 `HTTP` 请求方法有 `OPTIONS`、`GET`、`HEAD`、`POST`、`PUT`、`DELETE` 等，一般比较常用的是 `GET` 和 `POST` 这两个方法
* 随后的字符串 `/index.htm` 指明了请求访问的资源对象，也叫做请求 `URI`，如果直接与服务器进行对话，只要 `URL` 的路径部分是资源的绝对路径，通常就不会有什么问题
* 最后的 `HTTP/1.1`，即 `HTTP` 的版本号，用来提示客户端使用的 `HTTP` 协议功能，其格式通常是 `http/<major>.<minor>`，其中主版本号（`major`）与次版本号（`minor`）都是整数

综合来看，大意是请求访问某台 `HTTP` 服务器上的 `/index.htm` 页面资源

###### 请求头

报文头包含若干个属性，格式为 `key: value` 形式的键值对，服务端据此获取客户端的信息，可以有零个或多个报文头，每个报文头都包含一个名字，后面跟着一个英文冒号（`:`），然后是一个可选的空格，接着是一个值，最后是一个 `CRLF`，报文头是由一个空行（`CRLF`）结束的，表示了报文头列表的结束和实体主体部分的开始，有些 `HTTP` 版本，比如 `HTTP/1.1`，要求有效的请求或响应报文中必须包含特定的报文头

> 关于首部字段的相关内容，会在后面的 `HTTP` 首部字段章节当中来详细进行介绍


###### 空行（请求）

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头


###### 请求体

它将一个页面表单中的组件值通过键值对形式编码成一个格式化串，它承载多个请求参数的数据，报文体可以传递请求参数，请求 `URL` 也可以通过类似于 `/index.html?param1=value1&param2=value2` 的方式传递请求参数，请求数据不在 `GET` 方法中使用，而是在 `POST` 方法中使用，与请求数据相关的最常使用的请求头是 `Content-Type` 和 `Content-Length`



#### 响应报文

`HTTP` 的响应报文由 **状态行**、**响应头**、**空行**（有时会忽略掉这一部分）和 **响应体** 四部分组成，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/07-03.png)

响应报文也可以进行简化，如下

```html
<version><status><reason-phrase>
<headers>
 
<entity-body>
```

下面是一个响应报文示例

```js
HTTP/1.1 200 OK
Server: bfe/1.0.8.18
Date: Thu, 30 Mar 2019 12:28:00 GMT
Content-Type: text/html; charset=utf-8
Connection: keep-alive
Cache-Control: private
Expires: Thu, 30 Mar 2019 12:27:43 GMT
Set-Cookie: BDSVRTM=0; path=/
```

###### 状态行

状态行也大致分为四个部分 `HTTP-Version`（`HTTP` 协议版本），`Status-Code`（状态码），`Reason-Phrase`（状态码描述），`CRLF`（回车/换行符）

其中状态码（`Status-Code`）的格式是三位数字，其描述了请求过程中所发生的情况，每个状态码的第一位数字用于描述状态的一般类别，一般是由以下五段组成

* `1xx`，处理中，一般是告诉客户端，请求已经收到了，正在处理
* `2xx`，处理成功，一般表示请求已受理、已经处理完成等信息
* `3xx`，重定向到其它地方，它让客户端再发起一个请求以完成整个处理
* `4xx`，处理发生错误，错误发生在 **客户端**，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等
* `5xx`，处理发生错误，错误发生在 **服务端**，如服务端抛出异常，路由出错，`HTTP` 版本不支持等

> 关于状态码的相关内容，会在后面的 `HTTP` 状态码章节当中来详细进行介绍

而紧跟着后面的状态码描述（`Reason-Phrase`），也就是所谓的原因短语，数字状态码的可读版本，包含行终止序列之前的所有文本，原因短语只对人类有意义，比如说，尽管响应行 `HTTP/1.1 200 NOT OK` 和 `HTTP/1.1 200 OK` 中原因短语的含义不同，但同样都会被当作成功的标志，下面是一个假想的请求报文与响应报文

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/07-04.png)

不过需要注意的是，一组 `HTTP` 报文头总是应该以一个空行（仅有 `CRLF`）结束，甚至即使没有报文头和实体的主体部分也应该如此，但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误的）省略了最后的 `CRLF`，为了与这些流行但不符合规则的实现兼容，客户端和服务器都应该接受那些没有最后那个 `CRLF` 的报文


###### 响应头

响应头也是由格式为 `key: value` 形式的键值对组成，响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 `Request-URI` 进一步的信息

> 关于首部字段的相关内容，会在后面的 `HTTP` 首部字段章节当中来详细进行介绍


###### 空行（响应）

最后一个响应头之后是一个空行，发送回车符和换行符，通知浏览器以下不再有响应头


###### 响应体

服务器返回给浏览器的响应信息，下面是百度首页的响应体片段

```html
<!DOCTYPE html>
<!--STATUS OK-->
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <link rel="icon" sizes="any" mask href="//www.baidu.com/img/baidu.svg">
  <title>百度一下，你就知道</title>
</head>
<body>
  ...
</body>
</html>
```



## HTTP 首部字段


* `User-Agent`，用户代理信息（比如上面的 `Mozilla/5.0 ...`）
* `Accept`，客户端可识别的内容类型列表（`text/html,application/xhtml+xml,application/xml;`）
  * 请求报文可通过一个 `Accept` 报文头属性告诉服务端，客户端接受什么类型的响应
  * `Accept` 属性的值可以为一个或多个 `MIME` 类型的值，关于 `MIME` 类型可以见 [内容类型](https://zh.wikipedia.org/wiki/多用途互聯網郵件擴展#内容类型)
* `Accept-Language`，客户端可接受的自然语言（`zh-CN,zh;q=0.8,en;q=0.6,id;q=0.4`）
* `Accept-Encoding`，客户端可接受的编码压缩格式（`gzip, deflate, sdch, br`）
* `Host`，请求的主机名，允许多个域名同处一个 `IP` 地址，即虚拟主机（`www.baidu.com`）
* `connection`，连接方式
* `close`，告诉 `Web` 服务器或代理服务器，在完成本次请求的响应后，断开连接
* `keep-alive`，告诉 `Web` 服务器或代理服务器，在完成本次请求的响应后，保持连接，以等待后续请求
* `Cookie`，存储于客户端扩展字段，向同一域名的服务端发送属于该域的 `Cookie`（`PSTM=1490844191; BIDUPSID=2145FF54639208435F60E1E165379255;`）
  * 客户端的 `Cookie` 通过报文头的 `Cookie` 属性来传给服务端
  * 服务端就是通过 `HTTP` 请求报文头的 `Cookie` 属性的 `sessionId` 的值把用户关联起来的
* `Referer`，表示这个请求是从哪个 `URL` 过来的，比如广告商就可以得知某个用户是哪一个源头过来的
* `Cache-Control`，对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的 
  * 如设置 `Cache-Control: no-cache` 则相当于让服务端将对应请求返回的响应内容不要在客户端缓存



## HTTP 报文实体

我们在之前的 `HTTP` 报文章节当中介绍了请求报文与响应报文相关内容，我们也了解了一些 `HTTP` 报文结构的相关内容，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-07.png)

#### HTTP 报文实体概述

我们在上面的示例当中可以了解到各个组成部分对应的内容，这里我们主要来看报文和实体的概念，如果把 `HTTP` 报文想象成因特网货运系统中的箱子，那么 `HTTP` 实体就是报文中实际的货物

* 报文，是网络中交换和传输的数据单元，即站点一次性要发送的数据块，报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变
* 实体，作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成（实体首部相关内容在上面第六点中已有阐述）

我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体，而左图中粉红框内容就是报文主体

> 通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异




#### 内容编码

`HTTP` 应用程序有时在发送之前需要对内容进行编码，例如在把很大的 `HTML` 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间，服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容

这种类型的编码是在发送方应用到内容之上的，当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方，常见的内容编码类型有以下这几个

编码方式 | 描述
-|-
`gzip` | 表明实体采用 `GNU zip` 编码
`compress` | 表明实体采用 `Unix` 的文件压缩程序
`deflate` | 表明实体采用 `zlib` 的格式压缩的
`identity` | 表明没有对实体进行编码，当没有 `Content-Encoding` 首部字段时，默认采用此编码方式




#### 传输编码

在 `HTTP` 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码（`ChunkedTransfer Coding`）

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-08.png)




#### 分块编码

分块编码把报文分割成若干已知大小的块，块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了，分块编码是一种传输编码，是报文的属性

若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止，当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 `Content-Length` 首部中发送，如果服务器动态创建内容，就可能在发送之前无法知道主体的长度

分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了，因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程，服务器可以用大小为 `0` 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备，来看一个分块编码的报文示例

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-09.png)




#### 多部分媒体类型

`MIME` 中的 `multipart`（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送，每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起，相应的 `HTTP` 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体，多部分对象集合包含的对象如下

* `multipart/form-data`，在 `Web` 表单文件上传时使用
* `multipart/byteranges`，状态码 `206 Partial Content` 响应报文包含了多个范围的内容时使用

在这里多提一点，就是关于 `POST` 请求，协议规定 `POST` 提交的数据必须放在消息主体（`entity-body`）中，但协议中并没有规定数据必须使用什么编码方式，实际上开发者完全可以自己决定消息主体的格式，只要最后发送的 `HTTP` 请求满足上面的格式就可以

服务端通常是根据请求头（`headers`）中的 `Content-Type` 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析，所以说到 `POST` 提交数据方案，包含了 `Content-Type` 和消息主体编码方式两部分，下面是指定为几种类型后的区别



###### application/x-www-form-urlencoded

这个也就是所谓的表单提交方式了，浏览器的原生 `<form>` 表单，如果不设置 `enctype` 属性，那么最终就会以 `application/x-www-form-urlencoded` 方式提交数据，请求类似于下面这样

```js
POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&to=Mom
```

可以发现 `Content-Type` 被指定为 `application/x-www-form-urlencoded`，传递的是对应的 `key` 和 `val`



###### multipart/form-data

这种方式一般用来上传文件，也是一种常见的 `POST` 数据提交的方式，在我们使用表单上传文件时，必须让 `<form>` 表单的 `enctype` 等于 `multipart/form-data`

```js
POST /test.html HTTP/1.1 
Host: example.org 
Content-Type: multipart/form-data;boundary="boundary" 

--boundary 
Content-Disposition: form-data; name="field1" 

value1 
--boundary 
Content-Disposition: form-data; name="field2"; filename="example.txt" 

value2
```

首先生成了一个 `boundary` 用于分割不同的字段，为了避免与正文内容重复，`boundary` 很长很复杂，然后 `Content-Type` 里指明了数据是以 `multipart/form-data` 来编码，指明本次请求的 `boundary` 是什么内容，消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 `--boundary` 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）

如果传输的是文件，还要包含文件名和文件类型信息，消息主体最后以 `--boundary--` 标示结束，上面提到的这两种 `POST` 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 `<form>` 表单 [也只支持](https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4) 这两种方式，通过 `<form>` 元素的 `enctype` 属性指定，默认为 `application/x-www-form-urlencoded`，其实 `enctype` 还支持 `text/plain`，不过用得比较少


###### application/json

`application/json` 这个 `Content-Type` 一般用来告诉服务端消息主体是序列化后的 `JSON` 字符串，`JSON` 格式支持比键值对复杂得多的结构化数据，`AngularJS` 中的 `Ajax` 功能，默认就是提交 `JSON` 字符串

```js
var data = { 'title': 'test', 'sub': [1, 2, 3] };
$http.post(url, data).success(function (result) {
  // ...
});
```

最终发送的请求是

```js
POST http://www.example.com http/1.1 
Content-Type: application/json;charset=utf-8

{"title":"test","sub":[1,2,3]}.
```

这种方案，可以方便的提交复杂的结构化数据，特别适合 `RESTful` 的接口


###### text/xml

这种方案现在一般使用较少，`XML` 作为编码方式的远程调用规范，典型的 `XML-RPC` 请求是这样的

```xml
POST http://www.example.com http/1.1 
Content-Type: text/xml

<?xml version="1.0"?>
<methodCall>
  <methodName>examples.getStateName</methodName>
  <params>
    <param>
      <value><i4>41</i4></value>
    </param>
  </params>
</methodCall>
```

`XML-RPC` 协议简单、功能够用，各种语言的实现都有，`JavaScript` 中，也有类似 [XML-RPC over AJAX](https://plugins.jquery.com/xmlrpc/) 这样的库来支持以这种方式进行数据交互，能很好的支持已有的 `XML-RPC` 服务，不过，`XML` 结构过于臃肿，一般场景用 `JSON` 会更灵活方便




#### 范围请求

假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍，为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载，要实现该功能，这就要用到范围请求

有了范围请求，`HTTP` 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体，当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过，例如

```js
GET  /bigfile.html  HTTP/1.1
Host: www.sample.com
Range: bytes=20224-
···
```

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-10.png)


上面示例中，客户端请求的是文档开头 `20224` 字节之后的部分



#### 内容协商

同一个 `Web` 网站有可能存在着多份相同内容的页面，比如英语版和中文版的 `Web` 页面，它们内容上虽相同，但使用的语言却不同，当浏览器的默认语言为英语或中文，访问相同 `URI` 的 `Web` 页面时，则会显示对应的英语版或中文版的 `Web` 页面，这样的机制称为内容协商（`Content Negotiation`）

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准，包含在请求报文中的某些首部字段就是判断的基准，比如以下这些

* `Accept`
* `Accept-Charset`
* `Accept-Encoding`
* `Accept-Language`
* `Content-Language`

内容协商技术有以下三种类型，

类型 | 介绍
-|-
服务器驱动协商（`Server-driven Negotiation`） | 由服务器端进行内容协商，以请求的首部字段为参考，在服务器端自动处理，但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容
客户端驱动协商（`Agent-driven Negotiation`） | 由客户端进行内容协商的方式，用户从浏览器显示的可选项列表中手动选择，还可以利用 `JavaScript` 脚本在 `Web` 页面上自动进行上述选择，比如按 `OS` 的类型或浏览器类型，自行切换成 `PC` 版页面或手机版页面
透明协商（`Transparent Negotiation`） | 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法




## HTTP 状态码

`HTTP` 状态码负责表示客户端 `HTTP` 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作，状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误，比如状态码 `200 OK` ，以三位数字和原因短语组成，数字中的第一位指定了响应类别，后两位无分类，响应类别有以下五种

状态码| 类别 | 原因短语
 -|-|-
`1xx` | `Informational`（信息性状态码） | 接收的请求正在处理
`2xx` | `Success`（成功状态码） | 请求正常处理完毕
`3xx` | `Redirection`（重定向状态码） | 需要进行附加操作以完成请求
`4xx` | `Client Error`（客户端错误状态码） | 服务器无法处理请求
`5xx` | `Server Error`（服务器错误状态码） | 服务器处理请求出错

其实只要遵守状态码类别的定义，即使改变 `RFC2616` 中定义的状态码，或服务器端自行创建状态码都没问题，又因为 `HTTP` 状态码种类繁多，数量达几十种，但是比较常用的有以下这些，所以我们下面主要来看这些具有代表性质的状态码

* `2xx` 成功，该响应结果表明请求被正常处理了
  * `200 OK`，表示从客户端发来的请求在服务器端被正常处理了
  * `204 No Content`，代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，另外也不允许返回任何实体的主体，一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用
  * `206 Partial Content`，表示客户端进行了范围请求，而服务器成功执行了这部分的 `GET` 请求，响应报文中包含由 `Content-Range` 首部字段指定范围的实体内容
* `3xx` 重定向，表明浏览器需要执行某些特殊的处理以正确处理请求
  * `301 Moved Permanently`，永久性重定向，可以简单地理解为该资源已经被永久改变了位置，通常会发送 [HTTP Location](https://zh.wikipedia.org/wiki/HTTP_Location) 来 [重定向](https://zh.wikipedia.org/wiki/網域名稱轉址) 到正确的新位置
  * `302 Found`，临时性重定向，表示请求的资源已被分配了新的 `URI`，希望用户（本次）能使用新的 `URI` 访问，和 `301 Moved Permanently` 状态码相似，但 `302 Found` 状态码代表资源不是被永久移动，只是临时性质的，换句话说，已移动的资源对应的 `URI` 将来还有可能发生改变
  * `303 See Other`，表示由于请求的资源存在着另一个 `URI`，应使用 `GET` 方法定向获取请求的资源，`303 See Other` 和 `302 Found` 状态码有着相同的功能，但 `303 See Other` 状态码明确表示客户端应采用 `GET` 方法获取资源，这点与 `302 Found` 状态码有区别（当 `301`、`302`、`303` 响应状态码返回时，几乎所有的浏览器都会把 `POST` 改成 `GET`，并删除请求报文内的主体，之后请求会自动再次发送，本质上 `301`、`302` 标准是禁止将 `POST` 方法改变成 `GET` 方法的，但实际使用时大家都会这么做）
  * `304 Not Modified`，未修改，自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，也就是说当访问资源出现 `304` 访问的情况下其实就是浏览器先在本地缓存了访问的资源，然后直接返回了缓存的资源，这里涉及到了请求头中的两个请求参数 `If-Modified-Since` 和 `If-None-Match`，详细可见上方的 `HTTP` 首部字段章节
  * `307 Temporary Redirect`，临时重定向，该状态码与 `302 Found` 有着相同的含义，尽管 `302` 标准禁止 `POST` 变换成 `GET`，但实际使用时大家并不遵守，`307` 会遵照浏览器标准，不会从 `POST` 变成 `GET`，但是对于处理响应时的行为，每种浏览器有可能出现不同的情况
* `4xx` 客户端错误，表明客户端是发生错误的原因所在
  * `400 Bad Request`，错误请求，服务器不理解请求的语法，常见于客户端传参错误
  * `401 Unauthorized`，未授权，表示发送的请求需要有通过 `HTTP` 认证（`BASIC` 认证、`DIGEST` 认证）的认证信息，常见于客户端未登录
  * `403 Forbidden`，禁止访问，表明对请求资源的访问被服务器拒绝了，常见于客户端权限不足，未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 `IP` 地址试图访问）等列举的情况都可能是发生 `403` 的原因
  * `404 Not Found`，未找到，服务器找不到对应资源，除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用
* `5xx` 服务器错误，结果表明服务器本身发生错误
  * `500 Inter Server Error`，表明服务器端在执行请求时发生了错误，无法完成请求，也可能是 `Web` 应用存在的某些临时的故障
  * `501 Not Implemented`，尚未实施，服务器不具备完成请求的功能
  * `502 Bad Gateway`，作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
  * `503 service unavailable`，服务不可用，服务器目前无法使用（处于超载或停机维护状态）通常是暂时状态

> 这里需要注意一点，不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如 `Web` 应用程序内部发生错误，状态码依然返回 `200 OK`，这种情况也经常遇到






## 代理、网关、隧道、缓存

`HTTP` 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道等，它们可以配合服务器工作，这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端

#### 代理

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-11.png)

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器，代理不改变请求 `URI`，会直接发送给前方持有资源的目标服务器，持有资源实体的服务器被称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-12.png)

在 `HTTP` 通信过程中，可级联多台代理服务器，请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器，转发时需要附加 `Via` 首部字段以标记出经过的主机信息，使用代理服务器可以利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等

代理有多种使用方法，按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文

* 缓存代理，代理转发响应时，缓存代理（`Caching Proxy`）会预先将资源的副本（缓存）保存在代理服务器上，当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回
* 透明代理，转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（`Transparent Proxy`），反之对报文内容进行加工的代理被称为非透明代理



#### 网关

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-13.png)

网关是一种特殊的服务器，作为其他服务器的中间实体使用，网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非 `HTTP` 协议服务，利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全，比如网关可以连接数据库，使用 `SQL` 语句查询数据，另外在 `Web` 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动



#### 隧道

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-14.png)

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 `SSL` 等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全的通信，隧道本身不会去解析 `HTTP` 请求，也就是说，请求保持原样中转给之后的服务器，隧道会在通信双方断开连接时结束

`HTTP` 隧道的一种常见用途就是通过 `HTTP` 连接承载加密的安全套接字层（`SSL`）流量，这样 `SSL` 流量就可以穿过只允许 `Web` 流量通过的防火墙了


#### 缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间，缓存服务器是代理服务器的一种，并归类在缓存代理类型中，换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/10-15.png)

缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源，因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了

#### 缓存的有效期限

即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求，因为这关系到被缓存资源的有效性问题，当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的旧资源了，即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性，若判断缓存失效，缓存服务器将会再次从源服务器上获取新资源

#### 客户端的缓存

缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中，浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取，另外和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源

> 其实关于浏览器的缓存机制，更多的是与 `cache-control`，`max-age`，`Expires` 等头部字段有关，详细可以参考上方的 `HTTP` 首部字段当中的相关内容


## HTTPS

* 待整理

## 用户认证

* 待整理

## 追加协议

* 待整理

## 安全

* 待整理