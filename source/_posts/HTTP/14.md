---
title: TCP/IP 协议
date: 2020-09-20
categories: HTTP
tags: HTTP
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/14.jpg
---

在之前的章节当中，我们梳理了 [HTTP 协议](https://heptaluan.github.io/2020/09/01/HTTP/10/)，[HTTPS](https://heptaluan.github.io/2020/08/09/HTTP/09/)，[HTTP/2](https://heptaluan.github.io/2020/09/06/HTTP/11/) 和 [HTTP/3](https://heptaluan.github.io/2020/09/12/HTTP/12/) 的一些相关内容，本章我们再来看看姑且算是最后一部分内容，也就是 `TCP/IP` 协议相关内容，因为这部分内容在平常的工作之中接触有限，所以在这里简单记录一下也就当做是扩展知识了，内容主要参考的是 [图解 TCP/IP](https://book.douban.com/subject/24737674/)，更多相关内容可以参考 [计算机网络知识梳理](https://heptaluan.github.io/2020/08/08/HTTP/00/) 和 [前端知识体系整理](https://heptaluan.github.io/target/)

<!--more-->



## 协议

`TCP/IP` 是通信协议的统称，不过在此之前，我们有必要先来理清协议的概念，在计算机网络与信息通信领城里，人们经常提及协议一词，互联网中常用的具有代表性的协议有 `IP`、`TCP`、 `HTTP` 等，而 `LAN`（局域网）中常用的协议有 `IPX/SPX` 等，计算机网络体系结构将这些网络协议进行了系统的归纳，`TCP/IP` 就是 `IP`、`TCP`、`HTTP` 等协议的集合

网絡体系结构 | 协议 | 主要用途
-|-|-
`TCP/IP` | `IP/ICMP/TCP/UDP/HTTP/TELNET/SNMP/SMTP` 等 | 互联网、局城网
`IPX/SPX`（`NetWare`） | `IPX/SPX/NPC` 等 | 个人电脑局域网
`AplcTalk` | `DDP/RTMP/AEP/ATP/ZIP` 等 | 苹果公司现有产品的局城网
`DECnet` | `DPR/NSP/SCP` 等 | 前 `DEC` 小型机
`OSI` | `FTAM/MOTIS/VT/CMIS/CMIP,CLNP/CONP` | -
`XNS` | `IDP/SPP/PEP` 等 | 施乐公司网络


#### 协议的必要性

简单来说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种约定，这种约定使那些由不同厂商的设备、不同的 `CPU` 以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信，反之如果所使用的协议不同，就无法实现通信，但是在计算机通信诞生之初，系统化与标准化并未得到足够的重视，每家计算机厂商都出产各自的网络产品来实现计算机通信，对于协议的系统化、分层化等事宜没有特别强烈的意识

为了解决上述问题，`ISO` 制定了一个国际标准 `OSI`，对通信系统进行了标准化，现在 `OSI` 所定义的协议虽然并没有得到普及，但是在 `OSI` 协议设计之初作为其指导方针的 `OSI` 参考模型却常被用于网络协议的制定当中

但是我们在本章当中介绍的 `TCP/IP` 并非 `ISO` 所制定的某种国际标准，而是由 `IETF` 所建议的、致力于推进其标准化作业的一种协议，在当时大学等研究机构和计算机行业作为中心力量，推动了 `TCP/IP` 的标准化进程，`TCP/IP` 作为互联网之上的一种标准，也作为业界标准，俨然已成为全世界所广泛应用的通信协议，那些础知识支持互联网的设备及软件，也正着力遵循由 `IETF` 标准化的 `TCP/IP` 协议

协议得以标准化也使所有遵循标准协议的设备不再因计算机硬件或操作系统的差异而无法通信，因此协议的标准化也推动了计算机网络的普及


## OSI 参考模型

`IS0` 在制定标准化 `OSI` 之前，对网络体系结构相关的问题进行了充分的讨论，最终提出了作为通信协议设计指标的 `OSI` 参考模型，这一模型将通信协议中必要的功能分成了七层，通过这些分层，使得那些比较复杂的网络协议更加简单化，在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务

* 上下层之间进行交互时所遵循的约定叫做接口
* 同一层之间的交互所遵循的约定叫做协议

协议分层就如同计算机软件中的模块化开发，`OSI` 参考模型的建议是比较理想化的，它希望实现从第一层到第七层的所有模块，并将它们组合起来实现网络通信，分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及整个系统，因此可以构造一个扩展性和灵活性都较强的系统

* 此外通过层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务，这些都属于分层的优点
* 而分层的劣势，可能就在于过分模块化、使处理变得更加沉重以及每个模块都不得不实现相似的处理:逻辑等问题


`OSI` 参考模型如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-06.png)

不过，`OSI` 参考模型终究只是一个模型，它也只是对各层的作用做了一系列粗略的界定，并没有对协议和接口进行详细的定义，它对学习和设计协议只能起到一个引导的作用，许多通信协议，都对应了  `OSI` 参考模型七个分层中的某层，通过这一点，可以大致了解该协议在整个通信功能中的位置和作用

> 这里需要区分开来 `OSI` 协议与 `OSI` 参考模型

* `OSI` 协议是为了让异构的计算机之间能够相互通信的、由 `ISO` 和 `ITU-T` 推进其标准化的一种网絡体系结构，`OST`（参考模型）将通信功能划分为七个分层，称作 `OSI` 参考模型
* 而 `OSI` 协议以 `OSI` 参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准，遵循 `OSI` 协议的产品叫 `OSI` 产品，而它们所遵循的通信则被称为 `OSI` 通信



## TCP/IP 基础

从字面意义上讲，有人可能会认为 `TCP/IP` 是指 `TCP` 和 `IP` 两种协议，实际生活当中有时也确实就是指这两种协议，然而在很多情况下，它只是利用 `IP` 进行通信时所必须用到的协议群的统称，具体来说，`IP` 或 `ICMP`、`TCP` 或 `UDP`、`TELNET` 或 `FTP`、以及 `HTTP` 等都属于 `TCP/IP` 协议，他们与 `TCP` 或 `IP` 的关系紧密，是互联网必不可少的组成部分，`TCP/IP` 一词泛指这些协议

因此，有时也称 `TCP/IP` 为网际协议群，互联网进行通信时，需要相应的网络协议，`TCP/IP` 原本就是为使用互联网而开发制定的协议族，因此互联网的协议就是 `TCP/IP`，`TCP/IP` 就是互联网的协议

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-07.png)




## TCP/IP 协议分层模型

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg tr:nth-child(odd) td {background-color: transparent !important;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-nrix{text-align:center;vertical-align:middle}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-c3ow"><code>OSI</code> 七层模型</th>
    <th class="tg-baqh"><code>TCP/IP</code> 概念层模型</th>
    <th class="tg-baqh">功能</th>
    <th class="tg-baqh"><code>TCP/IP</code> 协议族</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-baqh">应用层</td>
    <td class="tg-nrix" rowspan="3">应用层</td>
    <td class="tg-baqh">文件传输，电子邮件,文件服务，虛拟终端</td>
    <td class="tg-baqh"><code>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</code></td>
  </tr>
  <tr>
    <td class="tg-baqh">表示层</td>
    <td class="tg-baqh">数据格式化,代码转换，数据加密</td>
    <td class="tg-baqh">没有协议</td>
  </tr>
  <tr>
    <td class="tg-baqh">会话层</td>
    <td class="tg-baqh">解除或建立与别的接点的联系</td>
    <td class="tg-baqh">没有协议</td>
  </tr>
  <tr>
    <td class="tg-baqh">传输层</td>
    <td class="tg-baqh">传输层</td>
    <td class="tg-baqh">提供端对端的接口</td>
    <td class="tg-baqh"><code>TCP，UDP</code></td>
  </tr>
  <tr>
    <td class="tg-baqh">网络层</td>
    <td class="tg-baqh">网络层</td>
    <td class="tg-baqh">为数据包选择路由</td>
    <td class="tg-baqh"><code>IP，ICIP，RIP，0SPF，BGP，IGMP</code></td>
  </tr>
  <tr>
    <td class="tg-baqh">数据链路层</td>
    <td class="tg-nrix" rowspan="2">链路层</td>
    <td class="tg-baqh">传输有地址的帧以及错误检测功能</td>
    <td class="tg-baqh"><code>SLIP，CSLIP，PPP，ARP，RARP，MTU</code></td>
  </tr>
  <tr>
    <td class="tg-baqh">物理层</td>
    <td class="tg-baqh">以二进制数据形式在物理媒体上传输数据</td>
    <td class="tg-baqh"><code>ISO2110，IEEE802，IEEE802.2</code></td>
  </tr>
</tbody>
</table>

不难看出，`TCP/IP` 与 `OSI` 在分层模块上稍有区别，`OSI` 参考模型注重「通信协议必要的功能是什么」，而 `TCP/IP` 则更强调「在计算机上实现协议应该开发哪种程序」




## 数据包

包、帧、数据包、段、消息以上五个术语都用来表述数据的单位，大致区分如下

* 包可以说是全能性术语
* 帧用于表示数据链路层中包的单位
* 数据包是 `IP` 和 `UDP` 等网络层以上的分层中包的单位
* 段则表示 `TCP` 数据流中的信息
* 消息是指应用协议中数据的单位

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-09.png)

每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息，通常为协议提供的信息为包首部，所要发送的内容为数据

如上图，在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据，网络中传输的数据包由两部分组成

* 一部分是协议所要用到的首部
* 另一部分是上一层传过来的数据

首部的结构由协议的具体规范详细定义，在数据包的首部，明确标明了协议应该如何读取数据，反过来说，看到首部也就能够了解该协议必要的信息以及所要处理的数据，「包首部就像协议的脸」




## 数据处理流程

我们以一个发送邮件的流程为例，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-10.png)

1. 应用程序处理首先应用程序会进行编码处理，这些编码相当于 `OSI` 的表示层功能，编码转化后邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 `OSI` 的会话层功能
2. `TCP` 模块的处理，`TCP` 根据应用的指示，负责建立连接、发送数据以及断开连接，`TCP` 提供将应用层发来的数据顺利发送至对端的可靠传输，为了实现这一功能，需要在应用层数据的前端附加一个 `TCP` 首部
3. `IP` 模块的处理，`IP` 将 `TCP` 传过来的 `TCP` 首部和 `TCP` 数据合起来当做自己的数据，并在 `TCP` 首部的前端加上自己的 `IP` 首部，`IP` 包生成后，参考路由控制表决定接受此 `IP` 包的路由或主机
4. 网络接口（以太网驱动）的处理从 `IP` 传过来的 `IP` 包对于以太网来说就是数据，给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端
5. 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 `MAC` 地址判断是否为发送给自己的包，若不是则丢弃数据，如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 `IP`、`ARP` 等，这里的例子则是 `IP` 
6. `IP` 模块的处理`IP` 模块接收到 数据后也做类似的处理，从包首部中判断此 `IP` 地址是否与自己的 `IP` 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 `TCP`、`UDP`，这里的例子则是 `TCP`，另外对于有路由器的情况，接收端地址往往不是自己的地址，此时需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据
7. `TCP` 模块的处理在 `TCP` 模块中，首先会计算一下校验和，判断数据是否被破坏，然后检查是否在按照序号接收数据，最后检查端口号，确定具体的应用程序，数据被完整地接收以后，会传给由端口号识别的应用程序
8. 应用程序的处理接收端应用程序会直接接收发送端发送的数据，通过解析数据，展示相应的内容




## IP 协议

`IP`（`IPv4`、`IPv6`）相当于 `OSI` 参考模型中的第三层（网络层），网络层的主要作用是「实现终端节点之间的通信」，这种终端节点之间的通信也叫「点对点通信」，而网络的下一层（数据链路层）的主要作用是在互连同一种数据链路的节点之间进行包传递，而一旦跨越多种数据链路，就需要借助网络层，网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输

`IP` 大致分为三大作用模块，它们是 `IP` 寻址、路由（最终节点为止的转发）以及 `IP` 分包与组包，下面我们就一个一个来介绍


#### IP 地址

在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识，在数据链路中的 `MAC` 地址正是用来标识同一个链路中不同计算机的一种识别码，作为网络层的 `IP` ,也有这种地址信息，一般叫做 `IP` 地址，`IP` 地址用于在「连接到网络中的所有主机中识别出进行通信的目标地址」，因此在 `TCP/IP` 通信中所有主机或路由器必须设定自己的 `IP` 地址，但是不论一台主机与哪种数据链路连接，其 `IP` 地址的形式都保持不变


#### IP 地址的定义

在用 `TCP/IP` 通信时，用 `IP` 地址识别主机和路由器，为了保证正常通信，有必要为每个设备配置正确的 `IP` 地址，在互联网通信中，全世界都必须设定正确的 `IP` 地址，否则，根本无法实现正常的通信，因此 `IP` 地址就像是 `TCP/IP` 通信的一块基石

`IP` 地址（`IPv4` 地址）由 `32` 位正整数来表示，`IP` 地址在计算机内部以二进制方式被处理，然而由于我们并不习惯于采用二进制方式，我们将 `32` 位的 `IP` 地址以每 `8` 位为一组，分成 `4` 组，每组以 `.`（点号）隔开，再将每组数转换成十进制数，如下

`2^8` | `2^8` | `2^8` | `2^8` | &nbsp;
-|-|-|-|-
`10101100` | `00010100` | `00000001` | `00000001` |  二进制
`10101100.` | `00010100.` | `00000001.` | `00000001` | 二进制
`172.` | `20.` | `1.` | `1` | 十进制


#### 组成

`IP` 地址由网络和主机两部分标识组成，如下图，网络标识在数据链路的每个段配置不同的值，网络标识必须保证相互连接的每个段的地址不相重复，而相同段内相连的主机必须有相同的网络地址，`IP` 地址的「主机标识」则不允许在同一个网段内重复出现，由此可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 `IP` 地址都不会相互重叠，即 `IP` 地址具有了唯一性

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-11.png)

`IP` 包被转发到途中某个路由器时，正是利用目标 `IP` 地址的网络标识进行路由，因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-12.png)


#### 分类

`IP` 地址分为四个级别，分别为 `A` 类、`B` 类、`C` 类、`D` 类，它根据 `IP` 地址中从第 `1` 位到第 `4` 位的比特列对其网络标识和主机标识进行区分

* `A` 类 `IP` 地址是首位以 `0` 开头的地址，从第 `1` 位到第 `8` 位是它的网络标识，用十进制表示的话，`0.0.0.0 ~ 127.0.0.0` 是 `A` 类的网络地址，`A` 类地址的后 `24` 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 `16777214` 个
* `B` 类 `IP` 地址是前两位 `10` 的地址，从第 `1` 位到第 `16` 位是它的网络标识，用十进制表示的话，`128.0.0.0 ~ 191.255.0.0` 是 `B` 类的网络地址，`B` 类地址的后 `16` 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 `65534` 个
* `C` 类 `IP` 地址是前三位为 `110` 的地址，从第 `1` 位到第 `24` 位是它的网络标识，用十进制表示的话，`192.0.0.0 ~ 223.255.255.0` 是 `C` 类的网络地址，`C` 类地址的后 `8` 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 `254` 个
* `D` 类 `IP` 地址是前四位为 `1110` 的地址，从第 `1` 位到第 `32` 位是它的网络标识，用十进制表示的话，`224.0.0.0 ~ 239.255.255.255` 是 `D` 类的网络地址，`D` 类地址没有主机标识，常用于多播

在分配 `IP` 地址时关于主机标识有一点需要注意，即要用比特位表示主机地址时，不可以全部为 `0` 或全部为 `1`，因为全部为 `0` 只有在表示对应的网络地址或 `IP` 地址不可以获知的情况下才使用，而全部为 `1` 的主机通常作为广播地址，因此在分配过程中，应该去掉这两种情况，这也是为什么 `C` 类地址每个网段最多只能有 `254`（`2^8 - 2 = 254`）个主机地址的原因



#### 广播地址

* 广播地址用于在同一个链路中相互连接的主机之间发送数据包，将 `IP` 地址中的主机地址部分全部设置为 `1`，就成了广播地址
* 广播分为本地广播和直接广播两种，在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播


#### IP 多播

* 多播用于将包发送给特定组内的所有主机，由于其直接使用 `IP` 地址，因此也不存在可靠传输
* 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-13.png)

多播使用 `D` 类地址，因此如果从首位开始到第 `4` 位是 `1110`，就可以认为是多播地址，而剩下的 `28` 位可以成为多播的组编号，此外对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 `224.0.0.1` 的组，所有的路由器必须属于 `224.0.0.2` 的组


#### 子网掩码

一个 `IP` 地址只要确定了其分类，也就确定了它的网络标识和主机标识，例如以下各类各自的网络标识部分

* `A` 类地址前 `8` 位（除首位 `0` 还有 `7` 位）
* `B` 类地址前 `16` 位（除首位 `10` 还有 `14` 位）
* `C` 类地址前 `24` 位（除首位 `110` 还有 `21` 位）

但是直接使用 `A` 类或 `B` 类地址，确实有些浪费，随着互联网的覆盖范围逐渐增大，网络地址会越来越不足以应对需求，直接使用 `A` 类、`B` 类、`C` 类地址就更加显得浪费资源，为此人们已经开始一种新的组合方式以减少这种浪费

现在，一个 `IP` 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做「子网掩码」的识别码通过子网网络地址细分出比 `A` 类、`B` 类、`C` 类更小粒度的网络，这种方式实际上就是将原来 `A` 类、`B` 类、`C` 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制

子网掩码用二进制方式表示的话，也是一个 `32` 位的数字，它对应 `IP` 地址网络标识部分的位全部为 `1`，对应 `IP` 地址主机标识的部分则全部为 `0`，由此，一个 `IP` 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度，当然子网掩码必须是 `IP` 地址的首位开始连续的 `1`

对于子网掩码，目前有两种表示方式，第一种是，将 `IP` 地址与子网掩码的地址分别用两行来表示，以 `172.20.100.52` 的前 `26` 位是网络地址的情况为例，如下

地址 | &nbsp; | &nbsp; | &nbsp; | &nbsp;
-|-|-|-|-
`IP` 地址 | `172.` | `20.` | `100.` | `52`
子网掩码 | `255.` | `255.` | `255.` | `192`
网络地址 | `172.` | `20.` | `100.` | `0`
子网掩码 | `255.` | `255.` | `255.` | `192`
广播地址 | `172.` | `20.` | `100.` | `63`
子网掩码 | `255.` | `255.` | `255.` | `192`

第二种表示方式是，在每个 `IP` 地址后面追加网络地址的位数用 `/` 隔开，如下

地址| &nbsp; | &nbsp; | &nbsp; | &nbsp; | &nbsp; 
-|-|-|-|-|-
`IP` 地址 |	`172.` | `20.` | `100.` |	`52`	| `/26`
网络地址 |	`172.` | `20.` | `100.` |	`0 ` | `/26`
广播地址 |	`172.` | `20.` | `100.` |	`63`	| `/26`


## 路由控制

发送数据包时所使用的地址是网络层的地址，即 `IP` 地址，然而仅仅有 `IP` 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于「指明路由器或主机」的信息，以便真正发往目标地址，保存这种信息的就是路由控制表，该路由控制表的形成方式有两种

* 一种是管理员手动设置（静态路由控制）
* 另一种是路由器与其他路由器相互交换信息时自动刷新（动态路由控制）

`IP` 协议始终认为路由表是正确的，`IP` 本身并没有定义制作路由控制表的协议，即 `IP` 没有制作路由控制表的机制，该表示由一个叫做「路由协议」的协议制作而成


#### IP 地址与路由控制

`IP` 地址的网络地址部分用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址，在发送 `IP` 包时，首先要确定 `IP` 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 `IP` 包转发给相应的下一个路由器，如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-14.png)

* 默认路由
  * 如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费，这时默认路由是不错的选择，默认路由是指路由表中任何一个地址都能与之匹配的记录
  * 默认路由一般标记为 `0.0.0.0/0` 或 `default`，这里的 `0.0.0.0/0` 并不是指 `IP` 地址是 `0.0.0.0`，由于后面是 `/0`，所以并没有标识 `IP` 地址，它只是为了避免人们误以为 `0.0.0.0` 是 `IP` 地址，有时默认路由也被标记为 `default`，但是在计算机内部和路由协议的发送过程中还是以 `0.0.0.0/0` 进行处理
* 主机路由
  * `/32` 也被称为主机路由（`Host Route`），例如 `192.168.153.15/32` 就是一种主机路由，它的意思是整个 `IP` 地址的所有位都将参与路由，进行主机路由，意昧着要基于主机上网卡上配置的 `IP` 地址本身，而不是基于该地址的网络地址部分进行路由
  * 主机路由多被用于不希望通过网络地址路由的情况
* 环回地址
  * 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址，计算机使用一个特殊的 `IP` 地址 `127.0.0.1` 作为环回地址，与该地址具有相同意义的是一个叫做 `localhost` 的主机名，使用这个 `IP` 或主机名时，数据包不会流向网络



#### IP 报文的分片与重组

* 每种数据链路的最大传输单元（`MTU`）都不尽相同，因为每个不同类型的数据链路的使用目的不同，使用目的不同，可承载的 `MTU` 也就不同
* 任何一台主机都有必要对 `IP` 分片进行相应的处理，分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理
* 经过分片之后的 `IP` 数据报在被重组的时候，只能由目标主机进行，路由器虽然做分片但不会进行重组


#### 路径 MTU 发现

* 分片机制也有它的不足，如路由器的处理负荷加重之类，因此只要允许，是不希望由路由器进行 `IP` 数据包的分片处理的
* 为了应对分片机制的不足，路径 `MTU` 发现技术应运而生，路径 `MTU` 指的是，从发送端主机到接收端主机之间不需要分片是最大 `MTU` 的大小，即路径中存在的所有数据链路中最小的 `MTU`
* 进行路径 `MTU` 发现，就可以避免在中途的路由器上进行分片处理，也可以在 `TCP` 中发送更大的包






## IPv6

`IPv6`（`IP version 6`）是为了根本解决 `IPv4` 地址耗尽的问题而被标准化的网际协议，`IPv4` 的地址长度为 `4` 个 `8` 位字节，即 `32` 比特，而 `IPv6` 的地址长度则是原来的 `4` 倍，即 `128` 比特，一般写成 `8` 个 `16` 位字节

#### IPv6 的特点

* `IP` 得知的扩大与路由控制表的聚合
* 性能提升，包首部长度采用固定的值（`40` 字节），不再采用首部检验码，简化首部结构，减轻路由器负担，路由器不再做分片处理
* 支持即插即用功能，即使没有 `DHCP` 服务器也可以实现自动分配 `IP` 地址
* 采用认证与加密功能，应对伪造 `IP` 地址的网络安全功能以及防止线路窃听的功能
* 多播、`Mobile IP` 成为扩展功能

#### IPv6 中 IP 地址的标记方法

* 一般人们将 `128` 比特 `IP` 地址以每 `16` 比特为一组，每组用冒号（`:`）隔开进行标记
* 而且如果出现连续的 `0` 时还可以将这些 `0` 省略，并用两个冒号（`::`）隔开，但是一个 `IP` 地址中只允许出现一次两个连续的冒号

* `IPv6` 的 `IP` 地址标记举例
  * 用二进制数表示 `1111111011011100: 1011101010011000: 0111011001010100:0011001000010000: 1111111011011100: 1011101010011000: 0111011001010100: 0011001000010000`
  * 用十六进制数表示 `FEDC: BA98: 7654: 3210: FEDC: BA98: 7654: 3210`
* `IPv6` 的 `IP` 地址省略举例
  * 用二进制数表示 `0001000010000000: 0000000000000000: 0000000000000000: 0000000000000000: 0000000000000000: 0000100000000000: 0010000000001100: 0100000101111010`
  * 用十六进制数表示 `1080: 0: 0: 0: 8: 800: 200C: 417A` 省略后为 `1080:: 8: 800: 200C: 417A`



#### IPv6 地址的结构

* `IPv6` 类似 `IPv4`，也是通过 `IP` 地址的前几位标识 `IP` 地址的种类
* 在互联网通信中，使用一种全局的单播地址，它是互联网中唯一的一个地址，不需要正式分配 `IP` 地址

结构 | &nbsp; | &nbsp;
-|-|-
未定义 | `0000 ... 0000`（`128` 比特） | `:: /128`
环回地址 | `0000 ... 0001`（`128` 比特） | `:: 1/128`
唯一本地地址 | `1111 110` | `FC00:: /7`
链路本地单播地址 | `1111 1110 10` | `FE80:: /10`
多播地址 | `1111 1111` | `FF00:: /8`
全局单播地址 | （其他） | （其他）


#### 全局单播地址

* 全局单播地址是指世界上唯一的一个地址，它是互联网通信以及各个域内部通信中最为常用的一个 `IPv6` 地址
* 格式如下图所示，现在 `IPv6` 的网络中所使用的格式为，`n = 48`，`m = 16` 以及 `128 - n - m = 64`，即前 `64` 比特为网络标识，后 `64` 比特为主机标识

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-15.png)


#### 链路本地单播地址

链路本地单播地址是指在同一个数据链路内唯一的地址，它用于不经过路由器，在同一个链路中的通信，通常接口 `ID` 保存 `64` 比特版的 `MAC` 地址

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-16.png)



#### 唯一本地地址

* 唯一本地地址是不进行互联网通信时所用的地址
* 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 `ID`
* `L` 通常被置为 `1`
* 全局 `ID` 的值随机决定
* 子网 `ID` 是指该域子网地址
* 接口 `ID` 即为接口的 `ID`

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-17.png)




#### IPv6 分段处理

* `IPv6` 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片
* `IPv6` 中最小 `MTU` 为 `1280` 字节，因此在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行路径 `MTU` 发现，而是在发送 `IP` 包时直接以 `1280` 字节为单位分片送出




## IPv4 首部

通过 `IP` 进行通信时，需要在数据的前面加入 `IP` 首部信息，`IP` 首部中包含着用于 `IP` 协议进行发包控制时所有的必要信息，了解 `IP` 首部的结构，也就能够对 `IP` 所提供的功能有一个详细的把握

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-19.png)

* 版本（`Version`）
  * 由 `4` 比特构成，表示标识IP首部的版本号，`IPv4` 的版本号即为 `4`，因此在这个字段上的值也是 `4` 
* 图首部长度（`Internet Header Length，IHL`）
  * 由 `4` 比特构成，表明 `IP` 首部的大小，单位为 `4` 字节（`32` 比特），对于没有可选项的 `IP` 包，首部长度则设置为 `5`，也就是说当没有可选项时，`IP` 首部的长度为 `20` 字节（ `4 x 5 = 20`）
* 区分服务（`Type Of Service，TOS`）
  * 由 `8` 比特构成，用来表明服务质量，每一位的具体含义如下

比特 | 含义
-|-
`0 1 2` | 优先度
`3` | 最低延迟
`4` | 最大吞吐
`5` | 最大可靠性
`6` | 最小代价
（`3 ~ 6`） | 最大安全
`7` | 未定义

* `DSCP` 段与 `ECN` 段
  * `DSCP`（`Differential Services Codepoint`，差分服务代码点）是 `TOS`（`Type OfService`）的一部分，现在统称为 `DiflServY`，用来进行质量控制
  * `ECN`（`Explicit Congestion Notification`，显式拥塞通告）用来报告网络拥堵情况，由两个比特构成

比特 | 简称 | 含义
-|-|-
6 | `ECT` | `ECN-Capable Transport`
7 | `CE` | `Congenstion Experienced`

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-20.png)

* 总长度（`Total Length`）
  * 表示 `IP` 首部与数据部分合起来的总字节数，该字段长 `16` 比特，因此 `IP` 包的最大长度为 `65535`（`2^16`）字节
* 标识（`Identification`）
  * 由 `16` 比特构成，用于分片重组，同一个分片的标识值相同，不同分片的标识值不同，通常每发送一个 `IP` 包，它的值也逐渐递增，此外即使 `ID` 相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片
* 标志（`Flags`）
  * 由 `3` 比特构成，表示包被分片的相关信息，每一位的具体含义请参考下表

比特 | 含义
-|-
`0` | 未使用，现在必须是 `0`
`1` | 指示是否进行分片，`0` 表示可以分片，`1` 表示不能分片
`2` | 包被分片的情况下，表示是否为最后一个包，`0` 表示最后一个分片的包，`1` 表示分片中段的包

* 片偏移（`Fragment Offset`）
  * 由 `13` 比特构成，用来标识被分片的每一个分段相对于原始数据的位置
* 生存时间（`Time To Live`）
  * 由 `8` 比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限，然而在实际中它是指可以中转多少个路由器的意思，每经过一个路由器，`TTL` 会减少 `1`，直到变成 `0` 则丢弃该包
* 协议（`Protocol`）
  * 由 `8` 比特构成，表示 `IP` 首部的下一个首部隶属于哪个协议
* 首部校验和（`Header Checksum`）
  * 由 `16` 比特（`2` 个字节）构成，也叫 `IP` 首部校验和，该字段只校验数据报的首部，不校验数据部分，它主要用来确保 `IP` 数据报不被破坏
* 源地址（`Source Address`）
  * 由 `32` 比特（`4` 个字节）构成，表示发送端 `IP` 地址
* 目标地址（`Destination Address`）
  * 由 `32` 比特（`4` 个字节）构成，表示接收端 `IP` 地址
* 可选项（`Options`）
  * 长度可变，通常只在进行实验或诊断时使用，该字段包含 安全级别/源路径/路径记录/时间戳 等信息
* 填充（`Padding`）
  * 也称作填补物，在有可选项的情况下，首部长度可能不是 `32` 比特的整数倍，为此通过向字段填充 `0`，调整为 `32` 比特的整数倍
* 数据（`Data`）
  * 存入数据，将 `IP` 上层协议的首部也作为数据进行处理




## IPv6 首部格式

`IPv6` 中为了减轻路由器的负担，省略了首部校验和字段，因此路由器不再需要计算校验和，从而也提高了包的转发效率，此外分片处理所用的识别码成为可选项，为了让 `64` 位 `CPU` 的计算机处理起来更方便，`IPv6` 的首部及可选项都由 `8` 字节构成

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-21.png)

* 版本（`Version`）
  * 与 `IPv4` 一样，由 `4` 比特构成，`IPv6` 其版本号为 `6`，因此在这个字段上的值为 `6`
* 通信量类（`Traffic Class`）
  * 相当于 `IPv4` 的 `TOS`（`Type Of Service`）字段，也由 `8` 比特构成
* 流标号（`Flow Label`）
  * 由 `20` 比特构成，用于服务质量控制
  * 此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流
* 有效载荷长度（`Payload Length`）
  * 有效载荷是指包的数据部分， `IPv4` 的 `TL`（`Total Length`）是指包括首部在内的所有长度，然而 `IPv6` 中的这个 `Playload Length` 不包括首部，只表示数据部分的长度，由于 `IPv6` 的可选项是指连接 `IPv6` 首部的数据，因此当有可选项时，此处包含可选项数据的所有长度就是 `Playload Length`
* 下一个首部（`Next Header`）
  * 相当于 `IPv4` 中的协议字段，由 `8` 比特构成，通常表示 `IP` 的上一层协议是 `TCP` 或 `UDP`，不过在有 `IPv6` 扩展首部的情况下，该字段表示后面第一个扩展首部的协议类型
* 跳数限制（`Hop Limit`）
  * 由 `8` 比特构成，与 `IPv4` 中的 `TTL` 意思相同，为了强调「可通过路由器个数」这个概念，数据每经过一次路由器就减 `1`，减到 `0` 则丟弃数据
* 源地址（`Source Address`）
  * 由 `128` 比特（`8` 个 `16` 位字节）构成，表示发送端 `IP` 地址
* 目标地址（`Destination Address`）
  * 由 `128` 比特（`8` 个 `16` 位字节）构成，表示接收端 `IP` 地址


#### IPv6 扩展首部

`IPv6` 的首部长度固定，无法将可选项加入其中，取而代之的是通过扩展首部对功能进行了有效扩展，扩展首部通常介于 `IPv6` 首部与 `TCP/UDP` 首部中间，在 `IPv4` 中可选项长度固定为 `40` 字节，但是在 `IPv6` 中没有这样的限制，也就是说 `IPv6` 的扩展首部可以是任意长度，扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段

`IPv6` 首部中没有标识以及标志字段，在需要对 `IP` 数据报进行分片时，可以使用扩展首部





## IP 协议相关技术

`IP` 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 `IP` 是无法实现通信的，必须还有能够解析主机名称和 `MAC` 地址的功能，以及数据包在发送过程中异常情况处理的功能


#### DNS

* 我们平常在访问某个网站时不适用 `IP` 地址，而是用一串由罗马字和点号组成的字符串，而一般用户在使用 `TCP/IP` 进行通信时也不使用 `IP` 地址，能够这样做是因为有了 `DNS`（`Domain Name System`）功能的支持，`DNS` 可以将那串字符串自动转换为具体的 `IP` 地址
* 这种 `DNS` 不仅适用于 `IPv4`，还适用于 `IPv6`


#### ARP

* 只要确定了 `IP` 地址，就可以向这个目标地址发送 `IP` 数据报，然而在底层数据链路层，进行实际通信时却有必要了解每个 `IP` 地址所对应的 `MAC` 地址
* `ARP` 是一种解决地址问题的协议，以目标 `IP` 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 `MAC` 地址，不过 `ARP` 只适用于 `IPv4`，不能用于 `IPv6`，`IPv6` 中可以用 `ICMPv6` 替代 `ARP` 发送邻居探索消息
* `RARP` 是将 `ARP` 反过来，从 `MAC` 地址定位 `IP` 地址的一种协议，



#### ICMP

* `ICMP` 的主要功能包括，确认 `IP` 包是否成功送达目标地址，通知在发送过程当中 `IP` 包被废弃的具体原因，改善网络设置等
* `IPv4` 中 `ICMP` 仅作为一个辅助作用支持 `IPv4`，也就是说在 `IPv4` 时期，即使没有 `ICMP`，仍然可以实现 `IP` 通信，然而在 `IPv6` 中，`ICMP` 的作用被扩大，如果没有 `ICMPv6`，`IPv6` 就无法进行正常通信


#### DHCP

* 如果逐一为每一台主机设置 `IP` 地址会是非常繁琐的事情，特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 `IP` 地址
* 于是为了实现自动设置 `IP` 地址、统一管理 `IP` 地址分配，就产生了 `DHCP`（`Dynamic Host Configuration Protocol`）协议，有了 `DHCP`，计算机只要连接到网络，就可以进行 `TCP/IP` 通信，也就是说 `DHCP` 让即插即用变得可能
* `DHCP` 不仅在 `IPv4` 中，在 `IPv6` 中也可以使用



#### NAT

* `NAT`（`Network Address Translator`）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 `IP` 地址的技术
* 除转换 `IP` 地址外，还出现了可以转换 `TCP`、`UDP` 端口号的 `NAPT`（`Network Address Ports Translator`）技术，由此可以实现用一个全局 `IP` 地址与多个主机的通信
* `NAT`（`NAPT`）实际上是为正在面临地址枯竭的 `IPv4` 而开发的技术，不过在 `IPv6` 中为了提高网络安全也在使用 `NAT`，在 `IPv4` 和 `IPv6` 之间的相互通信当中常常使用 `NAT-PT`




#### IP 隧道

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-18.png)

* 如上图的网络环境中，网络 `A` 与网络 `B` 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 `IP` 隧道的功能
* `IP` 隧道可以将那些从网络 `A` 发过来的 `IPv6` 的包统合为一个数据，再为之追加一个 `IPv4` 的首部以后转发给网络 `C`
* 一般情况下紧接着 `IP` 首部的是 `TCP` 或 `UDP` 的首部，然而现在的应用当中 `IP` 首部的后面还是 `IP` 首部或者 `IP` 首部的后面是 `IPv6` 的首部等情况与日俱增，这种在网络层的首部后面追加网络层首部的通信方法就叫做 `IP` 隧道




## TCP 和 UDP

`TCP/IP` 中有两个具有代表性的传输层协议，分别是 `TCP` 和 `UDP`，它们的区别如下

* `TCP` 是面向连接的、可靠的流协议，流就是指不间断的数据结构，当应用程序采用 `TCP` 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端，`TCP` 为提供可靠性传输，实行「顺序控制」或「重发控制」机制，此外还具备「流控制（流量控制）」、「拥塞控制」等提高网络利用率等众多功能
* `UDP` 是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成，在 `UDP` 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达，因此应用有时会根据自己的需要进行重发处理，
* `TCP` 和 `UDP` 的优缺点无法简单地、绝对地去做比较：`TCP` 用于在传输层有必要实现可靠传输的情况，而在一方面，`UDP` 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，`TCP` 和 `UDP` 应该根据应用的目的按需使用


#### 端口号

数据链路和 `IP` 中的地址，分别指的是 `MAC` 地址和 `IP` 地址，前者用来识别同一链路中不同的计算机，后者用来识别 `TCP/IP`  网络中互连的主机和路由器，在传输层也有这种类似于地址的概念，那就是端口号，端口号用来识别同一台计算机中进行通信的不同应用程序，因此它也被称为程序地址


###### 根据端口号识别应用

一台计算机上同时可以运行多个程序，传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-22.png)


###### 通过 IP 地址、端口号、协议号进行通信识别

仅凭目标端口号识别某一个通信是远远不够的

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-23.png)

* 一和二的通信是在两台计算机上进行的，它们的目标端口号相同，都是 `80`，这里可以根据源端口号加以区分
* 三和一的目标端口号和源端口号完全相同，但它们各自的源 `IP` 地址不同
* 此外当 `IP` 地址和端口号全都一样时，我们还可以通过协议号来区分（`TCP` 和 `UDP`）

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-24.png)

###### 端口号的确定

* 标准既定的端口号，这种方法也叫静态方法，它是指每个应用程序都有其指定的端口号，但并不是说可以随意使用任何一个端口号，例如 `HTTP`、`FTP`、`TELNET` 等广为使用的应用协议中所使用的端口号就是固定的，这些端口号被称为知名端口号，分布在 `0 ~ 1023` 之间，除知名端口号之外，还有一些端口号被正式注册，它们分布在 `1024 ~ 49151` 之间，不过这些端口号可用于任何通信用途
* 时序分配法，服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号，在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配，动态分配的端口号范围在 `49152 ~ 65535` 之间



###### 端口号与协议

* 端口号由其使用的传输层协议决定，因此不同的传输层协议可以使用相同的端口号
* 此外，那些知名端口号与传输层协议并无关系，只要端口一致都将分配同一种应用程序进行处理


#### UDP

* `UDP` 不提供复杂的控制机制，利用 `IP` 提供面向无连接的通信服务
* 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制，即使是出现网络拥堵的情况，`UDP` 也无法进行流量控制等避免网络拥塞行为
* 此外传输途中出现丢包，`UDP` 也不负责重发
* 甚至当包的到达顺序出现乱序时也没有纠正的功能
* 如果需要以上的细节控制，不得不交由采用 `UDP` 的应用程序去处理
* `UDP` 常用于以下几个方面
  * 包总量较少的通信（`DNS`、`SNMP` 等）
  * 视频、音频等多媒体通信（即时通信）
  * 限定于 `LAN` 等特定网络中的应用通信
  * 广播通信（广播、多播）



#### TCP

* `TCP` 与 `UDP` 的区别相当大，它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制，而这些在 `UDP` 中都没有
* 此外 `TCP` 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费
* 根据 `TCP` 的这些机制，在 `IP` 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）



###### 三次握手（重点）

* `TCP` 提供面向有连接的通信传输，面向有连接是指在数据通信开始之前先做好两端之间的准备工作
* 所谓三次握手是指建立一个 `TCP` 连接时需要客户端和服务器端总共发送三个包以确认连接的建立，在 `Socket` 编程中，这一过程由客户端执行 `Connect` 来触发

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-25.png)

* 第一次握手，客户端将标志位 `SYN` 置为 `1`，随机产生一个值 `seq = J`，并将该数据包发送给服务器端，客户端进入 `SYN_SENT` 状态，等待服务器端确认
* 第二次握手，服务器端收到数据包后由标志位 `SYN = 1` 知道客户端请求建立连接，服务器端将标志位 `SYN` 和 `ACK` 都置为 `1`，`ack = J + 1`，随机产生一个值 `seq = K`，并将该数据包发送给客户端以确认连接请求，服务器端进入 `SYN_RCVD` 状态
* 第三次握手，客户端收到确认后，检查 `ack` 是否为 `J + 1`，`ACK` 是否为 `1`，如果正确则将标志位 `ACK` 置为 `1`，`ack = K + 1`，并将该数据包发送给服务器端，服务器端检查 `ack` 是否为 `K + 1`，`ACK` 是否为 `1`，如果正确则连接建立成功，客户端和服务器端进入 `ESTABLISHED` 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了


###### 四次挥手（重点）

* 四次挥手即终止 `TCP` 连接，就是指断开一个 `TCP` 连接时，需要客户端和服务端总共发送 `4` 个包以确认连接的断开，在 `Socket` 编程中，这一过程由客户端或服务端任一方执行 `Close` 来触发
* 由于 `TCP` 连接是全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 `FIN` 来终止这一方向的连接，收到一个 `FIN` 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 `TCP` 连接上仍然能够发送数据，直到这一方向也发送了 `FIN`，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-26.png)

* 中断连接端可以是客户端，也可以是服务器端
* 第一次挥手，客户端发送一个 `FIN = M`，用来关闭客户端到服务器端的数据传送，客户端进入 `FIN_WAIT_1` 状态，意思是说「客户端没有数据要发给你了」，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据
* 第二次挥手，服务器端收到 `FIN` 后，先发送 `ack = M + 1`，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息，这个时候客户端就进入 `FIN_WAIT_2` 状态，继续等待服务器端的 `FIN` 报文
* 第三次挥手，当服务器端确定数据已发送完成，则向客户端发送 `FIN = N` 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了，服务器端进入 `LAST_ACK` 状态
* 第四次挥手，客户端收到 `FIN = N` 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 `ack = N + 1` 后进入 `TIME_WAIT` 状态，如果 `Server` 端没有收到 `ACK` 则可以重传，服务器端收到 `ACK` 后，就知道可以断开连接了，客户端等待了 `2MSL（最大报文段寿命）` 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了，最终完成了四次握手

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-27.png)



###### 通过序列号与确认应答提高可靠性

* 在 `TCP` 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（`ACK`），当发送端将数据发出之后会等待对端的确认应答，如果有确认应答，说明数据已经成功到达对端，反之则数据丢失的可能性很大
* 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发，由此即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输
* 未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到，只是返回的确认应答在途中丢失，这种情况也会导致发送端误以为数据没有到达目的地而重发数据
* 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜，此时源主机只要按照机制重发数据即可，对于目标主机来说，反复收到相同的数据是不可取的，为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包，为此我们引入了序列号
* 序列号是按照顺序给发送数据的每一个字节（`8` 位字节）都标上号码的编号，接收端查询接收数据 `TCP` 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去，通过序列号和确认应答号，`TCP` 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-28.png)



###### 重发超时的确定

* 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发，最理想的是，找到一个最小时间，它能保证「确认应答一定能在这个时间内返回」
* `TCP` 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性，为此它在每次发包时都会计算往返时间及其偏差，将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值
* 在 `BSD` 的 `Unix` 以及 `Windows` 系统中，超时都以 `0.5` 秒为单位进行控制，因此重发超时都是 `0.5` 秒的整数倍，不过最初其重发超时的默认值一般设置为 `6` 秒左右
* 数据被重发之后若还是收不到确认应答，则进行再次发送，此时等待确认应答的时间将会以 `2` 倍、`4` 倍的指数函数延长
* 此外，数据也不会被无限、反复地重发，达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止


###### 以段为单位发送数据

* 在建立 `TCP` 连接的同时，也可以确定发送数据包的单位，我们也可以称其为「最大消息长度」（`MSS`），最理想的情况是，最大消息长度正好是 `IP` 中不会被分片处理的最大数据长度
* `TCP` 在传送大量数据时，是以 `MSS` 的大小将数据进行分割发送，进行重发时也是以 `MSS`  为单位
* `MSS` 在三次握手的时候，在两端主机之间被计算得出，两端的主机在发出建立连接的请求时，会在 `TCP` 首部中写入 `MSS` 选项，告诉对方自己的接口能够适应的 `MSS` 的大小，然后会在两者之间选择一个较小的值投入使用



###### 利用窗口控制提高速度

* `TCP` 以 `1` 个段为单位，每发送一个段进行一次确认应答的处理，这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低
* 为解决这个问题，`TCP` 引入了窗口这个概念，确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短，也就是说发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送，如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-29.png)

* 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图中窗口大小为 `4` 个段，这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能


###### 滑动窗口控制

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-30.png)

* 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去，不过在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传，为此发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答
* 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据，当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除
* 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置，这样可以顺序地将多个段同时发送提高通信性能，这种机制也别称为滑动窗口控制


###### 窗口控制中的重发控制

在使用窗口控制中， 出现丢包一般分为两种情况

1. 确认应答未能返回的情况，在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-31.png)

2. 某个报文段丢失的情况，接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答，如下图所示，当某一报文段丢失后，发送端会一直收到序号为 `1001` 的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回，而发送端主机如果连续三次收到同一个确认应答，就会将其对应的数据进行重发，这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-32.png)





## 应用层协议

在上面我们介绍了 `IP` 协议、`TCP` 协议以及 `UDP` 协议相关内容，它们是通信最基本的部分，也是属于 `OSI` 参考模型中的下半部分，本小节我们所要介绍的应用协议主要是指 `OSI` 参考模型中第 `5` 层、第 `6` 层、第 `7` 层上半部分的协议


#### 应用协议的定义

利用网络的应用程序有很多，包括 `Web` 浏览器、电子邮件、远程登录、文件传输、网络管理等，能够让这些应用进行特定通信处理的正是应用协议，`TCP` 和 `IP` 等下层协议是不依赖于上层应用类型、适用性非常广的协议，而应用协议则是为了实现某种应用而设计和创造的协议

#### 应用协议与协议的分层

网络应用由不同的用户和软件供应商开发而成，为了实现网络应用的功能，在应用之间进行通信时将其连接的网络协议是非常重要的，设计师和开发人员根据所开发模块的功能和目的，可以利用现有的应用协议，也可以自己定义一个新的应用协议

应用可以直接享用传输层以下的基础部分，因为开发者只要关心选用哪种应用协议、如何开发即可，而不必担心应用中的数据该以何种方式发送到目标主机等问题，这也是得益于网络层的功劳





#### 远程登陆

远程登录是为了实现 `TSS`（`Time Sharing System`）环境，是将主机和终端的关系应用到计算机网络上的一个结果，`TSS` 中通常由一个处理能力非常强的主机，围绕这台主机有诸多性能较弱的终端机器，这些终端通过专线于主机连接

类似地，实现从自己的本地计算机登录到网络另一端计算功能的应用就叫做远程登录，远程登录主要使用 `TELNET` 和 `SSH` 两种协议

* `TELNET`

`TELNET` 利用 `TCP` 的一条连接，通过这一条连接向 主机发送文字命令并在主机上执行，本地用户好像直接与远端主机内部的 `Shell` 相连着似的，直接在本地进行操作，`TELNET` 可以分为两类基本服务，一是仿真终端功能，二是协商选项机制

`TELNET` 经常用于登录路由器或高性能交换机等网络设备进行相应的设置，通过 `TELNET` 登录主机或路由器等设备时需要将自己的登录用户名和密码注册到服务端

* `SSH`

`SSH` 是加密的远程登录系统，`TELNET` 中登录时无需输人密码就可以发送，容易造成通信窃听和非法入侵的危险，使用 `SSH` 后可以加密通信内容，即使信息被窃听也无法破解所发送的密码、具体命令以及命令返回的结果是什么，`SSH` 还包括很多非常方便的功能

* 可以使用更强的认证机制
* 可以转发文件
* 可以使用端口转发功能

端口转发是指将特定端口号所收到的消息转发到特定的IP地址和端口号码的一种机制，由于经过 `SSH` 连接的那部分内容被加密，确保了信息安全，提供了更为灵活的通信



#### 文件传输

`FTP` 是在两个相连的计算机之间进行文件传输所用的协议，`FTP` 也需要登录了对方计算机才能操作，`FTP` 有两条 `TCP` 连接，一条用来控制，一条用于数据文件传输

用于控制的 `TCP` 的工作包括登录用户和密码的验证、发送文件的名称、发送方式设置等，该连接使用 `TCP 21` 号端口，在进行 `GET`、`PUT`、`LIST` 等操作，都会建立一个用于数据传输的 `TCP` 连接，数据传送完毕则断开该连接，然后在控制连接上继续通信

一般数据连接的建立要于控制连接的方向相反，因此在用 `NAT` 连接外部 `FTP` 无法直接建立传输数据时使用的 `TCP` 连接，必须使用 `PASV` 命令修改连接的方向，数据连接的端口一般使用 `20`，出于安全考虑也可以用随机端口


#### 电子邮件

提供电子邮件的协议叫做 `SMTP`（`Simple Mail Transfer Protocol`），为了实现高效发送，在其传输层使用了 `TCP` 协议

传统方式的邮件发送必须在两者都联网的情况进行，当有一方离线则无法完成，为此在技术上改变了这种方式，引进了一个一直会联网的邮件服务器，发送和接收端通过邮件服务器进行收发邮件，接收端从邮件服务器接收邮件时使用 `POP3`（`Post Office Protocol`）协议


#### WWW

`WWW`（`World Wide Web`，万维网）是将互联网信息以超文本形式展现的系统，也叫 `Web` 系统，其客户端叫 `Web` 浏览器，`WWW` 有三个重要概念

* 访问信息的手段与位置 `URI`（`Uniform Resource Identifier`，统一资源定位符）
* 信息的表现形式 `HTML`（`HyperText Markup Language`，超文本语言）
* 信息转发 `HTTP`（`HyperText Transfer Protocol`，超文本传输协议）



## 其他应用层协议

互联网一直以来作为数据通信网络得到了蓬勃的发展，不仅用于实时收发音频、图像、视频等多媒体数据领城，还被用于电视电话会议、现场转播等即时性、双向性的领域

#### 多媒体通信实现技术

由于 `TCP` 具有流控制、拥塞控制、重发机制等功能，有时应用所发出去的数据可能无法迅速到达对端目标主机，然而在互联网电话和电视会议当中，即使有少许丢包，也希望系统延时少一点，非常注重系统的即时性，因此，在实时多媒体通信当中采用 `UDP`

然而只使用 `UDP` 还不足以达到进行实时多媒体通信的目的，例如在互联网电视电话议会中需要提供查询对方号码、模拟电话机的拨号以及以什么形式交互数据等功能，为此需要一个叫做「呼叫控制」的支持，呼叫控制主要采用 `H.323` 与 `SIP` 协议，此外还需要 `RTP` 协议（结合多媒体数据本身的特性进行传输的一种协议）和压缩技术（在网络上传输音频、视频等大型多媒体数据时进行压缩）的支持

###### H.323

`H.323` 是由 `ITU` 开发用于在 `IP` 网上传输音频、视频的一种协议，起初它主要是作为接人 `ISDN` 网和 `IP` 网之上的电话网为目的的一种规范而被提出的，`H.323` 定义了 `4` 个主要组件，它们分别是终端（用户终端）、网关（吸收用户数据压缩顺序的不-致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用）


###### SIP

与 `H.323` 相对的 `TCP/IP` 协议即是 `SIP`（`Session Initiation Protocol`）协议，`SIP` 的提出要晚于 `H.323`，但是被普遍认为更适用于互联网，`H.323` 的规范内容较多、对应起来比较复杂，而相比之下 `SIP` 的构成则简单了许多

终端之间进行多媒体通信时，需要具备事先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能，此外还需要具备中断会话和数据转发的功能，这些功能（呼叫控制与信令）都被统一于 `SIP` 协议中，它相当于 `OSI` 参考模型中的会话层


###### RTP

`UDP` 不是一种可靠性传输协议，因此有可能发生丢包或乱序等现象，因此采用 `UDP` 实现实时的多媒体通信需要附加一个表示报文顺序的序列号字段，还需要对报文发送时间进行管理，这些正是 `RTP`（`Real-Time Protocol`）的主要职责

`RTP` 为每个报文附加时间戳和序列号，接收报文的应用，根据时间戳决定数据重构的时机，序列号则根据每发出一次报文加一的原则进行累加，`RTP` 使用这个序列号对同一时间戳的数据进行排序，掌握是否有丢包的情况发生，`RTCP`（`RTP Control Protocol`）是辅助 `RTP` 的一种协议，通过丢包率等线路质量的管理，对 `RTP` 的数据传送率进行控制


#### P2P

互联网上电子邮件的通信，普遍属于一台服务器对应多个客户端的 `C/S` 模式，即 `1` 对 `N` 的通信形态，与之不同，网络上的终端或主机不经服务器直接 `1` 对 `1` 相互通信的情况叫做 `P2P`（`Peer To Peer`），这就好比使用无线收发器进行一对一通话，`P2P` 中主机具备客户端和服务端两方面的功能，以对等的关系相互提供服务

不过也有不支持 `P2P` 的环境，例如在服务器与客户端分离型的环境中，服务器要在一个可以由互联网直接访问的地方，而客户端即使是在 `NAT` 内侧也不会有问题，然而在 `P2P` 中这个结构却行不通，它必须具备从互联网越过 `NAT` 令双方终端能够访问的功能


#### LDAP

`LDAP`（`Lighweight Directory Aces Protocol`）是访问目录服务的一种协议，也叫轻量级目录访问协议，所谓「目录服务」是指网络上存在的一种提供相关资源的数据库的服务，这里的目录也有地址簿的意思，可以认为目录服务就是管理网络上资源的一种服务




## 网络安全

最后我们再来看看互联网中网络安全的重要性及其相关的实现技术


#### TCP/IP 与网络安全

起初，`TCP/IP` 只用于一个相对封闭的环境，之后才发展为并无太多限制、可以从远程访问更多资源的形式，因此安全这个概念并没有引起人们太多的关注，然而随着互联网的日益普及，发生了很多非法访问、恶意攻击等问题，着实影响了企业和个人的利益，由此网络安全逐渐成为人们不可忽视一个重要内容

互联网向人们提供了很多便利的服务，为了让人们能够更好、更安全的利用互联网，只有牺牲一些便利性来确保网络的安全，因此「便利性」和「安全性」作为两个对立的特性兼容并存，产生了很多新的技术，随着恶意使用网络的技术不断翻新，网络安全的技术也在不断进步，今后除了基本的网络技术外，通过正确理解安全相关的技术、制定合理的安全策略、按照制定的策略进行网络管理及运维成为一个重要的课题


#### 网络安全构成要素

随着互联网的发展，对网络的依赖程度越高就越应该重视网络安全，尤其是现在，对系统的攻击手段愈加多样化，某种特定程度的技术远不足以确保一个系统的安全，网络安全最基本的要领是要有预备方案，即不是在遇到问题的时候才去处理，而是通过对可能发生的问题进行预测，在可行的最大范围内为系统制定安保对策，进行日常运维，这才是重中之重

`TCP/IP` 相关的安全要素如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/14-33.png)


###### 防火墙

组织机构内部的网络与互联网相连时，为了避免域内受到非法访问的威胁，往往会设置防火墙，防火墙的种类和形态有很多种，例如专门过滤（或不过滤）特定数据包的包过滤防火墙、数据到达应用以后由应用处理并拒绝非法访问的应用网关，这些防火墙都有基本相同的设计思路，那就是「暴露给危险的主机和路由器的个数要有限」


###### IDS（入侵检测系统）

数据包符合安全策略，防火墙才会让其通过，即只要与策略相符，就无法判断当前访问是否为非法访问，所以全部允许通过，而 `IDS` 正是检查这种已经侵人内部网络进行非法访问的情况，并及时通知给
网络管理员的系统，`IDS` 根据不同的用途可以提供各种不同的功能

* 从设置形式上看，一般在防火墙或 `DMZ` 等边界设备上进行设置，有了这样监控、检测边界的功能，就可以设置在网络内部、全网或个别特殊的服务器上进行监控
* 从功能上看，`IDS` 有定期采集日志、长期监控、通知异常等功能，它可以监控网络上流动的所有数据包，为了确保各种不同系统的安全，`IDS` 可以与防火墙相辅相成，实现更为安全的网络环境


###### 反病毒/个人防火墙

反病毒和个人防火墙是继 `IDS` 和防火墙之后的另外两种安全对策，它们往往是用户使用的计算机或服务器上运行的软件，既可以监控计算机中进出的所有包、数据和文件，也可以防止对计算机的异常操作和病毒人侵



#### 安全协议

主要有三部分

###### IPsec 与 VPN

以前，为了防止信息泄露，对机密数据的传输一般不使用互联网等公共网络（`Public Network`），而是使用由专线连接的私有网络（`Private Network`），从而在物理上杜绝了窃听和篡改数据的可能，然而专线的造价太高是一个不可回避的问题

为了解决此类问题，人们想出了在互联网上构造一个虚拟的私有网络，即 `VPN`（`Virtual Private Network`，虚拟专用网），互联网中采用加密和认证技术可以达到「即使读取到数据也无法读懂」、「检查是否被篡改」等功效，`VPN` 正是一种利用这两种技术打造的网络

在构建 `VPN` 时，最常被使用的是 `IPsec`，它是指在 `IP` 首部的后面追加「封装安全有效载荷」和「认证首部」，从而对此后的数据进行加密，不被盗取者轻易解读，在发包的时候附加上述两个首部，可以在收包时根据首部对数据进行解密，恢复成原始数据，由此加密后的数据不再被轻易破解，即使在途中被篡改，也能够被及时检测

基于这些功能，`VPN` 的使用者就可以不必设防地使用一个安全的网络环境


###### TLS/SSL 与 HTTPS

现在有很多互联网应用已经逐渐进人人们的生活，例如网上购物、网上订车票、订飞机票或预订演出票等，在这些系统的支付过程中经常会涉及信用卡网上支付，而网上银行系统还需要用户直接在网上输人账号和密码

而信用卡卡号、银行账号、密码都属于个人的机密信息，因此在网络上传输这些信息时有必要对它们进行加密处理，`Web` 中可以通过 `TlS/SSL` 对 `HTTP` 通信进行加密，使用 `TLS/SSL` 的 `HTTP` 通信叫做 `HTTPS` 通信，`HTTPS` 中采用对称加密方式，而在发送其公共密钥时采用的则是公钥加密方式


###### IEEE802.1X

`IEEE802.1X` 是为了能够接人 `LAN` 交换机和无线 `LAN` 接人点而对用户进行认证的技术，并且它只允许被认可的设备才能访问网络，虽然它是一个提供数据链路层控制的规范，但是与 `TCP/IP` 关系紧密，一般由客户端终端、`AP`（无线基站）或 `2` 层交换机以及认证服务器组成
