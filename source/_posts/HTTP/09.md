---
title: HTTPS 是如何进行加密的
date: 2020-08-09
categories: HTTP
tags: HTTP
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/09.jpg
---

最近在梳理计算机网络相关知识，刚好梳理到 `HTTPS` 这一块，关于 `HTTPS`，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是 `HTTPS`，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念，所以打算抽些时间，通过参考一些文章，来梳理一下 `HTTPS` 整套机制的实现，更多内容可以参考 [计算机网络知识梳理](https://heptaluan.github.io/2020/08/08/HTTP/00/) 和 [前端知识体系整理](https://heptaluan.github.io/target/)，下面我们就从 `HTTP` 开始看起

<!--more-->


## HTTP

`HTTP` 是属于应用层的协议，它是基于 `TCP/IP` 的，所以它只是规定一些要传输的内容，以及头部信息，然后通过 `TCP` 协议进行传输，依靠 `IP` 协议进行寻址，通过一幅最简单的图来描述

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-01.png)

客户端发出请求，服务端进行响应，就是这么简单，在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露


## 加密

因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-02.png)

客户端和服务器公用一个密匙用来对消息加解密，加密和解密同用一个密钥的方式称为共享密钥加密（`Commonkeycrypto system`），也被叫做 **对称密钥加密**，客户端和服务器约定好一个加密的密匙，客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息，此时我们虽然对数据进行加密了，但是问题解决了吗？



## 多个客户端

我们在上面的情况是仅仅只有我们自己一个客户端，但是在 `WWW` 上，是成千上万的客户端，那么情况会怎样呢？

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-03.png)

难道是为所有的客户端都应用同一个秘钥吗，这种方式很显然是不合理的，万一破解了一个用户，那么岂不是所有的用户信息都会被盗取，所以在这种情况下，我们需要另寻他路，相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-04.png)




## 对称加密秘钥如何传输

我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过 `HTTP` 传输给另一端

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-05.png)

那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取，也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？

通过以上的例子我们可以发现，这种方式虽然在一定程度上保证了数据的安全性，但密钥一旦泄露（密钥在传输过程中被截获），传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法




## 非对称加密

在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫 **非对称加密**，采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密，私钥自己留着，公钥发给对方，这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密，这样攻击者只拿到传输过程中的公钥也无法破解传输的内容

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-06.png)

尽管非对称加密解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍然可以用篡改公钥的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的性能差了不少，我们来看下面这个 `MITM`（`Man-in-the-MiddleAttack`） 示意图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-07.png)

在这种情况下，如果客户端拿到的公钥是假的，那么我们该如何解决这个问题？




## 第三方认证

上面这种方法的弱点在于，客户端不知道公钥是由服务端返回，还是中间人返回的，因此我们再引入一个第三方认证的环节，即第三方使用私钥加密我们自己的公钥，在浏览器当中已经内置一些权威第三方认证机构的公钥，浏览器会使用第三方的公钥来解开第三方私钥加密过的我们自己的公钥，从而获取公钥，如果能成功解密，就说明获取到的自己的公钥是正确的，在 `HTTPS` 中，使用的也就是我们经常听闻的 **证书 + 数字签名** 来解决这个问题

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-08.png)

这里假设加密方式是 `MD5`，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名，也就是

```console
数字证书 = 网站信息 + 数字签名
```

假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-09.png)

为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向 `hash` 而来，一旦构成数字签名的信息发生变化，`hash` 值就会改变，这就构成了公钥来源的唯一标识

具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到 `CA`（第三方认证中心）去申请数字证书，`CA` 会通过一种单向 `hash` 算法（比如 `MD5`）生成一串摘要，这串摘要就是这堆信息的唯一标识，然后 `CA` 还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们

浏览器拿到数字签名后，会使用浏览器本地内置的 `CA` 公钥解开数字证书并验证，从而拿到正确的公钥，由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密


## 为什么要有签名

大家可以想一下，为什么要有数字签名这个东西呢？因为第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-10.png)

如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-11.png)

因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露



## 对称加密

在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后相关的 `Application Data` 就通过这个随机生成的对称秘钥进行 加密/解密，服务器也通过该对称秘钥进行 解密/加密

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-12.png)



## SSL 速度慢吗

说完了优点，我们再来看看 `HTTPS` 存在的一些问题，那就是当使用 `SSL` 时，它的处理速度会变慢，`SSL` 的慢分两种，一种是指通信慢，另一种是指由于大量消耗 `CPU` 及内存等资源，导致处理速度变慢，和使用 `HTTP` 相比，网络负载可能会变慢 `2` 到 `100` 倍，除去和 `TCP` 连接、发送 `HTTP` 请求/响应 以外，还必须进行 `SSL` 通信，因此整体上处理通信量不可避免会增加

另一点是 `SSL` 必须进行加密处理，在服务器和客户端都需要进行加密和解密的运算处理，因此从结果上讲，比起 `HTTP` 会更多地消耗服务器和客户端的硬件资源，导致负载增强，针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 `SSL` 加速器这种（专用服务器）硬件来改善该问题，该硬件为 `SSL` 通信专用硬件，相对软件来讲，能够提高数倍 `SSL` 的计算速度，仅在 `SSL` 处理时发挥 `SSL` 加速器的功效，以分担负载

那么既然 `HTTPS` 那么安全可靠，那为何所有的 `Web` 网站不一直使用 `HTTPS` 呢？

其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 `CPU` 及内存资源，如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少，因此，如果是非敏感信息则使用 `HTTP` 通信，只有在包含个人信息等敏感数据时，才利用 `HTTPS` 加密通信

特别是每当那些访问量较多的 `Web` 网站在进行加密处理时，它们所承担着的负载不容小觑，在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源





## 总结

其实关于 `HTTPS` 中具体的内容还有很多，我们这里也只是仅仅介绍了 加密/解密 相关内容，其他内容可以通过下图做一个参考

![](https://gitee.com/heptaluan/backups/raw/master/cdn/http/09-13.png)

`HTTPS` 就是使用 `SSL/TLS` 协议进行加密传输（`HTTPS = HTTP + TLS/SSL`），让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 `HTTPS` 的流程



## 参考

* [什么是 HTTPS](https://tasaid.com/blog/20161003001126.html)
* [What Is HTTPS?](https://www.wired.com/2016/04/hacker-lexicon-what-is-https-encryption/)
* [HTTPS 原理通俗了解](https://www.cnblogs.com/zhangshitong/p/6478721.html)
* [HTTP 和 HTTPS 有什么区别？](https://www.west.cn/faq/list.asp?unid=1346)
* [HTTP and HTTPS: What do they do, and how are they different?](https://www.instantssl.com/https-tutorials-ssl-certificates)
