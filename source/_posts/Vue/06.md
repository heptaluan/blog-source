---
title: Vite 梳理
date: 2021-03-07
categories: Vue
tags: Vue
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/06.webp
---

最近在学习 `Vue 3` 的相关内容，而在 `Vue 3` 当中则采用了 `Vite` 来作为构建工具，所以在这里简单的梳理一下，也算是记录一下

<!--more-->


## 什么是 Vite

`Vite` 是一款开发构建工具，在开发期，它是利用浏览的 `Native ES Modules` 特性来导入并且组织代码，生产环境中则是利用 `Rollup` 作为打包工具，它主要有以下几个特点

- 启动速度很快
- 热模块替换
- 按需编译

安装和使用的方式十分简单，并不需要过多的配置，安装流程如下

```js
npm install -g create-vite-app
```

安装完成以后我们就可以使用它来初始化我们的 `Vue 3` 项目

```js
$ npm init vite-app <project-name>

$ cd <project-name>

$ npm install

$ npm run dev
```


## 代码组织方式

这里我们来借助上面默认初始化完成以后的项目来进行简单的结构梳理，首先先从入口文件开始看起，也就是我们的 `index.html`，它在代码当中的引入方式是下面这样的

```js
<script type="module" src="/src/main.js"></script>
```

这里可以发现，我们引用了 `/src/main.js` 这个文件，但是是使用了 `type="module"` 的方式来进行引用，我们再来看看 `main.js`

```js
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

createApp(App).mount('#app')
```

我们先来简单的梳理几个可能会有疑惑的地方，首先就是这里直接采用了裸模块的方式直接进行了引用，也就是 `import { createApp } from 'vue'` 这样的使用方式，我们在上面也提到过，`Vite` 是利用浏览的 `Native ES Modules` 特性来导入并且组织代码，但是浏览器是如何知道这个文件具体是在什么位置的呢？

另外对于 `import App from './App.vue'` 这样的相对路径的引入方式我们很熟悉，但是它又是如何解析 `App.vue` 这样的文件的呢？同理下面的 `index.css` 也是一样的道理，也许它是一个纯的 `CSS`，但是如果是使用了预编译器的 `Sass`，那又该如何对它进行处理呢？

关于上面的这些疑问，我们可以在项目启动以后，借助 `Chrome` 浏览的开发者工具当中的 `Network` 标签来进行分析，我们先来看它的加载过程，这里我们主要关注以下几个文件的加载解析过程，它们按序加载的顺序如下

- `localhost`
- `main.js`
- `vue.js`
- `App.vue`
- `index.css?import`
- `HelloWorld.vue`
- `App.vue?type=template`

一开始首先加载 `localhost`，也就是请求本地服务器上的 `index.html`，它发现内部引用了 `main.js`，所以又发送了另外一条请求去请求该文件，但是我们可以发现，现在返回的 `main.js` 有了一些变化，如下所示

```js
import { createApp } from '/@modules/vue.js'
import App from '/src/App.vue'
import '/src/index.css?import'

createApp(App).mount('#app')
```

我们可以发现，返回的路径在 `Vite` 的处理下变成了 `'/@modules/vue.js'`，所以此时浏览器便会再次发送请求，去请求一个相对路径下的 `vue.js`，所以就会去 `node_modules` 下寻找 `vue` 文件夹，接下来就会去访问 `vue` 文件夹下的 `package.json`，如下

```js
// node_modules/vue/package.json
{
  // ...

  "main": "index.js",
  "module": "dist/vue.runtime.esm-bundler.js",

  // ...
}
```

通过 `package.json` 我们可以知道，所谓的入口文件也就是 `vue.runtime.esm-bundler.js` 这个文件，从命名上我们也可以看出，就是一个运行时的使用 `ES` 模块来打包的 `vue` 版本

所以我们在调用了 `import { createApp } from '/@modules/vue.js'` 这行代码以后就相当于在我们的代码当中从 `vue` 当中导出了 `createApp` 这个方法，然后就可以在后续过程当中执行 `createApp(App).mount('#app')` 来进行程序的创建了

接下来我们再来看看 `import App from '/src/App.vue'` 这一行，因为是相对路径，所以会去请求当前目录下的 `App.vue`，我们来对比看一下它的先后变化，首先是我们代码当中实现的 `App.vue`，如下

```js
<template>
  <img alt="Vue logo" src="./assets/logo.png" />
  <HelloWorld msg="Hello Vue 3.0 + Vite" />
</template>

<script>
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
</script>
```

而下面则是经过 `Vite` 处理后返回的 `App.vue`

```js
import HelloWorld from '/src/components/HelloWorld.vue'

const __script = {
  name: 'App',
  components: {
    HelloWorld
  }
}

import { render as __render } from '/src/App.vue?type=template'
__script.render = __render
__script.__hmrId = '/src/App.vue'
typeof __VUE_HMR_RUNTIME__ !== 'undefined' && __VUE_HMR_RUNTIME__.createRecord(__script.__hmrId, __script)
__script.__file = '/path/src/App.vue'
export default __script
```

可以发现，我们之前所写的 `<template></template>`，`<script></script>` 等相关代码全部被经过了一次编译，然后将它们组合，输出最终的代码，而返回的最终代码也就如上所示，简单梳理一下就是

- 首先将我们的路径替换成了相对路径 `'/src/components/HelloWorld.vue'`
- 之前 `export default { }` 的部分变成了一个名为 `__script` 的组件配置对象
- 通过请求 `App.vue` 引入了 `render` 函数，但是添加了 `type=template` 的查询参数，这样 `Vite` 就会对这个请求做特殊处理，也就是解析 `<template></template>` 这个模板，将其变成渲染函数
- 得到渲染函数以后，再将其合并到我们之前的组件配置对象当中
- 以上就是任务的整个流程，剩余的一些都是一些标识文件，这里我们就不过多探讨了，然后最后将我们的组件配置对象导出

其实简单总结的话就是『解析当前组件，并且把我们的最终解析结果导出』，所以这样一来 `App.vue` 就变成了一个组件配置对象返回到了前台，所以我们在使用这个组件配置对象的时候就可以正常的去使用了