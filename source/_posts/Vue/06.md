---
title: Vite 的工程化处理
date: 2021-03-07
categories: Vue
tags: Vue
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/06.webp
---

最近在学习 `Vue 3` 的相关内容，而在 `Vue 3` 当中则采用了 `Vite` 来作为构建工具，所以在这里简单的梳理一下，也算是记录一下

<!--more-->


## 什么是 Vite

`Vite` 是一款开发构建工具，在开发期，它是利用浏览的 `Native ES Modules` 特性来导入并且组织代码，生产环境中则是利用 `Rollup` 作为打包工具，它主要有以下几个特点

- 启动速度很快
- 热模块替换
- 按需编译

安装和使用的方式十分简单，并不需要过多的配置，安装流程如下

```js
npm install -g create-vite-app
```

安装完成以后我们就可以使用它来初始化我们的 `Vue 3` 项目

```js
$ npm init vite-app <project-name>

$ cd <project-name>

$ npm install

$ npm run dev
```


## 代码组织方式

这里我们来借助上面默认初始化完成以后的项目来进行简单的结构梳理，首先先从入口文件开始看起，也就是我们的 `index.html`，它在代码当中的引入方式是下面这样的

```js
<script type="module" src="/src/main.js"></script>
```

这里可以发现，我们引用了 `/src/main.js` 这个文件，但是是使用了 `type="module"` 的方式来进行引用，我们再来看看 `main.js`

```js
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

createApp(App).mount('#app')
```

我们先来简单的梳理几个可能会有疑惑的地方，首先就是这里直接采用了裸模块的方式直接进行了引用，也就是 `import { createApp } from 'vue'` 这样的使用方式，我们在上面也提到过，`Vite` 是利用浏览的 `Native ES Modules` 特性来导入并且组织代码，但是浏览器是如何知道这个文件具体是在什么位置的呢？

另外对于 `import App from './App.vue'` 这样的相对路径的引入方式我们很熟悉，但是它又是如何解析 `App.vue` 这样的文件的呢？同理下面的 `index.css` 也是一样的道理，也许它是一个纯的 `CSS`，但是如果是使用了预编译器的 `Sass`，那又该如何对它进行处理呢？

关于上面的这些疑问，我们可以在项目启动以后，借助 `Chrome` 浏览的开发者工具当中的 `Network` 标签来进行分析，我们先来看它的加载过程，这里我们主要关注以下几个文件的加载解析过程，它们按序加载的顺序如下

- `localhost`
- `main.js`
- `vue.js`
- `App.vue`
- `index.css?import`
- `HelloWorld.vue`
- `App.vue?type=template`

一开始首先加载 `localhost`，也就是请求本地服务器上的 `index.html`，它发现内部引用了 `main.js`，所以又发送了另外一条请求去请求该文件，但是我们可以发现，现在返回的 `main.js` 有了一些变化，如下所示

```js
import { createApp } from '/@modules/vue.js'
import App from '/src/App.vue'
import '/src/index.css?import'

createApp(App).mount('#app')
```

我们可以发现，返回的路径在 `Vite` 的处理下变成了 `'/@modules/vue.js'`，所以此时浏览器便会再次发送请求，去请求一个相对路径下的 `vue.js`，所以就会去 `node_modules` 下寻找 `vue` 文件夹，接下来就会去访问 `vue` 文件夹下的 `package.json`，如下

```js
// node_modules/vue/package.json
{
  // ...

  "main": "index.js",
  "module": "dist/vue.runtime.esm-bundler.js",

  // ...
}
```

通过 `package.json` 我们可以知道，所谓的入口文件也就是 `vue.runtime.esm-bundler.js` 这个文件，从命名上我们也可以看出，就是一个运行时的使用 `ES` 模块来打包的 `vue` 版本

所以我们在调用了 `import { createApp } from '/@modules/vue.js'` 这行代码以后就相当于在我们的代码当中从 `vue` 当中导出了 `createApp` 这个方法，然后就可以在后续过程当中执行 `createApp(App).mount('#app')` 来进行程序的创建了

接下来我们再来看看 `import App from '/src/App.vue'` 这一行，因为是相对路径，所以会去请求当前目录下的 `App.vue`，我们来对比看一下它的先后变化，首先是我们代码当中实现的 `App.vue`，如下

```js
<template>
  <img alt="Vue logo" src="./assets/logo.png" />
  <HelloWorld msg="Hello Vue 3.0 + Vite" />
</template>

<script>
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
</script>
```

而下面则是经过 `Vite` 处理后返回的 `App.vue`

```js
import HelloWorld from '/src/components/HelloWorld.vue'

const __script = {
  name: 'App',
  components: {
    HelloWorld
  }
}

import { render as __render } from '/src/App.vue?type=template'
__script.render = __render
__script.__hmrId = '/src/App.vue'
typeof __VUE_HMR_RUNTIME__ !== 'undefined' && __VUE_HMR_RUNTIME__.createRecord(__script.__hmrId, __script)
__script.__file = '/path/src/App.vue'
export default __script
```

可以发现，我们之前所写的 `<template></template>`，`<script></script>` 等相关代码全部被经过了一次编译，然后将它们组合，输出最终的代码，而返回的最终代码也就如上所示，简单梳理一下就是

- 首先将我们的路径替换成了相对路径 `'/src/components/HelloWorld.vue'`
- 之前 `export default { }` 的部分变成了一个名为 `__script` 的组件配置对象
- 通过请求 `App.vue` 引入了 `render` 函数，但是添加了 `type=template` 的查询参数，这样 `Vite` 就会对这个请求做特殊处理，也就是解析 `<template></template>` 这个模板，将其变成渲染函数
- 得到渲染函数以后，再将其合并到我们之前的组件配置对象当中
- 以上就是任务的整个流程，剩余的一些都是一些标识文件，这里我们就不过多探讨了，然后最后将我们的组件配置对象导出

其实简单总结的话就是『解析当前组件，并且把我们的最终解析结果导出』，所以这样一来 `App.vue` 就变成了一个组件配置对象返回到了前台，所以我们在使用这个组件配置对象的时候就可以正常的去使用了

#### 小结

最后我们来简单的总结一下上面梳理的内容，从开头部分开始说起，关键变化的是 `index.html` 中的入口文件的导入方式

```js
<script type="module" src="/src/main.js"></script>
```

这样 `main.js` 中就可以使用 `ES6 Module` 的方式来组织代码

```js
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'
```

浏览器会自动加载这些导入，`Vite` 会启动一个本地服务器处理这些不同的加载请求

- 对于相对地址的导入，要根据后缀名处理文件内容并返回
- 而对于裸模块导入要修改它的路径为相对地址并再次请求处理

```js
import { createApp } from '/@modules/vue.js'
import App from '/src/App.vue'
import '/src/index.css?import'
```


## 资源加载

下面我们再来看看 `Vite` 当中的资源加载，也就是图片，`CSS` 等一些静态资源是如何处理的，这也是工程化当中的一个十分重要的点

#### CSS 文件导入

`Vite` 中可以直接导入 `CSS` 文件，样式将影响导入的页面，还是以我们的 `main.js` 为例，它是以全局的方式进行引入的

```js
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'
```

同 `JavaScript` 的处理方式类似，`Vite` 会对这个 `CSS` 进行开发阶段的预处理，将其转换成 `JavaScript` 代码，然后热更新到界面当中，但是需要注意的是，最后还是会被打包到 `style.css` 当中，下面是处理后的 `main.js` 文件当中的引入方式

```js
import '/src/index.css?import'
```

可以发现，针对于 `CSS` 的处理，添加了 `import` 的标识，再来看看现在的 `index.css` 的样子，如下

```js
import { updateStyle } from "/vite/client"
const css = "#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n"
updateStyle("\"2418ba23\"", css)
export default css
```

可以发现，其实最终的处理是以 `JavaScript` 的形式传递到前端，下面我们再来看看 `CSS Module` 的使用方式

#### CSS Module

我们除了在模版当中的 `style` 里直接定义对应 `class` 的样式以外，还可以使用 `Module` 的方式，我们通常的使用方式是下面这样的

```js
<template>
  <img class="img" alt="Vue logo" src="./assets/logo.png" />
</template>

<style scoped>
  .img {
    width: 500px;
  }
</style>
```

但是我们可以将其调整为 `CSS Module` 的形式，这样一来我们的 `CSS` 在将来编译的时候会将我们的 `style` 变成计算属性，所以在模板当中使用的时候就不再是使用单纯的 `class` 了，而是使用 `$style` 来进行使用，也就是下面这样的使用方式

```js
<template>
  <img :class="$style.img" alt="Vue logo" src="./assets/logo.png" />
</template>

<style module>
  .img {
    width: 500px;
  }
</style>
```

运行以后可以发现，结果是和上面是一致的，并且最终生成的样式结果当中会自动帮助我们加上 `hash`，也就是下面这样的

```html
<img class="img_7ac74a55" alt="Vue logo" src="/src/assets/logo.png">
```

而这也是模块化带来的好处，因为有 `hash` 的存在，所以我们也不用担心它未来会重名，而这也是与使用 `scoped` 的区别

不过这里需要注意的一点就是，如果我们之前定义的 `class` 是使用 `-` 命名的话，则需要将其调整为驼峰命名，另外如果需要在 `JavaScript` 当中导入 `CSS Module`，只需要将 `CSS` 文件命名为 `*.module.css`，这样一来 `Vite` 也会自动对其进行模块化的处理

```js
import style from './HelloWorld.module.css'

export default {
  emits: ['close'],
  computed: {
    $style() {
      return style
    }
  }
}
```


#### PostCSS

`Vite` 自动会对 `*.vue` 文件和导入的 `.css` 文件应用 `PostCSS` 配置，我们只需要安装必要的插件和添加 `postcss.config.js` 文件即可

```js
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}
```

这里需要注意的一个地方就是，如果需要安装 `autoprefixer` 这个插件，最好保持和 `PostCSS` 相同的版本，否则会有不兼容的错误提示


#### 资源 URL 处理

我们可以在 `*.vue` 文件的 `<template>`，`<style>` 和纯的 `.css` 文件当中以相对和绝对路径方式引用静态资源，我们先来看看静态资源如何引用的

```js
<!-- 相对路径 -->
<img src="./assets/logo.png" />

<!-- 绝对路径 -->
<img src="/src/assets/logo.png" />
```

另外一个就是 `public` 目录，`public` 目录下可以存放未在源码中引用的资源，它们会被留下且文件名不会有哈希处理，这些文件会原封不动的拷贝到发布目录的根目录下

```js
<img src="./logo.png">
```

但是需要注意的是，引用放置在 `public` 下的文件需要使用绝对路径，例如 `public/icon.png` 应该使用 `/icon.png` 进行引用


## eslint

其实在 `Vite` 当中使用 `eslint` 并不会对我们进行约束，该怎么配置还是怎样配置，通常我们借助 `eslint` 规范项目代码，通过 `prettier` 做代码格式化，所以我们就需要进行两部分配置，而且我们希望两者是相匹配的，因为如果不匹配的话，在我们格式化以后是通过不了 `eslint` 的检查，这样就会引起很多的麻烦，下面我们来看看如何进行配置，首先在项目当中安装依赖，`package.json` 如下

```json
{
  "scripts": {
    "lint": "elint \"src/**/*.{js,vue}\""
  },
  "devDependencies": {
    "@vue/elint-config-prettier": "^6.0.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^6.7.2",
    "eslint-plugin-prettier": "^3.1.3",
    "eslint-plugin-vue": "^7.0.0-0",
    "prettier": "^1.19.1"
  }
}
```

接下来就是进行 `lint` 的规则配置，主要有两种方式，一种是采用 `.eslintrc` 的方式，也就是没有后缀的形式，但是这种方式需要写 `JSON`，它的好处是代码提示很好，并且如果安装了 `eslint` 扩展可以很好的帮助我们来进行提示有哪些项是可以选择的，可以使用的

另外一种是采用 `.eslintrc.js` 的方式，也就是带后缀的方式，它的好处是可以在配置文件当中加上一些动态的配置，比如环境变量等，这里我们采用带有后缀的方式，如下

```js
module.exports = {
  root: true,
  env: {
    node: true
  },
  // 引入三个扩展，一个是 vue3 核心的 lint 规则，exlint 的建议规则 和 prettier 建议的规则
  extends: ['plugin: vue/vue3-essential', 'eslint: recommended', ' @vue/prettier'],
  parserOptions: {
    parser: 'babel-eslint'
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'prettier/prettier': [
      'warn',
      {
        // 一些冲突项可以自定义设定
        // singleQuote: true,
        // semi: false,
        trailingComma: 'es5 ',
      },
    ],
  }
}
```

另外如果有必要我们还可以配置 `prettier.config.js` 来修改 `prettier` 的默认格式化规则，因为开发工具的不一致可能导致格式化后的结果不一致，所以我们将其配置成一致的

```js
module.exports = {
  printWidth: 80,             // 毎行代长度（默认 80）
  tabWidth: 2,                // 每个 tab 相当于多少个空格（默认 2）
  useTabs: false,             // 是否使用 tab 进行缩进（默认 false）
  singleQuote: true,          // 使用单引号（默认 false）
  semi: true,                 // 声明结尾使用分号（默认 true）
  trailingComma: 'es5',       // 多行使用拖尾逗号（默认 none），es5 表示只针对对象或数组才使用
  bracketSpacing: true,       // 对象字面量的大阔好间使用空格（默认 true）
  jsxBracketSameLine: false,  // 多行 jsx 中的 > 放置在最后一行的结尾，而不是另起一行（默认 false）
  arrowParens: 'avoid',       // 只有一个参数的箭头函数的参数是否带圆括号（默认 avoid）
}
```