---
title: 深入 React Fiber
date: 2020-12-06
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/18.webp
---

我们都知道，React 是一个用于构建用户交互界面的 JavaScript 库，其核心机制就是跟踪组件的状态变化，并将更新的状态映射到到新的界面。在 React 中，我们将此过程称之为协调（`Reconcilation`）。我们调用 setState方法来改变状态，而框架本身会去检查 state 或 props 是否已经更改来决定是否重新渲染组件。React 的官方文档对 [协调机制](https://reactjs.org/docs/reconciliation.html) 进行了良好的抽象描述，即

> React 的元素、生命周期、render 方法，以及应用于组件子元素的 diffing 算法综合起到的作用，就是协调

我们将从 render 方法返回的不可变的 React 元素通常称为「虚拟 DOM」，但是除了「虚拟 DOM」之外，React 框架总是在内部维护一个实例来持有状态（如组件、DOM 节点等）。从版本 16 开始， React 推出了内部实例树的新的实现方法，也就是我们经常听闻的 Fiber 算法。所以在本章当中，我们就来探索一下这个所谓的 Fiber 到底是什么以及它出现的缘由

<!--more-->



## 存在的问题

之所以会推出新的 Fiber，那就说明在之前的 React 版本当中是存在一定的问题的，那么下面我们就来看看之前到底是存在哪些问题，这个我们可以从官方提供的 [示例](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 开始看起，运行效果如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-01.gif)

至于根本原因，我们可以通过查看其对应的 [源码](https://github.com/claudiopro/react-fiber-vs-stack-demo) 来分析分析具体原因，通过观察源码我们可以发现，代码当中使用了 requestAnimationFrame（这里我们简称为 rAF）

关于 requestAnimationFrame 这个接口的使用我们就不介绍更多内容了，详细可以参考之前我们整理过的 [requestAnimationFrame 的使用](http://localhost:4000/2018/06/11/JavaScript/38/#window-requestAnimationFrame) 以及 [并发模型中的 requestAnimationFrame](http://localhost:4000/2018/08/12/JavaScript/30/#%E5%85%B3%E4%BA%8E-requestAnimationFrame)，直接来看代码

```js
var start = new Date().getTime();
function update() {
  ReactDOM.render(
    <ExampleApplication elapsed={new Date().getTime() - start} />,
    document.getElementById('container')
  );
  requestAnimationFrame(update);
}
requestAnimationFrame(update);
```

此外为了每秒更新一次圆点中的数字，ExampleApplication 组件维护了一个 seconds 状态，使用 setInterval 每秒更新一次。

```js
componentDidMount() {
  this.intervalID = setInterval(this.tick, 1000);
}
tick() {
  this.setState(state => ({ seconds: (state.seconds % 10) + 1 }))
}
```

这里我们简单总结一下就是，对绝大多的浏览器来说，它的页面刷新频率取决于显示器的刷新频率。比如一台刷新频率是 60fps 的显示器，rAF 会每 16.66ms（1000ms / 60）执行一次回调函数。但为了给主线程时间处理其他事务，一般要求产出一帧画面的时间不要超过 10ms 。rAF 的执行频率不会比显示器更高，但有可能更低

也就是说其根本原因，是因为大量的同步计算任务阻塞了浏览器的 UI 渲染。默认情况下，JavaSceipr 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。整个过程是一气呵成，不能被打断的。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。

为了解决主线程长时间被 JS 运算占用这一问题，基本思路是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。

旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而 React 团队使用 Fiber 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的requestIdleCallback这一 API。官方的解释是这样的

> window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。

React 的 Reconcilation 是CPU密集型的操作，所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 '适时'地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，如下就是优化后的效果，我们可以明显感觉到，示例运行起来会比之前看上去流畅许多

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-02.gif)

下面就让我们来深入的了解一下，到底什么是 Fiber？




## 什么是 Fiber

我们现在来讨论 React Fiber 架构的核心。Fibers 是一个非常底层的抽象描述。

我们已经建立了 Fiber 为 React 提供调度能力的主要目标，需要实现以下的能力：

* 暂停工作并在一段时间后恢复
* 对不同类型的工作提供优先级
* 再利用先前已经完成的工作
* 如果不需要则可以停止工作

为了实现以上目标，我们首先需要找到一种方式将工作切分成多个单位。一个 fiber 就代表了一个工作单元。

为了更近一步，我们回到之前的概念 [React 组件就是 data 的函数映射](https://github.com/reactjs/react-basic#transformation)，通常可以表示为：

```js
v = f(d);
```

渲染一个 React 应用本质上就是调用一个函数，这个函数体中包含了调用其他的函数，以此类推。这种类比在思考 fiber 时非常有用。

计算机追踪一个程序的执行通常的方式是采用 [调用栈](https://en.wikipedia.org/wiki/Call_stack)。当一个函数被执行，一个新的栈帧被加入该栈。这个栈帧代表函数执行的位置。

当处理 UI 时，一个问题是如果一次执行太多的函数会导致动画的丢帧，看起来断断续续。而且，如果有新的变动取代旧的，那么之前的工作实际上不是必须的。这就是 UI 组件和函数之间比较不同的地方，UI 组件有着比函数更多需要特殊关注的地方。

最近新的浏览器（和 React Native）实现了帮助解决这个问题的 APIs：requestIdleCallback 安排一个在程序空闲期被调用的低优先级函数，requestAnimationFrame 安排一个在下个动画帧中被调用的高优先级函数。问题在于，为了使用这些 APIs，我们需要将渲染工作切分成多个单元。如果只依靠调用栈，它会一直运行直到栈为空。

有没有办法来定制调用栈的行为来优化渲染 UIs？有没有办法能够中断调用并且手动操作栈帧呢？

这就是 React Fiber 的目的，Fiber 为 React 组件重新实现了栈。可以认为一个 fiber 就是一个虚拟的栈帧。

重新实现栈的好处是能在内存中保存栈帧，并且可以随时以任何方式去执行。这是实现调度至关重要的。

除了调度之外，手动处理栈帧还可以实现并发和错误边界等功能。



## Fiber 数据结构

具体来说，一个 fiber 是一个包含组件信息，它的输入、输出的 JavaScript 对象。

一个 fiber 对应一个栈帧，也对应一个组件的实例。

Fiber 原意是纤维。在计算机科学中也借用了这个词来描述一种比 Thread（线程）更碎片化的技术，Fiber Reconciliation 同样借用了这个概念。原本一旦开始就无法中断的连续工作被打碎成了若干个小工作单元（unit of work）。这为跟踪、调度、暂停和抛弃工作提供了可能。这就是为化整为零！

为了达到这个目的，我们必须升级原来的 React Elements，使它不仅拥有 key, props, type 之类的 ID 信息，还要描述它要做的工作。升级后的 React Element 称作 FIber Node。

```js
var createFiber = function (tag, key) {
  var fiber = {
    // Instance
    key: key,
    type: null,
    stateNode: null,
    // ...

    // Fiber
    'return': null,
    sibling: null,
    child: null,
    pendingProps: null,
    memoizedProps: null,
    updateQueue: null,
    // ...
  };
  // ...
  return fiber;
};
```

这是例子中的 Fiber Node（列举了几个关键字段）。除去熟悉的 key 和 type 还出现了几张新面孔。

#### type 和 key

fiber 的 type 和 key 对 React 元素起着同样的作用（实际上，fiber 从一个元素创建时，这两个属性直接被复制过来）。

fiber 的 type 描述了它对应的组件。对于合成组件，type 是一个函数或者类组件本身。对于原生元素（div, span 等），type 是一个字符串。

从概念上来说，type 是在执行时被栈帧追踪的函数（如在 v = f(d) 中）。

与 type 一起的 key，被用来在协调过程中决定 fiber 是否可以再利用。

#### child 和 sibling

这两个字段指向其他的 fibers，描述一个 fiber 的递归树结构。

child 字段对应组件 render 方法的返回值。

```js
function Parent() {
  return <Child />;
}
```
Parent 的子 fiber 对应着 Child。

sibling 字段对应 render 返回多个孩子节点（Fiber 的新特性！）的情况：

```js
function Parent() {
  return [<Child1 />, <Child2 />];
}
```
child fibers 组成了一个单链表，head 指针指向第一个孩子节点。所以在上例中， Parent 的孩子节点是 Child1，Child1 的兄弟节点是 Child2。

回到我们的函数类比，可以认为一个孩子 fiber 是一个尾调用函数。

#### return
return fiber 是当前 fiber 处理完成后需要返回的 fiber。从概念上来说它对应栈帧返回的地址。也可以理解为父 fiber。

如果一个 fiber 有多个子 fiber，每个子 fiber 返回的 fiber 都是它的父 fiber。在前一个例子中，Child1 和 Child2 的 return fiber 是 Parent。

#### pendingProps 和 memoizedProps

从概念上来说，props 是一个函数的参数。一个 fiber 的 pendingProps 是开始执行时被赋值，memoizedProps 是结束时被赋值。

当即将到来的 pendingProps 和当前 memoizedProps 一致时，表明了 fiber 的前一次输出可以被重新使用，省去了不必要的工作。






为了加以区分，以前的 Reconciler 被命名为Stack Reconciler。Stack Reconciler 运作的过程是不能被打断的，必须一条道走到黑：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-03.png)

而 Fiber Reconciler 每执行一段时间，都会将控制权交回给浏览器，可以分段执行：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-04.png)

为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配


## Fiber 树

Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表。

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-06.png)

Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-07.png)


如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。

在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息保存在Effect List当中，在阶段二执行的时候，会批量更新相应的节点。

## 调度器

React 更新界面的生命周期起点无非来自两处： ReactDOM.render 或 setState。当执行这两个方法的时候发生了些什么呢？

通过 ReactDOM.render 首次构建时，React 会通过每个组件的 render 方法为其构建一个 fiber node，保存在组件的 current.alternate 字段上，它的学名叫 work-in-progress，这个阶段被称为 render 或 reconciliation 阶段。现在这颗树还有工作没有做完，当所有工作完成以后在下个阶段它将被渲染到屏幕上，我们称这个阶段为 commit 阶段。 当 fiber node tree 被渲染到屏幕上以后，它就成为了 current，保存在组件实例的 current 字段上。当组件出现 update 时，React 继续重复上述过程，将还没开始的新工作保存在 work-in-progress 的 fiber node 上。遍历 work-in-progress 的算法和完成标志可以参阅这篇文章。我们接下来着重看它的性能表现。

在例子的 react-dom-fiber.js 文件中可以找到 performWork 方法，其中存在一个 while 循环，它被用来不停执行 work 直到无 work 可做或发生 fatalError。再往下可以看到一个 switch 结构。

Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：

```js
// There might be work left. Depending on the priority, we should
// either perform it now or schedule a callback to perform it later.
switch (nextPriorityLevel) {
  case SynchronousPriority:
  case TaskPriority:
    // Perform work immediately by switching the priority level
    // and continuing the loop.
    priorityLevel = nextPriorityLevel;
    break;
  case AnimationPriority:
    scheduleAnimationCallback(performAnimationWork);
    // Even though the next unit of work has animation priority, there
    // may still be deferred work left over as well. I think this is
    // only important for unit tests. In a real app, a deferred callback
    // would be scheduled during the next animation frame.
    scheduleDeferredCallback(performDeferredWork);
    break;
  case HighPriority:
  case LowPriority:
  case OffscreenPriority:
    scheduleDeferredCallback(performDeferredWork);
    break;
}
```

React 定义了 6 种优先级：

* SynchronousPriority：同 Stack Reconciler 一样需要同步响应的 work；
* TaskPriority：需要在下次 tick 前处理的 work；
* AnimationPriority：需要在下一帧展示到页面的 work；
* HighPriority：需要尽快处理以看到响应效果的 work；
* LowPriority：接受一定程度延迟响应的 work（比如获取数据后刷新界面。即使已经得到了数据，再延迟个100~200ms也无伤大雅）；
* OffscreenPriority：没必要现在立即渲染在屏幕上的 work（比如元素被隐藏或不在显示区域）。

能够看到除了 Synchronous 和 Task 以外，其他 priority 的 work 都在不同程度上被延后处理了。AnimationPriority 是将 work 推迟到下一次 rAF，High, Low 和 Offscreen 则是推迟到下一次 requestIdleCallback。我将这种对界面更新按优先级分类，采取不同做法的策略称为加急名单。如果不是必须马上执行的，就放到下一帧或等主线程有空的时候再执行。

也就是说优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。Fiber Reconciler 在执行过程中，会分为 2 个阶段。

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-05.png)

* 阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。
* 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。

阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。


## 策略三，精益管理

如果仅仅是区分了优先级的话，理论上界面应该还是一样卡顿，因为工作量没有减少。但是 FIber 的例子却很流畅，它一定还做了其他方面的优化。

在 Stack 例子中，为了生成整颗 element tree，reconciliation 从头到底调用了所有组件的 render 方法，最终被累积的 SierpinskiTriangle 组件中的 0.8ms 延时拖入了窘境。Fiber 例子则不然，首先是 ExampleApplication 组件对于 props.elapsed 的变化只产生了自身组件上的工作量。当检测到 SierpinskiTriangle 的 fiber 没有任何工作量时就不再向下 re-render，结束工作。我将这种避免大量无用开销的策略称为精益管理。原本保守估计高达 292ms 的开销现在只用了 4ms。

另外一边，通过 setState 传递到树叶上的 seconds 也因为 priority 的优化不会造成连续的执行。借助 requestIdleCallback 的力量，在断断续续几百毫秒的工作以后，新的 work-in-progress 完成工作，被 commit 到屏幕上。期间每隔 16ms 的渲染间隔没有被打断，用户体验得到了保障。











## 深入了解 React Fiber 内部实现

你是否曾思考过当调用 `ReactDOM.render(<App />, document.getElementById('root'))` 时 React 内部到底发生了什么？

我们知道 ReactDOM 会在后台构建 DOM 树并将应用渲染在屏幕上。那么 React 实际上是如何构建 DOM 树的呢？当应用的 state 改变时，它又如何更新 DOM 树？

在本文中，我将先介绍在 React 15.0.0 之前 React 构建 DOM 树的原理，以及其不足之处，然后再讲解 React 16.0.0 新的 DOM 渲染机制。这篇文章将涵盖大量关于 React 内部实现原理的细节，对于在常规使用 React 进行项目开发，这些可能并非必须掌握的。以及这个新的渲染机制解决是如何解决前一版本的不足的。

## 栈协调器

让我们从之前提到的 `ReactDOM.render(<App />, document.getElementById('root'))` 这段代码开始。

这里 `ReactDOM` 接收 `<App />` 作为参数，并将其传递给协调器（reconciler）。你可能会有如下两个疑问：

1. `<App />` 指的是什么?
2. 协调器（reconciler）又是什么?

下面将来回答这两个问题。

`<App />` 是一个 React 元素，用于描述 DOM 树的元素。

> “React 元素是描述组件实例或 DOM 节点及其所需属性的普通对象。” —— [React 博客](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree)

换句话说，React 元素并非真实的 DOM 节点或组件实例，而是一种描述方式，用于描述 DOM 元素的类型、拥有的属性以及包含的子元素。

这正是 React 的核心所在，React 将构建、渲染以及管理真实 DOM 树生命周期这些复杂的逻辑进行了抽象，从而有效地简化了开发人员的工作。要彻底理解这样做的独到之处，我们可以对比看一下使用传统的面向对象思想如何处理。

在典型的面向对象的编程世界中，开发者需要实例化并管理每个 DOM 元素的生命周期。例如，如果开发者想要创建一个简单的表单和一个提交按钮，即使是对于它们的简单的状态管理，都需要开发者去单独维护。

[](https://blog.logrocket.com/deep-dive-into-react-fiber-internals/)

假设 `Button` 组件有一个 state 变量 `isSubmitted`。`Button` 组件的生命周期类似于以下流程图，其中每个 state 都需要由应用程序处理：

![Button 组件生命周期流程图](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/button-component-lifecycle.png?resize=730%2C465&ssl=1)

流程图的规模和代码行数随着 state 数量的增加而呈指数增长。

React 使用元素来巧妙地解决了这个问题。React 中存在两种元素：

- DOM 元素: 当元素的类型为字符串时，例如 `<button class="okButton"> OK </button>`
- 组件元素: 当类型是类或函数时，例如 `<Button className="okButton"> OK </Button>`，其中 `<Button>` 就是我们常用的典型的类组件、函数组件之一

重要的是要了解这两种类型都是简单的对象。它们只是对需要在屏幕上渲染的内容的描述，在你创建、实例化它们时并不会有实际的渲染发生。这使得 React 更容易解析和遍历它们来构建 DOM 树。而实际的渲染将在遍历完成后进行。

当 React 遇到一个类或一个函数组件时，它会询问该元素，根据它的 props 该元素应该如何渲染。例如，如果 `<App>` 组件渲染以下内容：

```html
<Form>
  <Button>
    Submit
  </Button>
</Form>
```

然后 React 会根据它们对应的 props 询问 `<Form>` 和 `<Button>` 组件它们渲染什么。例如，如果 `Form` 组件是一个函数组件，如下所示：

```jsx
const Form = (props) => {
  return(
    <div className="form">
      {props.form}
    </div>
  )
}
```

React 会调用 `render()` 以了解它渲染的元素，并最终会看到它渲染了一个带有子元素的 `<div>`。React 将重复此过程，直到知道页面上每个组件的基础 DOM 标签元素为止。

递归遍历树以了解 React 应用程序组件树的底层 DOM 标签元素的确切过程称为协调。在协调结束时，React 知道了 DOM 树的结果，并且像 react-dom 或 react-native 这样的渲染器将应用更新 DOM 节点所需的最小更改集。

因此，这意味着当你调用 `ReactDOM.render()` 或 `setState()` 时，React 将执行协调。在 setState 的情况下，它执行遍历并通过将新树与已渲染的树进行区分来找出树中发生了什么变化。然后，将这些更改应用于当前树，从而更新与 `setState()` 调用相关的 state。

现在我们了解了协调是什么，让我们看一下该模式的陷阱。

哦，顺便说一句 —— 为什么将此称为“栈”协调器？

此名称是从“栈”数据结构派生的，该数据结构是一种后进先出的机制。栈与我们刚刚看到的内容有什么关系？好吧，事实证明，由于我们实际上进行了递归，因此它与栈有关。

## 递归

要了解为什么会发生这种情况，让我们举一个简单的例子，看看[调用栈](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack)中会发生什么。

```js
function fib(n) {
  if (n < 2){
    return n
  }
  return fib(n - 1) + fib (n - 2)
}

fib(10)
```

![调用栈图](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/call-stack-diagram.png?resize=730%2C352&ssl=1)

如我们所见，调用栈将每个对 `fib()` 的调用入栈，直到 `fib(1)` 出栈，这是返回的第一个函数调用。然后，它继续递归调用入栈，并在到达 return 语句时再次出栈。这样，它实际上使用了调用栈，直到 fib(3) 返回并成为出栈的最后一项为止。

我们刚刚看到的协调算法是纯递归算法。更新导致整个子树立即重新渲染。虽然这很好用，但是有一些限制。如 [Andrew Clark 指出](https://github.com/acdlite/react-fiber-architecture)：

- 在用户界面中，无需立即应用每个更新；实际上，这样做可能是浪费的，导致丢帧并降低用户体验。
- 不同类型的更新具有不同的优先级 —— 动画更新需要比数据存储中的更新更快地完成。

现在，当我们说丢帧时，我们说的是什么？为什么递归方法会出现这个问题？为了掌握这一点，让我从用户体验的角度简要说明什么是帧频以及为什么它很重要。

帧频是连续图像出现在显示器上的频率。我们在计算机屏幕上看到的所有内容都是由屏幕上播放的帧或图像组成，并且以瞬时出现的速率显示。

要理解这是什么意思，可以将计算机显示屏看作一本翻页书，而将翻页书的页面看作是翻页时以一定速率播放的帧。换句话说，计算机显示器不过是一本自动翻页书，当屏幕上的事物发生变化时，它会一直播放。如果不够清楚，请观看[此视频](https://youtu.be/FV97j-z3B7U)。

通常，如果要让人眼对视频感觉到平滑并即时，那么视频需要以每秒 30 帧（FPS）的频率播放。高于此值将提供更好的体验。这就是为什么游戏玩家在玩第一人称射击游戏中喜欢更高的帧频的主要原因之一，精确度非常重要。

话虽这么说，如今大多数设备以 60 FPS 刷新屏幕，换句话说就是 1/60 = 16.67ms，这意味着每 16ms 就会显示一个新帧。这个数字非常重要，因为如果 React 渲染器花费 16ms 以上的时间在屏幕上渲染某些东西，浏览器将丢帧。

但是，实际上，浏览器有“家务活”要做，因此你的所有工作都需要在 10 ms 内完成。当你不能满足这个预算时，帧频下降，屏幕上的内容会抖动。这通常被称为 jank，会对用户体验产生负面影响。

当然，对于静态和文本内容来说，这并不是什么大问题。但在显示动画的情况下，此数字至关重要。因此，如果每次有更新时 React 协调算法遍历整个 `App` 树并重新渲染，如果遍历时间超过 16 ms，则会导致令人讨厌的丢帧的问题。

这就是为什么最好按优先级对更新进行分类，而不是盲目地应用传递给协调器的每个更新的重要原因。另外，另一个不错的功能是能够在下一帧中暂停和恢复工作。这样，React 可以更好地控制其渲染用的 16 ms 预算。

这导致 React 团队重写了协调算法，新算法称为 Fiber。我认为有必要去了解 Fiber 是如何存在，为什么存在，它有什么意义。让我们看看 Fiber 是如何解决这个问题的。

## Fiber 工作原理

现在我们知道了 Fiber 的开发动机是什么，让我们总结实现 Fiber 所需的功能。

再次，我将引用 Andrew Clark 所指出的：

- 为不同类型的工作分配优先级
- 暂停和恢复工作
- 如果不再需要，就中止工作
- 复用先前完成的工作

实现这样的事情的挑战之一是 JavaScript 引擎的工作方式，并且在某种程度上该语言缺乏线程。为了理解这一点，让我们简要地探讨一下 JavaScript 引擎如何处理执行上下文。

### JavaScript 执行栈

每当你使用 JavaScript 编写函数时，JS 引擎都会创建所谓的函数执行上下文。另外，每次 JS 引擎启动时，它都会创建一个全局执行上下文，其中包含全局对象 —— 例如，浏览器中的 `window` 对象和 Node.js 中的 `global` 对象。这两个上下文都是在 JS 中使用栈数据结构（也称为执行栈）处理的。

因此，当你编写如下内容时：

```js
function a() {
  console.log("i am a")
  b()
}

function b() {
  console.log("i am b")
}

a()
```

JavaScript 引擎首先创建一个全局执行上下文，并将其推入执行栈。然后为 `a()` 函数创建函数执行上下文。由于 `b()` 在 `a()` 内部被调用，它将为 `b()` 创建另一个函数执行上下文并将其入栈。

当函数 `b()` 返回时，引擎将清除 `b()` 的上下文，而当我们退出函数 `a()` 时，将清除 `a()` 的上下文。执行期间的栈如下所示：

![执行栈图](https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/execution-stack.png?resize=534%2C822&ssl=1)

但是，当浏览器发出像 [HTTP 请求](https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/)这样的的异步事件时会发生什么？JS 引擎是存储执行栈并处理异步事件，还是等到事件完成？

JS 引擎在这里做了一些不同的事情。在执行堆栈的顶部，JS 引擎具有队列数据结构，也称为事件队列。事件队列处理进入浏览器的异步调用，例如 HTTP 请求或网络事件。

![事件队列图](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/event-queue-diagram.png?resize=730%2C542&ssl=1)

JS 引擎处理队列中内容的方式是等待执行栈变空。因此，每次执行堆栈变空时，JS 引擎都会检查事件队列，将里面的项目弹出队列，然后处理该事件。需要注意的是，JS 引擎只在执行栈为空或执行栈中只有全局执行上下文时才检查事件队列。

尽管我们称它们为异步事件，但这里有一个微妙的区别：事件相对于它们何时进入队列是异步的，但是相对于它们何时真正得到处理，它们并不是真正的异步。

回到我们的栈协调器，当 React 遍历树时，它正在执行栈中执行。因此，当获得更新时，它们到达事件队列（某种程度上）。只有当执行堆栈为空时，更新才会得到处理。这正是 Fiber 通过智能功能几乎重新实现栈来解决的问题 —— 暂停、继续和中止等。

在这里再次引用 Andrew Clark 所提到的：

> “Fiber 是对栈的重新实现，专用于 React 组件。你可以将单个的 Fiber 视为虚拟栈的帧。
>
> 重新实现栈的优点是，你可以将栈帧保留在内存中，并根据需要（以及在任何时候）执行它们。这对于实现我们计划的目标至关重要。
>
> 除了调度之外，手动处理堆栈帧还可以开放并发和错误边界等功能。我们将在以后的章节中介绍这些主题。”

简单来说，一个 fiber 相当于具有自己的虚拟栈的工作单元。在之前的协调算法实现中，React 创建了一个不可变的对象树（React 元素），并且递归遍历该树。

在当前的实现中，React 创建了一个可以变化的 fiber 节点树。fiber 节点有效地保存组件的 state、props 和它渲染的底层 DOM 元素。

而且由于 fiber 节点可以变化，React 不需要重新创建每个节点来进行更新 —— 它可以在更新时简单地克隆并更新节点。另外，对于 fiber 树，React 不会进行递归遍历。而是创建一个单链表，进行父级优先、深度优先的遍历。

### fiber 节点的单链表

一个fiber 节点代表一个栈帧，也代表一个 React 组件的实例。一个fiber 节点包括以下成员：

#### 类型

原生组件（字符串）的 `<div>`、`<span>` 等，复合组件的类或函数。

#### 健

与传给 React 元素的键相同。

#### 子元素

表示当我们在组件上调用 `render()` 时返回的元素。例如：

```jsx
const Name = (props) => {
  return(
    <div className="name">
      {props.name}
    </div>
  )
}
```

`<Name>` 的子元素是 `<div>`，因为它返回一个 `<div>` 元素。

#### 兄弟元素

代表 `render` 返回元素列表的情况。

```jsx
const Name = (props) => {
  return([<Customdiv1 />, <Customdiv2 />])
}
```

在上述情况下，`<Customdiv1>` 和 `<Customdiv2>` 是父元素 `<Name>` 的子元素。这两个子元素组成一个单链表。

#### 返回

表示返回栈帧，从逻辑上讲，它是返回到父 fiber 节点。 因此，它代表父级。

#### `pendingProps` 和 `memoizedProps`

记忆化指存储函数执行结果的值，以便以后可以使用它，从而避免重新计算。`pendingProps` 表示传递给组件的 props，而 `memoizedProps` 在执行栈的末尾初始化，存储该节点的 props。

当传入的 `pendingProps` 等于 `memoizedProps` 时，它表示 fiber 之前的输出可以复用，从而避免不必要的工作。

#### `pendingWorkPriority`

表示 fiber 工作优先级的数字。[`ReactPriorityLevel`](https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js) 模块列出了不同的优先级及其代表的含义。除了为零的 `NoWork` 之外，数字越大优先级越低。

例如，可以使用以下函数检查某个 fiber 的优先级是否至少与给定的级别一样高。调度程序使用优先级字段搜索要执行的下一个工作单元。

```js
function matchesPriority(fiber, priority) {
  return fiber.pendingWorkPriority !== 0 &&
         fiber.pendingWorkPriority <= priority
}
```

#### 备用

任何时候，一个组件实例最多具有两个与其对应的 fiber：当前 fiber 和进行中 fiber。它们互为彼此的备用。当前 fiber 表示已经渲染的内容，而进行中 fiber 从概念上讲是尚未返回的栈帧。

#### 输出

React 应用程序的叶节点。它们专用于渲染环境（例如，在浏览器应用中，它们是 `div`、`span` 等）。在 JSX 中，它们用小写标签名表示。

从概念上讲，fiber 的输出是函数的返回值。每个 fiber 最终都有输出，但是输出仅由原生组件在叶节点上创建。输出之后将传到树上。

最终将输出提供给渲染器，以便可以将更改刷新到渲染环境。例如，让我们看看 fiber 树将如何查找代码如下所示的应用程序：

```jsx
const Parent1 = (props) => {
  return([<Child11 />, <Child12 />])
}

const Parent2 = (props) => {
  return(<Child21 />)
}

class App extends Component {
  constructor(props) {
    super(props)
  }
  render() {
    <div>
      <Parent1 />
      <Parent2 />
    </div>
  }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

![Fiber 树图](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/fiber-tree-diagram.png?resize=730%2C586&ssl=1)

我们可以看到，fiber 树由相互链接的子节点的单链表（兄弟关系）和父子关系的链表组成。可以使用[深度优先搜索](https://en.wikipedia.org/wiki/Depth-first_search)遍历此树。

### 渲染阶段

为了理解 React 如何构建此树并对其执行协调算法，我决定在 React 源码中写一个单元测试，并附加一个调试器来追踪该过程。

如果你对此过程感兴趣，复制 React 源码并导航到[此目录](https://github.com/facebook/react/tree/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-dom/src/__tests__)。添加一个 Jest 测试并附加调试器。我编写的测试是一个简单的测试，基本上是渲染一个带文本的按钮。当你点击按钮时，应用程序会销毁该按钮，并渲染一个带不同文本的 `<div>`，因此文本在这里是一个 state 变量。

```jsx
'use strict';

let React;
let ReactDOM;

describe('ReactUnderstanding', () => {
  beforeEach(() => {
    React = require('react');
    ReactDOM = require('react-dom');
  });

  it('works', () => {
    let instance;
  
    class App extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          text: "hello"
        }
      }

      handleClick = () => {
        this.props.logger('before-setState', this.state.text);
        this.setState({ text: "hi" })
        this.props.logger('after-setState', this.state.text);
      }

      render() {
        instance = this;
        this.props.logger('render', this.state.text);
        if(this.state.text === "hello") {
        return (
          <div>
            <div>
              <button onClick={this.handleClick.bind(this)}>
                {this.state.text}
              </button>
            </div>
          </div>
        )} else {
          return (
            <div>
              hello
            </div>
          )
        }
      }
    }
    const container = document.createElement('div');
    const logger = jest.fn();
    ReactDOM.render(<App logger={logger}/>, container);
    console.log("clicking");
    instance.handleClick();
    console.log("clicked");

    expect(container.innerHTML).toBe(
      '<div>hello</div>'
    )

    expect(logger.mock.calls).toEqual(
      [["render", "hello"],
      ["before-setState", "hello"],
      ["render", "hi"],
      ["after-setState", "hi"]]
    );
  })

});
```

在初始渲染中，React创建一个当前树，该树是最初被渲染的树。

`[createFiberFromTypeAndProps()](https://github.com/facebook/react/blob/f6b8d31a76cbbcbbeb2f1d59074dfe72e0c82806/packages/react-reconciler/src/ReactFiber.js#L593)` 是使用来自特定 React 元素的数据创建每个 React fiber 的函数。当我们运行测试时，在此函数处放置一个断点，并查看调用栈，它看起来像这样：

![createFiberFromTypeAndProps() 调用栈](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/function-call-stack-1.png?resize=730%2C716&ssl=1)

如我们所见，调用栈会追踪到一个 `render()` 调用，该调用最终会返回到 `createFiberFromTypeAndProps()`。这里还有一些我们感兴趣的其他函数：`workLoopSync()`、`performUnitOfWork()` 和 `beginWork()`。

```js
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

`workLoopSync()` 是 React 开始构建树的地方，从 `<App>` 节点开始，递归地转到 `<div>`、`<div>` 和 `<button>`，这些是 `<App>` 的子节点。`workInProgress` 保存对下一个有工作要做的 fiber 节点的引用。

`performUnitOfWork()` 将一个 fiber 节点作为输入参数，获取该节点的备用节点，然后调用 `beginWork()`。这相当于在执行栈中开始执行函数执行上下文。

当 React 构建树时, `beginWork()` 只会指向 `createFiberFromTypeAndProps()` 并创建 fiber 节点。React 递归执行工作，最终 `performUnitOfWork()` 返回 null, 表示它已到达树的末尾。

现在，当我们执行 `instance.handleClick()` 时会发生什么，基本上是单击按钮并触发状态更新？在这个情况，React 遍历 fiber 树，克隆每个节点，并检查它是否需要在某些节点上执行某些工作。当我们查看这个情况的调用栈时，它看起来像这样：

![instance.handleClick() 调用栈](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/function-call-stack-2.png?resize=730%2C517&ssl=1)

尽管我们在第一个调用堆栈中没有看到 `completeUnitOfWork()` 和 `completeWork()`，但是我们可以在这里看到它们。就像 `performUnitOfWork()` 和 `beginWork()` 一样，这两个函数执行当前执行的完成部分，这实际上意味着返回到栈。

如我们所见，这四个函数一起执行工作单元的工作，并且还控制当前正在完成的工作，这正是栈协调器中缺少的。如下图所示，每个 fiber 节点由完成该工作单元所需的四个阶段组成。

![Fiber 节点图](https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/fiber-node-diagram.png?resize=730%2C405&ssl=1)

这里需要注意的是，在其子节点和兄弟节点返回 `completeWork()` 之前，每个节点都不会移动到 `completeUnitOfWork()`。例如，对于 `<App/>`，它从 `performUnitOfWork()` 和 `beginWork()` 开始，对于 Parent1，则转到 `performUnitOfWork()` 和 `beginWork()`，依此类推。一旦 `<App/>` 的所有子节点完成工作，它将返回并完成对 `<App>` 的工作。

这是 React 完成其渲染阶段的时间。 基于 `click()` 更新而新建的树称为 `workInProgress` 树。这基本上是等待渲染的草稿树。

## 提交阶段

渲染阶段完成后，React 进入提交阶段，在提交阶段，基本上是交换当前树和 `workInProgress` 树的根指针，从而有效地交换当前树与基于 `click()` 更新创建的草稿树。

![提交阶段图](https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2019/11/commit-phase-diagram.png?resize=730%2C874&ssl=1)

不仅如此，在交换根指针到 `workInProgress` 树后，React 还复用了老的当前树。这个优化过程的净效果是从应用程序的前一个状态平稳过渡到下一个状态，下下个状态，依此类推。

那么 16 ms 的帧时间呢？React 有效地为正在执行的每个工作单元运行一个内部计时器，并在执行工作时持续监视此时间限制。时间一到，React 就会暂停当前正在执行的工作单元，交给主线程控制，并让浏览器渲染此时完成的所有内容。

然后，在下一帧，React 从它停止的地方开始，继续构建树。然后，当有足够的时间，它会提交 `workInProgress` 树并完成渲染。





## 手动实现

* 简易版Fiber架构
* 简易版DIFF算法
* 简易版函数组件
* 简易版Hook: useState
* 娱乐版Class组件

https://juejin.cn/post/6844904197008130062





## 参考


* [剖析 useState 的执行过程](https://zhuanlan.zhihu.com/p/64354455)
* [React - Basic Theoretical Concepts](https://github.com/reactjs/react-basic#transformation)
* [React Fiber 架构](https://www.keisei.top/react-fiber-architecture/)
* [React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127)
* [深入了解 React Fiber 内部实现](https://blog.logrocket.com/deep-dive-into-react-fiber-internals/)
* [手写React的Fiber架构，深入理解其原理](https://juejin.cn/post/6844904197008130062)