---
title: 深入 React Fiber
date: 2020-12-06
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/18.webp
---

我们都知道，`React` 是一个用于构建用户交互界面的 `JavaScript` 库，其核心机制就是跟踪组件的状态变化，并将更新的状态映射到到新的界面，在 `React` 中，我们将此过程称之为「协调」（`Reconcilation`），我们调用 `setState` 方法来改变状态，而框架本身会去检查 `state` 或 `props` 是否已经更改来决定是否重新渲染组件，`React` 的官方文档对 [协调机制](https://reactjs.org/docs/reconciliation.html) 进行了良好的抽象描述，即

> `React` 的元素、生命周期、`render` 方法，以及应用于组件子元素的 `diffing` 算法综合起到的作用，就是「协调」

<!--more-->

我们将从 `render` 方法返回的不可变的 `React` 元素通常称为「虚拟 `DOM`」，但是除了「虚拟 `DOM`」之外，`React` 框架总是在内部维护一个实例来持有状态（如组件、`DOM` 节点等），从版本 `16` 开始， `React` 推出了新的内部实例树的实现方法，也就是我们经常听闻的 `Fiber` 算法，但是在本章当中我们并不会太过深入的去介绍源码相关内容，而是主要来探索一下这个所谓的 `Fiber` 到底是什么以及它出现的缘由和解决的一些问题


## 存在的问题

之所以会推出新的 `Fiber`，那就说明在之前的 `React` 版本当中是存在一定的问题的，那么下面我们就来先看看之前的版本当中到底是存在哪些问题，这个我们可以从官方提供的 [示例](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 开始看起，运行效果如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-01.gif)

至于根本原因，我们可以通过查看其对应的 [源码](https://github.com/claudiopro/react-fiber-vs-stack-demo) 来分析具体原因，通过观察源码我们可以发现，代码当中使用了 `requestAnimationFrame` 这个 `API`，关于 `requestAnimationFrame` 这个接口的使用我们就不介绍更多内容了，直接来看代码的实现，详细可以参考之前我们整理过的 [requestAnimationFrame 的使用](http://localhost:4000/2018/06/11/JavaScript/38/#window-requestAnimationFrame) 以及 [并发模型中的 requestAnimationFrame](http://localhost:4000/2018/08/12/JavaScript/30/#%E5%85%B3%E4%BA%8E-requestAnimationFrame)

```js
var start = new Date().getTime()

function update() {
  ReactDOM.render(
    <ExampleApplication elapsed={new Date().getTime() - start} />,
    document.getElementById('container')
  )
  requestAnimationFrame(update)
}

requestAnimationFrame(update)
```

另外，为了每秒更新一次圆点中的数字，`ExampleApplication` 组件维护了一个 `seconds` 状态，使用 `setInterval` 每秒更新一次

```js
componentDidMount() {
  this.intervalID = setInterval(this.tick, 1000)
}

tick() {
  this.setState(state => ({ 
    seconds: (state.seconds % 10) + 1 
  }))
}
```

以上效果之所以会卡顿，究其原因，对绝大多的浏览器来说，它的页面刷新频率取决于显示器的刷新频率，比如一台刷新频率是 `60FPS` 的显示器，`requestAnimationFrame` 会每 `16.66ms`（`1000ms / 60`）执行一次回调函数，但为了给主线程时间处理其他事务，一般要求产出一帧画面的时间不要超过 `10ms`，所以 `requestAnimationFrame` 的执行频率不会比显示器更高，但有可能更低

默认情况下，`JavaSceipr` 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系，如果 `JavaSceipr` 运算持续占用主线程，页面就没法得到及时的更新，当我们调用 `setState` 更新页面的时候，`React` 会遍历应用的所有节点，计算出差异，然后再更新 `UI`，整个过程是一气呵成，不能被打断的，如果页面元素很多，整个过程占用的时机就可能超过 `16` 毫秒，这是就容易出现掉帧的现象，也就是说，其根本原因是因为大量的同步计算任务阻塞了浏览器的 `UI` 渲染

而 `React` 的 `Reconcilation` 是 `CPU` 密集型的操作，旧版 `React` 通过「递归」的方式进行渲染，使用的是 `JavaSceipr` 引擎自身的函数调用栈，它会一直执行到栈空为止，也就是比对 `Virtual DOM` 树，找出需要变动的节点，然后同步更新它们，这个过程 `React` 称为 `Reconcilation`（协调）

而 `React` 团队使用 `Fiber` 实现了自己的组件调用栈以后，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务，基本思路是将运算切割为多个步骤，分批完成，也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染，等浏览器忙完之后，再继续之前未完成的任务，所以使用 `Fiber` 架构的目的是让 `Reconcilation` 过程变成「可被中断」，适时地让出 `CPU` 执行权，让浏览器及时地响应用户的交互

如下就是优化后的效果，我们可以明显感觉到，示例运行起来会比之前看上去流畅许多

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-02.gif)

下面就让我们来深入的了解一下，到底什么是 `Fiber`




## 什么是 Fiber

那么什么是 `Fiber` 呢？其实 `Fiber` 是一种流程控制原语，它是一个非常底层的抽象描述，我们可以称其 [协程](https://zh.wikipedia.org/wiki/协程) 或者「纤程」，但是需要注意的是，协程和「线程」并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制，这里我们可以对比普通函数和 `Generator` 的运行方式，普通函数执行的过程中无法被中断和恢复，如下

```js
const tasks = []

function run() {
  let task
  while (task = tasks.shift()) {
    execute(task)
  }
}
```

而 `Generator` 却是可以的

```js
const tasks = []

function* run() {
  let task
  while (task = tasks.shift()) {
    if (hasHighPriorityEvent()) {   // 判断是否有高优先级事件需要处理，有的话让出控制权
      yield
    }
    execute(task)                   // 处理完高优先级事件后，恢复函数调用栈，继续执行
  }
}
```

所以我们可以发现，其实 `React Fiber` 的思想和协程的概念是契合的，也就是说 `React` 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染，那么这里你可能会有一个疑问，那就是 `React` 是如何将控制权交回浏览器的呢？其实浏览器并没有抢占的条件，通常来说是 `React` 主动让出机制，这是因为

* 一来浏览器中没有类似进程的概念，任务之间的界限很模糊，没有上下文，所以不具备中断或是恢复的条件
* 二则是没有抢占的机制，我们无法中断一个正在执行的程序，所以我们只能采用类似协程这样控制权让出机制

观察我们上面的代码，其实上面代码示例中的 `hasHighPriorityEvent()` 在目前浏览器中是无法实现的，因为我们没办法判断当前是否有更高优先级的任务等待被执行，从而让其让出机制，所以我们只能换一种思路，也就是通过「超时检查的机制」来让出控制权，即确定一个合理的运行时长，然后在合适的检查点检测是否超时（比如每执行一个小任务），如果超时就停止执行，将控制权交换给浏览器，而这个方式的实现主要依赖的是浏览器提供的 [requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 这个 `API`

```js
window.requestIdleCallback(
  callback: (dealine: IdleDeadline) => void,
  option?: {timeout: number}
)
```

`IdleDeadline` 的接口如下

```js
interface IdleDealine {
  didTimeout: boolean                   // 表示任务执行是否超过约定时间
  timeRemaining(): DOMHighResTimeStamp  // 任务可供执行的剩余时间
}
```

单从名字上理解的话，`requestIdleCallback` 的意思是让浏览器在有空的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行，为了不耽误事，我们最好在这个时间范围内执行完毕，现在我们知道了如何让出机制，那么浏览器什么时候有空呢？我们先来看一下浏览器在一帧（`Frame`，可以认为事件循环的一次循环）内可能会做什么事情，通常来说可能会做执行下列任务，而且它们的执行顺序基本是固定的

* 处理用户输入事件
* `JavaScript` 执行
* `requestAnimation` 调用
* 布局 `Layout`
* 绘制 `Paint`

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-03.png)

理想的一帧时间是 `16ms`，如果浏览器处理完上述的任务（布局和绘制之后）还有盈余时间，浏览器就会调用 `requestIdleCallback` 的回调，例如

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-04.png)

但是在浏览器繁忙的时候，可能不会有盈余时间，这时候 `requestIdleCallback` 回调可能就不会被执行，所以在这种情况下可以通过 `requestIdleCallback` 的第二个参数指定一个超时时间

> 另外不建议在 `requestIdleCallback` 中进行 `DOM` 操作，因为这可能导致样式重新计算或重新布局（比如操作 `DOM` 后马上调用 `getBoundingClientRect()`），这些时间很难预估的，很有可能导致回调执行超时，从而掉帧

但是这个超时时间不是死的，低优先级的可以慢慢等待，高优先级的任务应该率先被执行，目前 `React` 预定义了五个优先级

* `Immediate`（`-1`），这个优先级的任务会同步执行，或者说要马上执行且不能中断
* `UserBlocking`（`250ms`），这些任务一般是用户交互的结果，需要即时得到反馈
* `Normal`（`5s`），应对哪些不需要立即感受到的任务，例如网络请求
* `Low`（`10s`），这些任务可以放后，但是最终应该得到执行，例如分析通知
* `Idle`（没有超时时间），一些没有必要做的任务（比如隐藏的内容）

但是目前 `requestIdleCallback` 只有 `Chrome` 支持，所以为了支持其它浏览器，`React` 干脆自己 [实现](https://github.com/facebook/react/tree/master/packages/scheduler/src/forks) 了一个，它是利用 `MessageChannel` 模拟将回调延迟到绘制操作之后执行，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-05.png)

看到这里你可能会问，我们在上面提到过，使用 `Generator` 函数也是可以控制函数的执行流程，那么为什么官方不直接采用 `Generator` 的实现方式呢？关于这一点的原因，可以参考官方在 [Fiber Principles: Contributing To Fiber](https://github.com/facebook/react/issues/7942) 当中的回答，这里我们就不详细展开了

其实我们上面介绍那么多，如果简单的理解的话，我们可以把 `Fiber` 认为是一种数据结构或者说执行单元（会在下面进行介绍），我们将它视作一个执行单元，每次执行完一个执行单元，`React` 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，`React` 没有使用 `Generator` 这种让出机制，而是实现了自己的调度让出机制，这个机制就是基于 `Fiber` 这个执行单元的

下面我们就来看看从 `React` 元素到 `Fiber` 节点是如何转化的，也就是 `React` 为 `Fiber` 架构做了哪些改造



## Fiber 节点

我们都知道，`React` 元素并非真实的 `DOM` 节点或组件实例，而是一种描述方式，用于描述 `DOM` 元素的类型、拥有的属性以及包含的子元素，这也正是 `React` 的核心所在，`React` 将构建、渲染以及管理真实 `DOM` 树生命周期这些复杂的逻辑进行了抽象，从而避免了我们直接操作真实 `DOM` 而引起的巨大性能消耗

在协调期间，从 `render` 方法返回的每个 `React` 元素的数据都会被合并到 `Fiber` 节点树中，每个 `React` 元素都有一个相应的 `Fiber` 节点，与 `React` 元素不同，不会在每次渲染时重新创建这些 `Fiber` ，这些是持有组件状态和 `DOM` 的可变数据结构

因此，这意味着当我们调用 `ReactDOM.render()` 或 `setState()` 时，`React` 将执行协调，在 `setState` 的情况下，它执行遍历并通过将新树与已渲染的树进行区分来找出树中发生了什么变化，然后将这些更改应用于当前树，从而更新与 `setState()` 调用相关的 `state`

我们在之前提到过，旧版 `React` 是通过「递归」的方式进行渲染的，也就是说这是基于函数调用栈的协调算法，只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复，不利于异步处理，这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始，恢复到之前的调用栈，所以针对于阵亡者情况就需要对 `React` 现有的数据结构进行调整，模拟函数调用栈，将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代

`React` 目前的做法是使用链表，每个 `VirtualDOM` 节点内部现在使用 `Fiber` 表示，它的结构大概如下

```js
export type Fiber = {     
  type: any,              // Fiber 类型信息
  return: Fiber | null,   // 链表结构，指向父节点，或者 render 该节点的组件
  child: Fiber | null,    // 指向第一个子节点
  sibling: Fiber | null,  // 指向下一个兄弟节点
  // ...
}
```

用图片来展示这种关系会更直观一些

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-06.png)

因为 `React` 为每个 `React` 元素创建一个 `Fiber` 节点，并且因为我们有一个这些元素组成的树，所以我们可以得到一个 `Fiber` 节点树，所有 `Fiber` 节点都通过链表连接，具体是使用 `Fiber` 节点上的 `child`、`sibling` 和 `return` 属性，至于它为什么以这种方式工作，可以参考 [如何以及为什么 React Fiber 使用链表遍历组件树](https://juejin.cn/post/6844903753347252237) 这篇文章，这里我们就不详细展开了

下面我们来深入的了解一下 `Fiber` 当中的节点类型，其实 `Fiber` 节点内部所包含的类型并不仅仅只有我们上面提到的一些，它包括

```js
interface Fiber {            
  // 节点的类型信息
  tag: WorkTag,              // 标记 Fiber 类型，例如函数组件、类组件、宿主组件
  type: any,                 // 节点元素类型，是具体的类组件、函数组件、宿主组件（字符串）

  // 结构信息
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,
  key: null | string,        // 子节点的唯一键，即我们渲染列表传入的 key 属性

  // 节点实例的状态
  // 对于宿主组件，这里保存宿主组件的实例，例如 DOM 节点
  // 对于类组件来说，这里保存类组件的实例
  // 对于函数组件说，这里为空，因为函数组件没有实例
  stateNode: any,
  pendingProps: any,         // 新的、待处理的props
  memoizedProps: any,        // 上一次渲染的props
  memoizedState: any,        // 上一次渲染的组件状态

  // 副作用
  effectTag: SideEffectTag,  // 当前节点的副作用类型，例如节点更新、删除、移动
  nextEffect: Fiber | null,  // 和节点关系一样，React 同样使用链表来将所有有副作用的 Fiber 连接起来

  // 指向旧树中的节点
  alternate: Fiber | null,
}
```

`Fiber` 包含的属性可以划分为五个部分

* 结构信息，上面已经介绍过，`Fiber` 使用链表的形式来表示节点在树中的定位
* 节点类型信息，`tag` 表示节点的分类、`type` 保存具体的类型值，如 `div`、`MyComp`
* 节点的状态，节点的组件实例 `props`、`state` 等，它们将影响组件的输出
* 副作用，在协调过程中发现的副作用就保存在节点的 `effectTag` 中（类似打上标记），这里也使用了链表结构，将本次渲染的所有副作用节点都收集起来，通过 `nextEffect` 连接起来
* `WIP` 树，`React` 在协调过程中会构建一颗新的树，可以认为是一颗表示当前工作进度的树，还有一颗表示已渲染界面的旧树，`React` 就是一边和旧树比对，一边构建 `WIP` 树的， `alternate` 指向旧树的同等节点（关于这点我们会在下面的渲染阶段当中来进行介绍）

下面我们就来简单的看看各个属性的作用

#### type 和 key

`Fiber` 的 `type` 和 `key` 对 `React` 元素起着同样的作用（实际上，`Fiber` 从一个元素创建时，这两个属性直接被复制过来），`type` 描述了它对应的组件，对于合成组件来说 `type` 是一个函数或者类组件本身，对于原生元素（`div`，`span` 等），它是一个字符串

从概念上来说，`type` 是在执行时被栈帧追踪的函数（如在 `v = f(d)` 中），与 `type` 一起的 `key`，被用来在协调过程中决定 `Fiber` 是否可以再利用

#### child 和 sibling

表示当我们在组件上调用 `render()` 时返回的元素，例如

```jsx
const Name = (props) => {
  return (<div className="name">
    {props.name}
  </div>)
}
```

`<Name>` 的子元素是 `<div>`，因为它返回一个 `<div>` 元素，而 `sibling` 字段则对应 `render` 返回多个孩子节点的情况，如下

```js
const Name = (props) => {
  return ([<Child1 />, <Child2 />])
}
```

在上述情况下，`<Child1>` 和 `<Child2>` 是父元素 `<Name>` 的子元素，这两个子元素组成一个单链表，`head` 指针指向第一个孩子节点，所以在上例中 `Parent` 的孩子节点是 `Child1`，`Child1` 的兄弟节点是 `Child2`，如果放到函数当中类比的话，可以认为一个子 `Fiber` 是一个尾调用函数

#### return

`return` 是当前 `fiber` 处理完成后需要返回的 `fiber`，从概念上来说它对应栈帧返回的地址，从逻辑上讲，它是返回到父 `fiber` 节点，因此可以理解为父 `fiber`，如果一个 `fiber` 有多个子 `fiber`，每个子 `fiber` 返回的 `fiber` 都是它的父 `fiber`，在上面示例中的 `Child1` 和 `Child2` 的 `return` 就是 `Parent`

#### pendingProps 和 memoizedProps

记忆化指存储函数执行结果的值，以便以后可以使用它，从而避免重新计算，`pendingProps` 表示传递给组件的 `props`，而 `memoizedProps` 在执行栈的末尾初始化，存储该节点的 `props`

当传入的 `pendingProps` 等于 `memoizedProps` 时，它表示 `fiber` 之前的输出可以复用，从而避免不必要的工作

#### pendingWorkPriority

表示 `fiber` 工作优先级的数字，除了为零的 `NoWork` 之外，数字越大优先级越低，例如可以使用以下函数检查某个 `fiber` 的优先级是否至少与给定的级别一样高，调度程序使用优先级字段搜索要执行的下一个工作单元

```js
function matchesPriority(fiber, priority) {
  return fiber.pendingWorkPriority !== 0 &&
    fiber.pendingWorkPriority <= priority
}
```



## 渲染阶段与提交阶段

除了 `Fiber` 工作单元的拆分，两个执行阶段的拆分也是一个非常重要的过程，在此之前通常都是一边执行协调一边进行提交的，我们先来看看这两者的区别

* 渲染阶段，可以认为是协调阶段，这个阶段可以被中断，这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等，这些变更 `React` 称之为副作用（`Effect`），以下生命周期钩子会在渲染阶段被调用
  * `constructor`
  * `componentWillMount`（废弃）
  * `componentWillReceiveProps`（废弃）
  * `static getDerivedStateFromProps`
  * `shouldComponentUpdate`
  * `componentWillUpdate`（废弃）
  * `render`
* 提交阶段，将上一个阶段计算出来的需要处理的副作用（`Effect`）一次性执行了，这个阶段必须同步执行，不能被打断，这些生命周期钩子在提交阶段被执行
  * `getSnapshotBeforeUpdate()`（严格来说这个是在进入 `commit` 阶段前调用）
  * `componentDidMount`
  * `componentDidUpdate`
  * `componentWillUnmount`

也就是说，在渲染阶段如果时间片用完，`React` 就会选择让出控制权，因为渲染阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题，但是需要注意的是，因为渲染阶段可能被中断、恢复，甚至重做，`React` 渲染阶段的生命周期钩子可能会被调用多次，例如 `componentWillMount` 可能会被调用两次，因此建议渲染阶段的生命周期钩子不要包含副作用，索性 `React` 就废弃了这部分可能包含副作用的生命周期方法，例如 `componentWillMount`、`componentWillUpdate` 等（这也是新版 `React` 的生命周期有所调整的原因）

现在我们应该知道为什么说在提交阶段必须同步执行，不能中断的吧？因为我们要正确地处理各种副作用，包括 `DOM` 变更、还有在 `componentDidMount` 中发起的异步请求、`useEffect` 中定义的副作用等，因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更，不容差池

> 至于为什么要拆分两个阶段，可以参考 [What is meant within the README of `create-subscription` by async limitations? Can it be clarified?](https://github.com/facebook/react/issues/13186#issuecomment-403959161) 这篇文章

下面我们就来详细看看这两个阶段当中具体执行了哪些操作


## 渲染阶段

在第一次渲染之后，React 最终得到一个 Fiber 树，这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表，它反映了用于渲染 UI 的应用程序的状态，这棵树通常被称为 current 树（当前树）

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-07.png)

当 React 开始处理更新时，它会构建一个所谓的 workInProgress 树（工作过程树），它反映了要刷新到屏幕的未来状态，，这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行，如果没有，则继续构建树的过程：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-08.png)

如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍，

所有的工作都是在 workInProgress 树的 Fiber 节点上执行的，当 React 遍历 current 树时，对于每个现有 Fiber 节点，React 会创建一个构成 workInProgress 树的备用节点，这一节点会使用 render 方法返回的 React 元素中的数据来创建，处理完更新并完成所有相关工作后，React 将准备好一个备用树以刷新到屏幕，一旦这个 workInProgress 树在屏幕上呈现，它就会变成 current树，

WIP 树构建这种技术类似于图形化领域的'双缓存(Double Buffering)'技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能，

放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染，它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树，另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉，


## 提交阶段

渲染阶段完成后，React 进入提交阶段，在提交阶段，基本上是交换当前树和 `workInProgress` 树的根指针，不仅如此，在交换根指针到 `workInProgress` 树后，React 还复用了老的当前树，这个优化过程的净效果是从应用程序的前一个状态平稳过渡到下一个状态，下下个状态，依此类推，

React 会有效地为正在执行的每个工作单元运行一个内部计时器（16 ms），并在执行工作时持续监视此时间限制，时间一到，React 就会暂停当前正在执行的工作单元，交给主线程控制，并让浏览器渲染此时完成的所有内容，然后，在下一帧，React 从它停止的地方开始，继续构建树，然后，当有足够的时间，它会提交 `workInProgress` 树并完成渲染，

但是现在已经不是在一边协调，一边提交了，而是在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息都保存在Effect List当中，最后批量更新相应的节点，

此列表的目标是标记具有 DOM 更新或其他相关副作用的节点，此列表是 finishedWork 树的子集，并使用 nextEffect 属性而不是 current 和 workInProgress 树中使用的 child 属性进行链接，

借用Lin Clark 演讲（见 [React Fiber](https://juejin.cn/post/6844903582622285831)）当中的一张图，我们可以清晰的发现这种变化

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-09.png)

上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树，对于需要变更的节点，都打上了'标签'， 在提交阶段，React 就会将这些打上标签的节点应用变更，





## Fiber 的执行流程


最后我们再来综合一下以上介绍过的内容，简单的梳理一下 Fiber 的整体执行流程，针对于此，我们可以编写一个单元测试，并附加一个调试器来追踪该过程（见 [react-dom/src/tests](https://github.com/facebook/react/tree/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-dom/src/__tests__)），内容很简单，就是渲染一个带文本的按钮，当我们点击按钮时，应用程序会销毁该按钮，并渲染一个带不同文本的 `<div>`，因此文本在这里是一个 state 变量，

```jsx
'use strict';

let React;
let ReactDOM;

describe('ReactUnderstanding', () => {
  beforeEach(() => {
    React = require('react');
    ReactDOM = require('react-dom');
  });

  it('works', () => {
    let instance;
  
    class App extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          text: "hello"
        }
      }

      handleClick = () => {
        this.props.logger('before-setState', this.state.text);
        this.setState({ text: "hi" })
        this.props.logger('after-setState', this.state.text);
      }

      render() {
        instance = this;
        this.props.logger('render', this.state.text);
        if(this.state.text === "hello") {
        return (
          <div>
            <div>
              <button onClick={this.handleClick.bind(this)}>
                {this.state.text}
              </button>
            </div>
          </div>
        )} else {
          return (
            <div>
              hello
            </div>
          )
        }
      }
    }
    const container = document.createElement('div');
    const logger = jest.fn();
    ReactDOM.render(<App logger={logger}/>, container);
    console.log("clicking");
    instance.handleClick();
    console.log("clicked");

    expect(container.innerHTML).toBe(
      '<div>hello</div>'
    )

    expect(logger.mock.calls).toEqual(
      [["render", "hello"],
      ["before-setState", "hello"],
      ["render", "hi"],
      ["after-setState", "hi"]]
    );
  })

});
```

在初始渲染中，React创建一个当前树，该树是最初被渲染的树，也就是我们上面提到的 current 树

[createFiberFromTypeAndProps()](https://github.com/facebook/react/blob/f6b8d31a76cbbcbbeb2f1d59074dfe72e0c82806/packages/react-reconciler/src/ReactFiber.js#L593) 是使用来自特定 React 元素的数据创建每个 React fiber 的函数，当我们运行测试时，在此函数处放置一个断点，并查看调用栈，它看起来像这样：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-10.png)

如我们所见，调用栈会追踪到一个 `render()` 调用，该调用最终会返回到 `createFiberFromTypeAndProps()`，这里还有一些我们感兴趣的其他函数：`workLoopSync()`、`performUnitOfWork()` 和 `beginWork()`，

```js
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

`workLoopSync()` 是 React 开始构建树的地方，从 `<App>` 节点开始，递归地转到 `<div>`、`<div>` 和 `<button>`，这些是 `<App>` 的子节点，`workInProgress` 保存对下一个有工作要做的 fiber 节点的引用，

```js
/**
 * @params fiber 当前需要处理的节点
 * @params topWork 本次更新的根节点
 */
function performUnitOfWork(fiber: Fiber, topWork: Fiber) {
  // 对该节点进行处理
  beginWork(fiber);

  // 如果存在子节点，那么下一个待处理的就是子节点
  if (fiber.child) {
    return fiber.child;
  }

  // 没有子节点了，上溯查找兄弟节点
  let temp = fiber;
  while (temp) {
    // 提交
    completeWork(temp);

    // 到顶层节点了, 退出
    if (temp === topWork) {
      break
    }

    // 找到，下一个要处理的就是兄弟节点
    if (temp.sibling) {
      return temp.sibling;
    }

    // 没有, 继续上溯
    temp = temp.return;
  }
}

// 将所有打了 Effect 标记的节点串联起来
function completeWork(fiber) {
  const parent = fiber.return

  // 到达顶端
  if (parent == null || fiber === topWork) {
    pendingCommit = fiber
    return
  }

  if (fiber.effectTag != null) {
    if (parent.nextEffect) {
      parent.nextEffect.nextEffect = fiber
    } else {
      parent.nextEffect = fiber
    }
  } else if (fiber.nextEffect) {
    parent.nextEffect = fiber.nextEffect
  }
}

// 副作用提交
function commitAllWork(fiber) {
  let next = fiber
  while(next) {
    if (fiber.effectTag) {
      // 提交，偷一下懒，这里就不展开了
      commitWork(fiber)
    }
    next = fiber.nextEffect
  }

  // 清理现场
  pendingCommit = nextUnitOfWork = topWork = null
}
```

`performUnitOfWork()` 是一个深度优先的遍历，它将一个 fiber 节点作为输入参数，获取该节点的备用节点，然后调用 `beginWork()`，这相当于在执行栈中开始执行函数执行上下文，

```js
function beginWork(fiber: Fiber): Fiber | undefined {
  if (fiber.tag === WorkTag.HostComponent) {
    // 宿主节点diff
    diffHostComponent(fiber)
  } else if (fiber.tag === WorkTag.ClassComponent) {
    // 类组件节点diff
    diffClassComponent(fiber)
  } else if (fiber.tag === WorkTag.FunctionComponent) {
    // 函数组件节点diff
    diffFunctionalComponent(fiber)
  } else {
    // ... 其他类型节点，省略
  }
}

// 宿主节点比对
function diffHostComponent(fiber: Fiber) {
  // 新增节点
  if (fiber.stateNode == null) {
    fiber.stateNode = createHostComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }

  const newChildren = fiber.pendingProps.children;

  // 比对子节点
  diffChildren(fiber, newChildren);
}

// 类组件节点比对
function diffClassComponent(fiber: Fiber) {
  // 创建组件实例
  if (fiber.stateNode == null) {
    fiber.stateNode = createInstance(fiber);
  }

  if (fiber.hasMounted) {
    // 调用更新前生命周期钩子
    applybeforeUpdateHooks(fiber)
  } else {
    // 调用挂载前生命周期钩子
    applybeforeMountHooks(fiber)
  }

  // 渲染新节点
  const newChildren = fiber.stateNode.render();
  // 比对子节点
  diffChildren(fiber, newChildren);

  fiber.memoizedState = fiber.stateNode.state
}

// 子节点比对
function diffChildren(fiber: Fiber, newChildren: React.ReactNode) {
  let oldFiber = fiber.alternate ? fiber.alternate.child : null;
  // 全新节点，直接挂载
  if (oldFiber == null) {
    mountChildFibers(fiber, newChildren)
    return
  }

  let index = 0;
  let newFiber = null;
  // 新子节点
  const elements = extraElements(newChildren)

  // 比对子元素
  while (index < elements.length || oldFiber != null) {
    const prevFiber = newFiber;
    const element = elements[index]
    const sameType = isSameType(element, oldFiber)
    if (sameType) {
      newFiber = cloneFiber(oldFiber, element)
      // 更新关系
      newFiber.alternate = oldFiber
      // 打上Tag
      newFiber.effectTag = UPDATE
      newFiber.return = fiber
    }

    // 新节点
    if (element && !sameType) {
      newFiber = createFiber(element)
      newFiber.effectTag = PLACEMENT
      newFiber.return = fiber
    }

    // 删除旧节点
    if (oldFiber && !sameType) {
      oldFiber.effectTag = DELETION;
      oldFiber.nextEffect = fiber.nextEffect
      fiber.nextEffect = oldFiber
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling;
    }

    if (index == 0) {
      fiber.child = newFiber;
    } else if (prevFiber && element) {
      prevFiber.sibling = newFiber;
    }

    index++
  }
}
```

当 React 构建树时, `beginWork()` 只会指向 `createFiberFromTypeAndProps()` 并创建 fiber 节点，React 递归执行工作，最终 `performUnitOfWork()` 返回 null, 表示它已到达树的末尾，

现在，当我们执行 `instance.handleClick()` 时会发生什么，基本上是单击按钮并触发状态更新？在这个情况，React 遍历 fiber 树，克隆每个节点，并检查它是否需要在某些节点上执行某些工作，当我们查看这个情况的调用栈时，它看起来像这样：

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-11.png)

尽管我们在第一个调用堆栈中没有看到 `completeUnitOfWork()` 和 `completeWork()`，但是我们可以在这里看到它们，就像 `performUnitOfWork()` 和 `beginWork()` 一样，这两个函数执行当前执行的完成部分，这实际上意味着返回到栈，

如我们所见，这四个函数一起执行工作单元的工作，并且还控制当前正在完成的工作，这正是栈协调器中缺少的，如下图所示，每个 fiber 节点由完成该工作单元所需的四个阶段组成，

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/18-12.png)

这里需要注意的是，在其子节点和兄弟节点返回 `completeWork()` 之前，每个节点都不会移动到 `completeUnitOfWork()`，例如，对于 `<App/>`，它从 `performUnitOfWork()` 和 `beginWork()` 开始，对于 Parent1，则转到 `performUnitOfWork()` 和 `beginWork()`，依此类推，一旦 `<App/>` 的所有子节点完成工作，它将返回并完成对 `<App>` 的工作，

这是 React 完成其渲染阶段的时间， 基于 `click()` 更新而新建的树称为 `workInProgress` 树，这基本上是等待渲染的草稿树，


## 手动实现

* 简易版Fiber架构
* 简易版DIFF算法
* 简易版函数组件
* 简易版Hook: useState
* 娱乐版Class组件

https://juejin.cn/post/6844904197008130062





## 参考

* [剖析 useState 的执行过程](https://zhuanlan.zhihu.com/p/64354455)
* [React - Basic Theoretical Concepts](https://github.com/reactjs/react-basic#transformation)
* [React Fiber 架构](https://www.keisei.top/react-fiber-architecture/)
* [React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127)
* [深入了解 React Fiber 内部实现](https://blog.logrocket.com/deep-dive-into-react-fiber-internals/)
* [手写React的Fiber架构，深入理解其原理](https://juejin.cn/post/6844904197008130062)

