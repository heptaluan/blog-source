---
title: React 中的 HOC
date: 2020-10-25
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/15.jpg
---

我们在之前的 [React 中的 Mixin](http://localhost:4000/2020/10/24/React/14/) 章节当中介绍了一些 `Mixin` 的基本原理和它存在的一些问题，而且在之前我们也提到过，`React` 现在已经不再推荐使用 `Mixin` 来解决代码复用问题，因为 `Mixin` 带来的危害比他产生的价值还要巨大，推荐我们使用高阶组件来替代它，所以在本章当中我们就来深入的了解一下什么是高阶组件，以及它存在的一些问题和其应用场景

<!--more-->


----

以下是之前的内容，待重新整理

----



## 装饰器模式

在介绍高阶组件之前，我们先来了解一下装饰器模式的相关内容，之所以先介绍装饰器模式，这是因为 `React` 当中的高阶组件其实就是装饰器模式的一种应用方式，所谓装饰器模式（`Decorator Pattern`），它允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，这里需要注意的是，它是不会改变原本类的，这一点很关键

#### JavaScript 当中的装饰器

装饰器是 `ES7` 中的一个新语法，正如其字面意思而言，它可以对类、方法、属性进行修饰，从而进行一些相关功能定制，简而言之就是对对象进行包装，返回一个新的对象描述（`descriptor`），这个概念其实和 `React` 中的高阶组件也类似，我们来看下面这个示例，假设我们现在要对一个函数 `log`，打印出它的执行记录，如果不使用装饰器是下面这样的

```js
const log = (fn) => {
  if (typeof (fn) !== 'function') {
    throw new Error(`the param must be a function`)
  }
  return (...arguments) => {
    console.info(`${fn.name} invoke with ${arguments.join(',')}`)
    fn(...arguments)
  }
}

const plus = (a, b) => a + b
const logPlus = log(plus)

logPlus(1, 2) // plus invoke with 1, 2
```

而如果使用装饰器则是下面这样的

```js
const log = (target, name, descriptor) => {
  var oldValue = descriptor.value
  descriptor.value = function () {
    console.log(`Calling ${name} with`, arguments)
    return oldValue.apply(this, arguments)
  }
  return descriptor
}

class Math {
  @log
  plus(a, b) {
    return a + b
  }
}

const math = new Math()

math.add(1, 2) // Calling plus with 1, 2
```

从上面的代码可以看出，如果有的时候我们并不需要关心函数的内部实现，仅仅是想调用它的话，装饰器能够带来比较好的可读性，使用起来也是非常的方便，下面我们就简单的来深入了解一下其中的原理



#### 装饰器原理

其实简单来说，`JavaScript` 当中的装饰器本质也是一个函数，利用的是 `JavaScript` 中 `Object` 的 `descriptor`，这个函数会接收三个参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
 */
function Decorator(target, name, descriptor) {
  // 以此可以获取实例化的时候此属性的默认值
  let v = descriptor.initializer && descriptor.initializer.call(this)
  // 返回一个新的描述对象作为被修饰对象的描述，或者直接修改也可以
  return {
    enumerable: true,
    configurable: true,
    get() {
      return v
    },
    set(c) {
      v = c
    },
  }
}

// USE
class Fudao {
  @Decorator
  title = '标题'
}
```

当然装饰器也可以接受参数，其实就是将外部包装一个函数，而函数可以带参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
*/
function Decorator(type) {
  return (target, name, descriptor) => {
    let v = descriptor.initializer && descriptor.initializer.call(this)
    return {
      enumerable: true,
      configurable: true,
      get() {
        return v + type
      },
      set(c) {
        v = c
      },
    }
  }
}

// USE
class Fudao {
  @Decorator('string')
  title = '标题'
}
```


#### 常见的装饰器

这里我们只挑选几个常见的装饰器简单的介绍一下，它们是 `autobind` 和 `readonly`，更多第三方装饰器可以参考 [core-decorators](https://github.com/jayphelps/core-decorators) 这个库，比如 `autobind` 修饰器使得方法中的 `this` 对象，绑定原始对象，使得 `this` 始终指向绑定的对象

```js
import { autobind } from 'core-decorators' // a NPM lib

class Person {
  @autobind
  getPerson() {
    return this
  }
}

let person = new Person()
let getPerson = person.getPerson

getPerson() === person
// true
```

而 `readonly` 修饰器使得属性或方法不可写

```js
import { readonly } from 'core-decorators'

class Fudao {
  @readonly
  title = '标题'
}

var fudao = new Fudao()
fudao.title = '新的标题'
```





## 高阶函数

说到高阶组件，这里我们就不得不先简单的来介绍一下高阶函数，关于高阶函数的定义，[维基](https://zh.wikipedia.org/zh-hans/高阶函数) 上的定义是，高阶函数是至少满足下列一个条件的函数

* 接受一个或多个函数作为输入
* 输出一个函数

比如下面这个示例，就是一个简单的高阶函数

```js
const add = (x, y, f) => f(x) + f(y)

add(-5, 6, Math.abs)
```

当我们在调用的时候，参数 `x`，`y` 和 `f` 分别接收 `-5`，`6` 和 `Math.abs`，根据函数定义，我们可以推导计算过程为

```js
x ==> -5
y ==> 6
f ==> Math.abs

f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11
```

所以上面代码执行后的结果为 `11`，有了这些了解以后，我们下面就正式的来看看高阶组件的相关内容



## 高阶组件

那么，什么是高阶组件呢？类比高阶函数的定义，高阶组件就是接受一个组件作为参数并返回一个新组件的函数，这里需要注意高阶组件是一个函数，并不是组件，这一点一定要注意

更通俗地描述为，高阶组件通过包裹（`wrapped`）被传入的 `React` 组件，经过一系列处理，最终返回一个相对增强（`enhanced`）的 `React` 组件，供其他组件调用，下面我们先来实现一个简单的高阶组件（函数）看看它是如何工作的，它接受一个 `React` 组件，包裹后然后返回

```js
export default function withHeader(WrappedComponent) {
  return class HOC extends Component {
    render() {
      return <div>
        <div className="demo-header">
          我是标题
        </div>
        <WrappedComponent {...this.props} />
      </div>
    }
  }
}
```

我们在其他组件里就可以来引用这个高阶组件，用来强化它

```js
@withHeader
export default class Demo extends Component {
  render() {
    return (
      <div>
        我是一个普通组件
      </div>
    )
  }
}
```

在这里我们使用了上面介绍到的装饰器模式来让写法变得更为优雅，当然下面这种写法也是可以的

```js
const EnhanceDemo = withHeader(Demo)
```

如下图所示，我们可以发现 `Demo` 组件已经被 `HOC` 组件包裹起来了，符合了高阶组件的预期，即组件是层层包裹起来的，如同洋葱一样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/15-01.png)

但是随之带来的问题是，如果这个高阶组件被使用了多次，那么在调试的时候，将会看到一大堆 `HOC`，所以这个时候需要做一点小优化，就是在高阶组件包裹后，应当保留其原有名称，我们改写一下上述的高阶组件代码，增加了 `getDisplayName` 函数以及静态属性 `displayName`

```js
function getDisplayName(component) {
  return component.displayName || component.name || 'Component'
}

export default function (WrappedComponent) {
  return class HOC extends Component {
    static displayName = `HOC(${getDisplayName(WrappedComponent)})`
    render() {
      return <div>
        <div className="demo-header">
          我是标题
        </div>
        <WrappedComponent {...this.props} />
      </div>
    }
  }
}
```

此时我们再去观察就会如下图所示，可以发现此时原本组件的名称也会正确的显示了

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/15-02.png)

由此可以看出，高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用



## 组件参数

但是我们仔细观察上方的示例可以发现，此时这个高阶组件的作用仅仅只是展示了标题名称，但是为了更好的抽象，此标题应当可以被参数化，如下方式调用

```js
// 如果传入参数，则传入的参数将作为组件的标题呈现
@withHeader('Demo')
export default class Demo extends Component {
  render() {
    return (
      //...
    )
  }
}
```

所以我们来简单的调整一下 `withHeader`，让它接受一个参数，然后返回一个高阶组件（函数）

```js
export default function (title) {
  return function (WrappedComponent) {
    return class HOC extends Component {
      render() {
        return <div>
          <div className="demo-header">
            {title
              ? title
              : '我是标题'}
          </div>
          <WrappedComponent {...this.props} />
        </div>
      }
    }
  }
}
```

也使用 `ES6` 写法来进行简化

```js
export default (title) => (WrappedComponent) => class HOC extends Component {
  render() {
    return <div>
      <div className="demo-header">
        {title
          ? title
          : '我是标题'}
      </div>
      <WrappedComponent {...this.props} />
    </div>
  }
}
```



## 组合多个高阶组件

我们在上面使用高阶组件为 `React` 组件添加一个显示标题的功能，但是如果需要同时增加多个功能需要怎么做？这种场景非常常见，例如我们既需要增加一个组件标题，又需要在此组件未加载完成时显示 `Loading`，即下面这种情况

```js
@withHeader
@withLoading
class Demo extends Component {

}
```

针对于这种情况，我们可以使用 `compose` 来简化上述过程，这样也能体现函数式编程的思想

```js
const enhance = compose(withHeader, withLoading)

@enhance
class Demo extends Component {

}
```

这里我们简单的介绍一下 `compose`，`compose` 可以帮助我们组合任意个（包括 `0` 个）高阶函数，例如 `compose(a, b, c)` 返回一个新的函数 `d`，函数 `d` 依然接受一个函数作为入参，只不过在内部会依次调用 `c, b, a`，从表现层对使用者保持透明

基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更 `compose` 函数里的参数个数便可，更多详细内容可以参考 [Redux-Compose](https://redux.js.org/api/compose)






## React 中的高阶组件

`React` 中的高阶组件主要有两种形式，即属性代理和反向继承，它们的区别如下

* 属性代理（`props proxy`），即高阶组件通过被包裹的 `React` 组件来操作 `props`
* 反向继承（`inheritance inversion`），即高阶组件继承于被包裹的 `React` 组件

#### 属性代理

属性代理是最常见的高阶组件的使用方式，最直观的就是接收到 `props`，我们可以做任何读取，编辑，删除的很多自定义操作，包括定义自定义事件，都可以通过 `props` 再传下去，这称之为属性代理

```js
import React, { Component } from 'React'

// 高阶组件定义
const HOC = (WrappedComponent) =>
  class WrapperComponent extends Component {
    render() {
      return <WrappedComponent {...this.props} />
    }
  }

// 普通的组件
class WrappedComponent extends Component {
  render() {
    //....
  }
}

// 高阶组件使用
export default HOC(WrappedComponent)
```

我们可以看见函数HOC返回了新的组件（`WrapperComponent`），这个组件原封不动的返回作为参数的组件（也就是被包裹的组件 `WrappedComponent`），并将传给它的参数（`props`）全部传递给被包裹的组件（`WrappedComponent`）

其实简单来说，属性代理其实就是一个函数接受一个 `WrappedComponent` 组件作为参数传入，并返回一个继承了 `React.Component` 组件的类，且在该类的 `render()` 方法中返回被传入的 `WrappedComponent` 组件，又因为属性代理类型的高阶组件返回的其实是一个标准的 `React.Component` 组件，所以我们可以利用属性代理来实现以下操作

* 操作 `props`
* 抽离 `state`
* 用其他元素包裹传入的组件 `WrappedComponent`


###### 操作 props

我们看到之前要传递给被包裹组件 `WrappedComponent` 的属性首先传递给了高阶组件返回的组件（`WrapperComponent`），这样我们就获得了 `props` 的控制权（这也就是为什么这种方法叫做属性代理），我们可以按照需要对传入的 `props` 进行增加、删除、修改（当然修改带来的风险需要你自己来控制）

```js
const HOC = (WrappedComponent) =>
  class WrapperComponent extends Component {
    render() {
      const newProps = {
        name: 'HOC'
      }
      return <WrappedComponent {...this.props} {...newProps} />
    }
  }
```

在上面的例子中，我们为被包裹组件（`WrappedComponent`）新增加了固定的 `name` 属性，因此 `WrappedComponent` 组件中就会多一个 `name` 的属性


###### 抽离 state

属性代理的情况下，我们可以将被包裹组件（`WrappedComponent`）中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变

```js
class WrappedComponent extends Component {
  render() {
    return <input name="name" {...this.props.name} />
  }
}

const HOC = (WrappedComponent) =>
  class extends Component {
    constructor(props) {
      super(props)
      this.state = {
        name: '',
      }
      this.onNameChange = this.onNameChange.bind(this)
    }
    onNameChange(event) {
      this.setState({
        name: event.target.value,
      })
    }
    render() {
      const newProps = {
        name: {
          value: this.state.name,
          onChange: this.onNameChange,
        },
      }
      return <WrappedComponent {...this.props} {...newProps} />
    }
  }
```

上面的例子中通过高阶组件，我们将不受控组件（`WrappedComponent`）成功的转变为受控组件



###### 用其他元素包裹传入的组件 WrappedComponent

又比如给 `WrappedComponent` 组件包一层背景色为 `#fafafa` 的 `div` 元素

```js
function withBackgroundColor(WrappedComponent) {
  return class extends React.Component {
    render() {
      return (
        <div style={{ backgroundColor: '#fafafa' }}>
          <WrappedComponent {...this.props} {...newProps} />
        </div>
      )
    }
  }
}
```



#### 反向继承

反向继承其实就是一个函数接受一个 `WrappedComponent` 组件作为参数传入，并返回一个继承了该传入 `WrappedComponent` 组件的类，且在该类的 `render()` 方法中返回 `super.render()` 方法

```js
const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      return super.render()
    }
  }
```

其实我们仔细观察可以发现，其实属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是 `React.Component`，反向继承中继承的是传入的组件 `WrappedComponent`，它的作用主要是下面两点

* 操作 `state`
* 渲染劫持（`Render Highjacking`）

###### 操作 state

高阶组件中可以读取、编辑和删除 `WrappedComponent` 组件实例中的 `state`，甚至可以增加更多的 `state` 项，但是 **非常不建议这么做** 因为这可能会导致 `state` 难以维护及管理

```js
function withLogging(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      return (
        <div>
          <h2>Debugger Component Logging...</h2>
          <p>state:</p>
          <pre>{JSON.stringify(this.state, null, 4)}</pre>
          <p>props:</p>
          <pre>{JSON.stringify(this.props, null, 4)}</pre>
          {super.render()}
        </div>
      )
    }
  }
}
```

在这个例子中利用高阶函数中可以读取 `state` 和 `props` 的特性，对 `WrappedComponent` 组件做了额外元素的嵌套，把 `WrappedComponent` 组件的 `state` 和 `props` 都打印了出来


###### 渲染劫持

渲染劫持是指我们可以有意识地控制 `WrappedComponent` 的渲染过程，从而控制渲染控制的结果，例如我们可以根据部分参数去决定是否渲染组件

```js
const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      if (this.props.isRender) {
        return super.render()
      } else {
        return null
      }
    }
  }
```

甚至我们可以修改修改 `render` 的结果

```js
const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      const elementsTree = super.render()
      let newProps = {}
      if (elementsTree && elementsTree.type === 'input') {
        newProps = { value: 'inner' }
      }
      const props = Object.assign({}, elementsTree.props, newProps)
      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)
      return newElementsTree
    }
  }

class WrappedComponent extends Component {
  render() {
    return (
      <input value={'Hello World'} />
    )
  }
}

// 实际显示的效果是 input 的值为 inner
export default HOC(WrappedComponent)

```

上面的例子中我们将 `WrappedComponent` 中的 `input` 元素 `value` 值修改为 `inner`，虽然在反向继承中，我们可以做非常多的操作，例如修改 `state`、`props` 等，但是反向继承有一个重要的点，那就是反向继承不能保证完整的子组件树被解析，关于这一点我们会在下面的高阶组件存在的问题当中来详细介绍


## 高阶组件存在的问题

主要有下面三点

* 静态方法丢失
* `refs` 属性不能透传
* 反向继承不能保证完整的子组件树被解析

#### 静态方法丢失

因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法

```js
// 定义静态方法
WrappedComponent.staticMethod = function () { }

// 使用高阶组件
const EnhancedComponent = HigherOrderComponent(WrappedComponent)

// 增强型组件没有静态方法
typeof EnhancedComponent.staticMethod === 'undefined' // true
```

所以必须将静态方法做拷贝

```js
function HigherOrderComponent(WrappedComponent) {
  class Enhance extends React.Component { }

  // 必须得知道要拷贝的方法
  Enhance.staticMethod = WrappedComponent.staticMethod

  return Enhance
}
```

但是这么做的一个缺点就是必须知道要拷贝的方法是什么，不过我们可以使用 [hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics) 这个库来自动处理，它会自动拷贝所有非 `React` 的静态方法

```js
import hoistNonReactStatic from 'hoist-non-react-statics'

function HigherOrderComponent(WrappedComponent) {
  class Enhance extends React.Component { }

  hoistNonReactStatic(Enhance, WrappedComponent)
  
  return Enhance
}
```


#### refs 属性不能透传

一般来说高阶组件可以传递所有的 `props` 给包裹的组件 `WrappedComponent`，但是有一种属性不能传递，它就是 `ref`，与其他属性不同的地方在于 `React` 对其进行了特殊的处理，如果你向一个由高阶组件创建的组件的元素添加 `ref` 引用，那么 `ref` 指向的是最外层容器组件实例的，而不是被包裹的 `WrappedComponent` 组件

那如果有一定要传递 `ref` 的需求呢，在这种情况下我们可以使用 `React.forwardRef` 这个 `API` 来进行解决

```js
function withLogging(WrappedComponent) {
  class Enhance extends WrappedComponent {
    componentWillReceiveProps() {
      console.log('Current props', this.props)
      console.log('Next props', nextProps)
    }
    render() {
      const { forwardedRef, ...rest } = this.props
      // 把 forwardedRef 赋值给 ref
      return <WrappedComponent {...rest} ref={forwardedRef} />
    }
  }

  // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数
  // 所以这边的 ref 是由 React.forwardRef 提供的
  function forwardRef(props, ref) {
    return <Enhance {...props} forwardRef={ref} />
  }

  return React.forwardRef(forwardRef)
}

const EnhancedComponent = withLogging(SomeComponent)
```

#### 反向继承不能保证完整的子组件树被解析

关于这一点可能不太好理解，但是我们可以借住 [React Components, Elements, and Instances](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html) 这篇文章来进行了解，在文章当中主要明确了以下两点内容

* 元素（`element`）是一个是用 `DOM` 节点或者组件来描述屏幕显示的纯对象，元素可以在属性（`props.children`）中包含其他的元素，一旦创建就不会改变，我们通过 `JSX` 和 `React.createClass` 创建的都是元素
* 组件（`component`）可以接受属性（`props`）作为输入，然后返回一个元素树（`element tree`）作为输出，有多种实现方式，比如 `Class` 或者函数（`Function`）

所以，反向继承不能保证完整的子组件树被解析的意思就是，如果解析的元素树中包含了组件（函数类型或者 `Class`类型），就不能再操作组件的子组件了，这就是所谓的不能完全解析，比如

```js
import React, { Component } from 'react'

const MyFuncComponent = (props) => {
  return (
    <div>Hello World</div>
  )
}

class MyClassComponent extends Component {
  render() {
    return (
      <div>Hello World</div>
    )
  }
}

class WrappedComponent extends Component {
  render() {
    return (
      <div>
        <div>
          <span>Hello World</span>
        </div>
        <MyFuncComponent />
        <MyClassComponent />
      </div>
    )
  }
}

const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      const elementsTree = super.render()
      return elementsTree
    }
  }

export default HOC(WrappedComponent)
```

运行结果如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/15-03.png)

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/15-04.png)

通过观察控制台当中的页面结构可以发现，`div` 下的 `span` 是可以被完全被解析的，但是 `MyFuncComponent` 和 `MyClassComponent` 都是组件类型的，其子组件就不能被完全解析了






## 高阶组件的约定

高阶组件带给我们极大方便的同时，我们也要遵循一些约定，主要有以下这些

* `props` 保持一致
* 你不能在函数式（无状态）组件上使用 `ref` 属性，因为它没有实例
* 不要以任何方式改变原始组件 `WrappedComponent`
* 透传不相关 `props` 属性给被包裹的组件 `WrappedComponent`
* 不要在 `render()` 方法中使用高阶组件
* 使用 `compose` 组合高阶组件
* 包装显示名字以便于调试


#### props 保持一致

高阶组件在为子组件添加特性的同时，要尽量保持原有组件的 `props` 不受影响，也就是说传入的组件和返回的组件在 `props` 上尽量保持一致

#### 不要改变原始组件 WrappedComponent

不要在高阶组件内以任何方式修改一个组件的原型，比如下面的代码

```js
function withLogging(WrappedComponent) {
  WrappedComponent.prototype.componentWillReceiveProps = function (nextProps) {
    console.log('Current props', this.props)
    console.log('Next props', nextProps)
  }
  return WrappedComponent
}

const EnhancedComponent = withLogging(SomeComponent)
```

可以发现，我们在高阶组件的内部对 `WrappedComponent` 进行了修改，一旦对原组件进行了修改，那么就失去了组件复用的意义，所以在这种情况下最好使用纯函数（相同的输入总有相同的输出）来返回新的组件

```js
function withLogging(WrappedComponent) {
  return class extends React.Component {
    componentWillReceiveProps() {
      console.log('Current props', this.props)
      console.log('Next props', nextProps)
    }
    render() {
      // 透传参数，不要修改它
      return <WrappedComponent {...this.props} />
    }
  }
}
```

这样优化之后的 `withLogging` 是一个纯函数，并不会修改 `WrappedComponent` 组件，所以不需要担心有什么副作用，进而达到组件复用的目的


#### 透传不相关 props 属性给被包裹的组件 WrappedComponent

```js
function HigherOrderComponent(WrappedComponent) {
  return class extends React.Component {
    render() {
      return <WrappedComponent name="name" {...this.props} />
    }
  }
}
```


#### 不要在 render() 方法中使用高阶组件

```js
class SomeComponent extends React.Component {
  render() {
    // 调用高阶函数的时候每次都会返回一个新的组件
    const EnchancedComponent = enhance(WrappedComponent)
    // 每次 render 的时候，都会使子对象树完全被卸载和重新
    // 重新加载一个组件会引起原有组件的状态和它的所有子组件丢失
    return <EnchancedComponent />
  }
}
```


#### 使用 compose 组合高阶组件

```js
// 不要这么使用
const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))
```

针对于这种情况，可以使用一个 `compose` 函数组合这些高阶组件，`lodash/redux/ramda` 等第三方库都提供了类似 `compose` 功能的函数

```js
const enhance = compose(withRouter, connect(commentSelector))

const EnhancedComponent = enhance(WrappedComponent)
```

因为按照约定实现的高阶组件其实就是一个纯函数，如果多个函数的参数一样（在这里 `withRouter` 函数和 `connect(commentSelector)` 所返回的函数所需的参数都是 `WrappedComponent`），所以就可以通过 `compose` 方法来组合这些函数

> 关于 `compose` 相关内容我们在上方已经简单介绍过了，更新详细内容可以参考 [Redux-Compose](https://redux.js.org/api/compose)



#### 包装显示名字以便于调试

高阶组件创建的容器组件在 `React Developer Tools` 中的表现和其它的普通组件是一样的，为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果

```js
const getDisplayName = WrappedComponent => WrappedComponent.displayName || WrappedComponent.name || 'Component'

function HigherOrderComponent(WrappedComponent) {
  class HigherOrderComponent extends React.Component { /* ... */ }

  HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(WrappedComponent)})`

  return HigherOrderComponent
}
```

实际上有一些第三方类库，比如 [recompose](https://github.com/acdlite/recompose) 等已经帮我们实现了类似的功能，如下

```js
import getDisplayName from 'recompose/getDisplayName'

HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(BaseComponent)})`

// or

import wrapDisplayName from 'recompose/wrapDisplayName'

HigherOrderComponent.displayName = wrapDisplayName(BaseComponent, 'HigherOrderComponent')
```



## 高阶组件的应用场景

最后我们来看一下如何在业务场景中使用高阶组件


#### 权限控制

利用高阶组件的条件渲染特性可以对页面进行权限控制，权限控制一般分为两个维度，页面级别和页面元素级别，这里以页面级别为例，首先是我们的高阶组件

```js
function withAdminAuth(WrappedComponent) {
  return class extends React.Component {
    state = {
      isAdmin: false,
    }
    async UNSAFE_componentWillMount() {
      const currentRole = await getCurrentUserRole()
      this.setState({
        isAdmin: currentRole === 'Admin',
      })
    }
    render() {
      if (this.state.isAdmin) {
        return <WrappedComponent {...this.props} />
      } else {
        return (<div>您没有权限查看该页面，请联系管理员！</div>)
      }
    }
  }
}
```

然后是两个页面 `A` 和 `B`

```js
class PageA extends React.Component {
  constructor(props) {
    super(props)
  }
  UNSAFE_componentWillMount() {
    // fetching data
  }
  render() {
    // render page with data
  }
}

export default withAdminAuth(PageA)
```

```js
class PageB extends React.Component {
  constructor(props) {
    super(props)
  }
  UNSAFE_componentWillMount() {
    // fetching data
  }
  render() {
    // render page with data
  }
}

export default withAdminAuth(PageB)
```

使用高阶组件对代码进行复用之后，可以发现是非常方便就可以进行拓展的，但是如果后续需求有所调整，比如某个组件需只要 `VIP` 权限就可以访问了，那该如何处理呢？当然你可以新写一个高阶组件 `withVIPAuth` 来进行使用

但是在这里我们可以采用一种更为高效的方式，那就是在高阶组件之上再抽象一层，所以我们就无需去实现各种 `withXXXAuth` 高阶组件，我们要做的就是实现一个返回高阶组件的函数，把变的部分（比如这里的 `Admin`、`VIP` 等）抽离出来，保留不变的部分，具体实现如下

```js
const withAuth = role => WrappedComponent => {
  return class extends React.Component {
    state = {
      permission: false
    }
    async UNSAFE_componentWillMount() {
      const currentRole = await getCurrentUserRole()
      this.setState({
        permission: currentRole === role
      })
    }
    render() {
      if (this.state.permission) {
        return <WrappedComponent {...this.props} />
      } else {
        return (<div>您没有权限查看该页面，请联系管理员！</div>)
      }
    }
  }
}
```

可以发现经过对高阶组件再进行了一层抽象后，前面的 `withAdminAuth` 可以写成 `withAuth('Admin')` 了，如果此时需要 `VIP` 权限的话，只需在 `withAuth` 函数中传入 `'VIP'` 就可以了，可以发现其实是和 `react-redux` 的 `connect` 方法的使用方式非常像，关于这部分更为详细的内容可以参考我们之前手动实现的 [connect](http://localhost:4000/2020/10/23/React/13/#Connect-和-mapStateToProps) 方法


#### 组件渲染性能追踪

借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录

```js
class Home extends React.Component {
  render() {
    return (<h1>Hello World.</h1>)
  }
}

function withTiming(WrappedComponent) {
  return class extends WrappedComponent {
    constructor(props) {
      super(props)
      this.start = 0
      this.end = 0
    }
    UNSAFE_componentWillMount() {
      super.UNSAFE_componentWillMount && super.UNSAFE_componentWillMount()
      this.start = Date.now()
    }
    componentDidMount() {
      super.componentDidMount && super.componentDidMount()
      this.end = Date.now()
      console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`)
    }
    render() {
      return super.render()
    }
  }
}

export default withTiming(Home)
```

如下，`withTiming` 是利用反向继承实现的一个高阶组件，功能是计算被包裹组件（这里是 `Home` 组件）的渲染时间



#### 页面复用

假设我们有两个页面 `pageA` 和 `pageB` 分别渲染两个分类的电影列表，普通写法可能是这样

```js
class PageA extends React.Component {
  state = {
    movies: [],
  }

  // ...

  async UNSAFE_componentWillMount() {
    const movies = await fetchMoviesByType('science-fiction')
    this.setState({
      movies,
    })
  }

  render() {
    return <MovieList movies={this.state.movies} />
  }
}

export default PageA
```

```js
class PageB extends React.Component {
  state = {
    movies: [],
  }

  // ...

  async UNSAFE_componentWillMount() {
    const movies = await fetchMoviesByType('action')
    this.setState({
      movies,
    })
  }

  render() {
    return <MovieList movies={this.state.movies} />
  }
}

export default PageB
```

页面少的时候可能没什么问题，但是假如随着业务的进展，需要上线的越来越多类型的电影，就会写很多的重复代码，所以我们需要重构一下

```js
const withFetching = fetching => WrappedComponent => {
  return class extends React.Component {
    state = {
      data: [],
    }
    async UNSAFE_componentWillMount() {
      const data = await fetching()
      this.setState({
        data,
      })
    }
    render() {
      return <WrappedComponent data={this.state.data} {...this.props} />
    }
  }
}

// A 组件
export default withFetching(fetching('science-fiction'))(MovieList)

// B 组件
export default withFetching(fetching('action'))(MovieList)

// C 组件
export default withFetching(fetching('some-other-type'))(MovieList)
```

会发现 `withFetching` 其实和前面的 `withAuth` 函数类似，把变的部分（`fetching(type)`）抽离到外部传入，从而实现页面的复用




## 参考

* [React 进阶之高阶组件](https://github.com/sunyongjian/blog/issues/25)
* [ES6 中优雅的 mixin 式继承](https://h5jun.com/post/mixin-in-es6.html)
* [装饰者模式的应用和 ES6 装饰器](https://segmentfault.com/a/1190000017082225)
* [使用高阶组件优化你的代码](https://segmentfault.com/a/1190000004598113?utm_source=sf-related)
* [React 高阶组件(HOC)入门指南](https://segmentfault.com/a/1190000009386662?utm_source=sf-related)

