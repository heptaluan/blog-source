---
title: React-Redux 的实现
date: 2020-10-23
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/13.jpg
---

接上回 [Redux 的实现](https://heptaluan.github.io/2020/10/04/React/12/)，我们在之前的章节当中，从一个简单的示例开始一步一步推导出 `Redux` 的实现方式，但是之前我们也提到过，它其实跟 `React.js` 一点关系都没有，所以在本章当中我们会把 `React.js` 和 `Redux` 结合起来，用 `Redux` 模式帮助我们来管理 `React.js` 的应用状态

<!--more-->

在前端当中应用的状态存在的问题就是一个状态可能被多个组件依赖或者影响，而 `React.js` 并没有提供好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，也就是我们可以把共享状态放到父组件的 `context` 上，让这个父组件以下的所有组件都可以从 `context` 中直接获取到状态而不需要一层层地进行传递了

但是直接从 `context` 里面存放、获取数据增强了组件的耦合性，并且所有组件都可以修改 `context` 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料，既然这样，我们为什么不把 `context` 和 `store` 结合起来呢？毕竟 `store` 的数据不能直接被修改，而是约定只能通过 `dispatch` 来进行修改，这样的话每个组件既可以去 `context` 里面获取 `store` 从而获取状态，又不用担心它们乱改数据

## 初始化

所以我们就来尝试一下，就拿官方文档当中那个主题色的示例，稍微的调整一下，比如我们要做下面这样的组件树

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/13-01.png)

`Header` 和 `Content` 的组件的文本内容会随着主题色的变化而变化，而 `Content` 下的子组件 `ThemeSwitch` 有两个按钮，可以切换红色和蓝色两种主题，按钮的颜色也会随着主题色的变化而变化，各组件代码如下

```js
export default class Header extends Component {
  render() {
    return (
      <h2>
        标题
      </h2>
    )
  }
}

export default class Content extends Component {
  render() {
    return (
      <div>
        <div>内容</div>
        <ThemeSwitch />
      </div>
    )
  }
}

export default class ThemeSwitch extends Component {
  render() {
    return (
      <div>
        <button>Red</button>
        <button>Blue</button>
      </div>
    )
  }
}

class Index extends Component {
  render() {
    return (
      <div>
        <Header />
        <Content />
      </div>
    )
  }
}
```

当然现在文本是没有颜色的，而且点击按钮也不会有什么反应，这些内容我们会在后面慢慢来进行完善


## 结合 Context 和 Store

下面我们就来构建 `store`，用的也就是我们在之前章节当中实现的 `createStore` 方法，然后我们在构建一个 `themeReducer` 来生成一个 `store`，如下

```js
function createStore(reducer) {
  let state = null
  const listeners = []
  const subscribe = (listener) => listeners.push(listener)
  const getState = () => state
  const dispatch = (action) => {
    state = reducer(state, action)
    listeners.forEach((listener) => listener())
  }
  dispatch({})
  return { getState, dispatch, subscribe }
}

const themeReducer = (state, action) => {
  if (!state) return {
    themeColor: 'red'
  }
  switch (action.type) {
    case 'CHANGE_COLOR':
      return { ...state, themeColor: action.themeColor }
    default:
      return state
  }
}

const store = createStore(themeReducer)

// ...
```

`themeReducer` 定义了一个表示主题色的状态 `themeColor`，并且规定了一种操作 `CHNAGE_COLOR`，只能通过这种操作修改颜色，现在我们把 `store` 放到 `Index` 的 `context` 里面，这样每个子组件都可以获取到 `store` 了

```js
class Index extends Component {
  static childContextTypes = {
    store: PropTypes.object
  }

  getChildContext() {
    return { store }
  }

  render() {
    return (
      <div>
        <Header />
        <Content />
      </div>
    )
  }
}

export default Index
```

这里有一个看上去可能有些疑惑的 `childContextTypes`，它的作用其实与 `propsType` 验证组件 `props` 参数的作用类似，不过它验证的是 `getChildContext` 返回的对象，那么为什么又要验证 `context` 呢？

这是因为 `context` 是一个危险的特性，所以 `React.js` 团队将其使用方式设置的复杂一些，提高使用门槛的同时也会让你注意到它的危险性，如果你要给组件设置 `context`，那么 `childContextTypes` 是必写的

下面我们就可以来调整 `Header` 组件，让它从 `context` 里面获取 `store`，并且获取里面的 `themeColor` 状态来设置自己的颜色

```js
export default class Header extends Component {
  static contextTypes = {
    store: PropTypes.object
  }

  constructor() {
    super()
    this.state = { 
      themeColor: '' 
    }
  }

  componentDidMount() {
    const { store } = this.context
    this._updateThemeColor()
    store.subscribe(() => this._updateThemeColor())
  }

  _updateThemeColor() {
    const { store } = this.context
    const state = store.getState()
    this.setState({ themeColor: state.themeColor })
  }

  render() {
    return (
      <h2 style={{ color: this.state.themeColor }}>
        标题
      </h2>
    )
  }
}
```

同样的，作为子组件的 `Header`，想要获取 `context` 里面的内容的话，就必须写 `contextTypes` 来声明和验证你需要获取的状态的类型，它也是必写的，如果你不写就无法获取 `context` 里面的状态

运行完成以后可以发现，标题的颜色已经变成了红色，其实上面的代码逻辑很简单，我们在 `constructor` 里面初始化了组件自己的 `themeColor` 状态，然后在生命周期中调用 `_updateThemeColor，_updateThemeColor` 会从 `context` 里面把 `store` 取出来，然后通过 `store.getState()` 获取当前的 `state` 对象，并且用里面的 `themeColor` 字段设置组件的 `state.themeColor`

同时通过 `store.subscribe` 进行监听，在数据变化的时候重新调用 `_updateThemeColor`，而 `_updateThemeColor` 会去 `store` 里面取最新的 `themeColor` 然后通过 `setState` 重新渲染组件

同理，我们将 `Content` 组件和 `ThemeSwitch` 组件也调整成从 `store` 当中来获取主题色

```js
export default class Content extends Component {
  static contextTypes = {
    store: PropTypes.object
  }

  constructor() {
    super()
    this.state = {
      themeColor: ''
    }
  }

  componentDidMount() {
    const { store } = this.context
    this._updateThemeColor()
    store.subscribe(() => this._updateThemeColor())
  }

  _updateThemeColor() {
    const { store } = this.context
    const state = store.getState()
    this.setState({ themeColor: state.themeColor })
  }


  render() {
    return (
      <div>
        <div style={{ color: this.state.themeColor }}>内容</div>
        <ThemeSwitch />
      </div>
    )
  }
}

export default class ThemeSwitch extends Component {
  static contextTypes = {
    store: PropTypes.object
  }

  constructor() {
    super()
    this.state = {
      themeColor: ''
    }
  }

  componentDidMount() {
    const { store } = this.context
    this._updateThemeColor()
    store.subscribe(() => this._updateThemeColor())
  }

  _updateThemeColor() {
    const { store } = this.context
    const state = store.getState()
    this.setState({ themeColor: state.themeColor })
  }

  render() {
    return (
      <div style={{ color: this.state.themeColor }}>
        <button>Red</button>
        <button>Blue</button>
      </div>
    )
  }
}
```

运行以后可以发现，主题已经完全生效了，此时整个页面当中的元素都是红色的，当然现在点按钮还是没什么效果，所以我们接下来就是给按钮添加点击事件

```js
export default class ThemeSwitch extends Component {
  
  // ...

  handleSwitchColor(color) {
    const { store } = this.context
    store.dispatch({
      type: 'CHANGE_COLOR',
      themeColor: color
    })
  }

  render() {
    return (
      <div>
        <button
          style={{ color: this.state.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'red')}
        >Red</button>
        <button
          style={{ color: this.state.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'blue')}
        >Blue</button>
      </div>
    )
  }
}
```

我们给两个按钮都加上了 `onClick` 事件监听，并绑定到了 `handleSwitchColor` 方法上，在点击的时候分别给这个方法传入不同的颜色，`handleSwitchColor` 会根据传入的颜色来 `store.dispatch` 一个 `action` 去修改颜色

如此一来，我们就完成了自由的切换主题颜色的功能了，但是其中还有不少可以优化的地方，我们下面慢慢来看



## Connect 和 mapStateToProps

我们仔细观察我们之前设计的组件，发现有两个比较严重的问题

1. 有大量重复的逻辑，它们基本的逻辑都是取出 `context`，得到里面的 `store`，然后用里面的状态设置自己的状态，这些代码逻辑其实都是相同的
2. 对 `context` 依赖性过强，这些组件都要依赖 `context` 来取数据，使得这个组件复用性基本为零

所以我们需要针对以上两点问题来进行处理，关于第一点，我们都知道在 `React.js` 当中有一个 `HOC`（高阶组件）的概念，我们可以把一些可复用的逻辑放在高阶组件当中，高阶组件包装的新组件和原来组件之间通过 `props` 传递信息，减少代码的重复程度

至于第二点，我们可以将其改写成为 `UI` 组件，关于 `UI` 组件，也称为 `Dumb Component`，因为你传递给它什么，它就渲染什么出来，对参数（`props`）以外的数据零依赖，也不产生副作用，所以我们需要高阶组件来帮助我们从 `context` 取数据，使用高阶组件和 `context` 打交道，把里面数据取出来通过 `props` 传给 `UI` 组件，也就是如下图当中所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/13-02.png)

我们把这个高阶组件起名为 `connect`，因为它把 `UI` 组件和 `context` 连接（`connect`）起来了

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export const connect = (WrappedComponent) => {
  class Connect extends Component {
    static contextTypes = {
      store: PropTypes.object
    }

    render() {
      return <WrappedComponent />
    }
  }

  return Connect
}
```

`connect` 函数接受一个组件 `WrappedComponent` 作为参数，把这个组件包含在一个新的组件 `Connect` 里面，`Connect` 会去 `context` 里面取出 `store`，现在要把 `store` 里面的数据取出来通过 `props` 传给 `WrappedComponent`，但是每个传进去的组件需要 `store` 里面的数据都不一样的，所以还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据

为了解决这个问题，我们需要一个映射函数来告诉 `store` 如何返回我们需要的数据，我们将其命名为 `mapStateToProps`，如下

```js
const mapStateToProps = (state) => {
  return {
    themeColor: state.themeColor,
    themeName: state.themeName,
    // ...
  }
}
```

这个函数会接受 `store.getState()` 的结果作为参数，然后返回一个对象，这个对象是根据 `state` 生成的，也就是我们使用 `mapStateTopProps` 去告知 `Connect` 应该如何去 `store` 里面取数据，然后得到我们需要的数据以后，再把这个函数的返回结果传给被包装的组件

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export const connect = (mapStateToProps) => (WrappedComponent) => {
  class Connect extends Component {
    static contextTypes = {
      store: PropTypes.object
    }

    render() {
      const { store } = this.context
      let stateProps = mapStateToProps(store.getState())
      return <WrappedComponent {...stateProps} />
    }
  }

  return Connect
}
```

其中的 `{...stateProps}` 意思是把这个对象里面的属性全部通过 `props` 方式传递进去，`connect` 现在接受一个参数 `mapStateToProps`，然后返回一个函数，这个返回的函数才是高阶组件，它会接受一个组件作为参数，然后用 `Connect` 把组件包装以后再返回，`connect` 的用法是

```js
// ...

const mapStateToProps = (state) => {
  return {
    themeColor: state.themeColor
  }
}

Header = connect(mapStateToProps)(Header)

// ...
```

我们把上面 `connect` 的函数代码单独分离到一个模块当中，再把之前的监听数据变化重新渲染的逻辑放到其中调整一下，并将其取名为 `react-redux.js`

```js
export const connect = (mapStateToProps) => (WrappedComponent) => {
  class Connect extends Component {
    static contextTypes = {
      store: PropTypes.object
    }

    constructor() {
      super()
      this.state = { allProps: {} }
    }

    componentDidMount() {
      const { store } = this.context
      this._updateProps()
      store.subscribe(() => this._updateProps())
    }

    _updateProps() {
      const { store } = this.context
      // 额外传入 props，让获取数据更加灵活方便
      let stateProps = mapStateToProps(store.getState(), this.props)
      this.setState({
        // 整合普通的 props 和从 state 生成的 props
        allProps: {
          ...stateProps,
          ...this.props
        }
      })
    }

    render() {
      return <WrappedComponent {...this.state.allProps} />
    }
  }

  return Connect
}
```

我们在 `Connect` 组件的 `constructor` 里面初始化了 `state.allProps`，它是一个对象，用来保存需要传给被包装组件的所有的参数，为了让 `connect` 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 `Connect` 的 `props` 原封不动地传给 `WrappedComponent`，所以在 `_updateProps` 里面会把 `stateProps` 和 `this.props` 合并到 `this.state.allProps` 里面，再通过 `render` 方法把所有参数都传给 `WrappedComponent`

`mapStateToProps` 也发生点变化，它现在可以接受两个参数了，我们会把传给 `Connect` 组件的 `props` 参数也传给它，那么它生成的对象配置性就更强了，我们可以根据 `store` 里面的 `state` 和外界传入的 `props` 生成我们想传给被包装组件的参数，接下来我们就可以在 `Header` 当中来进行使用了

```js
class Header extends Component {
  static propTypes = {
    themeColor: PropTypes.string
  }

  render() {
    return (
      <h2 style={{ color: this.props.themeColor }}>
        标题
      </h2>
    )
  }
}

const mapStateToProps = (state) => {
  return {
    themeColor: state.themeColor
  }
}

Header = connect(mapStateToProps)(Header)

export default Header
```

如上，可以发现我们在 `Header` 当中删掉了大部分关于 `context` 的代码，它除了 `props` 什么也不依赖，所以它是一个纯粹的 `UI` 组件，只需要通过 `connect` 来取得数据，但是我们不需要知道 `connect` 是怎么和 `context` 打交道的，所以只需要传递一个 `mapStateToProps` 告诉它应该怎么取数据就可以了，再用同样的方式来修改 `Content`

```js
class Content extends Component {
  static propTypes = {
    themeColor: PropTypes.string
  }

  render() {
    return (
      <div>
        <div style={{ color: this.props.themeColor }}>内容</div>
        <ThemeSwitch />
      </div>
    )
  }
}

const mapStateToProps = (state) => {
  return {
    themeColor: state.themeColor
  }
}

Content = connect(mapStateToProps)(Content)

export default Content
```

修改以后再次刷新界面，发现功能还是跟之前一样，但是我们的 `Header` 和 `Content` 的代码都大大减少了，但是我们的事情并没有做完，接下来我们还需要继续重构 `ThemeSwitch`




## mapDispatchToProps

在重构 `ThemeSwitch` 的时候我们发现，`ThemeSwitch` 除了需要 `store` 里面的数据以外，还需要 `store` 来 `dispatch`，但是我们目前版本的 `connect` 是达不到这个效果的，所以我们需要改进它，但是仔细一想，既然可以通过给 `connect` 函数传入 `mapStateToProps` 来告诉它如何获取、整合状态，那么我们也可以给它传入另外一个参数来告诉它我们的组件需要如何触发 `dispatch` 的，我们把这个参数叫 `mapDispatchToProps`

```js
const mapDispatchToProps = (dispatch) => {
  return {
    onSwitchColor: (color) => {
      dispatch({ type: 'CHANGE_COLOR', themeColor: color })
    }
  }
}
```

和 `mapStateToProps` 一样，它返回一个对象，这个对象内容会同样被 `connect` 当作是 `props` 参数传给被包装的组件，而不一样的是这个函数不是接受 `state` 作为参数，而是 `dispatch`，你可以在返回的对象内部定义一些函数，这些函数会用到 `dispatch` 来触发特定的 `action`，所以我们调整 `connect` 让它能接受这样的 `mapDispatchToProps`

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {
  class Connect extends Component {
    static contextTypes = {
      store: PropTypes.object
    }

    constructor() {
      super()
      this.state = { allProps: {} }
    }

    componentDidMount() {
      const { store } = this.context
      this._updateProps()
      store.subscribe(() => this._updateProps())
    }

    _updateProps() {
      const { store } = this.context
      let stateProps = mapStateToProps
        ? mapStateToProps(store.getState(), this.props)
        : {}
      let dispatchProps = mapDispatchToProps
        ? mapDispatchToProps(store.dispatch, this.props)
        : {}
      this.setState({
        allProps: {
          ...stateProps,
          ...dispatchProps,
          ...this.props
        }
      })
    }

    render() {
      return <WrappedComponent {...this.state.allProps} />
    }
  }
  return Connect
}
```

在 `_updateProps` 内部，我们把 `store.dispatch` 作为参数传给 `mapDispatchToProps`，它会返回一个对象 `dispatchProps`，接着把 `stateProps`、`dispatchProps`、`this.props` 三者合并到 `this.state.allProps` 里面去，这三者的内容都会在 `render` 函数内全部传给被包装的组件

这时候我们就可以重构 `ThemeSwitch`，让它摆脱 `store.dispatch`

```js
class ThemeSwitch extends Component {
  static propTypes = {
    themeColor: PropTypes.string,
    onSwitchColor: PropTypes.func
  }

  handleSwitchColor(color) {
    if (this.props.onSwitchColor) {
      this.props.onSwitchColor(color)
    }
  }

  render() {
    return (
      <div>
        <button
          style={{ color: this.props.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'red')}
        >Red</button>
        <button
          style={{ color: this.props.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'blue')}
        >Blue</button>
      </div>
    )
  }
}

const mapStateToProps = (state) => {
  return {
    themeColor: state.themeColor
  }
}

const mapDispatchToProps = (dispatch) => {
  return {
    onSwitchColor: (color) => {
      dispatch({ type: 'CHANGE_COLOR', themeColor: color })
    }
  }
}

ThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)

export default ThemeSwitch
```

现在的 `ThemeSwitch` 只依赖外界传进来的 `themeColor` 和 `onSwitchColor`，但是 `ThemeSwitch` 内部并不知道这两个参数其实都是我们去 `store` 里面取的，此时我们的三个组件的重构都已经完成了，代码大大减少、不依赖 `context`，并且功能和原来一样






## Provider

至此，我们的大体结构已经搭建的差不多了，但是还有一点就是我们能不能将和 `context` 相关的代码从所有业务组件中清除出去，这样一来就可以保证我们的业务组件都是干净的，所以我们来稍微的重构一下我们的 `Index` 组件

在 `Index` 组件当中之所以需要用到 `context`，就是因为要把 `store` 存放到里面，好让子组件 `connect` 的时候能够取到 `store`，所以我们可以额外构建一个单独的组件专门来做这件事情，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 `context` 了，我们把这个组件叫 `Provider`，因为它提供（`provide`）了 `store`

```js
export class Provider extends Component {
  static propTypes = {
    store: PropTypes.object,
    children: PropTypes.any
  }

  static childContextTypes = {
    store: PropTypes.object
  }

  getChildContext() {
    return {
      store: this.props.store
    }
  }

  render() {
    return (
      <div>{this.props.children}</div>
    )
  }
}
```

`Provider` 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来，它还会把外界传给它的 `props.store` 放到 `context`，这样子组件 `connect` 的时候都可以获取到，下面我们再来调整 `Index` 组件，也就是删除 `Index` 里面所有关于 `context` 的代码

```js
// 删除 Index 里面所有关于 context 的代码
class Index extends Component {
  render() {
    return (
      <div>
        <Header />
        <Content />
      </div>
    )
  }
}

// 把 Provider 作为组件树的根节点
ReactDOM.render(
  <Provider store={store}>
    <Index />
  </Provider>,
  document.getElementById('root')
)
```

这样我们就把所有关于 `context` 的代码从组件里面删除了