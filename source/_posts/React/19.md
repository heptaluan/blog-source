---
title: Fiber 架构的简单实现
date: 2020-12-18
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/19.webp
---

我们在之前的文章当中梳理了 [React Fiber](http://localhost:4000/2020/12/06/React/18/) 相关内容，了解了 `Fiber` 的基本作用以及它内部一些简单的运行原理，所以在本章当中我们来继续深入理解其原理，尝试尝试手动的模拟实现一个简易版本的 `Fiber` 架构，下面我们就先从 `JSX` 开始看起

<!--more-->


## JSX

我们都知道，`JSX` 是一种特殊的语法，在之前版本的 `React` 当中如果想要支持 `JSX` 语法的话还需要一个额外库的来进行支持（`JSXTransformer.js`），不过后来 `JSX` 的转换工作全部都集成到了 `Babel` 当中，比如下面这段简单的代码

```js
const App = (
  <div>
    <h1 id="title">Title</h1>
    <a href="###">Link</a>
    <section>
      <p>
        Article
      </p>
    </section>
  </div>
)
```

我们可以通过 `Babel` 的 [在线预览功能](https://www.babeljs.cn/repl#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYewdgzgLgBAggBwTAvDAFAKBjAPAEwEsA3APmxzwAsBGGQ_FAIikKgBsBTJ0gFTa64A9LXKU8AQxhUATpwBmzAMQ8AMoTABrYRLGVcETsFbg943AjPj4M1sC4VzQy47xDDxwqYrCiZTACUQA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.12.11&externalPlugins=) 来查看它转化后的样子，它是下面这样的

```js
var App = React.createElement(
  'div',
  null,
  React.createElement(
    'h1',
    {
      id: 'title',
    },
    'Title',
  ),
  React.createElement(
    'a',
    {
      href: '###',
    },
    'Link',
  ),
  React.createElement(
    'section',
    null,
    React.createElement('p', null, 'Article'),
  ),
)
```

可以发现，我们书写的 `JSX` 代码已经被换成了 `React.createElement` 的写法，同时从转换后的代码我们也可以发现 `React.createElement` 是支持多个参数的

* `type`，也就是节点类型
* `config`，节点上的属性，比如 `id` 和 `href`
* `children`，从第三个参数开始就全部是子元素，子元素可以有多个，类型可以是简单的文本，也可以还是 `React.createElement`，如果是 `React.createElement` 的话其实就是子节点了，子节点下面还可以有子节点，这样就用 `React.createElement` 的嵌套关系实现了 `HTML` 节点的树形结构

而我们上面这段 `JSX` 代码如果想在 `React` 框架下运行起来，还需要 `React` 提供的额外两个库来进行支持，如下

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = _ => {
  return (
    <div>
      <h1 id="title">Title</h1>
      <a href="###">Link</a>
      <section>
        <p>
          Article
      </p>
      </section>
    </div>
  )
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
)
```

通过观察我们可以发现，这里面用到了 `React` 的地方其实就两个，一个是 `JSX`，也就是 `React.createElement`，另一个就是 `ReactDOM.render`，所以下面我们就先来简单的看看 `createElement` 和 `render` 这两个方法


## createElement

对于 `<h1 id="title">Title</h1>` 这样一个简单的节点，我们都知道原生 `DOM` 会附加一大堆属性和方法在上面，所以我们在 `createElement` 的时候最好能将它转换为一种比较简单的数据结构，只包含我们需要的元素，比如下面这样

```js
{
  type: 'h1',
  props: {
    id: 'title',
    children: 'Title'
  }
}
```

有了这个数据结构后，我们对于 `DOM` 的操作其实可以转化为对这个数据结构的操作，新老 `DOM` 的对比其实也可以转化为这个数据结构的对比，这样我们就不需要每次操作都去渲染页面，而是等到需要渲染的时候才将这个数据结构渲染到页面上，这其实就是所谓的 「虚拟 `DOM`」，而我们 `createElement` 就是负责来构建这个虚拟 `DOM` 的方法

这里关于 `createElement` 的实现就不具体展开了，详细可以参考我们之前已经整理过的 [什么是 Virtual DOM](http://localhost:4000/2019/12/15/React/06/) 系列文章或是 [官方版本](https://github.com/facebook/react/blob/60016c448bb7d19fc989acd05dda5aca2e124381/packages/react/src/ReactElement.js#L348) ，核心逻辑并不复杂，这里我们只需要知道它是用来帮助我们构建虚拟 `DOM` 的方法即可





## render

在上面的代码中我们使用 `createElement` 将 `JSX` 代码转换成了虚拟 `DOM`，但是我们又该如何将虚拟 `DOM` 渲染为真实的 `DOM` 节点呢？所以我们还需要一个 `render` 方法来帮助我们实现这个功能，我们通过上面的使用可以发现，`render` 方法接收两个参数

* 根组件，其实是一个 `JSX` 组件，也就是一个 `createElement` 返回的虚拟 `DOM`
* 父节点，也就是我们要将这个虚拟 `DOM` 渲染的位置

有了这些了解以后我们就可以来实现我们自己的 `render` 方法了

```js
function render(vDom, container) {
  let dom
  if (typeof vDom !== 'object') {
    dom = document.createTextNode(vDom)
  } else {
    dom = document.createElement(vDom.type)
  }

  // 将 vDom 上除了 children 外的属性都挂载到真正的 DOM 上去
  if (vDom.props) {
    Object.keys(vDom.props)
      .filter(key => key != 'children')
      .forEach(item => {
        dom[item] = vDom.props[item]
      })
  }

  // 如果还有子元素，递归调用
  if (vDom.props && vDom.props.children && vDom.props.children.length) {
    vDom.props.children.forEach(child => render(child, dom))
  }

  container.appendChild(dom)
}
```

当然，上述代码只是简化版本的 `render` 方法，比如我们没有考虑节点具体类型的区别，又或是挂载和更新的不同处理逻辑等，详细内容同样可以参考我们之前已经整理过的 [什么是 Virtual DOM](http://localhost:4000/2019/12/15/React/06/) 系列文章或是 [官方源码](https://github.com/facebook/react/blob/3e94bce765d355d74f6a60feb4addb6d196e3482/packages/react-dom/src/client/ReactDOMLegacy.js#L287) 来了解更多，因为这一部分在本文当中不是我们重点关注的内容，所以我们只是简单介绍一二，下面我们就主要来看看 `Fiber` 的相关内容


## render 的拆分

我们在上面实现了虚拟 `DOM` 渲染到页面上的代码，这部分工作被 `React` 官方称为 `renderer`，`renderer` 是第三方可以自己实现的一个模块，其中有个核心模块叫做 `reconsiler`，而 `reconsiler` 的一大功能就是大家熟知的 `diff`，它会计算出应该更新哪些页面节点，然后将需要更新的节点虚拟 `DOM` 传递给 `renderer`，`renderer` 负责将这些节点渲染到页面上

但是这个流程有个问题，也是我们在 [React Fiber](http://localhost:4000/2020/12/06/React/18/) 章节开头部分所提到的，那就是虽然 `React` 的 `diff` 算法是经过优化的，但是它却是同步的，`renderer` 负责操作 `DOM` 的一些操作也是同步的，也就是说如果有大量节点需要更新，`JavaScript` 线程的运行时间可能会比较长，在这段时间浏览器是不会响应其它事件的，因为 `JavaScript` 线程和 `GUI` 线程是互斥的，如果这个时间太长了，用户就可能看到卡顿，这也就是为什么 `React` 会推出 `Fiber` 的原因，`Fiber` 可以将长时间的同步任务拆分成多个小任务，从而让浏览器能够抽身去响应其它事件，等它有空了再回来继续计算

但是我们在上面实现的 `render` 方法，它是直接递归遍历了整个树，如果我们在中途某一步停下来，下次再调用时其实并不知道上次在哪里停下来的，不知道从哪里开始，即使你将上次的结束节点记下来了，你也不知道下一个该执行哪个，所以简单的虚拟 `DOM` 树形结构并不满足中途暂停，下次继续的需求，所以我们需要改造数据结构

而另一个需要解决的问题是，拆分下来的小任务什么时候执行？我们的目的是让用户有更流畅的体验，所以我们最好不要阻塞高优先级的任务，比如用户输入，动画之类，等它们执行完了我们再计算，那我怎么知道现在有没有高优先级任务，浏览器是不是空闲呢？所以总结下来，`Fiber` 要想达到目的，需要解决两个问题

* 新的任务调度，有高优先级任务的时候将浏览器让出来，等浏览器空了再继续执行
* 新的数据结构，可以随时中断，下次进来可以接着执行

所幸，针对这两点我们都已经有了对应的解决方式，也就是 [之前文章](http://localhost:4000/2020/12/06/React/18/) 当中所提及到的 `Fiber` 数据结构与 `requestIdleCallback` 这个 `API`，这里我们就不过多介绍了，只简单提及一二

#### requestIdleCallback

`requestIdleCallback` 接收一个回调，这个回调会在浏览器空闲时调用，每次调用会传入一个 `IdleDeadline`，可以得到当前还空余多久，`options` 可以传入参数最多等多久，等到了时间浏览器还不空就强制执行了，使用这个 `API` 可以解决我们之前提到的任务调度的问题，让浏览器在空闲时才计算 `diff` 并渲染，调用方式如下

```js
// 开启调用
var handle = window.requestIdleCallback(callback[, options])

// 结束调用
Window.cancelIdleCallback(handle)
```

但是这个 `API` 还处在实验阶段，兼容性不好，所以 `React` 官方自己实现了一套，但是在这里我们还是使用 `requestIdleCallback` 来进行任务调度，我们进行任务调度的思想是将任务拆分成多个小任务，`requestIdleCallback` 里面不断的把小任务拿出来执行，当所有任务都执行完或者超时了就结束本次执行，同时要注册下次执行，我们可以借住官方的 [workLoopSync](https://github.com/facebook/react/blob/4c7036e807fa18a3e21a5182983c7c0f05c5936e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1481) 实现方式得出大致架子，如下所示

```js
function workLoop(deadline) {
  while (nextUnitOfWork && deadline.timeRemaining() > 1) {
    // while 循环会在任务执行完或者时间到了的时候结束
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
  }

  // 如果任务还没完，但是时间到了，我们需要继续注册 requestIdleCallback
  requestIdleCallback(workLoop)
}

// performUnitOfWork 用来执行任务，参数是我们的当前 fiber 任务，返回值是下一个任务
function performUnitOfWork(fiber) {

}

requestIdleCallback(workLoop)
```


#### Fiber 数据结构

上面我们的 `performUnitOfWork` 并没有实现，但是从上面的结构可以看出来，它接收的参数是一个小任务，同时通过这个小任务还可以找到它的下一个小任务，`Fiber` 构建的就是这样一个数据结构，而我们之前的虚拟 `DOM` 的数据结构是一棵树，父节点的 `children` 指向了子节点，但是只有这一个指针是不能实现中断继续的，所以我们需要对之前的结构进行一定的调整，可以参考官方演讲当中的方式，如下

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/19-01.png)

现在可以看到和之前父节点指向所有子节点不同，这里有三个指针

* `child`，父节点指向第一个子元素的指针
* `sibling`，从第一个子元素往后，指向下一个兄弟元素
* `return`，所有子元素都有的指向父元素的指针

有了这几个指针后，我们可以在任意一个元素中断遍历并恢复，比如在上图 `List` 处中断了，恢复的时候可以通过 `child` 找到他的子元素，也可以通过 `return` 找到他的父元素，如果他还有兄弟节点也可以用 `sibling` 找到，`Fiber` 这个结构外形看着还是棵树，但是没有了指向所有子元素的指针，父节点只指向第一个子节点，然后子节点有指向其他子节点的指针，所以可以发现这其实是个链表结构





