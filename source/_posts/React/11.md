---
title: React 查漏补缺
date: 2020-10-11
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/11.jpg
---

本章主要用于记录一些 `React` 相关知识点，因为最近在复习 `React` 相关内容，发现版本迭代了许多，废弃了很多 `API`，也添加了一些新的方法（比如生命周期钩子等），所以就简单的在这里汇总整理一下，也算是查漏补缺

<!--more-->



## 回调函数中的 this

通常，我们在 `React` 当中的事件处理是下面这样

```js
class Toggle extends React.Component {
  constructor(props) {
    super(props)
    this.state = { isToggleOn: true }

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }))
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    )
  }
}
```

我们之所以要在构造函数当中进行显式的 `this` 绑定，这是因为在 `JavaScript` 中，`Class` 的方法默认不会绑定 `this`，如果你忘记绑定 `this.handleClick` 并把它传入了 `onClick`，当你调用这个函数的时候 `this` 的值为 `undefined`，如果不想显式的执行绑定操作的话，我们经常还会采用下面这种方式，即使用箭头函数的方式

```js
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this)
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    )
  }
}
```

此语法问题在于每次渲染 `LoggingButton` 时都会创建不同的回调函数，在大多数情况下，这没什么问题，但如果该回调函数作为 `prop` 传入子组件时，这些组件可能会进行额外的重新渲染，所以建议使用下面这种方式来进行绑定，即使用 `Class fields` 语法

```js
class LoggingButton extends React.Component {
  // 确保 `handleClick` 内的 `this` 已被绑定
  handleClick = () => {
    console.log('this is:', this)
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    )
  }
}
```



## 事件处理程序参数传递

在循环中，通常我们会为事件处理函数传递额外的参数，例如 `id` 是你要删除那一行的 `id`，以下两种方式都可以向事件处理函数传递参数

```html
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>

// or

<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

在这两种情况下，`React` 的事件对象 `e` 会被作为第二个参数传递，如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 `bind` 的方式，事件对象以及更多的参数将会被隐式的进行传递



## React.lazy

`React.lazy` 函数能让你像渲染常规组件一样处理动态引入（的组件），在使用之前

```js
import OtherComponent from './OtherComponent'
```

而使用之后

```js
const OtherComponent = React.lazy(() => import('./OtherComponent'))
```

不过更为常见的方式是搭配 `React.Suspense` 使用

```js
import React, { Suspense } from 'react'

const OtherComponent = React.lazy(() => import('./OtherComponent'))

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  )
}
```

`React.lazy()` 接收一个函数作为参数，该函数需要返回一个 `Promise` 对象，`reslove` 后返回一个模块，模块的默认导出对象作为渲染的 `React` 组件，例如

```js
import React from 'react'

function OtherComponent() {
  return (
    <h1>
      Hello World
    </h1>
  )
}

export default OtherComponent
```


#### 如何支持有名导出的模块

使用 `React.lazy()` 加载的模块，如果其中的 `React` 组件不是默认导出话，可能会报以下错误

```js
Warning: React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined. 

You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.
```

这是因为 `React.lazy()` 目前只支持默认导出（`Default Export`），不支持有名导出（`Named Exports`），假如在 `OtherComponent` 中导出了多个组件，如下

```js
import React, { Component } from 'react'

export class AComponent extends Component {
  render() {
    return (
      <div>
        Hello
      </div>
    )
  }
}

export class BComponent extends Component {
  render() {
    return (
      <div>
        World
      </div>
    )
  }
}
```

我们在 `OtherComponent` 组件当中分别导出了 `AComponent` 和 `BComponent` 两个组件，在不修改 `OtherComponent` 的前提下，可以这样写

```js
const OtherComponent = React.lazy(() => {
  return new Promise((resolve, reject) => {
    import('./OtherComponent').then(module => {
      resolve({
        // 这里可以根据需求加载 `AComponent` 或是 `BComponent`
        default: module.AComponent
      })
    }).catch(err => {
      reject(err)
    })
  })
})

export default class Test extends Component {
  render() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <OtherComponent />
        </Suspense>
      </div>
    )
  }
}
```

#### 搭配 Webpack 实现代码分割

借助 `Webpack` 的 [Code Splitting](https://webpack.js.org/guides/code-splitting/) 功能，使用动态 `import()` 引入的模块会被自动拆分为异步加载的 `chunk`，如果希望自定义 `chunk` 的文件名，可以在 `import()` 中加入 `Webpack` 特定的注释，如下

```js
const OtherComponent = React.lazy(
  () => import(/* webpackChunkName: 'Other-Component' */ './OtherComponent')
)
```

例如如下代码

```js
const AComponent = React.lazy(() => import(/* webpackChunkName: 'A-component' */ './AComponent'))
const BComponent = React.lazy(() => import(/* webpackChunkName: 'B-component' */ './BComponent'))

export default class Test extends Component {
  render() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <AComponent />
          <BComponent />
        </Suspense>
      </div>
    )
  }
}
```

运行后可以在控制台的 `Network` 选项当中发现 `A-component.chunk.js` 和 `B-component.chunk.js`


