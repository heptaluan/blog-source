---
title: 高阶组件（HOC）
date: 2020-10-25
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/14.jpg
---

在 `React` 中，我们会经常听到或是看到关于高阶组件的一些用法，所以在今天就抽些时间，来深入的了解一下什么是高阶组件，以及它存在的一些问题和其应用场景

<!--more-->



## 装饰器模式

在介绍高阶组件之前，我们先来了解一下装饰器模式的相关内容，之所以先介绍装饰器模式，这是因为 `React` 当中的高阶组件其实就是装饰器模式的一种应用方式，所谓装饰器模式（`Decorator Pattern`），它允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，这里需要注意的是，它是不会改变原本类的，这一点很关键

#### JavaScript 当中的装饰器

装饰器是 `ES7` 中的一个新语法，正如其字面意思而言，它可以对类、方法、属性进行修饰，从而进行一些相关功能定制，简而言之就是对对象进行包装，返回一个新的对象描述（`descriptor`），这个概念其实和 `React` 中的高阶组件也类似，我们来看下面这个示例，假设我们现在要对一个函数 `log`，打印出它的执行记录，如果不使用装饰器是下面这样的

```js
const log = (fn) => {
  if (typeof (fn) !== 'function') {
    throw new Error(`the param must be a function`)
  }
  return (...arguments) => {
    console.info(`${fn.name} invoke with ${arguments.join(',')}`)
    fn(...arguments)
  }
}

const plus = (a, b) => a + b
const logPlus = log(plus)

logPlus(1, 2) // plus invoke with 1, 2
```

而如果使用装饰器则是下面这样的

```js
const log = (target, name, descriptor) => {
  var oldValue = descriptor.value
  descriptor.value = function () {
    console.log(`Calling ${name} with`, arguments)
    return oldValue.apply(this, arguments)
  }
  return descriptor
}

class Math {
  @log
  plus(a, b) {
    return a + b
  }
}

const math = new Math()

math.add(1, 2) // Calling plus with 1, 2
```

从上面的代码可以看出，如果有的时候我们并不需要关心函数的内部实现，仅仅是想调用它的话，装饰器能够带来比较好的可读性，使用起来也是非常的方便，下面我们就简单的来深入了解一下其中的原理



#### 装饰器原理

其实简单来说，`JavaScript` 当中的装饰器本质也是一个函数，利用的是 `JavaScript` 中 `Object` 的 `descriptor`，这个函数会接收三个参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
 */
function Decorator(target, name, descriptor) {
  // 以此可以获取实例化的时候此属性的默认值
  let v = descriptor.initializer && descriptor.initializer.call(this)
  // 返回一个新的描述对象作为被修饰对象的描述，或者直接修改也可以
  return {
    enumerable: true,
    configurable: true,
    get() {
      return v
    },
    set(c) {
      v = c
    },
  }
}

// USE
class Fudao {
  @Decorator
  title = '标题'
}
```

当然装饰器也可以接受参数，其实就是将外部包装一个函数，而函数可以带参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
*/
function Decorator(type) {
  return (target, name, descriptor) => {
    let v = descriptor.initializer && descriptor.initializer.call(this)
    return {
      enumerable: true,
      configurable: true,
      get() {
        return v + type
      },
      set(c) {
        v = c
      },
    }
  }
}

// USE
class Fudao {
  @Decorator('string')
  title = '标题'
}
```


#### 常见的装饰器

这里我们只挑选几个常见的装饰器简单的介绍一下，它们是 `autobind` 和 `readonly`，更多第三方装饰器可以参考 [core-decorators](https://github.com/jayphelps/core-decorators) 这个库

autobind修饰器使得方法中的this对象，绑定原始对象，使得this始终指向绑定的对象，

```js
import { autobind } from 'core-decorators'; // a NPM lib

class Person {
  @autobind
  getPerson() {
    return this;
  }
}

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
```

而 readonly修饰器使得属性或方法不可写，

```js
import { readonly } from 'core-decorators';

class Fudao {
  @readonly
  title = '企鹅辅导';
}

var fudao = new Fudao();
fudao.title = '腾讯课堂'; // This will log error & doesn't work
```





## 高阶函数

说到高阶组件，这里我们就不得不先简单的来介绍一下高阶函数，关于高阶函数的定义，[维基](https://zh.wikipedia.org/zh-hans/高阶函数) 上的定义是，高阶函数是至少满足下列一个条件的函数

* 接受一个或多个函数作为输入
* 输出一个函数

比如下面这个示例，就是一个简单的高阶函数

```js
const add = (x, y, f) => f(x) + f(y)

add(-5, 6, Math.abs)
```

当我们在调用的时候，参数 `x`，`y` 和 `f` 分别接收 `-5`，`6` 和 `Math.abs`，根据函数定义，我们可以推导计算过程为

```js
x ==> -5
y ==> 6
f ==> Math.abs

f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11
```

所以上面代码执行后的结果为 `11`，有了这些了解以后，我们下面就正式的来看看高阶组件的相关内容



## 高阶组件

那么，什么是高阶组件呢？类比高阶函数的定义，高阶组件就是接受一个组件作为参数并返回一个新组件的函数，这里需要注意高阶组件是一个函数，并不是组件，这一点一定要注意

更通俗地描述为，高阶组件通过包裹（`wrapped`）被传入的 `React` 组件，经过一系列处理，最终返回一个相对增强（`enhanced`）的 `React` 组件，供其他组件调用，下面我们先来实现一个简单的高阶组件（函数）看看它是如何工作的，它接受一个 `React` 组件，包裹后然后返回

```js
export default function withHeader(WrappedComponent) {
  return class HOC extends Component {
    render() {
      return <div>
        <div className="demo-header">
          我是标题
        </div>
        <WrappedComponent {...this.props} />
      </div>
    }
  }
}
```

我们在其他组件里就可以来引用这个高阶组件，用来强化它

```js
@withHeader
export default class Demo extends Component {
  render() {
    return (
      <div>
        我是一个普通组件
      </div>
    )
  }
}
```

在这里我们使用了上面介绍到的装饰器模式来让写法变得更为优雅，当然下面这种写法也是可以的

```js
const EnhanceDemo = withHeader(Demo)
```

如下图所示，我们可以发现 `Demo` 组件已经被 `HOC` 组件包裹起来了，符合了高阶组件的预期，即组件是层层包裹起来的，如同洋葱一样

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/14-01.png)

但是随之带来的问题是，如果这个高阶组件被使用了多次，那么在调试的时候，将会看到一大堆 `HOC`，所以这个时候需要做一点小优化，就是在高阶组件包裹后，应当保留其原有名称，我们改写一下上述的高阶组件代码，增加了 `getDisplayName` 函数以及静态属性 `displayName`

```js
function getDisplayName(component) {
  return component.displayName || component.name || 'Component'
}

export default function (WrappedComponent) {
  return class HOC extends Component {
    static displayName = `HOC(${getDisplayName(WrappedComponent)})`
    render() {
      return <div>
        <div className="demo-header">
          我是标题
        </div>
        <WrappedComponent {...this.props} />
      </div>
    }
  }
}
```

此时我们再去观察就会如下图所示，可以发现此时原本组件的名称也会正确的显示了

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/14-02.png)

由此可以看出，高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用



## 组件参数

但是我们仔细观察上方的示例可以发现，此时这个高阶组件的作用仅仅只是展示了标题名称，但是为了更好的抽象，此标题应当可以被参数化，如下方式调用

```js
// 如果传入参数，则传入的参数将作为组件的标题呈现
@withHeader('Demo')
export default class Demo extends Component {
  render() {
    return (
      //...
    )
  }
}
```

所以我们来简单的调整一下 `withHeader`，让它接受一个参数，然后返回一个高阶组件（函数）

```js
export default function (title) {
  return function (WrappedComponent) {
    return class HOC extends Component {
      render() {
        return <div>
          <div className="demo-header">
            {title
              ? title
              : '我是标题'}
          </div>
          <WrappedComponent {...this.props} />
        </div>
      }
    }
  }
}
```

也使用 `ES6` 写法来进行简化

```js
export default (title) => (WrappedComponent) => class HOC extends Component {
  render() {
    return <div>
      <div className="demo-header">
        {title
          ? title
          : '我是标题'}
      </div>
      <WrappedComponent {...this.props} />
    </div>
  }
}
```



## 组合多个高阶组件

我们在上面使用高阶组件为 `React` 组件添加一个显示标题的功能，但是如果需要同时增加多个功能需要怎么做？这种场景非常常见，例如我们既需要增加一个组件标题，又需要在此组件未加载完成时显示 `Loading`，即下面这种情况

```js
@withHeader
@withLoading
class Demo extends Component {

}
```

针对于这种情况，我们可以使用 `compose` 来简化上述过程，这样也能体现函数式编程的思想

```js
const enhance = compose(withHeader, withLoading)

@enhance
class Demo extends Component {

}
```

这里我们简单的介绍一下 `compose`，`compose` 可以帮助我们组合任意个（包括 `0` 个）高阶函数，例如 `compose(a, b, c)` 返回一个新的函数 `d`，函数 `d` 依然接受一个函数作为入参，只不过在内部会依次调用 `c, b, a`，从表现层对使用者保持透明

基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更 `compose` 函数里的参数个数便可，更多详细内容可以参考 [Redux-Compose](https://redux.js.org/api/compose)






## React 中的高阶组件

`React` 中的高阶组件主要有两种形式，即属性代理和反向继承，它们的区别如下

* 属性代理（`props proxy`），即高阶组件通过被包裹的 `React` 组件来操作 `props`
* 反向继承（`inheritance inversion`），即高阶组件继承于被包裹的 `React` 组件

#### 属性代理

属性代理是最常见的高阶组件的使用方式，最直观的就是接收到 `props`，我们可以做任何读取，编辑，删除的很多自定义操作，包括定义自定义事件，都可以通过 `props` 再传下去，这称之为属性代理，它可以分为无状态和无状态两种情况

```js
// 无状态
function HigherOrderComponent(WrappedComponent) {
  return props => <WrappedComponent {...props} />
}

// 有状态
function HigherOrderComponent(WrappedComponent) {
  return class extends React.Component {
    render() {
      return <WrappedComponent {...this.props} />
    }
  }
}
```

可以发现，属性代理其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件，那我们可以利用属性代理类型的高阶组件做一些什么呢？

因为属性代理类型的高阶组件返回的是一个标准的 React.Component 组件，所以在 React 标准组件中可以做什么，那在属性代理类型的高阶组件中就也可以做什么，比如：

* 操作 props
* 抽离 state
* 通过 ref 访问到组件实例
* 用其他元素包裹传入的组件 WrappedComponent


###### 操作 props

我们可以为 WrappedComponent 添加新的属性

```js
function HigherOrderComponent(WrappedComponent) {
    return class extends React.Component {
        render() {
            const newProps = {
                name: '大板栗',
                age: 18,
            };
            return <WrappedComponent {...this.props} {...newProps} />;
        }
    };
}
```


###### 抽离 state

也可以利用 props 和回调函数把 state 抽离出来

```js
function withOnChange(WrappedComponent) {
    return class extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                name: '',
            };
        }
        onChange = () => {
            this.setState({
                name: '大板栗',
            });
        }
        render() {
            const newProps = {
                name: {
                    value: this.state.name,
                    onChange: this.onChange,
                },
            };
            return <WrappedComponent {...this.props} {...newProps} />;
        }
    };
}
```

可以按照下面的方式进行使用，这样就将 input 转化成受控组件了

```js
const NameInput = props => (<input name="name" {...props.name} />);
export default withOnChange(NameInput);
```

###### 通过 ref 访问到组件实例

有时会有需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性，它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上，ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是

* 组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例，
* 组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null，

如何在 高阶组件 中获取到 WrappedComponent 组件的实例呢？答案就是可以通过 WrappedComponent 组件的 ref 属性，该属性会在组件 componentDidMount 的时候执行 ref 的回调函数并传入该组件的实例

```js
function HigherOrderComponent(WrappedComponent) {
    return class extends React.Component {
        executeInstanceMethod = (wrappedComponentInstance) => {
            wrappedComponentInstance.someMethod();
        }
        render() {
            return <WrappedComponent {...this.props} ref={this.executeInstanceMethod} />;
        }
    };
}
```

再次强调，不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例

###### 用其他元素包裹传入的组件 WrappedComponent

比如给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：

```js
function withBackgroundColor(WrappedComponent) {
    return class extends React.Component {
        render() {
            return (
                <div style={{ backgroundColor: '#fafafa' }}>
                    <WrappedComponent {...this.props} {...newProps} />
                </div>
            );
        }
    };
}
```



#### 反向继承

反向继承其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法

```js
function HigherOrderComponent(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            return super.render();
        }
    };
}
```

其实我们仔细观察可以发现，其实属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是 React.Component，反向继承中继承的是传入的组件 WrappedComponent，它的作用主要是下面两点

* 操作 state
* 渲染劫持（Render Highjacking）

###### 操作 state

高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state，甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理，

```js
function withLogging(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            return (
                <div>
                    <h2>Debugger Component Logging...</h2>
                    <p>state:</p>
                    <pre>{JSON.stringify(this.state, null, 4)}</pre>
                    <p>props:</p>
                    <pre>{JSON.stringify(this.props, null, 4)}</pre>
                    {super.render()}
                </div>
            );
        }
    };
}
```

在这个例子中利用高阶函数中可以读取 state 和 props 的特性，对 WrappedComponent 组件做了额外元素的嵌套，把 WrappedComponent 组件的 state 和 props 都打印了出来，


###### 渲染劫持

之所以称之为 渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以

* 有条件地展示元素树（element tree）
* 操作由 render() 输出的 React 元素树
* 在任何由 render() 输出的 React 元素中操作 props
* 用其他元素包裹传入的组件 WrappedComponent （同 属性代理）

比较常用的比如下面的这个条件渲染，即通过 props.isLoading 这个条件来判断渲染哪个组件

```js
function withLoading(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            if(this.props.isLoading) {
                return <Loading />;
            } else {
                return super.render();
            }
        }
    };
}
```

以及修改元素树

```js
function HigherOrderComponent(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            const tree = super.render();
            const newProps = {};
            if (tree && tree.type === 'input') {
                newProps.value = 'something here';
            }
            const props = {
                ...tree.props,
                ...newProps,
            };
            const newTree = React.cloneElement(tree, props, tree.props.children);
            return newTree;
        }
    };
}
```


## 高阶组件存在的问题

主要有下面三点

* 静态方法丢失
* refs 属性不能透传
* 反向继承不能保证完整的子组件树被解析

#### 静态方法丢失

因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法：

```js
// 定义静态方法
WrappedComponent.staticMethod = function() {}
// 使用高阶组件
const EnhancedComponent = HigherOrderComponent(WrappedComponent);
// 增强型组件没有静态方法
typeof EnhancedComponent.staticMethod === 'undefined' // true
```

所以必须将静态方法做拷贝

```js
function HigherOrderComponent(WrappedComponent) {
    class Enhance extends React.Component {}
    // 必须得知道要拷贝的方法
    Enhance.staticMethod = WrappedComponent.staticMethod;
    return Enhance;
}
```

但是这么做的一个缺点就是必须知道要拷贝的方法是什么，不过 React 社区实现了一个库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法：

```js
import hoistNonReactStatic from 'hoist-non-react-statics';

function HigherOrderComponent(WrappedComponent) {
    class Enhance extends React.Component {}
    hoistNonReactStatic(Enhance, WrappedComponent);
    return Enhance;
}
```


#### refs 属性不能透传

一般来说高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref，与其他属性不同的地方在于 React 对其进行了特殊的处理，
如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件，
那如果有一定要传递 ref 的需求呢，别急，React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题

```js
function withLogging(WrappedComponent) {
    class Enhance extends WrappedComponent {
        componentWillReceiveProps() {
            console.log('Current props', this.props);
            console.log('Next props', nextProps);
        }
        render() {
            const {forwardedRef, ...rest} = this.props;
            // 把 forwardedRef 赋值给 ref
            return <WrappedComponent {...rest} ref={forwardedRef} />;
        }
    };

    // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数
    // 所以这边的 ref 是由 React.forwardRef 提供的
    function forwardRef(props, ref) {
        return <Enhance {...props} forwardRef={ref} />
    }

    return React.forwardRef(forwardRef);
}
const EnhancedComponent = withLogging(SomeComponent);
```

#### 反向继承不能保证完整的子组件树被解析

React 组件有两种形式，分别是 class 类型和 function 类型（无状态组件），
我们知道反向继承的渲染劫持可以控制 WrappedComponent 的渲染过程，也就是说这个过程中我们可以对 elements tree、state、props 或 render() 的结果做各种操作，
但是如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了，




## 高阶组件的约定

待续














## 参考

[react进阶之高阶组件](https://github.com/sunyongjian/blog/issues/25)
[ES6 中优雅的 mixin 式继承](https://h5jun.com/post/mixin-in-es6.html)
[装饰者模式的应用：react高阶组件和ES6 装饰器](https://segmentfault.com/a/1190000017082225)
[React进阶——使用高阶组件（Higher-order Components）优化你的代码](https://segmentfault.com/a/1190000004598113?utm_source=sf-related)

