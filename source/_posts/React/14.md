---
title: applyMiddleware(...middlewares)
date: 2019-06-16
categories: React
tags: React
toc: true
thumbnail: https://raw.githubusercontent.com/heptaluan/blog/master/backups/cdn/cover/14.jpg
---

在此之前，先来看看 `middleware`

<!--more-->


## Middleware

本质上，`Redux` 引入中间件机制，其实就是为了将在 `dispatch` 前后所做的事情统一起来

诸如统一的日志记录、引入 `thunk` 统一处理异步 `Action Creator` 等都属于中间件，比如下面就是一个简单的打印动作前后 `state` 的中间件

```js
// 比较优雅的写法
const printStateMiddleware = ({ getState }) => next => action => {
  console.log('state before dispatch', getState())
  let returnValue = next(action)
  console.log('state after dispatch', getState())
  return returnValue
}


// 一般的写法
function printStateMiddleware(middlewareAPI) {   // ① <== 中间件内可用的 API

  return function (dispatch) {                   // ② <== 传入上级中间件处理逻辑（若无则为原 store.dispatch）

    // ③ <== 整个函数将会被传到下级中间件（如果有的话）作为它的 dispatch 参数
    return function (action) {
      console.log('state before dispatch', middlewareAPI.getState())

      // dispatch 的返回值其实还是 action
      var returnValue = dispatch(action)

      console.log('state after dispatch', middlewareAPI.getState())

      // 将 action 返回给上一个中间件（实际上可以返回任意值，或不返回）
      return returnValue

    }
  }
}
```


## Store Enhancer（增强器）

`Store` 增强器就是对生成的 `store API` 进行改造，这是它与中间件最大的区别（中间件不修改 `store` 的 `API`）

而改造 `store` 的 `API` 就要从它的缔造者 `createStore` 入手，例如 `Redux` 的 `API` -- `applyMiddleware` 就是一个 `Store` 增强器

```js
// 这个函数前面有提到过，其实就是 compose(f, g, h)(action) ====> f(g(h(action)))
import compose from './compose'

// 传入中间件
export default function applyMiddleware(...middlewares) {

  // 传入 createStore
  return function (createStore) {

    // 返回一个函数签名跟 createStore 一模一样的函数，即返回的是一个增强版的 createStore
    return function (reducer, preloadedState, enhancer) {

      // 用原 createStore 先生成一个 store，其包含 getState / dispatch / subscribe / replaceReducer 四个 API
      var store = createStore(reducer, preloadedState, enhancer)

      var dispatch = store.dispatch // 指向原 dispatch
      var chain = [] // 存储中间件的数组

      // 提供给中间件的 API（其实都是 store 的 API）
      var middlewareAPI = {
        getState: store.getState,
        dispatch: (action) => dispatch(action)
      }

      // 给中间件 "组装上" API，见上面的 ①
      chain = middlewares.map(middleware => middleware(middlewareAPI))

      // 串联所有中间件
      dispatch = compose(...chain)(store.dispatch)

      // 例如，chain 为 [M3, M2, M1]，而 compose 是从右到左进行 "包裹" 的，那么

      // M1 的 dispatch 参数为 store.dispatch
      // M2 的 dispatch 参数为 M1 的 ②
      // M3 的 dispatch 参数为 M2 的 ②

      // 最后，我们得到串联后的中间件链：M3(M2(M1(store.dispatch)))
      // 也就是所谓的：中间件的洋葱模型

      return {
        ...store, // store 的 API 中保留 getState/subsribe/replaceReducer
        dispatch  // 新 dispatch 覆盖原 dispatch，往后调用 dispatch 就会触发 chain 内的中间件链式串联执行
      }
    }
  }
}
```

其实最终返回的虽然还是 `store` 的那四个 `API`，但其中的 `dispatch` 函数的功能被增强了，这就是所谓的 `Store Enhancer`

## 一个综合案例

```js
function inc() {
  return { type: 'INCREMENT' };
}

function dec() {
  return { type: 'DECREMENT' };
}

function reducer(state, action) {
  state = state || { counter: 0 };

  switch (action.type) {
    case 'INCREMENT':
      return { counter: state.counter + 1 };
    case 'DECREMENT':
      return { counter: state.counter - 1 };
    default:
      return state;
  }
}

// 见上方
function printStateMiddleware(middlewareAPI) {
  return function (dispatch) {
    return function (action) {
      console.log('dispatch 前：', middlewareAPI.getState());
      var returnValue = dispatch(action);
      console.log('dispatch 后：', middlewareAPI.getState(), '\n');
      return returnValue;
    };
  };
}

var enhancedCreateStore = Redux.applyMiddleware(printStateMiddleware)(Redux.createStore);
var store = enhancedCreateStore(reducer);

store.dispatch(inc());
store.dispatch(inc());
store.dispatch(dec());

// ============================================

// 输出结果为
// dispatch 前：{ counter: 0 }
// dispatch 后：{ counter: 1 }

// dispatch 前：{ counter: 1 }
// dispatch 后：{ counter: 2 }

// dispatch 前：{ counter: 2 }
// dispatch 后：{ counter: 1 }

```

上述的案例中，生成 `store` 的代码中其实可以将中间件放到 `createStore` 中

```js
var store = Redux.createStore(
  reducer,
  Redux.applyMiddleware(printStateMiddleware)
)
```

如果有多个中间件以及多个增强器，还可以这样写

```js
import { createStore, applyMiddleware, compose } from 'redux'

const store = createStore(
  reducer,
  preloadedState,        // 可选参数，前后端同构的数据同步
  compose(               // 顺序是从右到左
    applyMiddleware(     // 关乎中间件的增强器，必须置于 compose 执行链的最后
      middleware1,
      middleware2,
      middleware3
    ),
    enhancer3,
    enhancer2,
    enhancer1
  )
)
```

之所以可以这样使用，是因为在 `createStore` 的源码的开头部分

```js
export default function createStore(reducer, preloadedState, enhancer) {

  // ...


  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    // 只传入 reducer 和 Store Enhancer 这两个参数的情况
    enhancer = preloadedState
    preloadedState = undefined
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }
    // 存在 enhancer 就立即执行，返回增强版的 createStore <== 注①
    return enhancer(createStore)(reducer, preloadedState)
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.')
  }


  // ...
}
```

如果有多个中间件以及多个增强器（有多个 `enhancer`），则注①中的代码会执行多次，生成最终的超级增强版 `store`

比如上例中 `compose` 内部的执行顺序示意图

```js
原 createStore ————
                  │
                  ↓
return enhancer1(createStore)(reducer, preloadedState, enhancer2)
   |
   ├———————→ createStore 增强版 1
                    │
                    ↓
return enhancer2(createStore1)(reducer, preloadedState, enhancer3)
   |
   ├———————————→ createStore 增强版 1 + 2
                        │
                        ↓
return enhancer3(createStore1 + 2)(reducer, preloadedState, applyMiddleware(m1, m2, m3))
   |
   ├————————————————————→ createStore 增强版 1 + 2 + 3
                                     │
                                     ↓
return appleMiddleware(m1, m2, m3)(createStore1 + 2 + 3)(reducer, preloadedState)
   |
   ├——————————————————————————————————→ 生成最终增强版 store
```