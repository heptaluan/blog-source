---
title: 高阶组件（HOC）
date: 2020-10-25
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/14.jpg
---

在 `React` 中，我们会经常听到或是看到关于高阶组件的一些用法，所以在今天就抽些时间，来深入的了解一下什么是高阶组件，以及它存在的一些问题和其应用场景

<!--more-->


<!-- 我们在之前的 [React-Redux 的实现](http://localhost:4000/2020/10/23/React/13/#Connect-和-mapStateToProps) 的章节当中曾在使用过 -->


## 装饰器模式

在介绍高阶组件之前，我们先来了解一下装饰器模式的相关内容，之所以先介绍装饰器模式，这是因为 `React` 当中的高阶组件其实就是装饰器模式的一种应用方式，所谓装饰器模式（`Decorator Pattern`），它允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，这里需要注意的是，它是不会改变原本类的，这一点很关键

#### JavaScript 当中的装饰器

装饰器是 `ES7` 中的一个新语法，正如其字面意思而言，它可以对类、方法、属性进行修饰，从而进行一些相关功能定制，简而言之就是对对象进行包装，返回一个新的对象描述（`descriptor`），这个概念其实和 `React` 中的高阶组件也类似，我们来看下面这个示例，假设我们现在要对一个函数 `log`，打印出它的执行记录，如果不使用装饰器是下面这样的

```js
const log = (fn) => {
  if (typeof (fn) !== 'function') {
    throw new Error(`the param must be a function`)
  }
  return (...arguments) => {
    console.info(`${fn.name} invoke with ${arguments.join(',')}`)
    fn(...arguments)
  }
}

const plus = (a, b) => a + b
const logPlus = log(plus)

logPlus(1, 2) // plus invoke with 1, 2
```

而如果使用装饰器则是下面这样的

```js
const log = (target, name, descriptor) => {
  var oldValue = descriptor.value
  descriptor.value = function () {
    console.log(`Calling ${name} with`, arguments)
    return oldValue.apply(this, arguments)
  }
  return descriptor
}

class Math {
  @log
  plus(a, b) {
    return a + b
  }
}

const math = new Math()

math.add(1, 2) // Calling plus with 1, 2
```

从上面的代码可以看出，如果有的时候我们并不需要关心函数的内部实现，仅仅是想调用它的话，装饰器能够带来比较好的可读性，使用起来也是非常的方便，下面我们就简单的来深入了解一下其中的原理



#### 装饰器原理

其实简单来说，`JavaScript` 当中的装饰器本质也是一个函数，利用的是 `JavaScript` 中 `Object` 的 `descriptor`，这个函数会接收三个参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
 */
function Decorator(target, name, descriptor) {
  // 以此可以获取实例化的时候此属性的默认值
  let v = descriptor.initializer && descriptor.initializer.call(this)
  // 返回一个新的描述对象作为被修饰对象的描述，或者直接修改也可以
  return {
    enumerable: true,
    configurable: true,
    get() {
      return v
    },
    set(c) {
      v = c
    },
  }
}

// USE
class Fudao {
  @Decorator
  title = '标题'
}
```

当然装饰器也可以接受参数，其实就是将外部包装一个函数，而函数可以带参数

```js
/**
 * 装饰器函数
 * @param {Object} target      被装饰器的类的原型
 * @param {string} name        被装饰的类、属性、方法的名字
 * @param {Object} descriptor  被装饰的类、属性、方法的描述
*/
function Decorator(type) {
  return (target, name, descriptor) => {
    let v = descriptor.initializer && descriptor.initializer.call(this)
    return {
      enumerable: true,
      configurable: true,
      get() {
        return v + type
      },
      set(c) {
        v = c
      },
    }
  }
}

// USE
class Fudao {
  @Decorator('string')
  title = '标题'
}
```



## 高阶函数

说到高阶组件，这里我们就不得不先简单的来介绍一下高阶函数，关于高阶函数的定义，[维基](https://zh.wikipedia.org/zh-hans/高阶函数) 上的定义是，高阶函数是至少满足下列一个条件的函数

* 接受一个或多个函数作为输入
* 输出一个函数

比如下面这个示例，就是一个简单的高阶函数

```js
const add = (x, y, f) => f(x) + f(y)

add(-5, 6, Math.abs)
```

当我们在调用的时候，参数 `x`，`y` 和 `f` 分别接收 `-5`，`6` 和 `Math.abs`，根据函数定义，我们可以推导计算过程为

```js
x ==> -5
y ==> 6
f ==> Math.abs

f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11
```

所以上面代码执行后的结果为 `11`，有了这些了解以后，我们下面就正式的来看看高阶组件的相关内容



## 高阶组件

那么，什么是高阶组件呢？类比高阶函数的定义，高阶组件就是接受一个组件作为参数并返回一个新组件的函数，这里需要注意高阶组件是一个函数，并不是组件，这一点一定要注意

更通俗地描述为，高阶组件通过包裹（`wrapped`）被传入的 `React` 组件，经过一系列处理，最终返回一个相对增强（`enhanced`）的 `React` 组件，供其他组件调用，下面我们先来实现一个简单的高阶组件（函数）看看它是如何工作的，它接受一个 `React` 组件，包裹后然后返回

```js
export default function withHeader(WrappedComponent) {
  return class HOC extends Component {
    render() {
      return <div>
        <div className="demo-header">
          我是标题
        </div>
        <WrappedComponent {...this.props} />
      </div>
    }
  }
}
```

我们在其他组件里就可以来引用这个高阶组件，用来强化它

```js
@withHeader
export default class Demo extends Component {
  render() {
    return (
      <div>
        我是一个普通组件
      </div>
    )
  }
}
```

在这里我们使用了上面介绍到的装饰器模式来让写法变得更为优雅，当然下面这种写法也是可以的

```js
const EnhanceDemo = withHeader(Demo)
```





## 








