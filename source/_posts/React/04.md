---
title: Hook
date: 2019-11-23
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/04.jpg
---

`React` 在 `16.8` 的版本当中新增了 `Hook` 这个特性，它可以让我们在不编写 `Class` 的情况下使用 `state` 以及其他的 `React` 特性，本章我们就来看看它到底该如何来进行使用，主要参考的是 [官方文档](https://zh-hans.reactjs.org/docs/hooks-intro.html) 和一些网络资料，在这里做一下整理汇总，便于自己理解

<!--more-->

## Hook

如果说为什么要使用 `Hook`，那么我们可以先来看看 `Hook` 主要解决的问题，主要有下面三个

* 在组件之间复用状态逻辑很难，`Hook` 使你在无需修改组件结构的情况下复用状态逻辑
* 复杂组件变得难以理解，`Hook` 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）
* 难以理解的 `Class`，`Hook` 使你在非 `Class` 的情况下可以使用更多的 `React` 特性


## 什么是 Hook

`Hook` 是一些可以让你在函数组件里 **钩入** `React state` 及生命周期等特性的函数，`React` 内置了一些像 `useState` 这样的 `Hook`，你也可以创建你自己的 `Hook` 来复用不同组件之间的状态逻辑，其实简单来说 `Hook` 就是我们常见的 `JavaScript` 函数，但是使用它们会有两个额外的规则

* 只能在函数最外层调用 `Hook`，不要在循环、条件判断或者子函数中调用
* 只能在 `React` 的函数组件中（包括自定义的 `Hook`）当中调用 `Hook`，不要在其他 `JavaScript` 函数中调用（也不能在 `Class` 组件中使用）

下面我们来看看官方提供的几个比较常用的 `Hook`

* `useState()`
* `useContext()`
* `useReducer()`
* `useEffect()`


## useState()

先来看看如何使用，下面是一个简单的例子

```jsx
import React, { useState } from 'react';

export default function Button() {
  const [text, setText] = useState('click me')

  function handleClick() {
    setText('clicked')
  }

  return (
    <button onClick={handleClick}>{text}</button>
  )
}
```

在上面示例当中，`useState` 就是一个 `Hook`，通过在函数组件里调用它来给组件添加一些内部 `state`，`React` 会在重复渲染时保留这个 `state`

`useState` 会返回一对值，包括 **当前状态** 和 **一个让你更新它的函数**，你可以在事件处理函数中或其他一些地方调用这个函数，它类似 `Class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并，`useState` 唯一的参数就是初始 `state`，值得注意的是，不同于 `this.state`，这里的 `state` 不一定要是一个对象，这个初始 `state` 参数只有在第一次渲染时会被用到

另外 `useState` 也可以使用函数式更新的方式，在上面的示例当中，我们只是简单的调用了 `handleClick`，但是如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`，该函数将接收先前的 `state`，并返回一个更新后的值，如下示例

```js
import React, { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>{count}</p>
      <button onClick={_ => setCount(0)}>重置</button>
      <button onClick={() => setCount(prev => prev + 1)}>增加</button>
      <button onClick={() => setCount(prev => prev - 1)}>减少</button>
    </div>
  )
}
```

不过需要注意的是与 `Class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象，你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果

```js
setState(prevState => {
  // 也可以使用 Object.assign
  return { ...prevState, ...updatedValues }
})
```


## useContext()

如果需要在多个组件之间共享状态，那么这种情况下就可以考虑使用 `useContext()`，其实和 `React` 当中的 `Context` 的使用方式有些类似，比如下面这种情况，我们有 `A` 和 `B` 两个组件，它们需要共享标题内容

```js
import React, { useContext } from 'react';

const AppContext = React.createContext({})

const A = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>A 组件的内容</p>
    </div>
  )
}

const B = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>B 组件的内容</p>
    </div>
  )
}

export default function App() {
  return (
    <AppContext.Provider value={{title: '文章标题'}}>
      <A></A>
      <B></B>
    </AppContext.Provider>
  )
}
```

我们首先使用了 `React.createContext({})` 在组件外部建立一个 `Context`，然后使用 `<AppContext.Provider>` 来提供了一个 `Context` 对象，这个对象可以被子组件共享，这里需要注意的是不能直接使用 `<AppContext>`，否则会报错

最后我们在需要被共享内容的子组件内使用 `useContext()` 钩子函数用来引入 `Context` 对象，从中来获取 `title` 属性



## useReducer()

`React` 本身不提供状态管理功能，通常我们需要借住一些第三方库（比如 `Redux`）来进行实现，而 `Redux` 的核心概念是，组件不能直接修改共享状态，而是需要发出 `Action` 与状态管理器通信，状态管理器收到 `Action` 以后，使用 `Reducer` 函数计算出新的状态进行返回

通常 `Reducer` 函数的形式是 `(state, action) => newState`，而 `useReducers()` 钩子就是用来引入 `Reducer` 功能的，比如下面这个计数器的示例

```js
import React, { useReducer } from 'react';

const myReducer = (state, action) => {
  switch (action.type) {
    case 'add':
      return {
        ...state,
        count: state.count + 1
      }
    case 'dec':
      return {
        ...state,
        count: state.count - 1
      }
    case 'reset':
      return {
        ...state,
        count: action.payload || 0
      }
    default:
      return state
  }
}

export default function App() {
  const [state, dispatch] = useReducer(myReducer, { count: 10 })
  return (
    <div>
      <p>{state.count}</p>
      <button onClick={_ => dispatch({ type: 'reset' })}>重置</button>
      <button onClick={_ => dispatch({ type: 'add' })}>增加</button>
      <button onClick={_ => dispatch({ type: 'dec' })}>减少</button>
    </div>
  )
}
```

以上就是 `useReducer` 的简单用法，可以发现其相对于 `Redux` 而言代码简化了不少，所以 `useReducer()` 在这些方面是可以取代 `Redux` 的，但是它并没有提供例如中间件（`middleware`）和时间旅行（`time travel`）等功能，所以还是根据实际情况来进行使用



## useEffect()

`useEffect()` 主要用来引入具有副作用的操作，比如数据获取、订阅或者手动修改过 `DOM` 等操作就可以称之为副作用，这里我们就以数据请求为例，在之前我们处理数据请求一般都是放在 `componentDidMount` 当中来进行的，但是现在我们可以放在 `useEffect()` 当中来进行，`useEffect()` 的用法如下

```js
useEffect(() => {
  // Async Action
}, [dependencies])
```

`useEffect()` 接受两个参数，第一个参数是一个函数，异步操作的代码放在里面，同时它还可以返回一个函数，用来执行清理操作，第二个参数是一个数组，用于给出 `Effect` 的依赖项，只要这个数组发生变化 `useEffect()` 就会执行，第二个参数可以省略，这时每次组件渲染时，就会执行 `useEffect()`，下面是一个具体示例

```js
import React, { useState, useEffect } from 'react'

const Book = ({ id }) => {
  const [loading, setLoading] = useState(true)
  const [book, setBook] = useState({})

  useEffect(() => {
    setLoading(true)
    fetch(`http://rap2api.taobao.org/app/mock/251195/list/${id}/`)
      .then(res => res.json())
      .then(data => {
        setBook(data)
        setLoading(false)
      })
  }, [id])

  if (loading === true) {
    return <p>Loading ...</p>
  }

  return (
    <div>
      <p>{book.title}</p>
    </div>
  )
}

export default function App() {
  const [show, setShow] = useState('1')
  return (
    <div>
      <Book id={show} />
      <div>
        <button onClick={_ => setShow('1')}>第一页</button>
        <button onClick={_ => setShow('2')}>第二页</button>
      </div>
    </div>
  )
}
```

在上面示例当中，我们传入 `[id]` 作为 `useEffect` 第二个参数，如果 `id` 的值在重新渲染的时候没有发生变化，`React` 会跳过这个 `effect`，这就实现了性能的优化，不过这里也需要注意

* 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 `effect` 中会使用的变量，否则你的代码会引用到先前渲染中的旧变量，即数组最好包含所有在 `effect` 当中使用的可能变化的变量
* 如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组（`[]`）作为第二个参数，这就告诉 `React` 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行

另外，`useEffect` 还可以接收一个返回函数，用来执行清理操作

```js
useEffect(() => {
  // 这里是某些操作
  return function cleanup() {
    // 命名为 cleanup 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字
  }
})
```

这里也有两个需要注意的地方

* 为什么要在 `useEffect` 当中返回一个函数？这是 `useEffect` 可选的清除机制，每个 `useEffect` 都可以返回一个清除函数（如此便可以将添加和移除订阅的逻辑放在一起）
* `React` 何时清除 `useEffect`？`React` 会在组件卸载的时候执行清除操作



