---
title: React 中的 Hook
date: 2020-10-31
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/16.jpg
---

我们在之前 [React 中的 Mixin](http://localhost:4000/2020/10/24/React/14/) 和 [React 中的 HOC](http://localhost:4000/2020/10/25/React/15/) 的章节当中介绍了 `Mixin` 和 `HOC` 的相关内容，了解了它们大致的实现原理和使用方式，也知道了 `HOC` 的出现就是为了替代 `Mixin`，但是 `HOC` 也并非完美无缺，它其实也是存在着一些缺陷的，比如

* `HOC` 需要在原组件上进行包裹或者嵌套，如果大量使用 `HOC`，将会产生非常多的嵌套，这让调试变得非常困难
* `HOC` 可以劫持 `props`，在不遵守约定的情况下也可能造成冲突

所以在本章当中我们就来看看 `React` 中的 `Hook` 是如何同时解决 `Mixin` 和 `HOC` 所带来的问题的

<!--more-->



## 为什么要使用 Hook

如果说为什么要使用 `Hook`，那么我们可以先来看看 `Hook` 主要解决的问题，主要有下面三个

* 在组件之间复用状态逻辑很难，`Hook` 使你在无需修改组件结构的情况下复用状态逻辑
* 复杂组件变得难以理解，`Hook` 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）
* 难以理解的 `Class`，`Hook` 使你在非 `Class` 的情况下可以使用更多的 `React` 特性

那么到底什么是 `Hook` 呢？



## 什么是 Hook

`React` 在 `16.8` 的版本当中新增了 `Hook` 这个特性，它可以让我们在不编写 `Class` 的情况下使用 `state` 以及其他的 `React` 特性，使用 `Hook`，你可以在将含有 `state` 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，同时 `Hook` 可以帮助你在不重写组件结构的情况下复用这些逻辑，所以它也可以作为一种实现状态逻辑复用的方案

`React` 内置了一些像 `useState` 这样的 `Hook`，你也可以创建你自己的 `Hook` 来复用不同组件之间的状态逻辑，其实简单来说 `Hook` 就是我们常见的 `JavaScript` 函数，但是使用它们会有两个额外的规则，如下

* 只能在函数最外层调用 `Hook`，不要在循环、条件判断或者子函数中调用
* 只能在 `React` 函数式组件或自定义 `Hook` 中使用 `Hook`，不要在其他 `JavaScript` 函数中调用

之所以不要在循环当中去调用 `Hook`，这是因为 `Hook` 是通过数组实现的，每次 `useState` 都会改变下标，`React` 需要利用调用顺序来正确更新相应的状态，如果 `useState` 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误，我们可以利用 `eslint` 插件来帮助我们避免这些问题

```js
// 安装
npm install eslint-plugin-react-hooks --save-dev

// 配置
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error"
  }
}
```

下面我们就先从官方提供的几个比较常用的 `Hook` 开始看起，它们分别是

* `useState()`
* `useContext()`
* `useReducer()`
* `useEffect()`
* `useRef()`

## useState()

先来看看如何使用，下面是一个简单的例子

```jsx
import React, { useState } from 'react'

export default function Button() {
  const [text, setText] = useState('click me')

  function handleClick() {
    setText('clicked')
  }

  return (
    <button onClick={handleClick}>{text}</button>
  )
}
```

在上面示例当中，`useState` 就是一个 `Hook`，通过在函数组件里调用它来给组件添加一些内部 `state`，`React` 会在重复渲染时保留这个 `state`

`useState` 会返回一对值，包括 **当前状态** 和 **一个让你更新它的函数**，你可以在事件处理函数中或其他一些地方调用这个函数，它类似 `Class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并，`useState` 唯一的参数就是初始 `state`，值得注意的是，不同于 `this.state`，这里的 `state` 不一定要是一个对象，这个初始 `state` 参数只有在第一次渲染时会被用到

另外 `useState` 也可以使用函数式更新的方式，在上面的示例当中，我们只是简单的调用了 `handleClick`，但是如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`，该函数将接收先前的 `state`，并返回一个更新后的值，如下示例

```js
import React, { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>{count}</p>
      <button onClick={_ => setCount(0)}>重置</button>
      <button onClick={() => setCount(prev => prev + 1)}>增加</button>
      <button onClick={() => setCount(prev => prev - 1)}>减少</button>
    </div>
  )
}
```

不过需要注意的是与 `Class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象，你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果

```js
setState(prevState => {
  // 也可以使用 Object.assign
  return { ...prevState, ...updatedValues }
})
```


## useContext()

如果需要在多个组件之间共享状态，那么这种情况下就可以考虑使用 `useContext()`，其实和 `React` 当中的 `Context` 的使用方式有些类似，比如下面这种情况，我们有 `A` 和 `B` 两个组件，它们需要共享标题内容

```js
import React, { useContext } from 'react'

const AppContext = React.createContext({})

const A = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>A 组件的内容</p>
    </div>
  )
}

const B = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>B 组件的内容</p>
    </div>
  )
}

export default function App() {
  return (
    <AppContext.Provider value={{title: '文章标题'}}>
      <A></A>
      <B></B>
    </AppContext.Provider>
  )
}
```

我们首先使用了 `React.createContext({})` 在组件外部建立一个 `Context`，然后使用 `<AppContext.Provider>` 来提供了一个 `Context` 对象，这个对象可以被子组件共享，这里需要注意的是不能直接使用 `<AppContext>`，否则会报错，另外需要注意在传递值的时候使用的两层大括号

最后我们在需要被共享内容的子组件内使用 `useContext()` 钩子函数用来引入 `Context` 对象，从中来获取 `title` 属性，这是因为当前的 `context` 的值是由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value prop` 所决定

但是这里有一个需要我们注意的地方，比如我们上方的 `B` 组件变成了下面这种情况，即不在依赖 `context`，但是渲染的时候仍然放在 `<AppContext.Provider>` 当中

```js
const B = () => {
  return (
    <div>
      <p>B 组件的内容</p>
    </div>
  )
}
```

这样一来就会涉及到下面两个问题

* `useContext` 的组件总会在 `context` 值变化时重新渲染， 所以 `<MyContext.Provider>` 包裹的越多，层级越深，性能会造成影响
* `<MyContext.Provider>` 的 `value` 发生变化时候，包裹的组件无论是否订阅 `content value`，所有组件都会从新渲染

所以在这种情况下，我们自然而然的可以想到，如果组件没有订阅的话，是不是可以避免不必要的渲染，答案是有的，我们可以使用 `React.memo()` 来进行优化，我们将 `B` 组件调整如下

```js
const B = React.memo((props) => {
  return <div>B 组件的内容</div>
})
```

但是需要注意的是，默认情况下 `React.memo()` 只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现，更多详细内容可以参考 [Preventing rerenders with React.memo and useContext hook](https://github.com/facebook/react/issues/15156)



## useReducer()

`React` 本身不提供状态管理功能，通常我们需要借住一些第三方库（比如 `Redux`）来进行实现，而 `Redux` 的核心概念是，组件不能直接修改共享状态，而是需要发出 `Action` 与状态管理器通信，状态管理器收到 `Action` 以后，使用 `Reducer` 函数计算出新的状态进行返回

通常 `Reducer` 函数的形式是 `(state, action) => newState`，而 `useReducers()` 钩子就是用来引入 `Reducer` 功能的，比如下面这个计数器的示例

```js
import React, { useReducer } from 'react'

const myReducer = (state, action) => {
  switch (action.type) {
    case 'add':
      return {
        ...state,
        count: state.count + 1
      }
    case 'dec':
      return {
        ...state,
        count: state.count - 1
      }
    case 'reset':
      return {
        ...state,
        count: action.payload || 0
      }
    default:
      return state
  }
}

export default function App() {
  const [state, dispatch] = useReducer(myReducer, { count: 10 })
  return (
    <div>
      <p>{state.count}</p>
      <button onClick={_ => dispatch({ type: 'reset' })}>重置</button>
      <button onClick={_ => dispatch({ type: 'add' })}>增加</button>
      <button onClick={_ => dispatch({ type: 'dec' })}>减少</button>
    </div>
  )
}
```

以上就是 `useReducer` 的简单用法，可以发现其相对于 `Redux` 而言代码简化了不少，所以 `useReducer()` 在这些方面是可以取代 `Redux` 的，但是它并没有提供例如中间件（`middleware`）和时间旅行（`time travel`）等功能，所以还是根据实际情况来进行使用



## useEffect()

`useEffect()` 主要用来引入具有副作用的操作，比如数据获取、订阅或者手动修改过 `DOM` 等操作就可以称之为副作用，这里我们就以数据请求为例，在之前我们处理数据请求一般都是放在 `componentDidMount` 当中来进行的，但是现在我们可以放在 `useEffect()` 当中来进行，`useEffect()` 的用法如下

```js
useEffect(() => {
  // 只要组件 render 后就会执行
})

useEffect(() => {
  // 只有 count 改变时才会执行
}, [count])
```

`useEffect()` 接受两个参数

* 第一个参数是一个回调函数，在第组件一次 `render` 和之后的每次 `update` 后运行，`React` 保证在 `DOM` 已经更新完成之后才会运行回调
* 第二个参数是一个状态依赖数组，当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数，第二个参数可以省略，这时每次组件渲染时，就会重新执行 `useEffect()`

另外关于 `useEffect()` 的执行顺序，有下面几点需要我们注意

* 正常情况下，`useEffect()` 会在 `render` 后按照前后顺序执行
* `useEffect()` 内部执行是异步的
* `useEffect()` 的回调函数也是按照先后顺序同时执行的

下面我们就先来看一个使用 `useEffect()` 的示例，如下

```js
import React, { useState, useEffect } from 'react'

const Book = ({ id }) => {
  const [loading, setLoading] = useState(true)
  const [book, setBook] = useState({})

  useEffect(() => {
    setLoading(true)
    fetch(`http://rap2api.taobao.org/app/mock/251195/list/${id}/`)
      .then(res => res.json())
      .then(data => {
        setBook(data)
        setLoading(false)
      })
  }, [id])

  if (loading === true) {
    return <p>Loading ...</p>
  }

  return (
    <div>
      <p>{book.title}</p>
    </div>
  )
}

export default function App() {
  const [show, setShow] = useState('1')
  return (
    <div>
      <Book id={show} />
      <div>
        <button onClick={_ => setShow('1')}>第一页</button>
        <button onClick={_ => setShow('2')}>第二页</button>
      </div>
    </div>
  )
}
```

在上面示例当中，我们传入 `[id]` 作为 `useEffect` 第二个参数，如果 `id` 的值在重新渲染的时候没有发生变化，`React` 会跳过这个 `effect`，这就实现了性能的优化，不过这里也需要注意

* 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 `effect` 中会使用的变量，否则你的代码会引用到先前渲染中的旧变量，即数组最好包含所有在 `effect` 当中使用的可能变化的变量
* 如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组（`[]`）作为第二个参数，这就告诉 `React` 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行

所以我们可以利用传递空数组的特性来模拟 `componentDidMount` 和 `componentWillUnmount`，其中 `componentDidMount` 等价于 `useEffect` 的回调仅在页面初始化完成后执行一次，当 `useEffect` 的第二个参数传入一个空数组时可以实现这个效果，但是我们最好忘掉生命周期，只记副作用

同时，`useEffect()` 的第一个参数还可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次 `useEffect()` 之前，会调用这个函数（组件卸载的时候也会执行清除操作），这个函数常常用来对上一次调用 `useEffect()` 进行清理

```js
useEffect(() => {
  // 这里是某些操作
  return function cleanup() {
    // 命名为 cleanup 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字
  }
})
```

下面是一个具体的示例

```js
export default function HookTest() {
  const [count, setCount] = useState(0)
  useEffect(() => {
    console.log('执行...', count)
    return () => {
      console.log('清理...', count)
    }
  }, [count])
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => { setCount(count + 1); setNumber(number + 1) }}>Click me</button>
    </div>
  )
}
```

在控制台当中我们看到对应的输出，但是如果加上浏览器渲染的情况，结果应该是这样的

```js
渲染  ==> 1
执行  ==> 1
渲染  ==> 2
清理  ==> 1
执行  ==> 2
渲染  ==> 3
清理  ==> 2
执行  ==> 3
渲染  ==> 4
清理  ==> 3
执行  ==> 4
```

那么这里就存在一个问题了，那就是为什么在浏览器渲染完后，再执行清理方法的时候还能找到上次的 `state` 呢？原因很简单，因为我们在 `useEffect` 中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染，可以参考下面的代码来进行理解

```js
var flag = 1
var clean

function effect(flag) {
  return function () {
    console.log(flag)
  }
}

clean = effect(flag)
flag = 2
clean()

clean = effect(flag)
flag = 3
clean()

clean = effect(flag)
```

执行后的结果是下面这样的

```js
effect  ==> 1
clean   ==> 1
effect  ==> 2
clean   ==> 2
effect  ==> 3
```




## useRef()

使用 `useRef Hook`，我们可以轻松的获取到 `dom` 的 `ref`

```js
export default function Input() {
  const inputEl = useRef(null)
  const onButtonClick = () => {
    inputEl.current.focus()
  }
  return (
    <div>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </div>
  )
}
```

这里需要注意的是 `useRef()` 并不仅仅可以用来当作获取 `ref` 使用，使用 `useRef` 产生的 `ref` 的 `current` 属性是可变的，这意味着你可以用它来保存一个任意值

同样的，我们也可以使用 `useRef()` 来模拟 `componentDidUpdate`，`componentDidUpdate` 就相当于除去第一次调用的 `useEffect`，我们可以借助 `useRef` 生成一个标识，来记录是否为第一次执行

```js
function useDidUpdate(callback, prop) {
  const init = useRef(true)
  useEffect(() => {
    if (init.current) {
      init.current = false
    } else {
      return callback()
    }
  }, prop)
}
```

简单总结一下就是

* `useRef` 返回一个可变的 `ref` 对象，它会在每次渲染时返回同一个 `ref` 对象，在整个组件的生命周期内是唯一的
* `useRef` 可以保存任何可变的值，即也可以存储那些不需要引起页面重新渲染的数据
* 如果你刻意地想要从某些异步回调中读取最新的 `state`，你可以用一个 `ref` 来保存它，修改它，并从中读取（关于这点可以参考官方文档当中的 [有类似实例变量的东西吗？](https://zh-hans.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables)）



## 自定义 Hook

在看完了官方提供的一些 `Hook` 以后，下面我们来看看自定义 `Hook`，其实像之前我们介绍过的 `HOC` 和 `Mixin` 一样，我们同样可以通过自定义的 `Hook` 将组件中类似的状态逻辑抽取出来

自定义 `Hook` 的实现比较简单，我们只需要定义一个函数，并且把相应需要的状态和 `effect` 封装进去，同时 `Hook` 之间也是可以相互引用的，使用 `use` 开头命名自定义 `Hook`，这样可以方便 `eslint` 进行检查，下面我们来看几个具体的 `Hook` 封装

#### 日志打点

我们可以使用上面封装的生命周期 `Hook`

```js
const useLogger = (componentName, ...params) => {
  useDidMount(() => {
    console.log(`${componentName} 初始化`, ...params)
  })
  useUnMount(() => {
    console.log(`${componentName} 卸载`, ...params)
  })
  useDidUpdate(() => {
    console.log(`${componentName} 更新`, ...params)
  })
}

function Page1(props) {
  useLogger('Page1', props)
  return (<div>...</div>)
}
```


#### 修改页面标题

根据不同的页面名称修改页面标题内容

```js
function useTitle(title) {
  useEffect(
    () => {
      document.title = title
      return () => (document.title = '首页')
    },
    [title]
  )
}

function Page1(props) {
  useTitle('Page1')
  return (<div>...</div>)
}
```


#### 双向绑定

关于双向绑定的需求，平常在业务当中可能是会经常遇到的，所以这里我们简单总结一下 `HOC`、`Render Props` 和 `Hook` 的三种实现方式

###### HOC

我们首先来看看 `HOC` 的实现方式，首先我们定义了一个高阶组件 `HocInput` 和一个普通组件 `Input`，在返回的时候我们使用高阶组件 `HocInput()` 将 `Input` 包裹以后在进行返回

```js
const HocInput = WrapperComponent =>
  class extends React.Component {
    state = {
      value: this.props.initialValue
    }
    onChange = e => {
      this.setState({ value: e.target.value })
      if (this.props.onChange) {
        this.props.onChange(e.target.value)
      }
    }
    render() {
      const newProps = {
        value: this.state.value,
        onChange: this.onChange
      }
      return <WrapperComponent {...newProps} />
    }
  }

const Input = props => (
  <>
    <p>{props.value}</p>
    <input placeholder="input" {...props} />
  </>
)

export default HocInput(Input)
```

然后像下面这样使用既可

```js
<HocInput initialValue="init" onChange={val => console.log(`HocInput`, val) } />
```



###### Render Props

与 `HOC` 不同的是，我们这次在 `render()` 的时候返回的是 `this.props.children()`，`props` 接受两个参数，初始值 `initialValue` 以及 `onChange` 方法

```js
class HocBind extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      value: props.initialValue
    }
  }
  onChange = e => {
    this.setState({ value: e.target.value })
    if (this.props.onChange) {
      this.props.onChange(e.target.value)
    }
  }
  render() {
    return (
      <>
        {this.props.children({
          value: this.state.value,
          onChange: this.onChange
        })}
      </>
    )
  }
}

export default HocBind
```

使用

```js
<HocBind initialValue="init" onChange={val => console.log(`HocBind`, val) } >
  {props => (
    <>
      <p>{props.value}</p>
      <input placeholder="input" {...props} />
    </>
  )}
</HocBind>
```


###### Hook

最后我们再来看看 `Hook` 的实现方式，我们定义了一个 `useBind` 方法，接受一个 `initialValue` 参数作为默认输入，使用的时候我们使用 `inputProps` 来接收调用 `useBind()` 以后的返回值，然后在使用的时候我们就可以直接用 `inputProps.value`，然后将剩余的 `props`（也就是 `onChange`）传递给 `input`

```js
import React, { Component, useState } from 'react'

function useBind(initialValue) {
  const [value, setValue] = useState(initialValue || '')
  const onChange = e => {
    setValue(e.target.value)
  }
  return { value, onChange }
}

function InputBind() {
  const inputProps = useBind('init')
  return (
    <>
      <p>{inputProps.value}</p>
      <input {...inputProps} />
    </>
  )
}

class App extends Component {
  render() {
    return (
      <InputBind />
    )
  }
}

export default App
```


###### 对比

最后我们再来比较一下上面的几种实现方式，`HOC` 和 `Render Props` 的方式都会侵入代码，使得代码阅读性下降，也不够优雅，组件内部暴露的 `value` 值，在外部也很难拿到，反观 `Hook` 的写法，逻辑完全解耦，使用场景最大化且不侵入代码，在组件顶层可以拿到双向绑定的值，比之前优雅很多，所以说

* 使用 `Hook` 可读性高，也易于维护
* 使用 `Hook` 不会侵入代码，不会造成嵌套
* 使用 `Hook`，`UI` 和逻辑彻底拆分，更容易复用


#### 数据请求

最后我们再来看一个稍微复杂点的示例，即封装我们自己的 `fetch` 方法，也就是自定义 `useFetch`，因为封装请求数据的逻辑也是我们最为常见的用法，下面来看看第一个版本的实现

```js
function useFetch(fetch, params) {
  const [data, setData] = useState({})
  const fetchApi = useCallback(async () => {
    const res = await fetch(params)
    if (res.code === 1) {
      setData(res.data)
    }
  }, [fetch, params])
  useEffect(() => {
    fetchApi()
  }, [fetchApi])
  return data
}

const getUrl = params => {
  const url = `url` + objToString(params)
  return fetch(url).then(res => res.json())
}

function getUserCode() {
  const data = useFetch(getUrl, { user: 'zhangsan' })
  return <div>{data.userCode}</div>
}
```

看上去似乎没有什么问题，但是运行以后却会发现，无限循环，浏览器崩溃了，那么问题到底出在哪里呢？其实我们仔细排查后就会发现，问题是出在 `useCallback` 上，首先我们调用 `useFetch(getUrl, { user: 'zhangsan' })` 的时候，`useFetch()` 的第二个参数 `params` 是被 `useCallback` 所依赖的，我们先来梳理一下执行流程，如下

1. `render`
2. 执行 `useEffect`
3. 调用 `useCallback` 方法
4. 更新 `data`
5. `render`
6. `useEffect`
7. 调用 `useCallback` 方法判断依赖是否变化来确定是否跳过这次执行
8. ...

看到问题所在了吗，因为对于 `useCallback` 来说 `params` 对象每次都是新的对象，所以这个渲染流程会一直执行，造成死循环，要解决上面的问题，我们可以使用我们之前提到过的 `useMemo`，`useMemo` 的作用就是帮助我们缓存 `params` 且返回一个之前记忆的值，当 `useMemo` 的依赖值没有变化的时候，记忆的值就是不变的，所以 `useCallback` 会跳过此次执行

```js
const params = useMemo(() => ({ user: 'zhangsan' }), [])
const data = useFetch(getUrl, params)
```

虽然我们的问题解决了，但是可以发现，我们每次在使用 `useFetch` 的时候都需要先使用 `useMemo` 将 `params` 包裹一遍，十分繁琐，那么有没有更好的解决办法呢？方法肯定是有的，在这种情况下我们就可以利用 `useState` 来帮助我们缓存 `params`，当它没有变化的时候，`useCallback` 和 `useEffect` 都会认为它是不变的，所以会跳过执行回调

```js
function useFetch(fetch, params) {
  const [data, setData] = useState({})
  const [newParams] = useState(params)
  const fetchApi = useCallback(async () => {
    const res = await fetch(newParams)
    if (res.code === 1000) {
      setData(res.data)
    }
  }, [fetch, newParams])

  useEffect(() => {
    fetchApi()
  }, [fetchApi])

  return data
}

// USE
const data = useFetch(getUrl, { user: 'zhangsan' })
```

任务虽然完成了，但是看上去显然不够通用，比如我们需要更新参数，又或者在不改变参数的情况下，手动点击刷新页面按钮等，所以最后我们再来调整一下，以便让其变得更为通用一些，最终版本代码如下

```js
function useFetch(fetch, params, visible = true) {
  const [data, setData] = useState({})
  const [loading, setLoading] = useState(false)
  const [newParams, setNewParams] = useState(params)
  const fetchApi = useCallback(async () => {
    if (visible) {
      setLoading(true)
      const res = await fetch(newParams)
      if (res.code === 1000) {
        setData(res.data)
      }
      setLoading(false)
    }
  }, [fetch, newParams, visible])

  useEffect(() => {
    fetchApi()
  }, [fetchApi])

  const doFetch = useCallback(rest => {
    setNewParams(rest)
  }, [])

  const reFetch = () => {
    setNewParams(Object.assign({}, newParams))
  }

  return { loading, data, doFetch, reFetch }
}
```




## Hook 的好处

我们在上面介绍了许多 `Hook` 的相关内容，包括如何定义，如何使用，下面我们就来看看它相对于 `HOC` 和 `Mixin` 所具备的一些优点


#### 减少状态逻辑复用的风险

`Hook` 和 `Mixin` 在用法上有一定的相似之处，但是 `Mixin` 引入的逻辑和状态是可以相互覆盖的，而多个 `Hook` 之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上，
在不遵守约定的情况下使用 `HOC` 也有可能带来一定冲突，比如 `props` 覆盖等等，使用 `Hook` 则可以避免这些问题


#### 避免地狱式嵌套

大量使用 `HOC` 的情况下让我们的代码变得嵌套层级非常深，使用 `Hook`，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套


#### 让组件更容易理解

在使用 `Class` 组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护，使用 `Hook`，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割


#### 使用函数代替class

相比函数，编写一个 `Class` 可能需要掌握更多的知识，需要注意的点也越多，比如 `this` 指向、绑定事件等等，另外计算机理解一个函数比理解一个 `Class` 更快，`Hook` 让你可以在 `Class` 之外使用更多 `React` 的新特性



## 参考

* [Hook 简介](https://zh-hans.reactjs.org/docs/hooks-intro.html)
* [React Hooks 入门教程](https://www.ruanyifeng.com/blog/2019/09/react-hooks.html)
* [从Mixin到HOC再到Hook](https://juejin.im/post/6844903815762673671)

