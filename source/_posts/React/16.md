---
title: React 中的 Hook
date: 2020-10-31
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/16.jpg
---

我们在之前 [React 中的 Mixin](http://localhost:4000/2020/10/24/React/14/) 和 [React 中的 HOC](http://localhost:4000/2020/10/25/React/15/) 的章节当中介绍了 `Mixin` 和 `HOC` 的相关内容，了解了它们大致的实现原理和使用方式，也知道了 `HOC` 的出现就是为了替代 `Mixin`，但是 `HOC` 也并非完美无缺，它其实也是存在着一些缺陷的，比如

* `HOC` 需要在原组件上进行包裹或者嵌套，如果大量使用 `HOC`，将会产生非常多的嵌套，这让调试变得非常困难
* `HOC` 可以劫持 `props`，在不遵守约定的情况下也可能造成冲突

所以在本章当中我们就来看看 `React` 中的 `Hook` 是如何同时解决 `Mixin` 和 `HOC` 所带来的问题的

<!--more-->



## 为什么要使用 Hook

如果说为什么要使用 `Hook`，那么我们可以先来看看 `Hook` 主要解决的问题，主要有下面三个

* 在组件之间复用状态逻辑很难，`Hook` 使你在无需修改组件结构的情况下复用状态逻辑
* 复杂组件变得难以理解，`Hook` 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）
* 难以理解的 `Class`，`Hook` 使你在非 `Class` 的情况下可以使用更多的 `React` 特性

那么到底什么是 `Hook` 呢？



## 什么是 Hook

`React` 在 `16.8` 的版本当中新增了 `Hook` 这个特性，它可以让我们在不编写 `Class` 的情况下使用 `state` 以及其他的 `React` 特性，使用 `Hook`，你可以在将含有 `state` 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，同时 `Hook` 可以帮助你在不重写组件结构的情况下复用这些逻辑，所以它也可以作为一种实现状态逻辑复用的方案

`React` 内置了一些像 `useState` 这样的 `Hook`，你也可以创建你自己的 `Hook` 来复用不同组件之间的状态逻辑，其实简单来说 `Hook` 就是我们常见的 `JavaScript` 函数，但是使用它们会有两个额外的规则，如下

* 只能在函数最外层调用 `Hook`，不要在循环、条件判断或者子函数中调用
* 只能在 `React` 函数式组件或自定义 `Hook` 中使用 `Hook`，不要在其他 `JavaScript` 函数中调用

之所以不要在循环当中去调用 `Hook`，这是因为 `Hook` 是通过数组实现的，每次 `useState` 都会改变下标，`React` 需要利用调用顺序来正确更新相应的状态，如果 `useState` 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误，我们可以利用 `eslint` 插件来帮助我们避免这些问题

```js
// 安装
npm install eslint-plugin-react-hooks --save-dev

// 配置
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error"
  }
}
```

下面我们就先从官方提供的几个比较常用的 `Hook` 开始看起，它们分别是

* `useState()`
* `useContext()`
* `useReducer()`
* `useEffect()`
* `useRef()`

## useState()

先来看看如何使用，下面是一个简单的例子

```jsx
import React, { useState } from 'react'

export default function Button() {
  const [text, setText] = useState('click me')

  function handleClick() {
    setText('clicked')
  }

  return (
    <button onClick={handleClick}>{text}</button>
  )
}
```

在上面示例当中，`useState` 就是一个 `Hook`，通过在函数组件里调用它来给组件添加一些内部 `state`，`React` 会在重复渲染时保留这个 `state`

`useState` 会返回一对值，包括 **当前状态** 和 **一个让你更新它的函数**，你可以在事件处理函数中或其他一些地方调用这个函数，它类似 `Class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并，`useState` 唯一的参数就是初始 `state`，值得注意的是，不同于 `this.state`，这里的 `state` 不一定要是一个对象，这个初始 `state` 参数只有在第一次渲染时会被用到

另外 `useState` 也可以使用函数式更新的方式，在上面的示例当中，我们只是简单的调用了 `handleClick`，但是如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`，该函数将接收先前的 `state`，并返回一个更新后的值，如下示例

```js
import React, { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>{count}</p>
      <button onClick={_ => setCount(0)}>重置</button>
      <button onClick={() => setCount(prev => prev + 1)}>增加</button>
      <button onClick={() => setCount(prev => prev - 1)}>减少</button>
    </div>
  )
}
```

不过需要注意的是与 `Class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象，你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果

```js
setState(prevState => {
  // 也可以使用 Object.assign
  return { ...prevState, ...updatedValues }
})
```


## useContext()

如果需要在多个组件之间共享状态，那么这种情况下就可以考虑使用 `useContext()`，其实和 `React` 当中的 `Context` 的使用方式有些类似，比如下面这种情况，我们有 `A` 和 `B` 两个组件，它们需要共享标题内容

```js
import React, { useContext } from 'react'

const AppContext = React.createContext({})

const A = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>A 组件的内容</p>
    </div>
  )
}

const B = () => {
  const { title } = useContext(AppContext)
  return (
    <div>
      <p>标题为 { title }</p>
      <p>B 组件的内容</p>
    </div>
  )
}

export default function App() {
  return (
    <AppContext.Provider value={{title: '文章标题'}}>
      <A></A>
      <B></B>
    </AppContext.Provider>
  )
}
```

我们首先使用了 `React.createContext({})` 在组件外部建立一个 `Context`，然后使用 `<AppContext.Provider>` 来提供了一个 `Context` 对象，这个对象可以被子组件共享，这里需要注意的是不能直接使用 `<AppContext>`，否则会报错

最后我们在需要被共享内容的子组件内使用 `useContext()` 钩子函数用来引入 `Context` 对象，从中来获取 `title` 属性



## useReducer()

`React` 本身不提供状态管理功能，通常我们需要借住一些第三方库（比如 `Redux`）来进行实现，而 `Redux` 的核心概念是，组件不能直接修改共享状态，而是需要发出 `Action` 与状态管理器通信，状态管理器收到 `Action` 以后，使用 `Reducer` 函数计算出新的状态进行返回

通常 `Reducer` 函数的形式是 `(state, action) => newState`，而 `useReducers()` 钩子就是用来引入 `Reducer` 功能的，比如下面这个计数器的示例

```js
import React, { useReducer } from 'react'

const myReducer = (state, action) => {
  switch (action.type) {
    case 'add':
      return {
        ...state,
        count: state.count + 1
      }
    case 'dec':
      return {
        ...state,
        count: state.count - 1
      }
    case 'reset':
      return {
        ...state,
        count: action.payload || 0
      }
    default:
      return state
  }
}

export default function App() {
  const [state, dispatch] = useReducer(myReducer, { count: 10 })
  return (
    <div>
      <p>{state.count}</p>
      <button onClick={_ => dispatch({ type: 'reset' })}>重置</button>
      <button onClick={_ => dispatch({ type: 'add' })}>增加</button>
      <button onClick={_ => dispatch({ type: 'dec' })}>减少</button>
    </div>
  )
}
```

以上就是 `useReducer` 的简单用法，可以发现其相对于 `Redux` 而言代码简化了不少，所以 `useReducer()` 在这些方面是可以取代 `Redux` 的，但是它并没有提供例如中间件（`middleware`）和时间旅行（`time travel`）等功能，所以还是根据实际情况来进行使用



## useEffect()

`useEffect()` 主要用来引入具有副作用的操作，比如数据获取、订阅或者手动修改过 `DOM` 等操作就可以称之为副作用，这里我们就以数据请求为例，在之前我们处理数据请求一般都是放在 `componentDidMount` 当中来进行的，但是现在我们可以放在 `useEffect()` 当中来进行，`useEffect()` 的用法如下

```js
useEffect(() => {
  // 只要组件 render 后就会执行
})

useEffect(() => {
  // 只有 count 改变时才会执行
}, [count])
```

`useEffect()` 接受两个参数

* 第一个参数是一个回调函数，在第组件一次 `render` 和之后的每次 `update` 后运行，`React` 保证在 `DOM` 已经更新完成之后才会运行回调
* 第二个参数是一个状态依赖数组，当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数，第二个参数可以省略，这时每次组件渲染时，就会执行 `useEffect()`

下面我们先来看一个使用 `useEffect()` 的示例，如下

```js
import React, { useState, useEffect } from 'react'

const Book = ({ id }) => {
  const [loading, setLoading] = useState(true)
  const [book, setBook] = useState({})

  useEffect(() => {
    setLoading(true)
    fetch(`http://rap2api.taobao.org/app/mock/251195/list/${id}/`)
      .then(res => res.json())
      .then(data => {
        setBook(data)
        setLoading(false)
      })
  }, [id])

  if (loading === true) {
    return <p>Loading ...</p>
  }

  return (
    <div>
      <p>{book.title}</p>
    </div>
  )
}

export default function App() {
  const [show, setShow] = useState('1')
  return (
    <div>
      <Book id={show} />
      <div>
        <button onClick={_ => setShow('1')}>第一页</button>
        <button onClick={_ => setShow('2')}>第二页</button>
      </div>
    </div>
  )
}
```

在上面示例当中，我们传入 `[id]` 作为 `useEffect` 第二个参数，如果 `id` 的值在重新渲染的时候没有发生变化，`React` 会跳过这个 `effect`，这就实现了性能的优化，不过这里也需要注意

* 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 `effect` 中会使用的变量，否则你的代码会引用到先前渲染中的旧变量，即数组最好包含所有在 `effect` 当中使用的可能变化的变量
* 如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组（`[]`）作为第二个参数，这就告诉 `React` 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行

所以我们可以利用传递空数组的特性来模拟 `componentDidMount`，`componentDidMount` 等价于 `useEffect` 的回调仅在页面初始化完成后执行一次，当 `useEffect` 的第二个参数传入一个空数组时可以实现这个效果

```js
function useDidMount(callback) {
  useEffect(callback, [])
}
```

但是官方并不推荐上面这种写法，因为这有可能导致一些错误，同样的也可以模拟 `componentWillUnmount`

```js
function useUnMount(callback) {
  useEffect(() => callback, [])
}
```

不像 `componentDidMount` 或者 `componentDidUpdate`，`useEffect` 中使用的 `effect` 并不会阻滞浏览器渲染页面，这会让你的程序看起来更加流畅

同时，`useEffect()` 的第一个参数还可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次 `useEffect()` 之前，会调用这个函数（组件卸载的时候也会执行清除操作），这个函数常常用来对上一次调用 `useEffect()` 进行清理

```js
useEffect(() => {
  // 这里是某些操作
  return function cleanup() {
    // 命名为 cleanup 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字
  }
})
```

下面是一个具体的示例

```js
export default function HookTest() {
  const [count, setCount] = useState(0)
  useEffect(() => {
    console.log('执行...', count)
    return () => {
      console.log('清理...', count)
    }
  }, [count])
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => { setCount(count + 1); setNumber(number + 1) }}>Click me</button>
    </div>
  )
}
```

在控制台当中我们看到对应的输出，但是如果加上浏览器渲染的情况，结果应该是这样的

```js
渲染  ==> 1
执行  ==> 1
渲染  ==> 2
清理  ==> 1
执行  ==> 2
渲染  ==> 3
清理  ==> 2
执行  ==> 3
渲染  ==> 4
清理  ==> 3
执行  ==> 4
```

那么这里就存在一个问题了，那就是为什么在浏览器渲染完后，再执行清理方法的时候还能找到上次的 `state` 呢？原因很简单，因为我们在 `useEffect` 中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染，可以参考下面的代码来进行理解

```js
var flag = 1
var clean

function effect(flag) {
  return function () {
    console.log(flag)
  }
}

clean = effect(flag)
flag = 2
clean()

clean = effect(flag)
flag = 3
clean()

clean = effect(flag)
```

执行后的结果是下面这样的

```js
effect  ==> 1
clean   ==> 1
effect  ==> 2
clean   ==> 2
effect  ==> 3
```




## useRef()

使用 `useRef Hook`，我们可以轻松的获取到 `dom` 的 `ref`

```js
export default function Input() {
  const inputEl = useRef(null)
  const onButtonClick = () => {
    inputEl.current.focus()
  }
  return (
    <div>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </div>
  )
}
```

这里需要注意的是 `useRef()` 并不仅仅可以用来当作获取 `ref` 使用，使用 `useRef` 产生的 `ref` 的 `current` 属性是可变的，这意味着你可以用它来保存一个任意值，同样的，我们也可以使用 `useRef()` 来模拟 `componentDidUpdate`，`componentDidUpdate` 就相当于除去第一次调用的 `useEffect`，我们可以借助 `useRef` 生成一个标识，来记录是否为第一次执行

```js
function useDidUpdate(callback, prop) {
  const init = useRef(true)
  useEffect(() => {
    if (init.current) {
      init.current = false
    } else {
      return callback()
    }
  }, prop)
}
```



## 自定义 Hook

在看完了官方提供的一些 `Hook` 以后，下面我们来看看自定义 `Hook`，其实像之前我们介绍过的 `HOC` 和 `Mixin` 一样，我们同样可以通过自定义的 `Hook` 将组件中类似的状态逻辑抽取出来

自定义 `Hook` 的实现比较简单，我们只需要定义一个函数，并且把相应需要的状态和 `effect` 封装进去，同时 `Hook` 之间也是可以相互引用的，使用 `use` 开头命名自定义 `Hook`，这样可以方便 `eslint` 进行检查，下面我们来看几个具体的 `Hook` 封装


#### 日志打点

我们可以使用上面封装的生命周期 `Hook`

```js
const useLogger = (componentName, ...params) => {
  useDidMount(() => {
    console.log(`${componentName} 初始化`, ...params)
  })
  useUnMount(() => {
    console.log(`${componentName} 卸载`, ...params)
  })
  useDidUpdate(() => {
    console.log(`${componentName} 更新`, ...params)
  })
}

function Page1(props) {
  useLogger('Page1', props)
  return (<div>...</div>)
}
```


#### 修改页面标题

根据不同的页面名称修改页面标题内容

```js
function useTitle(title) {
  useEffect(
    () => {
      document.title = title
      return () => (document.title = '首页')
    },
    [title]
  )
}

function Page1(props) {
  useTitle('Page1')
  return (<div>...</div>)
}
```


#### 双向绑定

```js
function useBind(init) {
  let [value, setValue] = useState(init)
  let onChange = useCallback(function (event) {
    setValue(event.currentTarget.value)
  }, [])
  return {
    value,
    onChange
  }
}

function Page1(props) {
  let value = useBind('')
  return <input {...value} />
}
```



## Hook 的好处

我们在上面介绍了许多 `Hook` 的相关内容，包括如何定义，如何使用，下面我们就来看看它相对于 `HOC` 和 `Mixin` 所具备的一些优点


#### 减少状态逻辑复用的风险

`Hook` 和 `Mixin` 在用法上有一定的相似之处，但是 `Mixin` 引入的逻辑和状态是可以相互覆盖的，而多个 `Hook` 之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上，
在不遵守约定的情况下使用 `HOC` 也有可能带来一定冲突，比如 `props` 覆盖等等，使用 `Hook` 则可以避免这些问题


#### 避免地狱式嵌套

大量使用 `HOC` 的情况下让我们的代码变得嵌套层级非常深，使用 `Hook`，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套


#### 让组件更容易理解

在使用 `Class` 组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护，使用 `Hook`，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割


#### 使用函数代替class

相比函数，编写一个 `Class` 可能需要掌握更多的知识，需要注意的点也越多，比如 `this` 指向、绑定事件等等，另外计算机理解一个函数比理解一个 `Class` 更快，`Hook` 让你可以在 `Class` 之外使用更多 `React` 的新特性



## 参考

* [Hook 简介](https://zh-hans.reactjs.org/docs/hooks-intro.html)
* [React Hooks 入门教程](https://www.ruanyifeng.com/blog/2019/09/react-hooks.html)


