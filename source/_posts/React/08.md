---
title: React-Redux
date: 2019-03-25
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/08.jpg
---


`React-Redux` 将所有组件分成两大类，`UI` 组件（`presentational component`）和容器组件（`container component`）

<!--more-->


## UI 组件

`UI` 组件有以下几个特征

* 只负责 `UI` 的呈现，不带有任何业务逻辑

* 没有状态（即不使用 `this.state` 这个变量）

* 所有数据都由参数（`this.props`）提供

* 不使用任何 `Redux` 的 `API`

因为不含有状态，`UI` 组件又称为纯组件，即它像纯函数一样，纯粹由参数决定它的值


## 容器组件

容器组件的特征恰恰相反

* 负责管理数据和业务逻辑，不负责 `UI` 的呈现

* 带有内部状态

* 使用 `Redux` 的 `API`

> 总之，只要记住一句话，`UI` 组件负责 `UI` 的呈现，容器组件负责管理数据和逻辑

在 `React-Redux` 当中比较常用的 `API` 就两个，一个是提供的一个组件 `<Provider>`，另一个就是 `connect()` 方法


## connect()

`React-Redux` 提供 `connect` 方法，用于**从 `UI` 组件生成容器组件**，`connect` 的意思就是将这两种组件连起来

```js
import { connect } from 'react-redux';

const mapStateToProps = (state) => {
  return {
    inputValue: state.inputValue,
    list: state.list
  }
}

const mapDispatchToProps = (dispatch) => {
  return {
    handleInputChange(e) {
      const action = {
        type: 'change_input_value',
        value: e.target.value
      }
      dispatch(action);
    },
    handleSubmit() {
      const action = {
        type: 'add_todo_item'
      }
      dispatch(action);
    },
    handleDelete(index) {
      const action = {
        type: 'delete_todo_item',
        index
      }
      dispatch(action);
    }
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```

上面代码中，`connect` 方法接受两个参数，`mapStateToProps` 和 `mapDispatchToProps`，它们定义了 `UI` 组件的业务逻辑

前者负责输入逻辑，即将 `state` 映射到 `UI` 组件的参数（`props`），后者负责输出逻辑，即将用户对 `UI` 组件的操作映射成 `Action`

`connect()` 方法有两个比较重要的参数，`mapStateToProps` 和 `mapDispatchToProps`（都是函数）

#### mapStateToProps

官方解释如下：

* 如果你传入了这个参数，那么这个组件将会注册 `redux` 的 `store` 的更新信息（简单的可以理解为虚拟 `DOM` 那样，即变化了会自动更新）

* 即意味着无论什么时候 `store` 更新了，`mapStateToProps` 函数将会被调用

* `mapStateToProps` 的返回值必须是一个 `plain object`（简单的对象），这个对象将和组件的 `props` 融合，也就是说返回的对象中的 `key` 将自动成为组件的 `props` 中的成员（就比如上例中的 `App` 组件中的参数）

* 如果不想订阅 `store` 的更新，可以不用传入该参数，此时使用 `null` 来占位即可（不能不传）

抛开官方那些比较繁琐的解释，本质上 `mapStateToProps()` 就是一个函数，它的作用就是建立一个从（外部的）`state` 对象到（`UI` 组件的）`props` 对象的映射关系

作为函数，`mapStateToProps` 执行后应该返回一个对象，里面的每一个键值对就是一个映射

```js
const mapStateToProps = (state) => {
  return {
    inputValue: state.inputValue,
    list: state.list
  }
}
```

这个函数内部返回的键值对可以被 `connect()` 传入的参数组件所拿到（上例中的 `App`），即 `App` 组件当中可以拿到传递过去的参数（`state`）（当作 `props` 来使用）

而 `</Provider>` 中传递的 `store` 之所以可以被全局使用，也是依靠的这个函数（间接的通过参数传递过去了）

然后最重要的一点就是：**它可以得到全局唯一的 `store` 中的 `state`**



#### mapDispatchToProps

`mapDispatchToProps` 是 `connect` 函数的第二个参数，用来建立 `UI` 组件的参数到 `store.dispatch` 方法的映射

也就是说，它定义了哪些用户的操作应该当作 `Action`，传给 `Store`

官方解释如下：

* 如果传入了第二个参数，并且是一个函数，那么这个函数将获得 `dispatch` 方法（可以发出 `action`，也可以导致 `state`（`store`） 改变）

* 即 `connect()` 方法第一个参数来获得 `state`（但是不能修改），第二个参数可以用来修改 `state`（但是最终都传递回了 `App` 组件）

它接收参数 `dispatch`（`dispatch` 是 `store` 中用来分发命令的 `API`，这里简化了），返回一个总的 `actions` 清单对象

```js
const mapDispatchToProps = (dispatch) => {
  return {
    handleInputChange(e) {
      const action = {
        type: 'change_input_value',
        value: e.target.value
      }
      dispatch(action);
    },
    handleSubmit() {
      const action = {
        type: 'add_todo_item'
      }
      dispatch(action);
    },
  }
}
```



## &lt;Provider&gt;

`connect` 方法生成容器组件以后，需要让容器组件拿到 `state` 对象，才能生成 `UI` 组件的参数

`React-Redux` 提供 `Provider` 组件，可以让容器组件拿到 `state`

```js
import React from 'react';
import ReactDOM from 'react-dom';
import TodoList from './TodoList';
import { Provider } from 'react-redux';
import store from './store';

const App = (
  <Provider store={store}>
    <TodoList />
  </Provider>
)

ReactDOM.render(App, document.getElementById('root'));
```

在上面的示例当中，`Provider` 在根组件外面包了一层，这样一来 `App` 的所有子组件就默认都可以拿到 `state` 了