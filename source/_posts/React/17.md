---
title: 渲染器的核心 Diff 算法
date: 2019-12-18
categories: React
tags: React
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/17.jpg
---

最近在深入学习 `Virtual DOM` 的相关知识，参考了许多资料，拜读了许多大神的文章，感谢大神们的无私奉献

在这里大致的整理成了比较适合自己理解的方式，方便时不时回来翻翻，复习一下

篇幅较长，主要会分为三个部分来分别进行介绍，具体章节如下，目录名就差不多代表了章节的相关内容

[什么是 Virtual DOM？](http://localhost:4000/2019/12/16/React/15/)

[渲染器](http://localhost:4000/2019/12/16/React/16/)

[渲染器的核心 Diff 算法](http://localhost:4000/2019/12/16/React/17/)

在上一章当中，我们主要讨论了渲染器是如何更新各种类型的 `VNode` 的

本章是第三部分，主要介绍渲染器当中的核心，也就是传说中的 `Diff` 算法，主要参考的是 [HcySunYang/vue-design](https://github.com/HcySunYang/vue-design/tree/master/docs/zh)，本章相关内容如下

<!--more-->

* 减小 `DOM` 操作的性能开销




## 减小 DOM 操作的性能开销

在上一章当中，我们在遇到了旧的 `children` 和新的 `children` 均为多个子节点的情况，如下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/19.png)

我们当时提到，**只有当新旧子节点的类型都是多个子节点时，核心 Diff 算法才派得上用场**

并且当时我们采用了一种仅能实现目标但并不完美的算法，即 **遍历旧的子节点，将其全部移除；再遍历新的子节点，将其全部添加**

虽然能够达到目的，但并非最佳处理方式，在正式展开之前，我们先来思考一下上面的算法存在的问题，可以简化为下图

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/20.png)

简单来说就是遍历旧的 `VNode`，通过旧 `VNode` 对真实 `DOM` 的引用取得真实 `DOM`，即可将已渲染的 `DOM` 移除，接着遍历新的 `VNode` 并将其全部添加到页面中

我们可以先假定它们都是 `<li>` 标签，想象一下如果它们只是单纯的交换位置，或者只是简单的调整了一下包含的文本被人，我们是不是可以复用已有 `DOM` 元素呢？

实际上是可以的，我们在介绍 `pathcElement` 函数时了解到，当新旧 `VNode` 所描述的是相同标签时，那么这两个 `VNode` 之间的差异就仅存在于 `VNodeData` 和 `children` 上

所以我们完全可以通过遍历新旧 `VNode`，并一一比对它们，这样对于任何一个 `DOM` 元素来说，由于它们都是相同的标签，所以更新的过程是不会移除和新建任何 `DOM` 元素的

而是复用已有 `DOM` 元素，需要更新的只有 `VNodeData` 和 `children`，优化后的算法如下图所示

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/21.png)

但是会发现有问题，如果新旧 `children` 的长度相同的话是可行的，但是如果不同呢，所以我们就可以大致的分为三种情况来单独的进行处理，代码如下

```js
function patchChildren(prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) {
  switch (prevChildFlags) {

    // ...

    // 旧的 children 中有多个子节点
    default:
      switch (nextChildFlags) {
        
        // ...

        default:
          // 新的 children 中有多个子节点
          // 获取公共长度，取新旧 children 长度较小的那一个
          const prevLen = prevChildren.length
          const nextLen = nextChildren.length
          const commonLength = prevLen > nextLen ? nextLen : prevLen
          for (let i = 0; i < commonLength; i++) {
            patch(prevChildren[i], nextChildren[i], container)
          }

          // 如果 nextLen > prevLen，将多出来的元素添加
          if (nextLen > prevLen) {
            for (let i = commonLength; i < nextLen; i++) {
              mount(nextChildren[i], container)
            }
          
          // 如果 prevLen > nextLen，将多出来的元素移除
          } else if (prevLen > nextLen) {
            for (let i = commonLength; i < prevLen; i++) {
              container.removeChild(prevChildren[i].el)
            }
          }
          break
      }
      break
  }
}
```

实际上，这个算法就是在没有 `key` 时所采用的算法，该算法是存在优化空间的，下面我们将分析如何进一步优化



## 尽可能的复用 DOM 元素

在上一小节中，我们通过减少 `DOM` 操作的次数使得更新的性能得到了提升，但它仍然存在可优化的空间，我们假设新旧 children 如下

```js
// 旧的 children
[
  h('li', null, 1),
  h('li', null, 2),
  h('li', null, 3)
]

// 新的 children
[
  h('li', null, 2),
  h('li', null, 3),
  h('li', null, 4)
]
```

如果还是使用我们之前的算法，`patch` 函数知道它们是相同的标签，所以只会更新 `VNodeData` 和子节点，由于这两个标签都没有 `VNodeData`，所以只需要更新它们的子节点

它会依次进行比对，然后调用 `patchText` 方法来更新文本子节，比如在上面的示例当中，它会执行三次

实际上我们通过观察可以很明显的发现，最佳的操作应该是 **通过移动元素的位置来达到更新的目的**，那么应该如何移动元素来完成更新呢？

#### key 的作用

所以，我们需要在新旧 children 的节点中保存映射关系，以便我们能够在旧 children 的节点中找到可复用的节点

这时候我们就需要给 children 中的节点添加唯一标识，也就是我们常说的 key，有了 key 我们就能够明确的知道新旧 children 中节点的映射关系

比如下面这个例子

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/22.png)

知道了映射关系，我们就很容易判断新 children 中的节点是否可被复用：只需要遍历新 children 中的每一个节点，并去旧 children 中寻找是否存在具有相同 key 值的节点

```js
// 遍历新的 children
for (let i = 0; i < nextChildren.length; i++) {
  const nextVNode = nextChildren[i]
  let j = 0
  // 遍历旧的 children
  for (j; j < prevChildren.length; j++) {
    const prevVNode = prevChildren[j]
    // 如果找到了具有相同 key 值的两个节点，则调用 patch 函数更新之
    if (nextVNode.key === prevVNode.key) {
      patch(prevVNode, nextVNode, container)
      break // 这里需要 break
    }
  }
}
```


#### 找到需要移动的节点

我们已经找到了可复用的节点，并进行了合适的更新操作，下一步需要做的，就是判断一个节点是否需要移动以及如何移动

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/23.png)

我们可以先来看看不需要移动的情况，如上图，我们假定以上面的算法来执行，流程是下面这样的

1. 取出新 children 的第一个节点，并尝试在旧 children 中寻找 li-a，找到了，索引为 0
2. 取出新 children 的第二个节点，并尝试在旧 children 中寻找 li-b，找到了，索引为 1
3. 取出新 children 的第三个节点，并尝试在旧 children 中寻找 li-c，找到了，索引为 2

可以发现，我们先后遇到的索引顺序依次为 0 ==> 1 ==> 2，这是一个递增的顺序，这就说明

* 如果在寻找的过程中遇到的索引呈现递增趋势，则说明新旧 children 中节点顺序相同，不需要移动操作

* 相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作

下面再来看一个例子

![](https://gitee.com/heptaluan/backups/raw/master/cdn/react/24.png)

还是按照我们上面的流程，来看一看执行结果

1. 取出新 children 的第一个节点，并尝试在旧 children 中寻找 li-c，找到了，索引为 2
2. 取出新 children 的第二个节点，并尝试在旧 children 中寻找 li-a，找到了，索引为 0
3. 取出新 children 的第三个节点，并尝试在旧 children 中寻找 li-b，找到了，索引为 1

这次可以发现，递增的趋势被打破了，索引顺序依次为 2 ==> 0 ==> 1

在第二次查找过程中，0 < 2，这说明在旧 children 中 li-a 的位置要比 li-c 靠前，但在新的 children 中 li-a 的位置要比 li-c 靠后，所以得知 li-a 是需要被移动的

在第三次查找过程中，1 也是小于 2 的，这说明在旧 children 中节点 li-b 的位置也要比 li-c 的位置靠前，但在新的 children 中 li-b 的位置要比 li-c 靠后，所以 li-b 也需要被移动

在这个过程当中可以发现，因为有 2 这个数字的存在才使得我们能够知道哪些节点需要移动，我们可以把它称为**寻找过程中在旧 children 中所遇到的最大索引值**

如果在后续寻找的过程中发现存在索引值比最大索引值小的节点，意味着该节点需要被移动



















## 




## 参考

如果想了解更多的相关内容，可以参考以下链接查看详情

[React 源码深度解读](https://segmentfault.com/a/1190000016741764)

[深入理解 React 中的虚拟 DOM 和 Diff 算法](https://www.cnblogs.com/zhuzhenwei918/p/7271305.html)

[解析 Snabbdom 源码](https://github.com/creeperyang/blog/issues/33)

[React 源码剖析系列 － 不可思议的 React Diff](https://zhuanlan.zhihu.com/p/20346379)

[React Diff 算法](http://zencode.in/12.react-diff%E7%AE%97%E6%B3%95.html)

[A Survey on Tree Edit Distance and Related（这一篇是介绍标准的 Diff 算法，其复杂度为 O(n ^ 3)）](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf) 
