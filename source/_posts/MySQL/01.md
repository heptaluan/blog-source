---
title: 缓存穿透和缓存雪崩
date: 2018-03-03
categories: MySQL
tags: MySQL
toc: true
thumbnail: https://gitee.com/heptaluan/backups/raw/master/cdn/cover/01.jpg
---

分布式缓存系统面临的问题

<!--more-->

## 缓存一致性问题

* 缓存系统与底层数据的一致性

  * 这点在底层系统是可读可写时，写得尤为重要 

* 有继承关系的缓存之间的一致性

  * 为了尽量提高缓存命中率，缓存也是分层的，分为全局缓存和二级缓存，他们是存在继承关系的，全局缓存可以有二级缓存来组成

* 多个缓存副本之间的一致性

  * 为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如 `MemCache`，`Redis` 等）



## 缓存穿透

一般的缓存系统，都是按照 `key` 去缓存查询，如果不存在对应的 `value`，就应该去后端系统查找（比如 `DB`）

如果 `key` 对应的 `value` 是一定不存在的，并且对该 `key` 并发请求量很大，就会对后端系统造成很大的压力，这就叫做**缓存穿透**
 
## 如何避免

* 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 `key` 对应的数据 `insert` 了之后清理缓存

* 对一定不存在的 `key` 进行过滤，可以把所有的可能存在的 `key` 放到一个大的 `Bitmap` 中，查询时通过该 `Bitmap` 过滤


## 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如 `DB`）带来很大压力

## 如何避免

* 在缓存失效后，通过**加锁**或者队列来控制读数据库写缓存的线程数量，比如对某个 `key` 只允许一个线程查询数据和写缓存，其他线程等待

* 不同的 `key` ，设置不同的过期时间，让缓存失效的时间点尽量均匀

* 做二级缓存，`A1` 为原始缓存，`A2` 为拷贝缓存，`A1` 失效时，可以访问 `A2`，`A1` 缓存失效时间设置为短期，`A2` 设置为长期（此点为补充）

 
## 缓存数据的淘汰

策略有两种： 

* 定时去清理过期的缓存

* 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

两者各有优劣，第一种的缺点是维护大量缓存的 `key` 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，可以根据自己的应用场景来权衡
 
* 预估失效时间 

* 版本号（必须单调递增，时间戳是最好的选择）

* 提供手动清理缓存的接口

