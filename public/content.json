{"pages":[{"title":"彩蛋页","text":"算是备忘页面吧，主要记录一些常用的操作或是小贴士 Google 使用记录一些在使用 Google 搜索过程中的一些小技巧，如下表所示 介绍 用法 使用引号强制进行精确匹配搜索 &quot;搜索内容&quot; And 运算符只会返回和它们都相关的搜索结果 html AND css 使用 OR 操作符获取搜索词中某一个的结果 (javascript OR python) free course - 操作符将排除包含搜索词的结果 javascript -css 使用 * 通配符作为占位符，它将被任何单词或短语替换 &quot;how to start * in 6 months&quot; 在一个单一的网站搜索 搜索内容:target.com 查找特定的文件类型 filetype:pdf learn css 搜索一个数字范围 ecmascript 2016..2020 VSCode 快捷键记录一些在使用 VSCode 过程中的一些比较少用但是非常实用的快捷键，如下表所示 介绍 用法 打开用户设置 CTRL + , 显示所有快捷键 CTRL + K CTRL + S 切换工作区（类似全局 TAB 切换） CTRL + R 切换自动换行 ALT + Z 跳转到指定行数 CTRL + G 跳转到指定文件 CTRL + P 切换 VSCode 当中的文件 TAB CTRL + TAB 选中所有找到的匹配项 CTRL + F2 裁剪尾随空格 CTRL + K CTRL + X 如何选择图片格式这里简单罗列一下各个图片格式之间的区别，如下表所示 图片格式 压缩方式 透明度 动画 浏览器兼容 适应场景 JPEG 有损压缩 不支持 不支持 所有 复杂颜色及形状、尤其是照片 GIF 无损压缩 支持 支持 所有 简单颜色，动画 PNG 无损压缩 支持 不支持 所有 需要透明时 APNG 无损压缩 支持 支持 FirefoxSafari iOS Safari 需要半透明效果的动画 WebP 有损压缩 支持 支持 ChromeOpera Android ChromeAndroid Browser 复杂颜色及形状浏览器平台可预知 SVG 无损压缩 支持 支持 所有（IE8 以上） 简单图形，需要良好的放缩体验需要动态控制图片特效","link":"/tips/index.html"},{"title":"前端知识体系整理","text":"最后更新于 2020-10-04 虽然工作时间不短了，但是却从来没有静下心来好好梳理一下自己所掌握的东西，博客当中的许多内容都是在工作当中遇到，然后查阅资料解决后随手记录的一些知识点，亦或是无意间看到个新东西觉得好玩学一下，明天又看到那个有意思学一下，但是却没有真正的整理构建过属于自己的知识体系，所以在这里打算对照当下比较流行的一些方向，从新的整理一份个人的前端知识体系，主要目的是 梳理已经熟练掌握的知识 复习之前已经掌握但并不算熟练的知识 补习自身没有掌握，但是知道是必须要掌握的知识 希望通过梳理可以让自己的知识面达到一定的深度和广度，其实最主要的目的还是明确未来的方向，并有一个比较好的规划，这样才能让自己的职业生涯走的更远，另外博客当中的一些在初学时期整理的文章全部移动到了 这里，本文中所涉及到的内容均可在这两个地方找到 这里推荐一篇文章 《一个程序员的成长之路》，虽然文章是很早之前的了，但是依然给了我比较多关于未来的思考，也明确了未来短期内的一个方向，路漫漫其修远兮，与君共勉 HTML/CSS HTML Web 标准 文档类型（DOCTYPE） HTML5 标签新特性 渐进增强与优雅降级 CSS 盒子模型 样式来源与层叠规则（层叠权重值） 伪类与伪元素 经典布局（文档流/浮动/定位/圣杯/双飞翼/flex/grid） BFC/IFC/haslayout float/display/position/z-index/line-height/vertical-align JavaScript ECMAScript ES5 基本数据类型（类型转换/值和引用的传递/类型判断） 运算符（优先级/隐式类型转换） 对象（定义方式/原型链） 函数（事件流/作用域/执行上下文栈/继承） this（调用方式/如何确定 this 的值） 闭包（闭包模型/柯里化/反柯里化/偏函数） 深浅拷贝 跨域 ES6+ 块级作用域/模板字符串/迭代器/生成器 Class/Reflect/Symbol/Set/Map/Generator/Iterator/Arrow Function BOM 和 DOM DOM（节点类型/节点关系/节点操作） BOM（Window/Navigator/Screen/History/Location） 手写函数 工具（once/debounce/thorttle/slowcopy/deepcopy） 原生（call/apply/bind/new/Promise/Object.create/instanceof/getOwnPropertyNames） 数组（push/unshift/shift/pop/forEach/map/filter/reduce/find/indexOf） 执行过程 同步（调用栈/执行上下文栈/作用域链/VO/AO） 异步（Callback/Promise/Generator/Async/Await） 事件轮询机制（渲染进程/EventLoop/任务队列/requestAnimationFrame） V8 引擎 解析器与 AST（基线编译器/优化编译器） 内存管理（分配/使用/回收/内存泄漏） 垃圾回收机制 标记清除/引用计数 V8 垃圾回收策略（内存限制/新生代/晋升/老生代） 设计模式 工厂模式/工厂方法模式/观察者模式/发布订阅模式/单例模式/装饰者模式/中介者模式/代理模式 原型模式/外观模式/适配器模式/桥接模式/模版方法模式/状态模式/策略模式/访问模式 TypeScript 基础类型/内置对象/对象类型/数组类型/函数类型 元组/枚举/类与接口（readonly/抽象类/私有字段） 泛型（接口/类/约束/参数默认类型/条件类型/工具类型） 正则表达式（待整理） 主流框架 Angular Angular-CLI 生命周期流程/变化检测机制 依赖注入/装饰器/管道 动态加载 rxjs ngrx 与 @effect React 生命周期流程 Virtual DOM 与 Diff 算法 Redux/Flux/React-Redux/Middleware Mixin/Render Props/HOC/Hook React Fiber（节点与架构） Vue 生命周期流程 双向绑定原理 Router 原理 Vuex 工程实践 模块化/组件化 Webpack（待完善） AST/Babel/Babylon/Loader/Library 构建方式/配置/优化 性能优化（字体优化/精灵图/懒加载/预加载/静态资源的渲染阻塞/选择器优化/表达式优化） 微前端 计算机网络 HTTP/HTTPS HTTP 概述/协议/报文/首部字段/报文实体/状态码 结构组件（代理、网关、隧道、缓存） 用户认证（Session/Cookie/Token/JWT） HTTPS 追加协议 HTTP/2 HTTP/3 安全 TCP/IP OSI 参考模型 TCP/IP 基础与分层模型 数据包与数据处理流程 IP 协议（地址/组成/分类/广播地址/多播/子网掩码） 路由控制（地址/报文的分片与重组/路径 MTU 发现） IPv4 与 IPv6 IP 协议相关技术（DNS/ARP/ICMP/DHCP/NAT） TCP 和 UDP 应用层协议 其他应用层协议（多媒体通信实现技术/H.323/SIP/RTP/P2P/LDAP） 网络安全（构成要素/防火墙/入侵检测系统/安全协议） 浏览器 HTTP 请求流程 域名发散与收敛 渲染机制 DOM/CSSOM/渲染树 重绘/回流 浏览器缓存 前端安全（XSS/CSRF） 服务端 Node.js 模块机制 原生模块（HTTP/Buffer/EventEmitter/Stream） 中间件 多进程与事件轮询机制 Koa.js/Egg.js 数据库（待完善） MySQL SQLite 数据结构与算法 线性表（顺序存储结构/链式存储结构/循环链表/双向循环链表） 栈和队列 递归（尾调用/分治思想/汉诺塔/八皇后问题） 树和二叉树 树的定义/二叉树的定义/二叉树的遍历/线索二叉树 树、森林与二叉树之间的转换/赫夫曼树 图结构 存储结构与遍历 最小生成树（普里姆算法/克鲁斯卡尔算法） 最短路径（迪杰斯特拉算法/弗洛伊德算法） 关键路径（拓扑序列/拓扑排序/AOV 网/AOE 网） 查找算法 顺序查找/二分查找/插值查找/斐波那契查找/线性索引查找（有序） 散列表查找（无序） 二叉排序树/平衡二叉排序树/散列表查找 排序算法 比较排序（冒泡排序/选择排序/插入排序/希尔排序/归并排序/快速排序/堆排序） 非比较排序（计数排序/基数排序/桶排序） 数学 向量 线性代数 矩阵 矩阵的秩 高等数学 链式求导 梯度 &amp;&amp; 导数 &amp;&amp; 偏导 待整理想捣鼓但暂时没时间深入折腾，记录一下 正则表达式 PWA RxJS Docker Deno Golang WebAssembly Flutter Microservices ServerLess/GraphSQL D3/WebGL WebRTC Svelte","link":"/target/index.html"},{"title":"Three.js 入门","text":"因为最近公司新项目需要用到 Three.js 的一些相关内容，所以在这里简单记录一下在 React 当中使用 Three.js 的一些学习内容以及踩坑过程，也方便以后可以回来回顾总结一下 我们先从一张图开始看起，下图当中简单的囊括了 Three.js 当中涉及到的一些概念，可以让我们在整体上有一个大致的概念，但是这里我们只简单的梳理一下入门所需要用到的一些内容，其他更多其他相关内容可以参考 教程 三个基础概念我们先从 Three.js 当中的三个基本概念开始看起，也就是场景（scene）、相机（camera）和渲染器（renderer） 场景 这个比较好理解，场景其实就是一个载体，也就是我们常说的容器，我们代码当中所有的一切都运行在这个容器里面（存放着所有渲染的物体和使用的光源） 相机 相机的作用是『定义可视域』，相当于我们的双眼，生产一个个快照，相机主要分为两类，正投影相机和透视相机 正投影相机的话，所有方块渲染出来的尺寸都一样，对象和相机之间的距离不会影响渲染结果 而透视相机接近真实世界，看物体会产生远近高低各不同 比较常见的相机有以下这些 PerspectiveCamera，透视摄像机，也是最为常用的，模拟人眼的视觉，根据物体距离摄像机的距离，近大远小 ArrayCamera，阵列摄像机（包含多个子摄像机，通过这一组子摄像机渲染出实际效果，适用于 VR 场景） CubeCamera，立方摄像机（创建六个 PerspectiveCamera，适用于镜面场景） StereoCamera，立体相机（双透视摄像机适用于 3D 影片、视差效果） 渲染器 负责用如何渲染出图像，是使用 WegGL 还是 Canvas，类似于 react 中 render，产生实际的页面效果 其他一些概念 网格（Mesh） 有了场景和摄像头就可以看到 3D 场景中的物体，场景中的我们最为常用的物体称为网格，而网格则是由两部分组成，几何体和材质 材料（Materials）与纹理（Textures），物体的表面属性可以是单纯的颜色，也可以是很复杂的情况，比如反射/透射/折射的情况，还可以有纹理图案，比如包装盒外面的贴图 几何形状（Geometry），Three.js 使用 Geometry 定义物体的几何形状，其实 Geometry 的核心就是点集，之所以有这么多的 Geometry，是为了更方便的创建各种形状的点集 光照（Lights） 算是组成部分，如果没有光源，就不可能看到任何渲染结果，具体介绍可以参考 光照效果 这篇文章，这里我们只来看看一些比较常用的光源，主要有下面这些 AmbientLight，环境光源，属于基础光源，为场景中的所有物体提供一个基础亮度 DirectionalLight，平行光源，类似太阳光，发出的光源都是平行的 HemisphereLight，半球光源，只有圆球的半边会发出光源 PointLight，点光源，一个点向四周发出光源，一般用于灯泡 SpotLight，聚光灯光源，一个圆锥体的灯光 但是需要注意的是，并不是每一种光源都能产生阴影（Shadow），DirectionalLight、PointLight、SpotLight 这三种光源都能产生阴影，另外如要开启模型的阴影的话，模型是由多个 Mesh 组成的，只开启父的 Mesh 的阴影是不行的，还需要遍历父 Mesh 下所有的子 Mesh 为其开启投射阴影 castShadow 和接收投射阴影 receiveShadow 加载器（Loaders） 用来解析的导入的模型文件，常见的有 OBJLoader（加载 .obj 文件）、JSONLoader、MTLLoader 实例单纯的概念理解起来可能比较抽象，所以我们下面就通过一个实际的实例来结合了解一下，例子很简单，就是在页面当中显示一个三维的立方体 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 创建场景对象 Scene */var scene = new THREE.Scene()/** * 创建网格模型 */var geometry = new THREE.BoxGeometry(100, 100, 100) // 创建一个立方体几何对象 Geometryvar material = new THREE.MeshLambertMaterial({ // 材质对象 Material color: 0x0000ff,})var mesh = new THREE.Mesh(geometry, material) // 网格模型对象 Meshscene.add(mesh) // 网格模型添加到场景中/** * 光源设置 */var point = new THREE.PointLight(0xffffff) // 点光源point.position.set(400, 200, 300) // 点光源位置scene.add(point) // 点光源添加到场景中var ambient = new THREE.AmbientLight(0x444444) // 环境光scene.add(ambient)/** * 相机设置 */var width = window.innerWidth // 窗口宽度var height = window.innerHeight // 窗口高度var k = width / height // 窗口宽高比var s = 200 // 三维场景显示范围控制系数，系数越大，显示的范围越大var camera = new THREE.OrthographicCamera( // 创建相机对象 -s * k, s * k, s, -s, 1, 1000)camera.position.set(200, 300, 200) // 设置相机位置camera.lookAt(scene.position) // 设置相机方向（指向的场景对象） /** * 渲染 */var renderer = new THREE.WebGLRenderer() // 创建渲染器对象renderer.setSize(width, height) // 设置渲染区域尺寸renderer.setClearColor(0xb9d3ff, 1) // 设置背景颜色document.body.appendChild(renderer.domElement) // 插入 canvas 对象renderer.render(scene, camera) // 执行渲染操作，指定场景、相机作为参数 下面我们来对照代码一个一个来看 几何体（Geometry） 1var geometry = new THREE.BoxGeometry(100, 100, 100) 这里无需过多提及，我们通过构造函数 THREE.BoxGeometry() 的方式创建了一个长宽高都是 100 立方体几何对象 Geometry，通过构造函数名字 BoxGeometry 我们也能猜出这个构造函数的意义，当然我们也可以通过下面这种方式创建一个球体几何对象 1var geometry = new THREE.SphereGeometry(60, 40, 40) 材质（Material） 1var material = new THREE.MeshLambertMaterial({ color: 0x0000ff }) 通过构造函数 THREE.MeshLambertMaterial() 创建了一个可以用于立方体的材质对象，构造函数的参数是一个对象，对象包含了颜色、透明度等属性 光源（Light） 1var point = new THREE.PointLight(0xffffff) 通过构造函数 THREE.PointLight() 创建了一个点光源对象，参数 0xffffff 定义的是光照强度，Three.js 引擎对 WebGL 光照模型算法都进行了封装，使得我们可以直接使用调用three.js光源相关API直接创建一个光源对象，就像你使用普通的三维建模渲染软件一样 相机（Camera） 1var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000) 通过构造函数 THREE.OrthographicCamera() 创建了一个正射投影相机对象，相机构造函数的的前四个参数定义的是拍照窗口大小，类似于我们平时拍照一样，取景范围为大，被拍的人相对背景自然变小了，而后面的 camera.position.set(200, 300, 200) 和 camera.lookAt(scene.position) 则定义的是相机的位置和拍照方向 程序的结构 至此，我们可以梳理出整个代码的结构，如下图所示 我们来简单的梳理一下流程 首先我们分别使用构造函数 THREE.Scene()、THREE.OrthographicCamera()、THREE.WebGLRenderer() 创建了场景、相机、渲染器三个最顶层的总对象，然后通过总对象的子对象、方法和属性进行设置 使用构造函数 Mesh() 创建了一个网格模型对象，该对象把我们定义的几何对象和材质对象作为参数，然后使用 .add() 的方式把三维场景的子对象添加到场景中，另外使用 new THREE.PointLight(0xffffff)、new THREE.AmbientLight(0x444444) 定义了两个点光源、环境光对象，然后也作为场景的子对象插入场景中 场景、相机、渲染器设置完成后，设置代码 renderer.render(scene,camera) 把场景、相机对象作为渲染器对象方法 render() 的参数，其实就是相当于告诉浏览器根据相机的放置方式拍摄已经创建好的三维场景对象","link":"/target/Three/01.html"}],"posts":[{"title":"Angular 中的管道","text":"Angular 中的管道主要是用来对字符串、货币金额、日期和其他显示数据进行转换和格式化，管道通常是一些简单的函数，可以在模板表达式中用来接受输入值并返回一个转换后的值，我们先来看看一些简单的使用场景 123456789&lt;p&gt;生日是 {{ birthday | data: 'yyyy-MM-dd' }}&lt;/p&gt;&lt;p&gt;圆周率为 {{ 3.14159265 | number: '1.2-2' }}&lt;/p&gt;&lt;p&gt;转为大写 {{ 'Angular' | uppercase }}&lt;/p&gt;&lt;p&gt;转为小写 {{ 'Angular' | lowercase }}&lt;/p&gt;&lt;p&gt;格式化 {{ { name: 'semlinker' } | json }}&lt;/p&gt; 管道参数管道可以接收任意数量的参数，使用方式是在管道名称后面添加 : 和参数值，如 number: '1.2-2' ，若需要传递多个参数则参数之间用冒号隔开 1&lt;p&gt;{{ 'semlinker' | slice:0:3 }}&lt;/p&gt; 管道链可以将多个管道连接在一起，组成管道链对数据进行处理 1&lt;p&gt;{{ 'semlinker' | slice:0:3 | uppercase }}&lt;/p&gt; 自定义管道管道是一个带有管道元数据装饰器的类，与组件和模块类似，就是一个简单的 TypeScript 类，通过 @pipe 装饰器来告诉 Angular 这是一个管道类，然后去实现 PipeTransform 接口即可，一个简单的管道，如果跟随参数，则返回和参数相乘的值，如果没有传递参数，则返回原值 12345678910111213141516import { Pipe, PipeTransform } from '@angular/core'@Pipe({ name: 'formatNumber'})// 只需实现 PipeTransform 接口即可// 内部仅有一个 transform 方法export class TestPipe implements PipeTransform { transform(value: number, args?: number): any { if (!args) { args = 1 } return value * args }} 然后使用也很简单 1&lt;div&gt;{{num | formatNumber: '2'}}&lt;/div&gt; 在构造函数当中使用管道一个小技巧，但不是经常使用 12345678910import { DatePipe } from '@angular/common'class MyService { constructor(private datePipe: DatePipe) {} transformDate(date) { this.datePipe.transform(myDate, 'yyyy-MM-dd') }} AsyncPipe（异步管道）使用 AsyncPipe 可以直接在模版当中使用 Promise 和 Observable 对象，而不需要通过定义一个类的成员属性来存储返回的结果，下面来看两个例子，Promise 和 Observable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Promiseimport { Component } from '@angular/core'@Component({ selector: 'exe-promise-pipe', template: ` &lt;h4&gt;Promise with AsyncPipeComponent&lt;/h4&gt; &lt;p&gt;{{ promise | async }}&lt;/p&gt; `})export class PromiseAsyncPipeComponent { promise: Promise&lt;string&gt; constructor() { this.promise = this.getPromise() } getPromise(): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(`Promise with AsyncPipe complete!`) }, 2000) }) }}// Observablesimport { Component } from '@angular/core'import { Observable } from 'rxjs/Rx'@Component({ selector: 'exe-observable-pipe', template: ` &lt;h4&gt;Observable with AsyncPipe Component&lt;/h4&gt; &lt;p&gt;{{ observable | async }}&lt;/p&gt; `})export class ObservableAsyncPipeComponent { observable: Observable&lt;number&gt; constructor() { this.observable = this.getObservable() } getObservable(): Observable&lt;number&gt; { return Observable .interval(1000) .take(10) .map(v =&gt; v * v) }} 两者的区别 Promise，返回单个值，不可取消的 Observable，随着时间的推移发出多个值，可以取消的，支持 map、filter、reduce 等操作符，延迟执行，当订阅的时候才会开始执行 AsyncPipe 会发送多次请求比如如下情况 12345678910@Component({ selector: 'exe-app', template: ` &lt;div&gt; &lt;p&gt;{{ (person$ | async)?.id }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.title }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.body }}&lt;/p&gt; &lt;/div&gt; `}) 几种解决办法 使用 share()123// 使用 rxjs 中的共享操作符this.http.get(url) .map(res =&gt; res.json()).share() 使用 publishReplay()但是页面当中如果有按钮存在的情况，再次请求同样的地址还是会发送请求，这时可以使用 publishReplay() 1234567891011121314constructor(private http: Http) { this.preparePersonInfo()}ngOnInit() { // 调用 connect() 方法的时候，将主动执行订阅操作 this.person$.connect()}// 调用 publishReplay() 方法后将返回一个 ConnectableObservable 对象preparePersonInfo() { this.person$ = this.http.get(url) .map(res =&gt; res.json()).publishReplay()} 如果只需要从服务器获取数据并显示数据可以使用 Promise 来修复 AsyncPipe 发送多次请求的问题 12this.person = this.http.get(url) .map(res =&gt; res.json()).toPromise() AsyncPipe 执行流程如下图","link":"/2018/01/11/Angular/04/"},{"title":":host 和 ::ng-deep","text":"这里会涉及到 Angular 的 ViewEncapsulation，即控制视图的封装模式，主要分为三种，原生（Native）、仿真（Emulated）和无（None）三种 Native 模式，完全隔离，外面的样式无法影响组件，组件里面的样式也无法影响外面 Emulated 模式（默认值），全局样式可以影响组件，但组件样式无法影响外层 None 意味着完全消除隔离特性，全局样式可以影响组件，组件样式也可以影响外层 这种情况下 Angular 不使用视图封装，会把 CSS 添加到全局样式中，而不会应用之前那些作用域规则、隔离和保护等 从本质上来说，这跟把组件的样式直接放进 HTML 是一样的 术语上来说就是 ViewEncapsulation 允许设置三个可选的值 ViewEncapsulation.Emulated 没有 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，使得组件的样式不受外部影响，这是 Angular 的默认设置 虽然样式仍然是应用到整个 document，但 Angular 会为所在的类创建了一个 [_ngcontent-cmy-0] 选择器 ViewEncapsulation.Native 使用原生的 Shadow DOM 特性，Angular 会把组件按照浏览器支持的 Shadow DOM 形式渲染 ViewEncapsulation.None 即没有 Shadow DOM，并且也无样式包装，即所有的样式都应用到整个 document，换句话说，组件的样式会受外界影响，可能被覆盖掉 唯一的区别在于 Shadow DOM，当然其作用是让组件的样式只进不出，换言之即组件内的样式不会影响到外部组件，三者的表现形成如下，假设基本模版为 12345@Component({ template: `&lt;h1&gt;test&lt;/h1&gt;`, styles: [`h1 { color: #f50; }`], encapsulation: ViewEncapsulation.Native}) 三种方式生成的分别为 Native1234#shadow-root (open) &lt;style&gt;h1 { color: #f50; }&lt;/style&gt; &lt;h1&gt;test&lt;/h1&gt; Emulated123&lt;style&gt;h1[_ngcontent-c0] { color: #f50; }&lt;/style&gt;&lt;h1 _ngcontent-c0&gt;test&lt;/h1&gt; None123&lt;style&gt;h1 { color: #f50; }&lt;/style&gt;&lt;h1&gt;test&lt;/h1&gt; 需要注意的是 Native 和 None 在内容是一样的，但其后者会影响至其他外部组件的 h1 元素 组件样式组件样式的封装模式取决于我们对 encapsulation 的配置，当然你可以了在 main.ts 时为所有组件统一设定一种行为模式，例如 1234// 使用 None 模式platformBrowserDynamic().bootstrapModule(AppModule, { defaultEncapsulation: ViewEncapsulation.None}) 虽然三种模式都有不同的风格，但对于一个组件而言，如果没有统一使用风格，那么在实际项目中则会让我们很头疼，特别是当项目中同时在使用第三方组件库，情况会更为复杂，比如你在某一个组件当中添加了一个 class 样式 123.active-link { color: red;} 若组件设定为 None 模式，只要该组件出现过一次，并且在未来所有即使不再使用，那么这个样式也会得到保留，所有的添加了这个 class 的元素均会改变，反之，对于 Shadow 行为，它会为该组件创建一个额外的属性 _ngcontent-c1 来标识（不管是 Native、Emulated 本质是一样的）所设定的样式仅限于当前组件当中，而 Angular 中即采用 :host 来表示组件自身，所以前面的 CSS 样式可以调整为 123456789:host .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link[_ngcontent-c1] { color: red;} 然而我们会发现，对于第三方组件组件而言，.active-link 是其组件内部某个 HTML 元素的 class 而已，且它有自己的一套组件封装规则，但我们生成的 CSS 中包括了一个奇怪的字符 [_ngcontent-c1]，最终导致该组件样式无法改变内嵌的第三方组件内容的样式，在这种情况下，Angular 提供了一种对未来工具更好兼容性的命令 ::ng-deep 来强制样式允许侵入子组件 123456789:host ::ng-deep .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link { color: red;} 最终的结果就是这个样式只会在这个组件内部当中有效","link":"/2018/02/02/Angular/06/"},{"title":"在 Angular 当中使用 WebSocket","text":"在正式展开之前，我们先来看看 WebSocket 和 Socket.IO 的相关内容 WebSocketWebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说服务器可以在任意时刻发送消息给浏览器，Websocket 协议本质上是一个基于 TCP 的协议，它由通信协议和编程 API 组成，WebSocket 能够在浏览器和服务器之间建立双向连接，以基于事件的方式，赋予浏览器事实通信的能力 既然是双向通信，就意味着服务器端和客户端可以同时发送并响应请求，而不再像 HTTP 的请求和响应，为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 Upgrade: WebSocket 表明这是一个申请协议升级的 HTTP 请求 服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接 WebSocket API一个简单的实例，大致流程为打开一个连接，为连接创建事件监听器，断开连接，消息时间，发送消息返回到服务器，关闭连接 1234567891011var socket = new WebSocket('ws://localhost:8000') // 创建一个 Socket 实例socket.onopen = function (event) { // 打开 Socket socket.send('socket init') // 发送一个初始化消息 socket.onmessage = function (event) { // 监听消息 console.log('Message listener') } socket.onclose = function (event) { // 监听 socket 的关闭 console.log('closed') } socket.close() // 关闭} ws 表示 WebSocket 协议，参数为 url（以 ws 开头） onopen，onclose，onmessage 方法把事件连接到 Socket 实例上 onmessage 事件提供了一个 data 属性，它可以包含消息的 body 部分（消息的 body 部分必须为一个字符串，可以进行序列化或者反序列化，以便传递更多的数据） Socket.IOSocket.IO 是 Node.js 当中的一个模块，它是通过 WebSocket 进行通信的一种简单方式，Socket.IO 使用检测功能来判断是否建立 WebSocket 连接，或者是 Ajax long-polling 连接，或 Flash 等，可快速创建实时的应用程序，下面是一个简单的示例 客户端 index.html 如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;Socket.io&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;I Am Socket.IO&lt;/h1&gt; &lt;script src='./socket.io.js'&gt;&lt;/script&gt; &lt;script&gt; var socket=io.connect('ws://localhost:8000') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端 index.js 如下 1234567891011121314151617181920var http = require('http')var fs = require('fs')var sever = http.createServer(function (req, res) { fs.readFile('./index.html', function (err, data) { res.writeHead(200, { 'Content-Type': 'text/html' }) res.end(data, 'utf-8') })}).listen(3000)// 为了在服务器上加入 Socket.io 的功能，必须将 Socket.IO 库包括进来，而后附加到服务器上var io = require('socket.io').listen(sever)// 在启动了服务器的 Socket.io 之后，用于初始化io.socket.on('connection', function (socket) { console.log('user conneted') socket.on('disconnect', function () { console.log('user disconnet') })}) 向服务器发送数据到客户端 1234io.sockets.on('connection', function (socket) { // 向客户端发送消息 socket.emit('message', { text:'you have connected' })}) 只要客户端连接，它就将数据发送给每一个新的客户端，而如果想给当前所有的客户端都发送消息，则需要发送广播消息 123456io.sockets.on('connection', function (socket) { // 单个客户端发送消息 socket.emit('message', { text: 'A new user has connected' }) // 广播消息给客户端 socket.broadcast.emit('massage', { text: 'A new user has connected' })}) 接下来需要做的就是客户端先连接 Socket.io 服务器，然后侦听在 'message' 事件上接收的数据，然后做出响应 1234var socket = io.connect('ws://localhost:8000')socket.on('message', function (data) { console.log(`${data.text}`)}) 在 Angular 项目当中使用 WebSocket主要是结合 WebSocket 和 rxjs 两者一起使用 12345678910111213141516171819202122// socket.service.tsimport { Injectable } from '@angular/core'import { Observable } from 'rxjs'@Injectable()export class SocketService { ws: WebSocket constructor() { } createObservableSocket(url: string): Observable&lt;any&gt; { this.ws = new WebSocket(url) return new Observable( observer =&gt; { this.ws.onmessage = (event) =&gt; observer.next(event.data) this.ws.onerror = (event) =&gt; observer.error(event) this.ws.onclose = (event) =&gt; observer.complete() }) }} 当然别忘了在当前 Module 当中进行注册 1234567891011121314151617import { SocketService } from './header/socket.service'@NgModule({ declarations: [ AppComponent, ... ], imports: [ BrowserModule, ... ], providers: [SocketService], bootstrap: [AppComponent]})export class AppModule {} 最后是导入使用 1234567891011121314151617181920212223import { Component, OnInit } from '@angular/core'import { SocketService } from './socket.service'@Component({ selector: 'app-header', templateUrl: './header.component.html', styleUrls: ['./header.component.css']})export class HeaderComponent implements OnInit { messageCount = 0 constructor(public socketService: SocketService) { } ngOnInit() { this.socketService.createObservableSocket('ws://localhost:8000') .map(event =&gt; JSON.parse(event)) .subscribe( event =&gt; this.messageCount = event.messageCount ) }}","link":"/2019/05/20/Angular/15/"},{"title":"伪类与伪元素","text":"我们先来了解一下两者的官方定义，可以见 伪元素和伪类，简单的总结一下就是 CSS 引入伪类和伪元素概念是为了格式化文档树以外的信息，也就是说，伪类和伪元素的作用主要是用来修饰不在文档树中的部分，两者的区别如下 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的 比如说，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态 伪元素用于创建一些不在文档树中的元素，并为其添加样式 比如说，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式 虽然用户可以看到这些文本，但是这些文本实际上不在文档树中 简单的总结就是 伪类的操作对象是文档树中已有的元素 而伪元素则创建了一个文档数外的元素 两者的区别主要在于有没有创建一个文档树之外的元素，具体可见下图 伪元素是使用单冒号还是双冒号？CSS3 规范中的要求使用双冒号（::）表示伪元素，以此来区分伪元素和伪类 比如 ::before 和 ::after 等伪元素使用双冒号（::） :hover 和 :active 等伪类使用单冒号（:） 除了一些低于 IE8 版本的浏览器外，大部分浏览器都支持伪元素的双冒号（::）表示方法，然而，除了少部分伪元素，如 ::backdrop 必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法，比如 ::after，写成 :after 也可以正确运行 那么我们到底应该是使用单冒号还是双冒号呢？我们可以参考 MDN 得知，大概的意思就是，虽然 CSS3 标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法（为了向后兼容，建议你在目前还是使用单冒号的写法），实际上，伪元素使用单冒号还是双冒号很难说得清谁对谁错，你可以按照个人的喜好来选择某一种写法 下面我们再来看看一些操作伪元素的方式，比如如何获取并修改伪元素的值 获取伪元素的值这里主要涉及 ::before 和 ::after，其余几个伪元素（::first-letter、::first-line、::selection 等）由于没有 content 属性，所以一笔带过，本质上是一样的，由于 JavaScript 里没有可以直接操作伪元素的选择符，但是我们可以通过获取其 CSS 属性的方法来达到目的，这里可以利用 window.getComputedStyle 方法选择到伪元素，然后利用 getPropertyValue 方法获取对应的属性的值 1window.getComputedStyle(element[, pseudoElt]) 此方法包含两个参数，一个是元素本身另一个是元素的伪元素 1234var div = document.querySelector('div')// 获取 before 伪元素的字号大小（获取的时候使用 : 或者 :: 都是可以的）var fontSize = window.getComputedStyle(div, '::before').getPropertyValue('content') 更改伪元素值虽然上面的方法可以获取到伪元素的属性值，但是却无法更改，如果使用 JavaScript 来更改伪元素属性值的话，这里主要介绍下面两种方法 更改 data-* 属性值来更改伪元素的 content 值data-* 是 HTML5 新增的 DOM 元素属性，作用大致可以理解为标记，伪元素的 content 属性值除了常规赋值外，还有一种特殊的 attr() 方法来获取 1&lt;div class=\"test\" data-text=\"AAA\" data-color=\"red\"&gt;&lt;/div&gt; 123.test::before { content: attr(data-text) /* AAA */} 另外 content 其实可以多个 attr 连写，而且 attr() 内的可以是 DOM 元素的任意属性（比如 class 等，甚至非 W3C 标准属性也支持，不过不推荐这么做） 1234/* 注意用空格连接，不要用 + 号拼接 */.test::before { content: '类名是' attr(class) '颜色是' attr(data-color)} 需要注意，目前只有 content 属性支持 这个方法 创建多个 class，通过切换 class 来达到改变样式的目的这个方法的优点是简单好用且无兼容性问题，缺点是多了一些其实用处不大的 class 参考 Attribute References: attr() Pseudo-elements and pseudo-classes 总结伪类与伪元素","link":"/2018/11/25/CSS/04/"},{"title":"CSS 当中的 float","text":"算是一篇系列文章吧，主要涉及到 CSS 当中的 float、display、position、vertical-align、line-height 这几个属性，因为在平常开发当中也只是拿来使用，并没有十分深入的去了解它们，所以就打算在这里从头开始慢慢的梳理一遍，也当是复习复习了，我们就先从 float 开始 特性在 CSS 中，是存在流的概念的，在正常情况下页面总是从左到右，从上到下布局，这种被称为正常的流，但是有很多情况，正常流是没办法实现的，因此我们需要一些手段来破坏流，从而实现一些特殊的布局，而本节的主角 float 就具备破坏流的特性 在还是新手阶段的时候，我们通常在布局的时候，总喜欢用 float 来实现，例如一个三栏布局，左右固定，中间自适应，则会通过 float 来一列一列把它们砌起来，这样的布局看上去是实现了目的，但是也是极其容易崩溃，只要高度或者宽度稍微有些变化，整个页面都会错乱，这是因为 float 的设计初衷并不是用来布局的，其本意仅仅是实现图片文字环绕效果，即图片左浮动，文字环绕图片，也就是下面这样的效果 一个元素如果设置了 float 属性，它会表现出如下特性 包裹性 块状化 高度塌陷 没有 margin 合并 其中的高度塌陷和没有 margin 合并的内容我们在之前的 BFC 章节当中都已经详细介绍过了，所以这里就不在展开了，详细内容可以参考链接，所以这里我们只介绍包裹性和块状化两个特性 包裹性包裹性包含了包裹和自适应两个特性，包裹指的是一个浮动元素，如果子元素宽度足够小，则浮动元素的宽度就是该子元素的宽度，比如下面这个例子 123&lt;p style=\"float:left;\"&gt; &lt;span&gt;这是浮动元素的子元素&lt;/span&gt;&lt;/p&gt; 运行以后可以发现，父元素 p 的宽度就是它的子元素 span 的宽度，也就是说父元素是将子元素 span 给包裹了起来，而自适应指的是如果浮动元素的父元素有设置宽度，并且浮动元素的子元素宽度超出了父元素，则浮动元素的宽度最终表现为父元素的宽度，如下 12345&lt;div style=\"width:100px;\"&gt; &lt;p style=\"float:left;\"&gt; &lt;span&gt;这是浮动元素的子元素&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 运行以后可以发现，浮动的元素 p 的宽度和父元素一样也是 100px 块状化块状化的意思是，一旦元素 float 的属性不为 none，则其 display 计算值就是 block 或者 table，举个例子，我们使用 JavaScript 来进行测试，如下 1234567var span = document.createElement('span')document.body.appendChild(span)console.log('1.' + window.getComputedStyle(span).display) // inlinespan.style.cssFloat = 'left'console.log('2.' + window.getComputedStyle(span).display) // block 运行完了以后观察两者的输出值可以发现这里存在一个问题，既然元素设置 float 后，元素就块状化了，那么怎么还能产生包裹性的效果呢？要回答这个问题，需要重新阐述下块状化的意思，这里的块状化意思是可以像 block 元素一样设置宽和高，但并不是真正的块元素，因此下面这些属性是多余的，并且如果你使用的代码编辑器有提示功能的话，它也会提示你存在多余这个问题 123456789span { display: block; /* 多余属性 */ float: left;}div { float: left; vertical-align: middle; /* 多余属性 */} 作用机制我们还是以之前的例子来进行了解 1234&lt;div&gt; &lt;span&gt;标题&lt;/span&gt; &lt;a style=\"float:right\"&gt;链接&lt;/a&gt;&lt;/div&gt; 这个页面展示的情况我们已经知晓，即在标准浏览器下，标题会和链接在同一行展示，并且链接会浮动在右边，但是如果标题非常长，一行放不下呢，链接是浮动在第一行还是第二行呢？答案是第二行，要想解释这个，我们得先理解两个概念，一个是浮动锚点，一个是浮动参考 浮动锚点是 float 元素所在的流中的一个点，这个点本身并不浮动，表现得就像是一个没有 margin、padding 和 border 的空的内联元素 浮动参考指的是浮动元素对齐参考的实体 float 元素的浮动参考是行框盒子，也就是 float 元素在当前行框盒子内定位，因此上面的例子链接会在第二行展示，但是也有一种情况是，浮动元素前后并没有内联元素，因此也就不存在行框盒子，这时候就是浮动锚点在起作用，因为浮动锚点表现得像一个内联元素，有内联元素，自然就有行框盒子，只是这个盒子看不见也摸不着罢了","link":"/2018/11/28/CSS/05/"},{"title":"IFC","text":"在上一篇文章当中，我们介绍了 BFC 相关概念，所以在这一篇当中我们就来看一下与它十分类似的 IFC，所谓 IFC（Inline Formatting Context），直译为行内格式化上下文，与之相关的就是行盒模型，行盒模型是一个显示区域，根据块状容器内，每一行的多个内联元素（inline-level element）都会共同生成一个行盒模型 IFC 定义每个盒子都有一个 FC 特性，不同的 FC 值代表一组盒子不同的排列方式，有的 FC 值表示盒子从上到下垂直排列，有的 FC 值表示盒子从左到右水平排列等等 而 IFC 则是表示盒子从左到右的水平排列方式，仅此而已（注意：一个盒子仅且仅有一个 FC 值） 而 inline-level box 的 FC 特性值固定为 IFC 在 IFC 中，盒子水平放置，一个接着一个，从包含块的顶部开始，水平 margins，borders 和 padding 在这些盒子中被平分，这些盒子也许通过不同的方式进行对齐，它们的底部和顶部也许被对齐，或者通过文字的基线进行对齐，矩形区域包含着来自一行的盒子叫做 line box line box 的宽度由浮动情况和它的包含块决定，line box 的高度由 line-height 的计算结果决定，一个 line box 总是足够高对于包含在它内的所有盒子，它也许比包含在它内最高的盒子高（比如，盒子对齐导致基线提高了） 当盒子的高度比包含它的 line box 的高度低，在 line box 内的垂值对齐线通过 vertical align 属性决定 当几个行内级盒子在一个单独的 line box 内不能很好的水平放置，则它们被分配成了 2 个或者更多的垂直重叠的 line boxs 因此，一个段落是很多个 line boxs 的垂直叠加，line boxs 被叠加没有垂直方向上的分离（特殊情况除外），并且它们也不重叠，通常 line box 的左边缘挨着它的包含块的左边缘，右边缘挨着它的包含块的右边缘，然而浮动盒子也许会在包含块边缘和 line box 边缘之间 因此尽管 line boxs 在同样的行内格式上下文中通常都有相同的宽度（就是他的包含块的宽度），但是水平方向上的空间因为浮动被减少了，它的宽度也会变得复杂，line boxs 在同样的行内格式上下文中通常在高度上是多样的（比如，一行也许包含了一个最高的图片然后其他的也可以仅仅只包含文字） 注意事项注意以下几种情况 当在一行中行内级盒子的总宽度比包含它们的 line box 的宽度小 它们在 line box 中的水平放置位置由 text align 属性决定 如果属性是 justify，用户代理可能会拉伸空间和文字在 inline boxs 内 当一个行内盒子超过了 line box 的宽度 则它被分割成几个盒子并且这些盒子被分配成几个横穿过的 line boxs 如果一个行内盒子不能被分割，则行内盒子溢出 line box 当一个行内盒子被分割，分割发生则 margins，borders 和 padding 便没有了视觉效果 在同样的 line box 内的行内盒子也许会被分割成几个盒子因为 双向的文字 line boxs 在行内格式上下文中档需要包含行内级内容时被创造 line boxs 包含没有文字，没有空格，没有带着 margins，padding 和 borders 以及没有其他在流中的内容（比如图片，行内盒子和行内表格） 也不会以新起一行结尾，对于在它们内的任何盒子的位置都以它们决定并且必须将它们视作没有高度的 line boxs 影响效果影响 IFC 内布局的 CSS 主要有以下几个 font-size line-height height vertical-aligin 下面我们就一个一个来进行介绍 font-size一般用于指定文本类型节点的大小，IFC 内的很多属性的值是基于这个的 line-height &amp;&amp; height在一个由多个内联元素组成的块状容器内，line-height 为内联元素的行盒模型指定了一个最低高度，这个最低高度是分别由基线上的最小高度和基线下的最小深度组成，如下图，从上到下四条线分别是顶线、中线、基线、底线，那么行高是指上下文本行的基线间的垂直距离，即两条红线间垂直距离（实际在数值上，行高也等于其它相同颜色间的距离） 关于 line-height 更为详细的介绍可以见 CSS 当中的 line-height vertical-align该属性影响由多个内联元素生成的盒模型组成的行内盒模型的垂直定位，vertical 有几个特定的值，或者指定一个值 12345678&lt;p class=\"a1\"&gt; &lt;span style=\"vertical-align:60px\"&gt; English中文 &lt;/span&gt; &lt;span&gt; 中文English &lt;/span&gt;&lt;/p&gt; 显示如下 其中，黄色线就是基线（baseline），绿线和黄线的间隔即为 60px，这里会发现，容器（蓝色）的高度被撑高了，所以这里需要注意的是容器的高度是 1height = line-height + vertical-align 当然同理，如果容器的高度被指定了，那么高度则不变，而超出的部分则不影响布局，如果设置 overflow: hidden，则超过的部分则不可见，而 vertical-align 的其它特殊值，均可以看做一个根据容器高度而变化的相对值（比如可以设置百分比） 关于 vertical-align 更为详细的介绍可以见 CSS 当中的 vertical-align","link":"/2018/12/05/CSS/07/"},{"title":"IE 中的 haslayout","text":"特别注意，hasLayout 在 IE8 及之后的 IE 版本中已经被抛弃，所以在实际开发中只需针对 IE8 以下的浏览器为某些元素触发 hasLayout haslayout 定义Layout 是 IE 浏览器渲染引擎的一个内部组成部分，在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容，为了协调这两种方式的矛盾，渲染引擎采用了 hasLayout 属性，属性值可以为 true 或 false 当一个元素的 hasLayout 属性值为 true 时，我们说这个元素有一个布局（layout），或者说是拥有布局，可以通过 hasLayout 属性来判断一个元素是否拥有 layout，如 object.currentStyle.hasLayout，hasLayout 与 BFC 有很多相似之处，但 hasLayout 的概念会更容易理解，在 Internet Explorer 中，元素使用『布局』概念来控制尺寸和定位，分为拥有布局和没有布局两种情况 拥有布局的元素由它控制本身及其子元素的尺寸和定位 而没有布局的元素则通过父元素（最近的拥有布局的祖先元素）来控制尺寸和定位 而一个元素是否拥有布局则由 hasLayout 属性告知浏览器，它是个布尔型变量，true 代表元素拥有布局，false 代表元素没有布局，简而言之，hasLayout 只是一个 IE 下专有的属性，hasLayout 为 true 的元素浏览器会赋予它一系列的效果 触发 layout一个元素触发 hasLayout 会影响一个元素的尺寸和定位，这样会消耗更多的系统资源，因此 IE 设计者默认只为一部分的元素触发 hasLayout （即默认有部分元素会触发 hasLayout，这与 BFC 基本完全由开发者通过特定 CSS 触发并不一样），这部分元素如下 1234567&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt; 除了 IE 默认会触发 hasLayout 的元素外，Web 开发者还可以使用特定的 CSS 触发元素的 hasLayout，通过为元素设置以下任一 CSS ，可以触发 hasLayout （即把元素的 hasLayout 属性设置为 true） 属性名 取值 display inline-block height 除 auto 外任何值 width 除 auto 外任何值 float left 或 right position absolute writing-mode tb-rl zoom 除 normal 外任意值 min-height 任意值 min-width 任意值 max-height 除 none 外任意值 max-width 除 none 外任意值 overflow 除 visible 外任意值，仅用于块级元素 overflow-x 除 visible 外任意值，仅用于块级元素 overflow-y 除 visible 外任意值，仅用于块级元素 position fixed 对于内联元素（可以是默认被浏览器认为是内联元素的 span 元素，也可以是设置了 display: inline 的元素），width 和 height 只在 IE5.x 下和 IE6 或更新版本的 quirks 模式下能触发元素的 hasLayout 但是对于 IE6，如果浏览器运行于标准兼容模式下，内联元素会忽略 width 或 height 属性，所以设置 width 或 height 不能在此种情况下令该元素触发 hasLayout，但 zoom 除了在 IE 5.0 中外，总是能触发 hasLayout，zoom 用于设置或检索元素的缩放比例，为元素设置 zoom: 1 既可以触发元素的 hasLayout，同时不会对元素造成多余的影响，因此综合考虑浏览器之间的兼容和对元素的影响， 建议使用 zoom: 1 来触发元素的 hasLayout 解决的问题hasLayout 表现出来的特性跟 BFC 很相似，所以可以认为是 IE 中的 BFC，规则几乎都遵循，所以在之前 BFC 当作遇到的问题在 IE 里都可以通过触发 hasLayout 来解决，虽然 hasLayout 也会像 BFC 那样影响着元素的尺寸和定位，但它却又不是一套完整的标准，并且由于它默认只为某些元素触发，这导致了 IE 下很多前端开发的 bugs 触发 hasLayout 更大的意义在于解决一些 IE 下的 bugs，而不是利用它的一些副作用来达到某些效果，另外由于触发 hasLayout 的元素会出现一些跟触发 BFC 的元素相似的效果，因此为了统一元素在 IE 与支持 BFC 的浏览器下的表现，建议为触发了 BFC 的元素同时触发 hasLayout ，当然还需要考虑实际的情况，也有可能只需触发其中一个就可以达到表现统一","link":"/2018/10/12/CSS/08/"},{"title":"静态链表","text":"我们都知道，C 语言是一门伟大都语言，它都魅力在于指针都灵活性，使得它可以非常容易的操作内存中的地址和数据，这使得它比一些其他的高级语言更加灵活和方便，但是在一些高级语言当中，比如 Java 中的面向对象，就是使用对象引用机制间接的实现了指针的某些功能 静态链表其实是为了给没有指针的编程语言设计的一种实现单链表功能的方法，尽管我们可以使用单链表，但是静态链表的思想是非常巧妙的，应该有所了解 什么是静态链表但是在 C 语言之前，只有原始的 Basic，Fortran 等早期的编程语言，这些语言当中并没有类似于 C 的指针功能，所以有人就想出了一种使用数组来代替指针用来描述单链表，这种用数组来描述的链表就叫做『静态链表』，这种描述的方法叫做『游标实现法』，如下图所示 对应的线性表的静态链表存储结构代码如下 123456#define MAXSIZE 1000typedef struct { ElemType data; // 数据 int cur; // 游标} Component, StaticLinkList[MAXSIZE]; 对静态链表进行初始化相当于初始化数组 1234567Status InitList(StaticLinkList space) { int i; for(i = 0; i &lt; MAXSIZE - 1; i++) space[i].cur = i + 1; space [MAXSIZE - 1].cur = 0; return OK;} 下面是一些需要注意的地方 一般对数组的第一个和最后一个元素做特殊处理，他们的 data 不存放数据 通常把未使用的数组元素称为备用链表 数组的第一个元素，即下标为 0 的那个元素的 cur 就存放备用链表的第一个结点的下标 数组的最后一个元素，即下标为 MAXSIZE - 1 的 cur 则存放第一个有数值的元素的下标，相当于单链表中的头结点作用 下面我们就来看看静态链表如何模拟单链表进行插入和删除的操作 静态链表的插入操作在静态链表中，我们主要解决的就是如何模拟动态链表结构的存储空间分配，也就是需要的时候申请，不需要的时候释放，在之前，我们提到过，为了辨明数组中哪些分量未被使用，解决的方法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时， 便可以从备用链表上取得第一个结点作为待插入的新结点，我们以上面第示例来进行说明，比如我们要在 A 的后面插入 B，如下图 我们要做的首先是获得空闲分量的下标 12345678910111213141516171819202122232425262728293031int Malloc_SLL(StaticLinkList space) { int i = space[0].cur; if(space[0].cur) { space[0].cur = space[i].cur; // 把它的下一个分量用来作为备用 return i; }}/* 在静态链表 L 中第 i 个元素之前插入新第数据元素 */Status ListInsert(StaticLinkList L, int i, ElemType e) { int j, k, l; k = MAXSIZE - 1; // 数组第最后一个元素 if (i &lt; 1 || i &gt; ListLength(L) + 1) { return ERROR; } j = Malloc_SLL(L); if (j) { L[j].data = e; for(l = 1; l &lt;= i - 1; l++) { k = L[k].cur; } L[j].cur = L[k].cur; L[k],cur = j return OK; } return ERROR;} 最终结果如下图所示 静态链表的删除操作还是以上面的示例为例，这次我们来删掉 C 元素 123456789101112131415161718192021222324252627282930313233343536373839/* 删除在 L 中的第 i 个数据元素 */Status ListDelete(StaticLinkList L, int i) { int j, k; if(i &lt; 1 || i &gt; ListLength(L)) { return ERROR; } k = MAXSIZE - 1; for(j = 1; j &lt;= i - 1; j++) { k = L[k].cur; } j = L[k].cur; L[k].cur = L[j].cur; Free_SLL(L, j) ; return OK;}/* 将下标为 k 的空闲结点回收到备用链表 */void Free_SLL(StaticLinklist space, int k) { space[k].cur = space[0].cur; space[0].cur = k;}/* 返回 L 中数据元素个数 */int ListLength(StaticLinkList L) { int j = 0; int i = L[MAXSIZE - 1].cur; while (i) { i = L[i].cur; j++; } return j;} 结果如下 静态链表的优缺点静态链表的优点是在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点，而缺点也比较明显，没有解决连续存储分配（数组）带来的表长难以确定的问题，失去了顺序存储结构随机存取的特性，即不能直接使用下标来找到指定的值了，因为它某些程度上来说，已经具备了一些单链表的特性了","link":"/2020/02/05/Essay/08/"},{"title":"树","text":"在之前的章节当中，我们花费了许多篇幅介绍了 单链表，循环链表，双向链表与双向循环链表，栈和队列 等相关知识，但是如果细心观察可以发现，我们之前介绍的种种，它们其实都是一种『一对一』的线性结构，无论是线性表也好，或者说是栈和队列，都是一样的，所以今天我们就来看一种『一对多』的数据结构，那就是『树结构』 树的定义树（Tree）是 n（n &gt;= 0）个结点的有限集，当 n = 0 时成为空树，在任意一棵非空树中，有以下特点 有且仅有一个特定的称为根（Root）的结点 当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1、T2、... Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree） 如下图所示 但是有两个需要注意的地方，即 当 n &gt; 0 时，根结点是唯一的，不可能存在多个根结点 当 m &gt; 0 时，子树的个数是没有限制的，但它们互相是一定不会相交的 比如下面两个图片所表示的『均是错误』的 结点分类在之前树的定义当中，图中的每一个圈圈我们就称为树的一个结点，结点拥有的子树数称为结点的度（Degree），树的度取树内各结点的度的最大值 度为 0 的结点称为叶结点（Leaf）或终端结点 度不为 0 的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点 可以用下图来进行表示 结点间的关系结点间的关系简单来说，结点的子树的根称为结点的孩子（Child），相应的，该结点称为孩子的双亲（Parent），同一双亲的孩子之间互称为兄弟（Sibling），而结点的祖先则是从根到该结点所经分支上的所有结点，结点的层次（Level）从根开始定义，根为第一层，根的孩子为第二层，其双亲在同一层的结点互为堂兄弟，树中结点的最大层次称为树的深度（Depth）或高度，如下图所示 树的存储结构之前我们介绍了树的定义和一些基本概念，下面我们就来看看如何在内存中安排树这种结构的存放，说到存储结构，就会想到我们之前介绍过的顺序存储和链式存储两种基本结构，对于线性表来说，很直观就可以理解，但是对于树这种一对多的结构，我们应该怎么办呢？ 如果要存储树，简单的顺序存储结构和链式存储结构是无法实现的，但是如果充分利用它们各自的特点，完全可以间接地来实现，这里我们主要介绍三种不同的表示法，『双亲表示法』、『孩子表示法』和『孩子兄弟表示法』，下面我们就一个一个来看 双亲表示法双亲表示法，言外之意就是以双亲作为索引的关键词的一种存储方式，我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中位置的元素，也就是说，每个结点除了知道自己是谁之外，还知道它的双亲结点在哪里，可以作如下定义 123456789101112131415// 树的双亲表示法结点结构定义#define MAX_TREE_SIZE 100typedef int ElemType;typedef struct PTNode { ElemType data; // 结点数据 int parent; // 双亲位置} PTNode;typedef struct { PTNode nodes[MAX_TREE_SIZE]; int r; // 根的位置 int n; // 结点数目} PTree; 如果用图片来表示的话，如下 如上图这样的存储结构，我们可以根据某结点的 parent 指针找到它的双亲结点，所用的时间复杂度是 O(1)，索引到 parent 的值为 -1 时，表示找到了树结点的根，但是也是存在缺点的，比如我们如果想要知道某结点的孩子是什么？那么则需要遍历整个树结构，所以基于这个问题，我们可以考虑稍微来改变一下它的结构，如下图 同理，比如我们需要了解它的兄弟之间的关系，可以调整如下图 由上我们可以发现，存储结构的设计是一个非常灵活的过程，只要你愿意，你可以设计出任何你想要的结构，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等等，所以并不需要拘泥于所学过的有限的数据类型，而是以当前的使用场景来进行考虑 孩子表示法看完了双亲表示法，我们再来看看孩子表示法，这次我们换个角度来考虑，由于树中每个结点可能有多棵子树，所以可以考虑用多重链表来实现，这里我们还是以开头例子当中的树为例，同样的，孩子表示法也有多种可以实现的方式，我们一个一个来看，首先来看方案一，也是最简单粗暴的方法，即『根据树的度，声明足够空间存放子树指针的结点』即可，如下图所示（在这里我们使用 ^ 来代表空指针，也就是 null） 当然，缺点也是显而易见的，那就是造成了空间的浪费，所以针对于这个缺点，我们就有了方案二，如下图 我们引入了一个新的变量用来表示『每个结点的度的值』，这样一来我们就克服了空间浪费这个缺点，但是同时可以发现，因为每个结点的度的值不同，初始化和维护起来也是存在一定问题的，所以就有了方案三 我们通过将数组和链表的一定搭配结合来进行实现，但是如果只找到孩子找不到双亲貌似还不够完善，那么我们干脆就将它们一起合并起来，也就有了我们的『双亲孩子表示法』，如下图 下面我们就来看看『双亲孩子表示法』的定义代码 12345678910111213141516171819202122#define MAX_TREE_SIZE 100typedef char ElemType;// 孩子结点typedef struct CTNode { int child; // 孩子结点的下标 struct CTNode *next; // 指向下一个孩子结点的指针} * ChildPtr;// 表头结构typedef struct { ElemType data; // 存放在树中的结点的数据 int parent; // 存放双亲的下标 ChildPtr firstchild; // 指向第一个孩子的指针} CTBox;// 树结构typedef struct { CTBox nodes[MAX_TREE_SIZE]; // 结点数组 int r, n;}","link":"/2020/03/12/Essay/15/"},{"title":"二叉树的遍历","text":"在之前的 二叉树 章节当中，我们介绍了二叉树的定义以及性质，所以本章我们就重点来看看二叉树遍历的相关内容 二叉树的遍历二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次的遍历方式，这里需要注意上文提及的两个概念『某种次序依次访问』和『访问一次且仅被访问一次』 这是因为二叉树的遍历次序不同于线性结构，因为线性结构最多也就是分为顺序、循环、双向等简单的遍历方式，而树的结点之间不存在唯一的前驱和后继这样的关系，所以在访问一个结点后，下一个被访问的结点面临着不同的选择，所以二叉树的遍历方式就可以有很多，在这里我们简单的总结一下，主要分为以下四种遍历方式 前序遍历 中序遍历 后序遍历 层序遍历 有个比较简单的记忆方式就是 先序遍历，根 ==&gt; 左 ==&gt; 右 中序遍历，左 ==&gt; 根 ==&gt; 右 中序遍历，左 ==&gt; 右 ==&gt; 根 可以发现，前中后的遍历顺序是看『根结点』放在何处来决定的，下面我们就借助下方这个二叉树的图（注意不是完全二叉树），一个一个来进行了解 前序遍历基本逻辑是，如果二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树，顺序如下图所示 遍历的顺序为 A ==&gt; B ==&gt; D ==&gt; H ==&gt; I ==&gt; E ==&gt; J ==&gt; C ==&gt; F ==&gt; K ==&gt; G 中序遍历若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树，顺序如下图所示 遍历的顺序为 H ==&gt; D ==&gt; I ==&gt; B ==&gt; E ==&gt; J ==&gt; A ==&gt; F ==&gt; K ==&gt; C ==&gt; G 后序遍历若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点，顺序如下图所示 遍历的顺序为 H ==&gt; I ==&gt; D ==&gt; J ==&gt; E ==&gt; B ==&gt; K ==&gt; F ==&gt; G ==&gt; C ==&gt; A 层序遍历这个也是我们最好理解的方式，就是一层一层的遍历，若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问，顺序如下图所示 遍历的顺序为 A ==&gt; B ==&gt; C ==&gt; D ==&gt; E ==&gt; F ==&gt; G ==&gt; H ==&gt; I ==&gt; J ==&gt; K 二叉树的建立和遍历我们直接来看如何用代码进行实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 首先创建一个类来表示二叉树，它的内部有一个 Node 类，用来创建节点class Node { constructor(key) { this.key = key this.left = null this.right = null }}class BinaryTree { constructor() { this.root = null } // 插入数据 insert(key) { // 传入需要插入的 key 值，它会自动初始化为左右节点为 null 的一个新节点 var newNode = new Node(key) if (this.root == null) { this.root = newNode } else { var current = this.root // 通过循环来找到新添加节点的合适位置 while (true) { if (key &lt; current.key) { if (current.left) { current = current.left } else { current.left = newNode break } } else if (key &gt; current.key) { if (current.right) { current = current.right } else { current.right = newNode break } } } } } // 中序遍历 centerSort(node) { // 检查传入的 node 是否为 null，如果不为空，就继续递归调用自身检查 node 的 left、right 节点 if (node) { this.centerSort(node.left) console.log(node.key) this.centerSort(node.right) } } // 前序遍历 prevSort(node) { if (node) { console.log(node.key) this.prevSort(node.left) this.prevSort(node.right) } } // 后续遍历 nextSort(node) { if (node) { this.nextSort(node.left) this.nextSort(node.right) console.log(node.key) } }}var arr = [13, 21, 15, 29, 3, 55]var bst = new BinaryTree()arr.map(item =&gt; { bst.insert(item)})bst.centerSort(bst.root)// bst.prevSort(bst.root)// bst.nextSort(bst.root) 我们通过上面的方式实现了对二叉树的节点插入，和三种遍历方法，同时我们很明显可以看到，在二叉树当中，最左侧的节点的值是最小的，而最右侧的节点的值是最大的，而这些内容对于我们在后面将要介绍到的 二叉排序树 有很大帮助，因为我们可以借住二叉查找树很方便的拿到其中的最大值和最小值 另外可以发现，我们也并没有涉及到比如在二叉树当中查找给定的值，亦或者删除某个给定的值的操作，关于这些内容我们会在后面的 二叉排序树 当中重点来进行介绍","link":"/2020/03/25/Essay/17/"},{"title":"exports、module.exports 和 export、export default","text":"在 JavaScript 模块化编程的模块引入上，主要有两种方式，如下 CommonJS 模块标准 ES6 moduel 特性 但是我们需要注意的是，CommonJS 模块规范和 ES6 模块规范完全是两种不同的概念，下面我们就来看看他们之间的区别 CommonJS 模块规范Node.js 应用由模块组成，它采用了 CommonJS 模块规范，根据这个规范，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见的，CommonJS 规范规定，每个模块内部，module 变量代表当前模块，这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口，加载某个模块，其实是加载该模块的 module.exports 属性，如下 123456789var x = 5var addX = function (value) { return value + x}module.exports.x = xmodule.exports.addX = addX 上面代码通过 module.exports 输出变量 x 和函数 addX，而我们使用 require 方法就可以来加载该模块 1234var example = require('./example.js')console.log(example.x) // 5console.log(example.addX(1)) // 6 exports 与 module.exports我们在一般开发过程当中导出模块的方式有两种方式，第一种就是直接对 module.exports 赋值，这个也是使用较多的 1234module.exports = { x: x, addX: addX} 或者也可以直接使用 exports，即直接在该对象上添加方法，表示对外输出的接口，如同在 module.exports 上添加一样 1exports.addX = addX 但是针对上面的第一种用法，你不可以直接对 exports 赋值，就像下面这样 12345// 错误的使用方式exports = { x: x, addX: addX} 代码虽然可以执行，但是模块并没有输出任何变量，这里就需要注意了，是不能直接将 exports 变量指向一个值的，因为这样操作就等于切断了 exports 与 module.exports 之间的联系了 那么这里就存在一个问题了，exports 和 module.exports 到底有什么区别和联系呢？这里就要提起 require() 这个方法了，在官方 API 当中，有一个经典的例子就是把 require 方法简化成了下面这个函数 12345678910function require() { // ... function (module, exports) { // Your module code here exports = some_func // re-assigns exports, exports is no longer // a shortcut, and nothing is exported. module.exports = some_func // makes your module export 0 } (module, module.exports) return module} 通过观察传入进去的参数，我们可以看到 exports = module.exports，所以说，一开始这两个东西是指向同一个对象实例的（实际上是同一个变量，并且初始化为空对象 { } ），如下图所示 如果直接添加一个方法，比如 exports.fn = func，那么由于 exports 指向 module.exports，由于复制引用的关系，相当于 module.exports 也添加了同样的方法，类似下图 123456// 在 exports 上添加了一个方法，module.exports 也添加了同样的方法，因为它们指向了同样的对象实例 exports.fn = function () { console.log(`hello world!`)}module.exports.fn() // hello world! 如果给 exports 直接赋值，比如这里 exports = some_func，那么 exports 的指向就变了，但最后导出的是 module，因此，exports 指向的方法或者今后在 exports 上添加的方法都不会影响到 module.exports，因此不会被导出 引用官方 API 的一句话 As a guideline, if the relationship between exports and module.exports seems like magic to you, ignore exports and only use module.exports. 所以还是建议尽量使用 module.exports，但是在有的时候，比如我们要输出的是一个函数或者数组，那么，只能给 module.exports 赋值 1module.exports = function () { return 'foo' } 给 exports 赋值是无效的，因为赋值后，module.exports 仍然是空对象 {} （因为最后导出的是 module），我们可以简单的总结一下 如果要输出一个键值对象 {}，可以利用 exports 这个已存在的空对象 {}，并继续在上面添加新的键值 如果要输出一个函数或数组，必须直接对 module.exports 对象赋值 所以我们可以得出结论，直接对 module.exports 赋值，可以应对任何情况 123module.exports = { foo: function () { return 'foo' }} 或者 1module.exports = function () { return 'foo' } 总之，尽量使用 module.exports 来输出模块变量 ES6 模块规范在看完了 CommonJS 模块规范之后，我们再来看看 ES6 当中的模块规范，不同于 CommonJS，ES6 使用 export 和 import 来导出、导入模块，在 ES6 模块当中比较容易混淆的也就是 export 和 export default 以及它们对应的引入方式，我们先来看看它们的区别，如下 export 与 export default 均可用于导出常量、函数、文件、模块等 在一个文件或模块中 export 和 import 可以有多个，但是 export default 仅有一个 通过 export 方式导出，在导入时要加 { }，export default 则不需要 export 能直接导出变量表达式，export default 不行 我们先来看看如何进行导出，先来看看通常的 export 导出方式 1234567// 导出变量export const a = '100'// 导出方法export const say = function () { console.log(`hello`)} export default 导出方式如下，这里需要注意，不能写成 export defult const m = 100 这样的格式 123const m = 100export default m 另外还有一种使用较少的导出方式 12345function say() { console.log(`hello`)}export { say } 我们假设上方代码是写在 test.js 当中的，引入方式如下 12345import { say } from './test' // 导出了 export 方法 import m from './test' // 导出了 export default import * as testModule from './test' // as 集合成对象导出 区别最后我们再来简单的看看它们两者之间的区别，如下所说 CommonJS 模块输出的是一个值的拷贝，而 ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 CommonJS 是单个值导出，ES6 Module 可以导出多个 CommonJS 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 CommonJS 的 this 是当前模块，ES6 Module 的 this 是 undefined","link":"/2018/06/05/Node/03/"},{"title":"React 中的 Mixin","text":"最近在复习到 React 高阶组件相关内容的时候，发现之前比较常见的 Mixin 已经差不多被废弃了，而 HOC 相关内容也渐渐的在被 Hook 所替代，只能感叹变化太快 所以在这里打算重新的从头梳理一下，将之前博客当中关于 React 的一些过时内容也删减整合一下，也算是重新的温习一下 React 当中的几种状态逻辑复用的方式，也就是 Mixin，HOC 和 Hook 它们几者的实现原理、使用方法、实际应用以及如何选择等内容 我们先从快要被抛弃的 Mixin 开始看起，不过内容不会介绍很多，毕竟现在使用的已经不是很多了 Mixin 设计模式 在学习 JavaScript 的过程当中，我们可能已经听闻过 Mixin 这个东西，JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承怎么办呢？所以在这种情况下就出现了 Mixin Mixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的，它的出现主要就是为了解决代码复用问题，我们可以自己尝试封装一个 Mixin 方法来感受下 123456789101112131415161718192021function mixin(destClass, srcClass) { var destProto = destClass.prototype var srcProto = srcClass.prototype for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method] } }}function Parent() { }Parent.prototype.say = function () { console.log('hello')}function Child() { }mixin(Child, Parent)var child = new Child()child.say() // hello 再比如下面这个 Mixin 实现多继承 123456789101112131415161718192021222324252627282930313233function mixin(destClass) { var classes = Array.prototype.slice.call(arguments, 1) for (var i = 0; i &lt; classes.length; i++) { var srcClass = classes[i] var srcProto = srcClass.prototype var destProto = destClass.prototype for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method] } } }}function Parent() { }Parent.prototype.getName = function () { }Parent.prototype.setName = function () { }function Child() { }Child.prototype.showName = function () { }function Man() { }mixin(Man, Child, Parent)var man = new Man()console.log(man.__proto__)// {// getName: ƒ ()// setName: ƒ ()// showName: ƒ ()// constructor: ƒ Man()// } 其实在很多开源库当中都提供了 Mixin 的实现，比如 Underscore 的 _.extend 方法，jQuery 的 extend 方法，这里我们来看看如何使用 _.extend 方法实现代码复用 1234567891011121314151617181920var Mixin = { sayHello: function () { console.log('hello') }, sayWorld: function () { console.log('world') },}function Foo() { }function Bar() { }_.extend(Foo.prototype, Mixin)_.extend(Bar.prototype, Mixin)var foo = new Foo()var bar = new Bar()foo.sayHello() // hellobar.sayWorld() // world 看完了 Mixin 的基本使用方式以后我们再来看看如何在 React 中应用 Mixin React 中的 MixinReact 当中也提供了 Mixin 的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，但是只有在使用 createClass 来创建 React 组件时才可以使用，因为在 React 组件的 ES6 写法中它已经被废弃掉了 例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等，如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过 Mixin 我们可以解决这一问题 12345678910111213141516171819202122232425var Mixin = { log: function () { console.log('log') }, componentDidMount: function () { console.log('in') }, componentWillUnmount: function () { console.log('out') }}var Foo = React.createClass({ mixins: [Mixin], render: function () { return &lt;div&gt;&lt;/div&gt; }})var Bar = React.createClass({ mixins: [Mixin], render: function () { return &lt;div&gt;&lt;/div&gt; }}) 不过这种使用方式已经过时了，不再推荐使用 Mixin 带来的危害React 官方文档在 Mixins Considered Harmful 一文中提到了 Mixin 带来了危害 Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的 Mixin 中的方法可能会相互冲突 Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 React 现在已经不再推荐使用 Mixin 来解决代码复用问题，因为 Mixin 带来的危害比他产生的价值还要巨大，并且 React 已经全面推荐使用高阶组件来替代它，另外高阶组件还能实现更多其他更强大的功能，所以这一部分内容我们会在后面的 React 中的 HOC 章节当中来详细进行介绍","link":"/2020/10/24/React/14/"},{"title":"在 Vue 中使用 JSX","text":"平常在写 Vue 组件的时候一般使用的都是模版，但是在一些需要自定义内容的场景下就会用到 Vue 中的 render 函数，但是 render 函数的语法非常繁琐，通常一个非常简单的模版在写成 render 函数之后就会变得十分繁琐 所以在这种情况之下可以考虑采用 JSX 的语法来进行编写，如果需要使用 JSX ，那么就需要事先安装一个 Babel 插件 babel-plugin-transform-vue-jsx，如果是使用 Vue-Cli 构建的项目的话，只需要安装下面三个依赖 12345npm install\\ babel-plugin-syntax-jsx\\ babel-plugin-transform-vue-jsx\\ babel-helper-vue-jsx-merge-props\\ --save-dev 然后在 .babelrc 文件当中配置一下即可 1'plugins': ['transform-runtime', 'transform-vue-jsx'], 简单示例配置完成之后，我们就可以在 Vue 当中编写 JSX 了，如下 1234567891011121314151617// test 组件export default { props: ['onClick', 'isShow'], data() { return { test: 123 } }, render() { return ( &lt;div class='test' onClick={this.onClick}&gt; {this.test} {this.isShow + ''} &lt;/div&gt; ) }} 不过还是有一些需要注意的地方 render 方法是 Vue 2.0 才支持的 Vue 当中的 JSX 语法和 React 当中的 JSX 语法存在一定的区别 下面是一个涵盖大部分语法的示例 12345678910111213141516render(h) { return ( &lt;div id='foo' domPropsInnerHTML='bar' onClick={this.clickHandle} nativeOnClick={this.nativeClickHandle} class={{ foo: true, bar: false }} style={{ color: 'red', fontSize: '14px' }} key='key' ref='ref' refInFor slot='slot' &gt;&lt;/div&gt; )} 一些区别如下 DOM 属性需要加上 domProps 前缀（style 等不需要） React 使用的是 className，Vue 使用的是 class 事件监听是以 on 或 nativeOn 开头 经过编译后为 12345678910111213141516171819202122232425262728render(h) { return h('div', { attrs: { id: 'foo' }, domProps: { innerHTML: 'bar' }, on: { click: this.clickHandler }, nativeOn: { click: this.nativeClickHandler }, class: { foo: true, bar: false }, style: { color: 'red', fontSize: '14px' }, key: 'key', ref: 'ref', refInFor: true, slot: 'slot' })} 注意事项 在模板中引入 JSX 的组件，可以通过 components 引用，另外 props 的编写从驼峰变为连接符 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class='wrapper'&gt; &lt;Text :on-click='clickHandle' :is-show='show' &gt;&lt;/Text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test from './Test.vue' export default { name: 'hello', components: { Test }, data() { return { msg: 'welcome', show: true } }, methods: { clickHandle() { this.show = !this.show; } } }&lt;/script&gt; 如果反之，即在 JSX 里面引入 Vue 模版组件，除了连接符的属性转换为驼峰式，还有一个需要注意的就是指令 如果使用了 JSX，那么内置的指令都不会生效（除了 v-show） 可以手动使用 JSX 来进行描述，使用 v-name={value} 语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt;import Vue from 'vue'Vue.directives('my-directive', { inserted: function(el) { el.style.fontWeight = 900 }})export default { props: ['onClick', 'isShow'], data() { return { test: 123 } }, methods: { afterLeave() { console.log('afterLeave') } }, render() { const directives = [{ name: 'my-directive', value: 666, modifiers: { abc: true } }]; return ( &lt;transition onAfterLeave={this.afterLeave} name='fade'&gt; &lt;div class='test' onClick={this.onClick} v-show={this.isShow} v-my-directive &gt; { this.test } { this.isShow + '' } &lt;/div&gt; &lt;/transition&gt; ) }}&lt;/script&gt;&lt;style&gt;.fade-enter-active, .fade-leave-active { transition: opacity .5s}.fade-enter, .fade-leave-to { opacity: 0}&lt;/style&gt; 另外还可以使用原生 vNode 的数据格式使用自定义指令 12345const directives = [ { name: 'my-dir', value: 123, modifiers: { abc: true } }] return &lt;div {...{ directives }}/&gt; 简化 Vue 中的 createElement 嵌套写法的函数一般用于创建带有附加元素的组件，比如 Tooltip 等，代码如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 简化 createElement 嵌套写法class VNode { constructor(tag, props = {}, children = []) { // 初始化容器，传递过来的 props 和子元素 this.tag = tag this.props = props this.children = children } // 用于添加子元素 push(vnode) { if (this.isArray(vnode)) { this.children.push(...vnode) } else { if (vnode) { this.children.push(vnode) } } return this } isArray(o) { return Object.prototype.toString.call(o) === '[object Array]' } // 渲染 resolve(h) { var children = this.children.map(child =&gt; { if (child instanceof VNode) { return child.resolve(h) } else { return child } }) return h(this.tag, this.props, children) }}// div.dy-tooltip-popup ==&gt; [div, dy-tooltip-popup]function createElement(tag, props = {}, children = []) { if (tag.indexOf('.') !== -1) { var [realTag, className] = tag.split('.') tag = realTag if (className !== '') { var classList = className.split() if (!props['class']) { props['class'] = {} } classList.forEach(el =&gt; { props['class'][el.trim()] = true }) } } return new VNode(tag, props, children)}export { createElement} 使用方式如下 12345678910111213141516171819import { createElement } from './createElement'// ...render(h) { var $wrapper = createElement('div.dy-tooltip-popup', { style: { top: this.top + 'px', left: this.left + 'px', visibility: this.visibility, opacity: this.opacity }, // 用于标记 Tooltip 弹出方向，这里可以忽略 attrs: { 'x-placement': this.placement } }).push(createElement('div.dy-tooltip-popup-inner', {}, [this.content])) return $wrapper.resolve(h)} 相关示例代码可见 ToolTip 和 Table","link":"/2018/04/29/Vue/02/"},{"title":"Object.create()","text":"Object.create() 是 E5 的一个新特性，其实可以理解为继承一个对象，官方的定义为 Object.create() 方法可以创建一个拥有指定原型和若干个指定属性的对象 它的基本语法为 1Object.create(proto, [ propertiesObject ]) 参数 proto，一个对象，作为新创建对象的原型 propertiesObject，可选，该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符 需要注意的是，该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的 下面我们就来看看如何使用 Object.create() 当中的 propertyObject 参数 参数12345678910111213141516// 创建一个原型为 null 的空对象var o = Object.create(null)// 以字面量方式创建的空对象就相当于var o = Object.create(Object.prototype, { // foo 会成为所创建对象的数据属性 foo: { writable: true, configurable: true, value: 'hello' }, // bar 会成为所创建对象的访问器属性 bar: { configurable: false, get: function () { return 10 }, set: function (value) { console.log(value) } }}) 另外一个示例 12345678910111213141516171819202122232425262728function Constructor() { }o = new Constructor()// 上面的一句就相当于 ==&gt;// 当然，如果在 Constructor 函数中有一些初始化代码，Object.create 不能执行那些代码o = Object.create(Constructor.prototype)// 创建一个以另一个空对象为原型，且拥有一个属性 p 的对象o = Object.create({}, { p: { value: 42 } })// 省略了的属性特性默认为 false，所以属性 p 是不可写，不可枚举，不可配置的o.p = 24o.p// 42o.q = 12for (var prop in o) { console.log(prop)}// 'q'delete o.p// false// 创建一个可写的，可枚举的，可配置的属性 po2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } }) 不过有几个需要注意的地方，第一种情况 12345var a = { x: 1 }var b = Object.create(a)console.log(b) // 输出 { }console.log(b.__proto__) // 输出 { x: 1 } 第二种情况，注意区分 __proto__ 和 prototype 12345// 如果用的是 b = new object(a)connsole.log(b) // 输出 { x: 1 }congsole.log(b.__proto__) // 输出 { } 实例一般来说，Object.create() 的使用还是在继承当中使用较多，下面我们就来看一个使用它来实现类式继承的具体实现 123456789101112131415161718192021222324252627function Foo(name) { this.name = name}Foo.prototype.myName = function () { return this.name}function Bar(name, label) { Foo.call(this, name) this.label = label}// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototypeBar.prototype = Object.create(Foo.prototype)// 现在没有 Bar.prototype.constructor 了，如果你需要这个属性的话可能需要手动修复一下它// Bar.prototype.constructor = BarBar.prototype.myLabel = function () { return this.label}var a = new Bar('a', 'obj a')a.myName() // 'a' a.myLabel() // 'obj a' 这段代码的核心部分就是语句 Bar.prototype = Object.create(Foo.prototype)，调用 Object.create() 会凭空创建一个新对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype），换句话说，这条语句的意思是，创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype 声明函数 Bar() 的时候，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype，因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉，注意下面这两种方式是常见的错误做法，实际上它们都存在一些问题 12345// 和你想要的机制不一样Bar.prototype = Foo.prototype// 基本上满足你的需求，但是可能会产生一些副作用Bar.prototype = new Foo() 第一种情况的 Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象，因此当你执行类似 Bar.prototype.myLabel = ... 的赋值语句时会直接修改 Foo.prototype 对象本身 而第二种情况的 Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象，但是它使用了 new 操作符来进行调用，如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的后代 因此，要创建一个合适的关联对象，我们必须使用 Object.create() 而不是使用具有副作用的 new 操作，这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象 ES6 中的 Object.setPrototypeOf()如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了，在 ES6 之前，我们只能通过设置 .__proto__ 属性来实现，但是这个方法并不是标准并且无法兼容所有浏览器，ES6 添加了辅助函数 Object.setPrototypeOf()，可以用标准并且可靠的方法来修改关联，我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法 12345// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create(Foo.prototype)// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype) 如果忽略掉 Object.create() 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高，不过无论如何，这是两种完全不同的语法 最后我们再来看一种特殊的使用方式，它就是 Object.create(null) Object.create(null)通过 Object.create(null) 创建出来的对象，就没有 Object.prototype 上的一些方法（需要注意与 {} 进行区分），我们可以在控制台进行简单的测试 123{} // {} __proto__: ObjectObject.create(null) // {} No properties 所以并不是所有的对象都继承有 Object.prototype 上的一些方法，看下面代码 12345var obj = Object.create(null)obj.__proto__ // undefinedobj.toString() // obj.toString is not a function Object.create(null) 会创建一个拥有空（或者说 null）[[Prototype]] 链接的对象，这个对象无法进行委托 由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 这些特殊的空 [[Prototype]] 对象通常被称作字典，它们完全不会受到原型链的干扰，因此非常适合用来存储数据，另外一个需要注意的地方，那就是并不是所有的函数对象都会有 prototype 属性，代码如下 123456789function abc() {}abc.prototype // constructor: ƒ abc()var binded = abc.bind(null)typeof binded // 'function'binded.prototype // undefined ==&gt; 需要注意，binded 没有 prototype 属性","link":"/2017/03/03/JavaScript/07/"},{"title":"运算符优先级","text":"在 JavaScript 当中，运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行，在一些看上去比较复杂的运算程序，理清了其中的先后关系后更利于我们得出最后的结果 比如下面这个例子，结果是多少 1var str = 'Hello' + true ? 'World' : 'JavaScript' 最后的结果为 World， 因为 + 运算符优先级是高于条件运算符的，其实就相当于执行了 ('Hello' + true) ? 'World' : 'JavaScript' 优先级看完了开胃菜，我们再来通过一个稍微复杂点的示例来进行深入的了解，如下 1234567891011121314var provider = { test: { $get: function () { return function anonymous(config) { // window console.log(this) } } }}var type = 'test'var config = {}new provider[type].$get()(config) // ? 针对于 new provider[type].$get()(config) 的执行结果，一眼看上去就感觉十分复杂，在理清它的执行顺序之前，我们需要先明确两点 一个是构造函数的返回 另一个是 new 操作符的执行顺序 我们先来理清上面这两点 构造函数的返回简单来说 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象 如果返回的是一个引用类型的值时，返回的是引用对象本身 比如如下示例 12345678910111213function Person() { }const person = new Person()console.log(typeof person) // object// ----function Person() { return function () { }}const person = new Person()console.log(typeof person) // function new 操作符的执行顺序在 MDN 的 new 操作符描述中，语法是 1new constructor[([arguments])] 可以发现，参数 arguments 是可缺省的，那么就意味着，对于不含参数的构造函数而言，new Person() 和 new Person 是一样的，那么又会涉及到一个问题，为什么执行的时候是执行的 new Person()，而不是 (new Person)() 呢，这里就涉及到操作符的执行顺序，这里也只列举几个本章可能涉及到的运算符，更多详细的可以参考 MDN - 运算符优先级 优先级 运算类型 运算符 20 圆括号 () 19 成员访问，new（带参数列表），函数调用 . [] () 18 new（无参数列表） new … 17 后置递增（运算符在后），后置递减（运算符在后） … ++ … -- 16 逻辑非，按位非，一元加法，一元减法，前置递增（运算符在前），前置递减（运算符在前） ! ~ + - ++ … -- … 14 乘法，除法，取模 * / % 13 加法，减法 + - 11 小于，小于等于，大于，大于等于 &lt; &lt;= &gt; &gt;= 10 等号，非等号，全等号，非全等号 == != === !== 6 逻辑与 &amp;&amp; 5 逻辑或 || 4 条件运算符 … ? … : … 3 赋值 = += -= …… 0 逗号 , 了解了原理之后，我们可以很轻松的将上面的问题解析为 12// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用(new provider[type].$get())(config) 实战在了解完运算符优先级以后，我们在来通过一系列的示例来加深一下印象，如下 123456789101112131415161718192021222324252627282930313233function Foo() { getName = function () { console.log('1') } return this}Foo.getName = function () { console.log('2')}Foo.prototype.getName = function () { console.log('3')}var getName = function () { console.log('4')}function getName() { console.log(5)}// 输出结果依次为多少Foo.getName()getName()Foo().getName()getName()new Foo.getName()new Foo().getName()new new Foo().getName()// 结果为 2 4 1 1 2 3 3 一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方 1234567function Foo() { // 注意这里是全局的 getName = function () { console.log('1') } return this} 还有下面这个，两者都会提升，但是函数声明的提升级别是要比 var 高的，所以实际执行的是 12345678function getName() { console.log(5)}// 会覆盖上面的var getName = function () { console.log('4')} Foo.getName()函数 Foo 本身并没有执行，执行的是函数的属性 getName，输出的是 2 getName()这是在全局执行 getName()，根据我们上面的分析可知，输出的结果是 4 Foo().getName()因为 () 的优先级最高，所以首先运行 Foo()，全局的 getName 被覆盖成输出 console.log('1')，并且返回的 this 此时代表的是 window，也就是相当于执行了 window.getName()，所以输出的结果为 1 getName()这个因为之前调用了 Foo()，所以输出的结果仍然是 1 new Foo.getName()因为 . 操作符要比 new 优先级要高，所以执行的是 new (Foo.getName)()，所以输出为 2 new Foo().getName()根据优先级可知，带参数的 new 操作符是优先级最高的，所以执行的就是 (new Foo()).getName()，而 new Foo() 又会生成一个实例对象，但是生成的对象身上没有 getName() 的方法，那么就会去 prototype 当中寻找，所以输出的是 3 new new Foo().getName()老规矩，按照优先级添加括号，首先带参数的 new 操作符优先级最高，则为 new (new Foo()).getName()，然后就会发现和上面是类似的，. 操作符要比 new 优先级要高，所以可以转换为 new ((new Foo()).getName)()，所以输出的也为 3 升级版另外还有一个升级版本，其中的基本原理和上面那个差不多，只需要理清两点即可 一个是构造函数的返回值 另一个是构造函数公有方法和原型链方法的优先级 12345678910111213141516171819202122232425262728293031323334353637383940function Foo() { this.getName = function () { console.log(3) return { getName: getName } } getName = function () { console.log(1) } return this}Foo.getName = function () { console.log(2)}Foo.prototype.getName = function () { console.log(6)}var getName = function () { console.log(4)}function getName() { console.log(5)}Foo.getName() // 2getName() // 4console.log(Foo()) // windowFoo().getName() // 1getName() // 1new Foo.getName() // 2new Foo().getName() // 3new Foo().getName().getName() // 3 1new new Foo().getName() // 3 关于最后两个结果 new Foo().getName().getName()根据之前的结论，其实执行的是 ((new Foo()).getName)().getName()，这里需要注意的是 ((new Foo()).getName) 返回的结果是 123456function () { console.log(3) return { getName: getName }} 然后在进行调用 ((new Foo()).getName)()，所以会输出 3，但是又再次返回了函数内部的一个对象 1234567891011{ getName: getName}// ==&gt;{ getName: function () { console.log(1) }} 然后再次调用这个对象的 getName 方法，所以会再次返回 1 new new Foo().getName()理清楚了上一步的操作，这里就很好理解了，其实调用的是 new ((new Foo()).getName)()，又因为 (new Foo()).getName 返回的是一个函数，就相当于 new 了一个函数，所以输出结果是 3，但是还会返回一个 getName 的对象，跟之前是一样的","link":"/2018/05/27/JavaScript/28/"},{"title":"为什么 Object.keys 的返回值会自动排序","text":"我们先从一个示例开始看起，如下所示 1234567var arr = ['a', 'b', 'c']console.log(Object.keys(arr)) // ['0', '1', '2']// -------------------------------var an_obj = { 100: 'a', 2: 'b', 7: 'c' }console.log(Object.keys(an_obj)) // ['2', '7', '100'] 可以明显的发现，在下面一种的遍历方式当中，结果的顺序被改变了，至于为什么会发生这样的情况，我们需要来看看在 Object.keys() 的调用过程中到底发生了些什么，我们通过查阅 规范 可知，在 Object.keys() 的调用过程中总共有三步流程 调用 ToObject(O) 将结果赋值给变量 obj 调用 EnumerableOwnPropertyNames(obj, key) 将结果赋值给变量 nameList 调用 CreateArrayFromList(nameList) 得到最终的结果 下面我们就分别来看看这三个步骤 ToObject(O)首先第一步是将参数转换成 Object()，根据参数的不同结果有所不同，如下所示 参数类型 结果 undefined 抛出 TypeError null 抛出 TypeError 布尔值 返回一个新的布尔对象 数值 返回一个新的数值对象 字符串 返回一个新的字符串对象 Symbol 返回一个新的 Symbol 对象 Object 直接将 Object 返回 几个示例 12345Object.keys(null) // TypeErrorObject.keys(true) // []Object.keys('abc') // ['0', '1', '2'] EnumerableOwnPropertyNames(obj, key)接下来就是获得属性列表，过程有很多，比较重要的一个是调用对象的内部方法 OwnPropertyKeys 获得对象的 ownKeys，也正是该方法决定了属性的顺序 声明变量 keys 值为一个空列表（List 类型） 把每个 number 类型的属性，按数值大小升序排序，并依次添加到 keys 中 把每个 string 类型的属性，按创建时间升序排序，并依次添加到 keys 中 把每个 Symbol 类型的属性，按创建时间升序排序，并依次添加到 keys 中 将 keys 返回（return keys） 除此之外，还有一点需要补充，如果对象的属性类型是数字，字符与 Symbol 混合的，那么返回顺序永远是数字在前，然后是字符串，最后是 Symbol，不过还有一点需要注意，就是虽然在规范当中规定了 Symbol，但是最终会将 Symbol 类型的属性过滤出去 12345678910111213let s = Symbol()const obj = { [s]: 'd', 7: 'a', a: '7', 10: 'b', b: '10', 44: 'c', c: '44'}Object.keys(obj) // ['7', '10', '44', 'a', 'b', 'c'] CreateArrayFromList(nameList)最后一步就是调用 CreateArrayFromList(nameList) 来得到最终的结果，现在已经得到了一个对象的属性列表，最后一步是将 List 类型的属性列表转换成 Array 类型 先声明一个变量 Array，值是一个空数组 循环属性列表，将每个元素添加到 Array 中 将 Array 返回 一些其他的 API上面介绍的排序规则同样适用于下列 API Object.entries Object.values for-in Object.getOwnPropertyNames Reflect.ownKeys 不过需要注意的是，以上 API 除了 Reflect.ownKeys 之外，其他 API 均会将 Symbol 类型的属性过滤掉 如果想要保证对象遍历的输出顺序，可以将对象转换为数组来进行操作","link":"/2019/03/16/JavaScript/32/"},{"title":"Reflect 对象","text":"Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API 简单来说两点，一个就是将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上，另一个就是让 Object 操作都变成函数行为，因为 ES5 很多 Object 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来），这里只简单的介绍几个常用的方法，详细的可见 ECMAScript 6 入门 和 Reflect - MDN Reflect.apply(target, thisArgument, argumentsList)与 ES5 的 Function.prototype.apply 方法是类似的，比如查找数组中最大数 123456// ES5Math.max.apply(undefined, [1, 2, 3, 4, 5])Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5])// ES6 Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5]) 切割字符串 123456// ES5 'hello world'.slice(2, 8) // 'llo wo'String.prototype.slice.apply('hello world', [2, 8]) // 'llo wo'// ES6 Reflect.apply(String.prototype.slice, 'hello world', [2, 8]) // 'llo wo' Reflect.construct(target, argumentsList[, newTarget])与使用 new target(...args) 方法类似，相当于提供了一种新的不使用 new 来调用构造函数的方法 target 表示被运行的目标函数 argumentsList 调用构造函数传递的参数数组或者伪数组 newTarget 参数为构造函数，表示使用 Reflect.construct 后生成的对象是谁的实例 如果没有传递第三个参数，默认和 target 一样 如果没有传递第三个参数，那么 target 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实例的属性部分（constructor）由第一个参数生成，实例的方法部分由第三个参数生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A1 { constructor(name) { console.log('Class A1 is invoked!') this.name = name } getName() { console.log(this.name) return this.name }}class B1 { constructor(age) { console.log('Class B1 is invoked!') this.age = age } getAge() { console.log(this.age) return this.age }}// 使用 A1 类作为构造函数let a1 = Reflect.construct(A1, ['happy'])// 使用 B1 类作为构造函数let b1 = Reflect.construct(A1, ['happy'], B1)console.log(a1)console.log(b1)// A1 {name: 'happy'}// name: 'happy'// __proto__:// constructor: class A1// getName: ƒ getName()// __proto__: Object// B1 {name: 'happy'}// name: 'happy'// __proto__:// constructor: class B1// getAge: ƒ getAge()// __proto__: Object Reflect.defineProperty(target, propertyKey, attributes)与 Object.defineProperty 相似，不过如果 Object.defineProperty 的属性定义失败了，就会抛出一个错误，而 Reflect.defineProperty 如果定义属性失败的话就会返回 false 123456789let obj = {}let result = Reflect.defineProperty(obj, 'name', { configurable: true, enumerable: true, value: 'happy'})console.log(result) // true Reflect.getPrototypeOf(target)与 Object.getPrototypeOf 方法是一样的，都是返回一个对象的原型，也就是内部的 [[Prototype]] 属性的值，如果要获取原型的那个值不是一个对象，那么函数 Reflect.getPrototypeOf 会抛出一个异常，对于给定对象的原型，如果没有继承的属性，则返回 null Reflect.ownKeys(target)返回由目标对象自身的属性键组成的数组，包括 Symbol 的值 12345678910111213let a = Symbol.for('a')let b = Symbol.for('b')let obj = { [a]: 10, [b]: 20, key1: 30, key2: 40}Object.getOwnPropertyNames(obj) // [ 'key1', 'key2' ]Object.getOwnPropertySymbols(obj) // [ Symbol(a), Symbol(b) ]Reflect.ownKeys(obj) // [ 'key1', 'key2', Symbol(a), Symbol(b) ]","link":"/2017/09/21/JavaScript/43/"},{"title":"正则表达式","text":"今天我们就来简单的复习一下 JavaScript 当中的正则表达式的一些内容，顺便记录记录，关于正则表达式，官网的说法是，正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 模式修饰符参数如下 i，忽略大小写 g，全局匹配 m，多行匹配 /hello/，两个反斜杠是正则表达式的字面量表示法 两个测试方法test123const test = new RegExp('hello world', 'ig')console.log(test.test('hello world')) // true exec返回的是数组，有就返回数组的值，没有返回为 null 12345const test = new RegExp('hello world', 'ig')console.log(test.exec('hello')) // nullconsole.log(test.exec('hello world')) // ['hello world', index: 0, input: 'hello world', groups: undefined] 四个正则表达式方法match(pattern)将所有匹配的字符串组合成数组返回 1234const pattern = /Box/igconst str = 'This is a Box! The is a box!'console.log(str.match(pattern)) // ['Box', 'box'] search(pattern)返回字符串中 pattern 开始位置，『忽略全局匹配』 1234const pattern = /Box/igconst str = 'This is a Box! The is a box!'console.log(str.search(pattern)) // 10 replace(pattern)替换匹配到的字符串 12345const pattern = /Box/igconst str = 'This is a Box! The is a box!'console.log(str.replace(pattern, 'Big box'))// This is a Big box! The is a Big box! split(pattern)返回字符串指定 pattern 拆分数组 12345const pattern = /\\s/igconst str = 'This is a Box! The is a box!'console.log(str.split(pattern))// ['This', 'is', 'a', 'Box!', 'The', 'is', 'a', 'box!'] 匹配模式有下面这些匹配模式 +，其前导字符必须在目标对象中连续出现一次或多次 *，其前导字符必须在目标对象中出现零次或连续多次 ?，其前导对象必须在目标对象中连续出现零次或一次 \\s，用于匹配单个空格符，包括 tab 键和换行符 \\S，用于匹配除单个空格符之外的所有字符 \\d，用于匹配从 0 到 9 的数字 \\w，用于匹配字母，数字或下划线字符 \\W，用于匹配所有与 \\w 不匹配的字符 .，用于匹配除换行符之外的所有字符 ^，定位符，规定匹配模式必须出现在目标字符串的开头（强制首匹配） $，定位符，规定匹配模式必须出现在目标对象的结尾（强制尾匹配，并且只匹配一个） \\b，定位符，规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一 \\B，定位符，则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内，即匹配对象既不能作为目标字符串的开头，也不能作为目标字符串的结尾 /[A-Z]/，与从 A 到 Z 范围内任何一个大写字母相匹配 /[a-z]/，与从 a 到 z 范围内任何一个小写字母相匹配 /[0-9]/，与从 0 到 9 范围内任何一个数字相匹配 /([a-z][A-Z][0-9])+/，与任何由字母和数字组成的字符串，如 aB0 等相匹配 下面是一个示例 1234const pattern = /^[a-z]oogle\\d$/const str = 'aoogle2'console.log(pattern.test(str)) // true 另外还有一些需要注意的地方 可以使用 () 把字符串组合在一起，() 符号包含的内容必须同时出现在目标对象中 如果希望实现类似编程逻辑中的『或』运算，在多个不同的模式中任选一个进行匹配的话，可以使用管道符 | 比如 /to|too|2/，表示与目标对象中的 to、too 或 2 相匹配 还有一个较为常用的否定符 [^]，与之前的定位符 ^ 不同，否定符 [^] 规定目标对象中不能存在模式中所规定的字符串 比如 /[^A-C]/，表示将会与目标对象中除 A，B，和 C 之外的任何字符相匹配 一般来说，当 ^ 出现在 [] 内时就被视做否定运算符，而当 ^ 位于 [] 之外，或没有 [] 时，则应当被视做定位符 12345// 匹配或选择其中某个字符，不是相等，包含的意思const pattern = /baidu|google|bing/const str = 'baidu a google'console.log(pattern.test(str)) // true ES6 中正则表达式的扩展在 ES5 当中，有下面两种情况 情况一第一个参数是字符，第二个是修饰符 1234let regex = new RegExp('xyz', 'i')console.log(regex.test('xyz123')) // trueconsole.log(regex.test('xyZ123')) // true 情况二第一个参数是正则表达式，但是此时不接受第二个参数是一个修饰符，否则会报错 12345let regex2 = new RegExp(/xyz/i) // 正确let regex3 = new RegExp(/xyz/i, 'i') // 错误，Uncaught TypeError: Cannot supply flags when constructing one RegExp console.log(regex2.test('xyz123')) // trueconsole.log(regex2.test('xyZ123')) // true ES6 改变了此行为，第一个参数是正则表达式，第二个参数也可以在指定修饰符 123let regex3 = new RegExp(/abc/ig, 'i')console.log(regex3.flags) // i 在以上示例中，原有正则对象的修饰符是 ig，它会被第二个参数 i 覆盖 常用正则表达式短横变驼峰12345678var f = function (s) { return s.replace(/-\\w/g, function (x) { console.log(x) return x.slice(1).toUpperCase() })}f('border-right-color') 千位分隔符12345678910function commafy(num) { return num &amp;&amp; num .toString() // 也可以使用 /\\B(?=(\\d{3})+$)/g .replace(/(\\d)(?=(\\d{3})+\\.)/g, function ($0, $1) { return $1 + ',' })}commafy(1234567.90) 解析 URL1234567const getURLParameters = url =&gt; (url.match(/([^?=&amp;]+)(=([^&amp;]*))/g) || []).reduce( (a, v) =&gt; ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a), {} )getURLParameters('https://www.baidu.com?id=123&amp;name=zhangsan') 字符串大小写切换12345678function caseConvert(str) { return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2) =&gt; { return `${s1.toUpperCase()}${s2.toLowerCase()}` })}caseConvert('abcdefg')caseConvert('ABCDEFG') 去空格1234str.replace(/\\s*/g, '') //去除字符串内所有的空格str.replace(/^\\s*|\\s*$/g, '') //去除字符串内两头的空格str.replace(/^\\s*/, '') //去除字符串内左侧的空格str.replace(/(\\s*$)/g, '') //去除字符串内右侧的空格 去除所有的 html1var con = content.replace(/&lt;[^&gt;]+&gt;/g,'') 提取括号中的数值1/\\(([^()]+)\\)/g.exec('add(18)') 匹配空行1^[\\s]*\\n 检查邮政编码12345// 共六位数，第一位不能为 0const pattern = /^[1-9]{1}[0-9]{5}$/const str = '430000'console.log(pattern.test(str)) // true 检查压缩包后缀名12345// 文件名（字母_数字）.zip|gz|rarconst pattern = /^[\\w]+\\.(zip|gz|rar)$/const str = 'a12_.zip'console.log(pattern.test(str)) // true 替换标签将模版字符串包裹的内容使用 &lt;code&gt; 标签包裹起来，但是需要注意防止 XSS，所以需要将 &lt;script&gt; 等标签过滤掉 1234567content .replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#039;\") .replace(/`([\\S\\s]+?)`/g, '&lt;code&gt;$1&lt;/code&gt;')","link":"/2019/10/17/JavaScript/47/"},{"title":"为什么要使用依赖注入","text":"前端应用在不断壮大的过程中，内部模块间的依赖可能也会随之越来越复杂，模块间的低复用性导致应用难以维护，不过我们可以借助计算机领域的一些优秀的编程理念来一定程度上解决这些问题 接下来我们要介绍的依赖注入就是其中之一，也是 Angular 当中比较重要的一部分，但是在展开之前我们先来看看 IOC 的概念 IOCIOC 的全称叫做 Inversion of Control，可翻译为为『控制反转』或『依赖倒置』，它主要包含了以下三个准则 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象 抽象不应该依赖于具体实现，具体实现应该依赖于抽象 面向接口编程 而不要面向实现编程 概念总是抽象的，所以下面我们用一个例子来解释上述的概念，假设我们需要构建一款应用叫 App，它包含一个路由模块 Router 和一个页面监控模块 Track，一开始我们可能会这么实现 123456789101112131415161718192021222324252627// app.jsimport Router from './modules/Router'import Track from './modules/Track'class App { constructor(options) { this.options = options this.router = new Router() this.track = new Track() this.init() } init() { window.addEventListener('DOMContentLoaded', () =&gt; { this.router.to('home') this.track.tracking() this.options.onReady() }) }}// index.jsnew App({ onReady() { // ... },}) 看起来似乎没什么问题，但是实际应用中需求是非常多变的，比如需要给路由新增新的功能（比如实现 history 模式）或者更新配置，这样一来就不得不在 App 内部去修改这两个模块，这是一个 INNER BREAKING 的操作，而对于之前测试通过了的 App 来说，也必须重新测试 很明显这不是一个好的应用结构，高层次的模块 App 依赖了两个低层次的模块 Router 和 Track，对低层次模块的修改都会影响高层次的模块 App，那么如何解决这个问题呢？解决方案就是我们接下将要介绍到的依赖注入（Dependency Injection） 使用依赖注入所谓的依赖注入，简单来说就是把高层模块所依赖的模块通过传参的方式把依赖『注入』到模块内部，上面的代码可以通过依赖注入的方式改造成如下方式 123456789101112131415161718192021222324252627282930// app.jsclass App { constructor(options) { this.options = options this.router = options.router this.track = options.track this.init() } init() { window.addEventListener('DOMContentLoaded', () =&gt; { this.router.to('home') this.track.tracking() this.options.onReady() }) }}// index.jsimport App from 'path/to/App'import Router from './modules/Router'import Track from './modules/Track'new App({ router: new Router(), track: new Track(), onReady() { // ... },}) 我们将依赖提升到了入口处的 new App({}) 当中，可以看到，通过依赖注入解决了上面所说的 INNER BREAKING 的问题，这时我们可以直接在 App 外部对各个模块进行修改而不影响内部，但是这样是不是就万事大吉了呢？仔细观察的话，如果我们现在想给 App 添加一个分享模块 Share，那么这样就又回到了之前所提到的 INNER BREAKING 的问题上，也就是我们不得不对 App 模块进行修改加上一行 this.share = options.share，这明显不是我们所期望的 虽然 App 通过依赖注入的方式在一定程度上解耦了与其他几个模块的依赖关系，但是还不够彻底，其中的 this.router 和 this.track 等属性其实都还是对『具体实现』的依赖，明显违背了 IOC 思想的准则，那我们该如何进一步的抽象 App 模块呢？往下看 12345678910111213141516171819class App { static modules = [] constructor(options) { this.options = options this.init() } init() { window.addEventListener('DOMContentLoaded', () =&gt; { this.initModules() this.options.onReady(this) }) } static use(module) { Array.isArray(module) ? module.map(item =&gt; App.use(item)) : App.modules.push(module) } initModules() { App.modules.map(module =&gt; module.init &amp;&amp; typeof module.init == 'function' &amp;&amp; module.init(this)) }} 现在，我们把依赖保存在了 App.modules 属性中，等待后续初始化模块的时候被调用，而 initModules() 方法就是遍历 App.modules 中所有的模块，判断模块是否包含 init 属性且该属性必须是一个函数，如果判断通过的话，该方法就会去执行模块的 init 方法并把 App 的实例 this 传入其中，以便在模块中引用它 从这个方法中可以看出，要实现一个可以被 App.use() 的模块，就必须满足两个『约定』 模块必须包含 init 属性 init 必须是一个函数 这其实就是 IOC 思想中对『面向接口编程，而不要面向实现编程』这一准则的很好的体现，App 不关心模块具体实现了什么，只要满足对接口 init 的『约定』就可以了，下面我们在来看看如何使用 App 来管理我们的依赖，如下 123456789101112131415161718192021222324252627282930313233343536// modules/Router.jsimport Router from 'path/to/Router'export default { init(app) { app.router = new Router(app.options.router) app.router.to('home') }}// modules/Track.jsimport Track from 'path/to/Track'export default { init(app) { app.track = new Track(app.options.track) app.track.tracking() }}// index.jsimport App from 'path/to/App'import Router from './modules/Router'import Track from './modules/Track'App.use([Router, Track])new App({ router: { mode: 'history', }, track: { // ... }, onReady(app) { // ... },}) 可以发现 App 模块在使用上也非常的方便，通过 App.use() 方法来『注入』依赖，在 ./modules/some-module.js 中按照一定的『约定』去初始化相关配置，比如此时需要新增一个 Share 模块的话，无需到 App 内部去修改内容 12345678910111213141516171819202122// modules/Share.jsimport Share from 'path/to/Share'export default { init(app) { app.share = new Share() app.setShare = data =&gt; app.share.setShare(data) }}// index.jsApp.use(Share)new App({ // ... onReady(app) { app.setShare({ title: 'Hello IOC.', description: '', // ... }) }}) 我们只需要直接在 App 外部去 use 这个 Share 模块即可，对模块的注入和配置极为方便，App 模块此时应该称之为『容器』比较合适了，跟业务已经没有任何关系了，它仅仅只是提供了一些方法来辅助管理注入的依赖和控制模块如何执行 简单总结就是控制反转（Inversion of Control）是一种思想，而依赖注入（Dependency Injection）则是这一思想的一种具体实现方式，这里的 App 则是辅助依赖管理的一个容器 在了解完上面的内容以后，下面我们就来看看 Angular 当中的依赖注入是什么样子的 Angular 当中的依赖注入同样的，我们也是通过一个示例开始看起，比如下面这个简单的 Person 类，它依赖于 Id 和 Address 两个类 12345678910111213141516171819202122232425class Id { static getId(type: string): Id { return new Id() }}class Address { constructor(city, street) { }}class Person { id: Id address: Address constructor(id: Id, address: Address) { this.id = id this.address = address }}// 在某个类当中调用的时候main() { const id = Id.getId('123') const address = new Address('北京', '北京') const person = new Person(id, address)} 和我们开头部分介绍的示例十分类似，我们也将依赖提升到了入口处的 main() 当中，但是在当下这种形式中，我们已经知道如果有新的需求变动，我们还是需要去模块的内部来进行修改，下面我们就来看看如何在 Angular 当中来解决这个问题的 在 Angular 的依赖注入中主要有三个概念 Injector，注入者，利用其提供的 API 去创建依赖的实例 Provider，告诉 Injector 如何去创建一个实例（构造这个对象） Object，创建好的对象，也就是当前所处的模块或者组件需要的依赖（某种类型的对象，依赖本身也是一种类型） 在这里我们先不利用 Angular 提供的现成方法，而是借住框架手动的来完善整个依赖注入的流程，最后再来和 Angular 当中提供的原生方法来做一个对比，话不多说，先来改写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import { Component, ReflectiveInjector, Inject } from '@angular/core'import { environment } from '../environments/environment'export class AppComponent { constructor() { // resolveAndCreate() 方法接收一个 provider 数组 // ReflectiveInjector 利用 resolveAndCreate() 方法会根据输入的一个 provider 数组来构建一个可以提供依赖性的池子 // 池子当中含有多个 provider 对象，该对象有两个属性 // 一个为 provide，可以简单的理解为 key/令牌 等，作用是唯一性的一个标识 // 另外一个为类型，类型有多种，比如 useClass, useFactory 等 // 简单来说，池子的作用就是把在这个类中所有想使用的依赖都存放到里面 const injector = ReflectiveInjector.resolveAndCreate([ // 针对于 { provide: Person, useClass: Person }, 这种 useClass 的方式可以直接简写为 Person // 可以直接使用类来去代替，因为本质上就是提供了这个类的构造，key/令牌 也是这个类的本身 Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 注入之后就可以来进行使用了，利用 injector 的 get() 方法来获取 Person 对象 const person = injector.get(Person) console.log(JSON.stringify(person)) }}class Id { static getId(type: string): Id { return new Id() }}class Address { city: string street: string constructor(city, street) { this.city = city this.street = street }}// 依赖 Id 和 Address 两个类class Person { id: Id address: Address // 需要两个依赖性，一个是 Id，一个是 Address // 这里执行的流程就是会去上面的池子当中进行寻找 constructor(@Inject(Id) id, @Inject(Address) address) { this.id = id this.address = address }} 我们使用 resolveAndCreate() 方法根据输入的一个 provider 数组来构建一个可以提供依赖性的池子，而池子的作用就是把在这个类中所有想使用的依赖都存放到里面，这样一来我们在需要使用的地方就可以直接使用 @Inject() 的方式去池子当中寻找我们所需要的依赖 上面就是我们手动的来实现 Angular 当中的依赖注入的流程，但是在绝大部分的情况下，我们并不需要显性的去手写这么一个 provider 对象，因为 Angular 已经帮我们都已经封装好了，并且提供给了我们一些便利，而我们就可以直接利用这些便利来完成上面这样复杂的操作 使用依赖注入下面我们就来看看如何在项目当中使用 Angular 提供的 provider 123456789101112131415// 一个公共模块// 在 @NgModule 当中注入 BASE_CONFIG 这个静态变量@NgModule({ // ... providers: [ { provide: 'BASE_CONFIG', useValue: 'http://localhost:3000'} ]})// 使用import { Inject } from '@angular/core'constructor(@Inject('BASE_CONFIG') config) { console.log(config)} 我们在 Module 或者 Component 当中，只需要在 providers 数组当中提供这个 provide 对象，Angular 便会自动的帮我们注册到 Inject 这个池子当中，所以在我们使用过程当中，只需要在 constructor 当中使用 @Inject() 注入进来即可，但是需要注意的一点就是，我们这样操作的话，在池子当中取的数据都是单例的，如果想要每次取的都是一个新的实例的话，比如之前的实例，只需在此基础上稍作调整，让其返回一个函数即可 12345678910111213141516171819202122232425export class AppComponent { constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { // 修改这里 return () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) const person = injector.get(Person) console.log(JSON.stringify(person)) }} 这是一种方式，另外一种方式就是利用父子传递的概念，这种情况一般使用较少，可以考虑使用返回一个函数的方式 12345678910111213141516171819202122232425262728constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 创建一个子注入者，传入 Person // 这里有一点需要注意，在创建子注入者的时候，我们仅仅只传入了 Person，并没有传入 Id 和 Address // 这里的情况是 当在子池子中找不到的情况下就回去父池子当中进行查找 const childInjector = injector.resolveAndCreateChild([Person]) const personFromChild = childInjector.get(Person) const person = injector.get(Person) console.log(person === personFromChild) // false} 以上就是 Angular 当中的依赖注入简单的使用方式，我们通过一个基本的示例了解了为什么要使用依赖注入，再到引出 Angular 当中的依赖注入，但是 Angular 当中的依赖注入的内容远远不止上文介绍到的这些，所以我们会在下一部分 Angular 中的依赖注入 来深入的了解 Angular 当中的依赖注入","link":"/2018/12/14/Angular/02/"},{"title":"Angular-CLI 与其整体架构","text":"因为年后公司项目转向 Angular 架构了，所以只有暂时性的放下 Vue 和 React 相关内容，转向 Angular 方向了，俗话说得好，技多不压身，就当学习一门新的框架了，那么废话不多说，让我们从头开始，慢慢来啃 Angular 这块硬骨头吧 Angular 在 2.x 之后的版本中相较与 1.x 的版本变化很多，说其为两个不同的框架也不为过，并且在新的版本当中，提供了一个 Angular-CLI 的脚手架，用于实现自动化开发工作流程，它可以创建一个新的 Angular 应用程序，并附带以下相关工具 运行带有 LiveReload 支持的开发服务器，以便在开发过程中预览应用程序 添加功能到现有的 Angular 应用程序（提供了一系列 ng xxx 相关命令） 运行应用程序的单元测试 运行应用程序的端到端（E2E）测试 构建应用程序 那么就先从最基本的 Angular-CLI 生成的目录结构以及相关初始化入口文件开始 Angular-CLI 目录结构12345678910111213141516171819202122232425262728293031323334353637├── e2e // ==&gt; 端到端│ ├── app.e2e-spec.ts // ==&gt; 端到端测试文件│ ├── app.po.ts // ==&gt; 端到端测试入口文件│ └── tsconfig.e2e.json // ==&gt; 用于端到端测试的 typescript 编译器的配置文件├── node_modules // ==&gt; 第三方依赖包├── src // ==&gt; 项目主文件所在目录│ ├── app // ==&gt; 组件所在文件夹│ │ ├── app.component.css // ==&gt; 组件的样式文件│ │ ├── app.component.html // ==&gt; 组件的 HTML 模板文件│ │ ├── app.component.spec.ts // ==&gt; 组件的单元测试文件│ │ ├── app.component.ts // ==&gt; 组件定义文件│ │ └── app.module.ts // ==&gt; 模块定义配置文件│ ├── assets // ==&gt; 静态资源│ │ └── .gitkeep // ==&gt; assets 目录用于存放图片等静态资源文件，构建时会拷贝到发布包里，新创建时一般为空│ │ // ==&gt; 但是由于 git 会忽略空文件夹，放置 .gitkeep 这个空文件以保证目录得到管理│ ├── environments // ==&gt; 环境│ │ ├── environment.prod.ts // ==&gt; 生产环境配置文件，在 .angular-cli.json 中被 mapping，mapping 值为 prod│ │ └── environment.ts // ==&gt; 开发环境配置，在 .angular-cli.json 中被 mapping，mapping 值为 dev│ ├── favicon.ico // ==&gt; 网页左上角显示的图标│ ├── index.html // ==&gt; 项目主页│ ├── main.ts // ==&gt; Angular 程序的入口│ ├── polyfills.ts // ==&gt; 不同浏览器，比如一些老旧的浏览器及版本的支持│ ├── styles.css // ==&gt; 全局的样式│ ├── test.ts // ==&gt; 单元测试入口│ ├── tsconfig.app.json // ==&gt; Angular 应用的 typescript 编译器的配置文件│ ├── tsconfig.spec.json // ==&gt; 单元测试的 typescirpt 编译器的配置文件│ ├── tsconfig.app.json // ==&gt; Angular 应用的 typescript 编译器的配置文件│ └── typings.d.ts // ==&gt; 项目中使用的 typescript 类型的引用文件├── .angular-cli.json // ==&gt; CLI 的配置文件，可以设定项目的基础信息，比如构建后的目标目录名称等├── .editorconfig // ==&gt; 编辑器的配置文件├── .gitignore // ==&gt; 为了保证自动生成的文件不被提交的 git 配置文件├── karma.conf.js // ==&gt; karma 单元测试的配置文件├── package.json // ==&gt; npm 的配置文件以及第三方依赖包├── protractor.conf.js // ==&gt; protractor 的端到端测试的配置文件├── README.md // ==&gt; 项目的基本信息，主要包含使用 cli 命令如何对项目进行 构建/测试/运行 等├── tsconfig.json // ==&gt; typescirpt 编译器的配置文件└── tslint.json // ==&gt; 提供给 TSLint 和 Codelyzer 的配置信息 以上就是使用 Angular-CLI 默认生成的文件结构，下面我们来梳理一下一个 Angular 应用的整体架构 整体架构整体架构可以如下图所示 Angular 使用扩展语法编写 HTML 模版，使用组件对其进行管理，通过服务来添加应用逻辑，最后使用模块来对组件进行打包，通过引导根模块来启动应用，Angular 在浏览器中接管、展现应用的内容，根据操作指令响应用户的交互，Angular 的架构主要分为四大块 组件，Angular 应用的基本构件块，可以简单的理解为一个组件就是一段带有业务逻辑和数据的 HTML 指令，允许向 HTML 元素添加自定义行为 模块，模块用来将应用中不同的部分组织成一个 Angular 框架可以理解的单元（组件） 服务，用来封装可从用的业务逻辑 而整个启动过程是通过引导模块来进行的，每个 Angular 应用至少应该有一个模块，而此模块被称为根模块（App Module） 根模块 @NgModule 装饰器所谓的根模块，也就是我们的 app.module.ts 文件，如下所示 12345678910111213141516171819202122232425262728import { BrowserModule } from '@angular/platform-browser'import { NgModule } from '@angular/core'import { AppComponent } from './app.component'// @NgModule 装饰器用来为模块定义元数据@NgModule({ // declarations 列出了应用中的顶层组件，包括引导性组件 AppComponent 和我们自己创建的组件 // 在 module 里面声明的组件在 module 范围内都可以直接使用 // 也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件 declarations: [ AppComponent, ... ], // 引入相关依赖 // BrowserModule 提供了运行在浏览器中的应用所需要的关键服务（Service）和指令（Directive） // 这个模块所有需要在浏览器中跑的应用都必须引用 imports: [ BrowserModule ], // providers 列出会在此模块中 \"注入\" 的服务（Service） providers: [], // bootstrap 指明哪个组件为引导性组件（默认的是 AppComponent） // 当 Angular 引导应用时，它会在 DOM 中渲染这个引导性组件 // 并把结果放进 index.html 的该组件的元素标签中（默认为 app-root） bootstrap: [AppComponent]})export class AppModule { } 而根模块在 Angular 程序的入口 main.ts 中被使用，也就是所谓的引导过程，Angular 通过在 main.ts 中引导 AppModule 来启动应用，但是针对不同的平台 Angular 提供了很多引导选项，默认的采用是即时（JIT）编译器动态引导，一般多用在进行开发调试的时候 12345678910111213141516// main.ts// 连同 Angular 编译器一起发布到浏览器import { enableProdMode } from '@angular/core'import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'import { AppModule } from './app/app.module'import { environment } from './environments/environment'if (environment.production) { enableProdMode()}// 对 AppModule 进行引导// Angular 编译器在浏览器中编译并引导该应用platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)) 另一种方式是使用预编译器（AoT - Ahead-Of-Time）进行静态引导，静态方案可以生成更小、启动更快的应用，建议优先使用它，特别是在移动设备或高延迟网络下，使用 static 选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂，它们的核心就是 AppModuleNgFactory，引导预编译的 AppModuleNgFactory 的语法和动态引导 AppModule 类的方式很相似 12345678// 不把编译器发布到浏览器import { platformBrowser } from '@angular/platform-browser'// 静态编译器会生成一个 AppModule 的工厂 AppModuleNgFactoryimport { AppModuleNgFactory } from './app.module.ngfactory'// 引导 AppModuleNgFactoryplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory) 模块化Anagulr 应用是模块化的，被称为 NgModule，@NgModule 是一个装饰器，装饰器其实是函数，是用来装饰函数，它可以把元数据附加到类上，NgModule 装饰器用来描述模块属性，常见的模块属性如下所示 属性 说明 declarations 声明本模块中拥有的视图类，Angular 有三种视图类，即组件，指令和管道 exports declarations 的子集，可用于其他模块的组件模版 imports 本模块声明的组件模板需要的类所在的其他模块 providers 服务的创建者，并加入到全局服务列表中，可用于应用任何部分 bootstrap 指定应用的主视图（根组件），它是所有其他视图的宿主 这里有两个地方需要注意 exports 属性并不是必须的，因为其他组件无需导入根模块，所以根模块也不需要导出 只有根模块才能设置 bootstrap 属性 组件和 @NgModule 类似，@Component 为 Angular 的组件装饰器，主要属性如下 属性 说明 selector CSS 选择器，它告诉 Angular 在父级 HTML 中查找 selector 中定义的标签，创建并插入该组件 template/templateUrl 组件或者组件 HTML 模块的相对地址 providers 组件所需服务的依赖注入提供商数组，这是在告诉 Angular 该组件的构造函数可能需要一个服务，这样组件就可以从服务中获得数据 在根模块的 bootstrap 属性中设定了 AppComponent 组件，说明根模块引导的为 AppComponent 组件 1234567891011import { Component } from '@angular/core'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'Angular Examples'} 装饰器 @Component 将三个东西结合在了一起，selector 和 HTML 模板以及 CSS 样式 通过插值的方式保证数据进行交互和传递 通过修改填充的内容则可以直接影响输出 通过 CSS 样式直接调整显示，做到数据和显示的分离 这也就是整体 Angular 程序的启动过程，不过特别需要注意的是 当组件编写完成后还需要进行组件声明后才能使用，每个组件都必须在一个 Angular 模块而且只能在一个 Angular 模块中进行声明","link":"/2018/12/12/Angular/01/"},{"title":"Angular 中的装饰器","text":"Angular 中的装饰器可以简单的总结为以下几句 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 它分为一下四类 类装饰器 （Class decorators） 属性装饰器 （Property decorators） 方法装饰器 （Method decorators） 参数装饰器 （Parameter decorators） TypeScript 中的装饰器先来了解一下 TypeScript 当中的装饰器，它们有以下这些 1234567891011121314151617181920// 类装饰器，用来装饰类的，它接收一个参数// target: TFunction，被装饰的类declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void// 属性装饰器，用来装饰类的属性，它接收两个参数// target: Object，被装饰的类// propertyKey: string | symbol，被装饰类的属性名declare type PropertyDecorator = (target:Object, propertyKey: string | symbol ) =&gt; void// 方法装饰器，用来装饰类的属性，它接收三个参数// target: Object，被装饰的类// propertyKey: string | symbol，方法名// descriptor: TypePropertyDescript，属性描述符declare type MethodDecorator = &lt;T&gt;(target:Object, propertyKey: string | symbol, descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void// 参数装饰器，用来装饰函数参数，它接收三个参数// target: Object，被装饰的类// propertyKey: string | symbol，方法名// parameterIndex: number，方法中参数的索引值declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number ) =&gt; void Angular 内置装饰器在 Angular 当中已经为我们内置了一些装饰器，如下 类装饰器：@Component，@NgModule，@Pipe，@Injectable 属性装饰器：@Input，@Output，@ContentChild，@ContentChildren，@ViewChild，@ViewChildren 方法装饰器：@HostListener，@HostBinding 参数装饰器：@Inject，@Optional，@Self，@SkipSelf，@Host 有些是默认生成组件的时候就自带了的，有的使用频率也较低，所以我们在这里主要介绍 @Input，@Output，@ViewChild，@ViewChildren，@HostListener 和 @HostBinding 六种 InputInput 是属性装饰器，用来定义组件内的输入属性，一般用来实现父组件向子组件传递数据 @Input()123456789101112131415161718192021222324252627282930313233343536// counter.component.tsimport { Component, Input } from '@angular/core'@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0 increment() { this.count++ } decrement() { this.count-- }}// app.component.tsimport { Component } from '@angular/core'@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5} @Input(bindingPropertyName)Input 装饰器支持一个可选的参数，用来指定组件绑定属性的名称，如果没有指定，则默认使用 @Input 装饰器装饰的属性名，如下所示 12345678910111213// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0}// app.component.ts@Component({ selector: 'exe-app', // 绑定的时候如果写成 [value]，那么在 @Input() 接收的时候指定为 value 即可 template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `}) inputs另外还可以使用 inputs 属性将绑定的输入属性名称直接写到 @Component({}) 的元数据当中 12345678910111213141516171819// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0}// app.component.ts@Component({ selector: 'exe-app', template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `, // 如果模版当中指定的为 [count]=\"initialCount\" // 可以直接写为 inputs: ['count'] inputs: ['count: value']})export class CounterComponent { count: number = 0} 不过需要注意的是，不能同时使用 @Input 装饰器，或在 @Directive、@Component inputs 字段中定义同一个输入属性 123456789// 错误的使用方式@Component({ selector: 'exe-counter', inputs:['count: value'] })export class CounterComponent { @Input('value') count: number = 0} @Input 和 inputs 两者的区别它们都是用来定义输入属性，而不同的地方在于 inputs 定义在指令的 metadata 信息中，开发者对指令的输入属性一目了然 此外对于未选用 TypeScript 作为开发语言的开发者，也只能在 metadata 中定义指令的输入属性 @Input 属于属性装饰器，通过它可以一起定义属性的访问描述符（public、private、protected） 1@Input() public attr: string @Output 与其类似 1@Output('countChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;() setter &amp; gettersetter 和 getter 是用来约束属性的设置和获取，它们提供了一些属性读写的封装，可以让代码更便捷，更具可扩展性，通过 setter 和 getter 方式，我们对类中的私有属性进行了封装，能避免外界操作影响到该私有属性 123456789101112131415161718192021222324252627282930313233import { Component, Input } from '@angular/core'@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }} &lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { _count: number = 0 biggerThanTen: boolean = false @Input() set count (num: number) { this.biggerThanTen = num &gt; 10 this._count = num } get count(): number { return this._count } increment() { this.count++ } decrement() { this.count-- }} OutputOutput 是属性装饰器，用来定义组件内的输出属性，主要用来实现子组件将信息通过事件的形式通知到父级组件 EventEmitterOutput 属性装饰器一般是和 EventEmitter 一起相互配合来使用的，先看 EventEmitter 12345let numberEmitter: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;()numberEmitter.subscribe((v: number) =&gt; console.log(v))numberEmitter.emit(10) 具体的应用流程为 子指令创建一个 EventEmitter 实例，并将其作为输出属性导出 子指令调用已创建的 EventEmitter 实例中的 emit(payload) 方法来触发一个事件 而父指令通过事件绑定（eventName）的方式监听该事件，并通过 $event 对象来获取 payload 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// counter.component.tsimport { Component, Input, Output, EventEmitter } from '@angular/core'@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0 @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;() increment() { this.count++ this.change.emit(this.count) } decrement() { this.count-- this.change.emit(this.count) }}// app.component.tsimport { Component } from '@angular/core'@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\" (change)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5 countChange(ev: number) { console.log(ev) }} @Output(bindingPropertyName)同 @Input 一样，@Output 装饰器支持一个可选的参数，用来指定组件绑定属性的名称，如果没有指定，则默认使用 @Output 装饰器，装饰的属性名 12345678910111213// counter.component.tsexport class CounterComponent { @Output('counterChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;()}// app.component.ts@Component({ template: ` &lt;exe-counter [count]=\"initialCount\" (counterChange)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `}) outputs同 inputs 一样，也支持在组建内部添加 outputs 属性，但是和上面一样不太推荐这种写法，所以在这里也不过多的进行介绍了 ngOnChanges当数据绑定输入属性的值发生变化的时候，Angular 将会主动调用 ngOnChanges 方法，它会获得一个 SimpleChanges 对象，包含绑定属性的新值和旧值，它主要用于监测组件输入属性的变化 1234567891011121314151617181920212223242526import { Component, Input, SimpleChanges, OnChanges } from '@angular/core'@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent implements OnChanges{ @Input() count: number = 0 ngOnChanges(changes: SimpleChanges) { console.dir(changes['count']) } increment() { this.count++ } decrement() { this.count-- }} 可以在控制台当中看到 SimpleChanges 对象的一些值（包括新值和旧值） 需要注意的是，当手动改变输入属性的值，是不会触发 ngOnChanges 钩子的 @ViewChild()通过 @ViewChild() 装饰器可以获得子组件的引用，从而可以在父组件当中来直接调用子组件的方法 12// 父组件&lt;app-header #child1&gt;&lt;/app-header&gt; 12345678910111213141516171819export class AppComponent implements OnInit{ @ViewChild('child1') child1: HeaderComponent ngOnInit() { this.child1.run('...') }}// 子组件export class HeaderComponent implements OnInit { constructor() { } ngOnInit() { } run(name) { console.log(name) }} @ViewChild 使用类型查询1234567891011121314151617181920212223242526272829303132333435// child.component.tsimport { Component, OnInit } from '@angular/core'@Component({ selector: 'exe-child', template: ` &lt;p&gt;Child Component&lt;/p&gt; `})export class ChildComponent { name: string = 'child-component'}// app.component.tsimport { Component, ViewChild, AfterViewInit } from '@angular/core'import { ChildComponent } from './child.component'@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { // 通过 @ViewChild() 来获取子组件 @ViewChild(ChildComponent) childCmp: ChildComponent ngAfterViewInit() { console.dir(this.childCmp) }} ViewChildrenViewChildren 用来从模版视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 123456789101112131415161718192021import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core'import { ChildComponent } from './child.component'@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { @ViewChildren(ChildComponent) childCmps: QueryList&lt;ChildComponent&gt; ngAfterViewInit() { console.dir(this.childCmps) }} 运行之后可以在控制台当中看到输出多个 ChildComponent 小结 ViewChild 装饰器用于获取模板视图中的元素，它支持 Type 类型或字符类型的选择器，同时支持设置 read 查询条件，以获取不同类型的实例 ViewChildren 装饰器是用来从模板视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 HostListener &amp; HostBinding在介绍 HostListener 和 HostBinding 属性装饰器之前，我们可以先来了解一下 Host Element（宿主元素），宿主元素的概念同时适用于指令和组件，对于指令来说，应用指令的元素就是『宿主元素』，而如果在自定义组件中使用的话，那么自定义组件就是宿主元素 HostListenerHostListener 是属性装饰器，用来为宿主元素添加事件监听，HostListenerDecorator 装饰器定义如下 1234export interface HostListenerDecorator { (eventName: string, args?: string[]): any new (eventName: string, args?: string[]): any} 使用 1234567891011121314import { Directive, HostListener } from '@angular/core'@Directive({ selector: 'onClicks'})export class onClicks { @HostListener('click') onClick() { // ... }} 此外还可以监听宿主元素外，其他对象产生的事件，比如 window 或 document 对象，一个点击目标区域会添加背景颜色，点击其他区域取消掉高亮 1234567891011121314151617181920export class SetBackgroundDirective { constructor( private el: ElementRef, private re: Renderer2 ) {} @HostListener('document:click', ['$event']) onClick(btn: Event) { if (this.el.nativeElement.contains(event.target)) { this.highlight('yellow') } else { this.highlight(null) } } highlight(color: string) { this.re.setStyle(this.el.nativeElement, 'backgroundColor', color) }} Host Event Listener还可以使用 host 参数来进行绑定（不太建议使用这种方式，推荐使用装饰器风格） 123456789101112131415import { Directive } from '@angular/core'@Directive({ selector: 'button[counting]', host: { '(click)': 'onClick($event.target)' }})export class CountClicks { numberOfClicks = 0 onClick(btn: HTMLElement) { console.log('button', btn, 'number of clicks:', this.numberOfClicks++) }} HostBindingHostBinding 是属性装饰器，用来动态设置宿主元素的属性值，定义如下 1234export interface HostBindingDecorator { (hostPropertyName?: string): any new (hostPropertyName?: string): any} 应用 123456789101112131415161718@Directive({ selector: '[exeButtonPress]'})export class ExeButtonPress { @HostBinding('attr.data') data = 'button' @HostBinding('class.active') isActive: boolean @HostListener('mouseenter') enter() { this.isActive = true } @HostListener('mouseleave') leave() { this.isActive = false }} 和上面一样，我们也可以在指令的元数据当中来进行绑定（同样的不建议这样使用） 123456789101112131415161718192021@Directive({ selector: '[exeButtonPress]', host: { 'data': 'button', '[class.active]': 'isActive' }})export class ExeButtonPress { isActive: boolean @HostListener('mouseenter') enter() { this.isActive = true } @HostListener('mouseleave') leave() { this.isActive = false }}","link":"/2018/01/19/Angular/05/"},{"title":"Angular 中的 ExpressionChangedAfterItHasBeenCheckedError","text":"最近在开发过程中，遇到了 ExpressionChangedAfterItHasBeenCheckedError 这个错误，网上搜索一翻后，发现各种说法众说纷纭，所有抽出时间深入了解一下这个错误，做一下总结，也可以避免以后在遇到这个问题的时候不知道怎么处理 简单来说，这个错误主要涉及到 Angular 的变化监测机制，不过关于 Angular 中的变化监测机制到底是什么样的可以参考 Angular 中的变化检测机制 这篇文章，本章主要介绍的是如何解决和避免 ExpressionChangedAfterItHasBeenCheckedError 这个错误 Angular 中的变化监测机制在 Angular 当中，每个 Angular 应用都是以组件树的形态呈现的，Angular 在变化监测阶段会按以下的顺序对每个组件执行如下操作（标记为 List1） 更新所有绑定在子 component/directive 上的属性 调用所有子 component/directive 的 ngOnInit，ngOnChanges，ngDoCheck 生命周期函数 解析、更新当前组件 DOM 上的 value 运行子 component 的变化监测流程（List1） 调用所有子 component/directive 上的 ngAfterViewInit 生命周期 这里需要注意，在每一步操作之后，Angular 都会保存与这次操作有关的 values 值，这个值被存在组件 view 的 oldValues 属性中，在开发模式下，所有组件完成变化监测之后 Angular 会开始下一个监测流程，第二次监测流程并不会再次执行上面列出的变化监测流程，而会比较之前变化监测循环保存的值（存在 oldValues 中的）与当前监测流程的值是否一致（标记为 List2） 检查被传递到子组件的 values（oldValues）与当前组件要被用于更新的 values（instance.value）是否一致 检查被用于更新 DOM 元素的 values（oldValues）与当前要被用于这些组件更新的 values（instance.value）是否一致 对所有子 component 执行相同的检查 需要注意的是，这些额外的检查（List2）只发生在开发模式下 出现原因接下来我们来看一个例子，假设你有一个父组件 A 和一个子组件 B，A 组件中有两个属性 name 和 text，A 组件的模板中使用了 name 属性 1template: '&lt;span&gt;{{name}}&lt;/span&gt;' 然后在模板中加入 B 组件，并且通过输入属性绑定给 B 组件输入 text 属性 12345678910111213// A 组件当中使用 B 组件@Component({ selector: 'a-comp', template: ` &lt;span&gt;{{name}}&lt;/span&gt; &lt;b-comp [text]=\"text\"&gt;&lt;/b-comp&gt; `})export class AComponent { name = 'I am A component' text = 'A message for the child component'} 那么 Angular 在开始变化监测后会发生什么呢？按照上面的流程，List1 变化监测会从 A 组件开始检查，第一步将 text 表达式中的 A message for the child component 向下传递到 B 组件，并且将这个值存在 view 上 1view.oldValues[0] = 'A message for the child component' 然后到了变化监测列表里的第二步，调用相应的生命周期函数，接下来再执行第三步，将 name 表达式解析为 I am A component 文本，将解析好的值更新到 DOM 上，并且存入 oldValues 1view.oldValues[1] = 'I am A component' 最后 Angular 对 B 组件执行相同的操作（List1），一旦 B 组件完成以上的操作，此次变化监测循环便完成了，但是如果 Angular 在开发模式下运行，那么将会执行另一个监测流程（List2），text 属性在传递给 B 组件时的值是 A message for the child component 并存入 oldValues ，现在想象一下 A 组件在此之后将 text 的值更新为 updated text，然后 List2 的第一步将会检查 text 属性是否被改变 12AComponentView.instance.text === view.oldValues[0] // false'updated text' === 'A message for the child component' // false 这个时候 Angular 就该抛出这个错误了 1Angular Debugging \"Expression has changed after it was checked\": Simple Explanation (and Fix) 同理，如果更新已经被渲染在 DOM 中并且被存在 oldValues 中的 name 属性，也会抛出相同的错误 12AComponentView.instance.name === view.oldValues[1] // false'updated name' === 'I am A component' // false 现在你可能会有些疑惑，这些值怎么会被改变呢？ 数据改变的原因引起这个错误的罪魁祸首一般都是子组件或指令，下面我们来详细的看一下之前的示例，我们将在子组件的 ngOnInit（此时数据已绑定）生命周期钩子中更新 text 属性 12345678910// B 组件export class BComponent { @Input() text constructor(private parent: AppComponent) { } ngOnInit() { this.parent.text = 'updated text' }} 我们可以看到预期的错误 123Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'A message for the child component'. Current value: 'updated text'. 现在我们对被用于父组件模板的 name 属性做相同的操作 123ngOnInit() { this.parent.name = 'updated name'} 这时候程序并没有报错，为什么会这样呢？如果你仔细看变化监测（List1）的执行顺序，你会发现子组件的 ngOnInit 将在当前 component 的 DOM 更新之前被调用（在记录 oldValues 前改变了数据），这就是为什么上面的例子中更改 name 属性却不会报错，然后我们来利用一个在 DOM 中 values 更新之后的钩子来做实验，比如 ngAfterViewInit 123456789export class BComponent { @Input() text constructor(private parent: AppComponent) {} ngAfterViewInit() { this.parent.name = 'updated name' }} 我们又一次得到了预期的错误 123AppComponent.ngfactory.js:8 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'I am A component'. Current value: 'updated name'. 当然现实中遇到的情况会更加错综复杂，父组件中属性在二次监测之前被更新通常是使用的外部服务或 observabals 间接导致的，但是其本质原因是相同的 可行解决方案如果你 google 过这个错误，那么你应该看过一些回答推荐使用异步更新数据和强制增加一个变化监测循环两种方法来解决这个错误，比如在动态创建组件的情况下，解决这个问题最好的方案是改变创建组件时所处的生命周期钩子，虽然这两种方式都可以解决问题，但是还是更推荐重新设计你的应用而不是使用这两种方法来解决这个问题 异步更新你应该注意到一件事，不管是变化监测还是第二次的验证 digest 都是同步执行的，这意味着如果我们在代码中异步更新属性的值，那么在第二次验证循环运行时这些属性是不会被改变的，那么也就不会报错了 123456789101112131415161718export class BComponent { name = 'I am B component' @Input() text constructor(private parent: AppComponent) {} ngOnInit() { setTimeout(() =&gt; { this.parent.text = 'updated text' }) } ngAfterViewInit() { setTimeout(() =&gt; { this.parent.name = 'updated name' }) }} 确实没有错误抛出，setTimeout 将函数加入 Macrotask 队列中，函数会在下一个 VM 周期里被调用，也可以通过使用 Promise 里的 then 回调将函数加入当前 VM 周期其他同步代码被执行完之后 1Promise.resolve(null).then(() =&gt; this.parent.name = 'updated name') Promise.then 并不会被放入 Macrotask，而是创建一个 Microtask，Microtask 队列将在当前周期中所有同步代码被执行完毕之后执行，因此属性的更新会发生在验证步骤之后 另外补充一个知识点，给 EventEmitter 传一个 true 能使事件的 emit 变为异步 1new EventEmitter(true) 强制变化监测另一个解决方案是在父组件 A 的第一和第二次验证之间强制加一个变化监测循环，触发强制变化监测的最佳位置是在 ngAfterViewInit 生命周期内，这时候所有的子组件的流程都已经执行完毕，所以随便在之前的哪个位置改变父组件的属性都无所谓 12345678910export class AppComponent { name = 'I am A component' text = 'A message for the child component' constructor(private cd: ChangeDetectorRef) { } ngAfterViewInit() { this.cd.detectChanges() }} 一样没有报错，但是其实这里有个问题，当在父组件 A 中触发新添加的变化监测时，Anuglar 同样会为所有的子组件运行一次变化监测，那么父组件可能会被又一次更新 为什么需要第二次监测循环Angular 强制使用至上而下的单向数据流，在父元素完成变化监测之后不允许内部子组件在第二次变化监测前改变父组件的属性，这能确保第一次变化监测后的组件树是稳定的，如果在监测循环周期里有属性的改变导致依赖这些属性的使用者需要同步更新变化，那么这棵组件树就是不稳定的，上面例子中子组件 B 依赖父组件的 text 属性，每当属性的值改变，在这些改变被传递到 B 组件之前这棵组件树都处于不稳定的状态 这同样体现在 DOM 与属性之间的关系上，DOM 作为这些属性的使用者，然后将这些属性渲染到 UI 界面上，如果某些属性没有同步更新到界面上，用户将会看到错误的界面，所以如果你在数据同步过程完成之后再通过子组件修改父组件中的属性会发生什么呢？是的，你留下了一个不稳定的组件树，其中数据变更的顺序将无法预测，大部分时候这将会给用户呈现出一个有错误数据的页面，而且问题的排查将十分困难 可能你会问了，那为什么不等到组件树稳定之后再进行变化监测呢？ 答案很简单，组件树可能永远不会稳定下来，一个子组件更新了父组件中的属性，父组件的属性又更新子组件的状态，子组件状态的更新又触发更新父组件的属性…，这将是个无限循环，之前展示了很多组件对属性直接更新或依赖的情况，但实际中的应用对属性的更新和依赖通常是间接，不易排查的 最后一个问题是，为什么第二次循环监测只在开发模式下运行？ 猜想这是因为数据层不稳定在框架运行时并不会产生引人关注的错误，毕竟数据在下一次监测循环后就会稳定下来，当然，在开发时期将可能得错误解决总好过在上线后的应用中排查错误 示例一，共享服务示例见 共享服务 这个应用中父组件和子组件共用一个共享服务，子元素通过共享服务设置一个属性的值并反映到父元素上，这个模式下子元素改变父元素的值的方式并不像上面简单例子中那么显而易见，是间接更新了父元素的属性 示例二，同步事件广播示例见 同步事件广播 这个应用中父元素监听一个子元素广播的事件，这个事件导致父元素的属性被更新，这个属性又被用于子元素的 Input 绑定，这同样间接更新了父元素的属性 示例三：动态的组件实例化示例见 动态的组件实例化 这种模式与之前两种模式略有不同，前两种模式都是 List2 中的第一步检测抛出的错误，而这种模式是由 DOM 更新检测（List2 第二步）抛出的错误，这个应用中父组件在 ngAfterViewInit 生命周期中动态添加子组件，该生命周期发生在当前组件 DOM 初次更新之后，而添加子组件将会修改 DOM 结构，那么前后两次 DOM 中所使用的 values 值就不同了（前提是子组件带有新的 value 引用），所以抛出了错误 解决这个问题最好的方案是改变创建组件时所处的生命周期钩子，动态创建组件的流程就可以被移到 ngOnInit 中，即使文档中说明了 ViewChildren 只能在 ngAfterViewInit 之后被获取到，但是创建视图时就在填充子组件了，所以能提前获取 ViewChildren 参考 ExpressionChangedAfterItHasBeenCheckedError ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked on ng 4 Everything you need to know about change detection in Angular","link":"/2019/03/11/Angular/07/"},{"title":"Web Components 与 Angular Component","text":"关于组件的概念，现在使用已经很广泛了，我们今天就来深入的了解一下 Web Components 与 Angular 当中的 Component Web ComponentsW3C 为统一组件化标准方式，提出 Web Components 的标准，它允许我们创建可重用的定制元素（它们的功能封装在代码之外）并且在 Web 应用中使用它们，Web Components 标准主要包括以下几个重要的概念 Custom elements（自定义元素） 可以创建自定义的 HTML 标记和元素 Shadow DOM（影子 DOM） 用于将封装的 Shadow DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能 通过这种方式，可以保持元素的功能私有，这样就可以被脚本化和样式化的同时而不用担心与文档的其他部分发生冲突 HTML templates（HTML 模板） 简单来说就是使用 &lt;template&gt; 和 &lt;slot&gt; 标签去预定义一些内容，但并不加载至页面，而是将来使用 JavaScript 代码去初始化它 可以作为自定义元素结构的基础被多次重用 下面我们就通过一个简单的示例来看看 Web Components 到底是怎么使用的，例子摘取自 mdn/web-components-examples，但是稍微调整了一下，使用方式很简单，直接在页面当中使用我们自定义的组件即可，如下 123&lt;!-- 使用 --&gt;&lt;component-a text=\"我是自定义组件 A\"&gt;&lt;/component-a&gt;&lt;component-b text=\"我是自定义组件 B\"&gt;&lt;/component-b&gt; 具体实现如下 1234567891011121314151617181920212223242526272829// 定义组件 A 和 Bwindow.customElements.define('component-a', class extends HTMLElement { constructor() { super() const pElem = document.createElement('p') pElem.textContent = this.getAttribute('text') const shadowRoot = this.attachShadow({ mode: 'open' }) shadowRoot.appendChild(pElem) } })window.customElements.define('component-b', class extends HTMLElement { constructor() { super() const pElem = document.createElement('p') pElem.textContent = this.getAttribute('text') const shadowRoot = this.attachShadow({ mode: 'closed' }) shadowRoot.appendChild(pElem) } })document.querySelector('html').addEventListener('click', e =&gt; { console.log(e.composed) console.log(e.composedPath())}) 很简单的一个示例，就算没有了解过 Web Components 相关知识也可以看懂大概，我们来简单的梳理一下 window.customElements，简单来说就是用来定义一个自定义标签（custom elements） attachShadow，给指定的元素挂载一个 Shadow DOM，并且返回它的 ShadowRoot，简单来说就是返回指定 Shadow DOM 封装模式，有下面两种方式 open，指定为开放的封装模式 closed，指定为关闭的封装模式，会让该 ShadowRoot 的内部实现无法被 JavaScript 访问及修改，也就是说将该实现不公开（比如 &lt;video&gt; 标签） 另外，在 Web Components 当中也是有生命周期回调函数存在的，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用，主要有下面四个 connectedCallback，当 customElements 首次被插入文档 DOM 时，被调用 disconnectedCallback，当 customElements 从文档 DOM 中删除时，被调用 adoptedCallback，当 customElements 被移动到新的文档时，被调用 attributeChangedCallback，当 customElements 增加、删除、修改自身属性时，被调用 上面就是一个简单的 Web Components 示例，这里也就只简单的介绍一下，如果想了解更多，可以参考 Web Components 在了解了 Web Components 的基本概念以后，我们就来看看 Angular 当中的 Component Angular Component在 Angular 当中，Component 属于指令的一种，即组件继承于指令（详细可见 packages/core/src/metadata/directives.ts），所以我们可以简单的将其理解为拥有模板的指令（其它两种是属性型指令和结构型指令），基本组成如下 1234567@Component({ selector: 'hello', templateUrl: './hello.component.html', styleUrls: ['./hello.component.scss']})export class HelloComponent implements OnInit { } 主要分为以下几部分 组件装饰器，每个组件类必须用 @component 进行装饰才能成为 Angular 组件 组件元数据，指的是 selector、template 这一系列的属性 组件模板，每个组件都会关联一个模板，这个模板最终会渲染到页面上，页面上这个 DOM 元素就是此组件实例的宿主元素 一般来说有两种引入方式 templateUrl 和 template，区别就是内联和外链 组件类，组件实际上也是一个普通的类，组件的逻辑都在组件类里定义并实现 组件接口，组件可以定义内部需要实现的接口（比如上面的 OnInit 对应着组件的生命周期钩子 ngOnInit()） 组件元数据主要分为两种，自身元数据属性和从 core/Directive 上继承过来的，先来看自身元数据属性 自身元数据属性 名称 类型 作用 animations AnimationEntryMetadata[] 设置组件的动画 changeDetection ChangeDetectionStrategy 设置组件的变化监测策略 encapsulation ViewEncapsulation 设置组件的视图包装选项 entryComponents any[] 设置将被动态插入到该组件视图中的组件列表 interpolation [string, string] 自定义组件的插值标记，默认是双大括号 moduleId string 设置该组件在 ES/CommonJS 规范下的模块 id，它被用于解析模板样式的相对路径 styleUrls string[] 设置组件引用的外部样式文件 styles string[] 设置组件使用的内联样式 template string 设置组件的内联模板 templateUrl string 设置组件模板所在路径（外链） viewProviders Provider[] 设置组件及其所有子组件（不含 ContentChildren）可用的服务 从 core/Directive 继承 名称 类型 作用 exportAs string 设置组件实例在模板中的别名，使得可以在模板中调用 host {[key: string]: string} 设置组件的事件、动作和属性等 inputs string[] 设置组件的输入属性 outputs string[] 设置组件的输出属性 providers Provider[] 设置组件及其所有子组件（含 ContentChildren）可用的服务（依赖注入） queries {[key: string]: any} 设置需要被注入到组件的查询 selector string 设置用于在模板中识别该组件的 CSS 选择器（组件的自定义标签） 下面我们就来看看一些比较常用的元数据的具体含义 inputs有两种写法，第一种方式不太推荐使用，用的比较多的是下面那种，推荐在组件当中使用 @Input() 来进行接收 12345678@Component({ selector: 'hello-component', inputs: ['param']})export class HelloComponent { param: any} 等价于下面这种 1234567@Component({ selector: 'hello-component'})export class HelloComponent { @Input() param: any} outputs同上，和 inputs 类似 12345678@Component({ selector: 'hello-component', outputs: ['test']})export class HelloComponent { test = new eventEmitter&lt;false&gt;()} 等价于 1234567@Component({ selector: 'hello-component'})export class HelloComponent { @Output() test = new eventEmitter&lt;false&gt;()} hosthost 主要用来绑定事件，同上面一样，还是推荐使用 @HostBinding 来进行绑定 123456789101112131415@Component({ selector: 'hello-component', host: { '(click)': 'onClick($event.target)', // 事件 'role': 'nav', // 属性 '[class.pressed]': 'isPressed', // 类 }})export class HelloComponent { isPressed: boolean = true onClick(elem: HTMLElement) { console.log(elem) }} 等价于 123456789101112131415@Component({ selector: 'hello-component'})export class HelloComponent { @HostBinding('attr.role') role = 'nav' @HostBinding('class.pressed') isPressed: boolean = true @HostListener('click', ['$event.target']) onClick(elem: HTMLElement) { console.log(elem) }} queries主要用来视图查询，就是 @ViewChild 另外一种写法，推荐使用 @ViewChild 装饰器 1234567891011121314@Component({ selector: 'hello-component', template: ` &lt;input #theInput type='text' /&gt; &lt;div&gt;Demo Component&lt;/div&gt; `, queries: { theInput: new ViewChild('theInput') }})export class HelloComponent { theInput: ElementRef} 等价于 1234567891011@Component({ selector: 'hello-component', template: ` &lt;input #theInput type='text' /&gt; &lt;div&gt;Demo Component&lt;/div&gt; `})export class HelloComponent { @ViewChild('theInput') theInput: ElementRef} queries这个主要用来内容查询使用的，也就是 @ContentChild 装饰器，不过一般情况下使用较少，模版如下 123&lt;my-list&gt; &lt;li *ngFor=\"let item of items\"&gt;{{item}}&lt;/li&gt;&lt;/my-list&gt; 123456789101112131415161718192021@Directive({ selector: 'li'})export class ListItem {}@Component({ selector: 'my-list', template: ` &lt;ul&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/ul&gt; `, queries: { items: new ContentChild(ListItem) }})export class MyListComponent { items: QueryList&lt;ListItem&gt;} 等价于 123456789101112@Component({ selector: 'my-list', template: ` &lt;ul&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/ul&gt; `})export class MyListComponent { @ContentChild(ListItem) items: QueryList&lt;ListItem&gt;} styleUrls 和 styles这两个元数据一般是用来设置样式，styleUrls 和 styles 是允许同时指定的，不过两者之间存在优先级的关系，如下 1模板内联样式 &gt; styleUrls &gt; styles 不过一般还是建议使用 styleUrls 引用外部样式表文件，这样代码结构相比 styles 更清晰、更易于管理 changeDetection这个参数主要用来设置组件的变换检测机制，有两种取值方式 Default 和 OnPush，默认为 Default ChangeDetectionStrategy.Default 组件的每次变化监测都会检查其内部的所有数据（引用对象也会深度遍历），以此得到前后的数据变化 ChangeDetectionStrategy.OnPush 组件的变化监测只检查输入属性（即 @Input 修饰的变量）的值是否发生变化，当这个值为引用类型（Object，Array 等）时，则只对比该值的引用 显然，OnPush 策略相比 Default 降低了变化监测的复杂度，很好地提升了变化监测的性能，如果组件的更新只依赖输入属性的值，那么在该组件上使用 OnPush 策略是一个很好的选择 encapsulation关于这个属性的详细介绍可以参考 :host 和 ::ng-deep，简单来说就是控制视图的封装模式，有三种模式，原生（Native）、仿真（Emulated）和无（None） 生命周期当 Angular 使用构造函数新建组件后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法 生命周期钩子 调用时机 ngOnChanges 在 ngOnInit 之前调用，或者当组件输入数据（通过 @Input 装饰器显式指定的那些变量）变化时调用 ngOnInit 第一次 ngOnChanges 之后调用，建议此时获取数据，不要在构造函数中获取 ngDoCheck 每次变化监测发生时被调用 ngAfterContentInit 使用将外部内容嵌入到组件视图后被调用，第一次 ngDoCheck 之后调用且只执行一次（只适用组件） ngAfterContentChecked ngAfterContentInit 后被调用，或者每次变化监测发生时被调用（只适用组件） ngAfterViewInit 创建了组件的视图及其子视图之后被调用（只适用组件） ngAfterViewChecked ngAfterViewInit，或者每次子组件变化监测时被调用（只适用组件） ngOnDestroy 销毁指令或者组件之前触发，此时应将不会被垃圾回收器自动回收的资源（比如已订阅的观察者事件、绑定过的 DOM 事件、通过 setTimeout 或 setInterval 设置过的计时器等等）手动销毁掉","link":"/2019/08/27/Angular/09/"},{"title":"rxjs 中的高阶操作符","text":"在之前的文章当中我们简单的介绍了 什么是 rxjs 以及一些常见的操作符使用场景，那么在本章当中，我们就在之前的基础上来看看另外几个比较常用的高阶操作符，关于更多的操作符的详细内容可以参见官方文档 rxjs flatMap当流中的每个元素其本身又是一个流的情况下，高阶操作符就是用来处理这样的情况 1234567Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .map(_ =&gt; Rx.Observable.interval(100)) .subscribe(val =&gt; { val.subscribe(val =&gt; console.log(val)) }) 像这样一层一层的调用不是很好的方法，所以我们可以采用 flatMap（在 rxjs 中是 mergeMap 的别名） 12345Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .flatMap(_ =&gt; Rx.Observable.interval(100)) .subscribe(val =&gt; console.log(val)) 这样一来每次触发都会从新生成一个新流，而两个新流则是并行，其中的每一个流并没有断开，mergeMap 会保证所有的订阅，保证外层元素所对应的子流的订阅 switchMap与 flatMap 有些不同，它会断开之前的流，转而从新生成一个新流 12345Rx.Observable .fromEvent(a, 'keyup') .pluck('target', 'value') .switchMap(_ =&gt; Rx.Observable.interval(1000)) .subscribe(val =&gt; console.log(val)) 一旦有新的外层元素进来，它就会抛弃掉这个元素之前的外层元素所关联的子元素 count这个操作符简单来说就是用来计算源的发送数量，并当源完成时发出该数值，可以简单的理解为将流中的数据做一个统计，然后输出出来（最后也是一个值），也就是告知之前的任务已经全部完成了，比如我们有一个删除列表的操作 12345678910111213// ...del(project: Project): Observable&lt;Project&gt; { // 用 mergeMap 的原因是因为如果在删除过程中有新的 id 进来，原有的删除操作还是需要继续做的，而且新的删除操作也会操作，即所有外层元素的流进来以后，它对应的子流全部都要保持住 const delTasks$ = Observable.from(project.list) .mergeMap(id =&gt; this.http.delete(url)) .count() // 汇总以后不用去关心其外层的流，利用 switchMap 执行删除操作，因为最后希望返回一个 project 对象，所以使用 mapTo 进行转换一下 return delTasks$.switchMap(_ =&gt; this.http.delete(url)) .mapTo(project)}// ... Observable 的冷和热冷和热的概念可能不太好理解，不过这里我们换一个角度来看待这个问题，我们可以将两者的区别分为一个是看视频，一个是看电视直播，虽然都是同样的内容，但是视频每次都必须需要从头开始看，这就是冷的 Observable，而电视直播，无论合适进来，看到的都是同样的内容，这就是热的 Observable 1234567// 冷的 Observableconst count$ = Rx.Observable.interval(1000)const sub1 = count$.subscribe(v =&gt; console.log(v))setTimeout(() =&gt; { const sub2 = count$.subscribe(v =&gt; console.log(v))}, 2000) 每次有新的流进来，都是从头开始计算，下面来看看热的 1234567// 热的 Observable，添加上 share() 即可const count$ = Rx.Observable.interval(1000).share()const sub1 = count$.subscribe(v =&gt; console.log(v))setTimeout(() =&gt; { const sub2 = count$.subscribe(v =&gt; console.log(v))}, 2000) 可以发现，后进来的流会将之前的全部抛弃掉，直接从进来时候的流的位置跟着往下走 SubjectSubject 既是 Observable 对象，又是 Observer 对象，是一个特殊的对象，一方面可以作为流的组成也就是输出的一方，另一方可以作为流的观察一方即接收的一方，这个操作符也是平常开发过程当中使用较多的，Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，Subject 对象会把订阅者添加到观察者列表中，每当有 Subject 对象接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next() 方法，把值一一送出 当有新消息时，Subject 会对内部的 observers 列表进行组播（multicast），Subject 之所以具有 Observable 中的所有方法，是因为 Subject 类继承了 Observable 类，在 Subject 类中有五个重要的方法 next，每当 Subject 对象接收到新值的时候，next 方法会被调用 error，运行中出现异常，error 方法会被调用 complete，Subject 订阅的 Observable 对象结束后，complete 方法会被调用 subscribe，添加观察者 unsubscribe，取消订阅 (设置终止标识符、清空观察者列表) 因为其同时实现了两个接口，在一些特殊的情景下会非常有用，下面是两个延伸方法 ReplaySubject 两者相差不多，Replay 会保留最新的 N 个值 BehaviorSubject 与上面使用方法一致，不过是一种特殊形式，会保留最新的一个值 12345678910111213141516171819// 调整一下上面的示例，这种情况下依然是一种冷的 Observableconst counter$ = Rx.Observable.interval(1000).take(5)const observer1 = { next: (v) =&gt; console.log(`v1 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}const observer2 = { next: (v) =&gt; console.log(`v2 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}counter$.subscribe(observer1)setTimeout(() =&gt; { counter$.subscribe(observer2)}, 2000) 可以发现，此时的输出结果是一样的，但是此时面临的情况为，需要执行两次 subscribe() 操作，而有时的场景为定义好的序列应该会在什么时刻来进行触发，只需要执行一次操作，两个序列都会执行，所以在这种情况下就可以使用 Subject 12345678910111213141516171819202122// 利用 subject 来进行中转，这种情况下成为了热的 Observableconst counter$ = Rx.Observable.interval(1000).take(5)const subject = new Rx.Subject()const observer1 = { next: (v) =&gt; console.log(`v1 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}const observer2 = { next: (v) =&gt; console.log(`v2 &gt;&gt; ${v}`), error: (err) =&gt; console.log(err), complete: (_) =&gt; console.log(`Completed -`)}subject.subscribe(observer1)setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject) subject.next()可以往流中推送两个新值 12345678subject.next(10)subject.next(11)subject.subscribe(observer1)setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject) 但是需要注意的是，添加的位置很重要，比如上面这样，与之前的输出是一样的，流中的数据没有改变，这是因为在推送新值的时候，还没有进行订阅 12345678910// 调整为这样即可subject.subscribe(observer1)subject.next(10)subject.next(11)setTimeout(() =&gt; { subject.subscribe(observer2)}, 2000)counter$.subscribe(subject) 可以看到第一个流中就有推送的新值存在了，但是第二个流中是没有新值的，因为在第二个流开始订阅的时候，推送新值的时间点已经过去了 Rx.ReplaySubject()将过去发生的一些事件进行重播，比如将之前发生的两个事件发生重播 1234567891011121314151617181920const subject = new Rx.ReplaySubject(2)subject.next(10)subject.next(11)// ...// v1 &gt;&gt; 10// v1 &gt;&gt; 11// v1 &gt;&gt; 0// v2 &gt;&gt; 11// v2 &gt;&gt; 0// v1 &gt;&gt; 1// v2 &gt;&gt; 1// v1 &gt;&gt; 2// v2 &gt;&gt; 2// v1 &gt;&gt; 3// v2 &gt;&gt; 3// v1 &gt;&gt; 4// v2 &gt;&gt; 4// Completed -// Completed - 可以发现，第一个流重播的为 10 和 11，而第二个流重播的则是 11 和 0，因为当第二个流开始重播的时候发现前两个的输出分别为 11 和 0 Rx.BehaviorSubject()与 ReplaySubject() 不同的是，BehaviorSubject() 只会记住最新的值 123const subject = new Rx.BehaviorSubject()subject.next(10)subject.next(11) 下面是一个示例 123456789101112131415161718// 使用 BehaviorSubject 去存储，因为其总是可以记住上一次的一个最新值private _dragData = new BehaviorSubject&lt;DragData&gt;(null)// 在开始拖拽的时候，把流中新增一个 data 元素，把这个最新值 next 出去setDragData(data: DragData) { this._dragData.next(data)}// 当放到否个区域的时候，可以得到这个 Observable，所以取值的时候就会取到最新的 data，尽管在拖拽的过程中值已经发射完了，但是依然可以得到上一次发射之后最新的一个值// this._dragData.asObservable() 的作用是将 Subject 转换成 ObservablegetDragData(): Observable&lt;DragData&gt; { return this._dragData.asObservable()}// 清空的时候将一个 null 放到这个流中，可以保证在其他误接收的地方会发现这是一个 null，即没有这个值clearDragData() { this._dragData.next(null)} Async Pipe在常规编程中，如果得到一个 Observable 数组，在页面当中是没有办法去直接使用，需要去 Subscribe 一下，然后赋予给声明的本地变量，用来得到返回的数据，最后再用于页面渲染，但是有了 Async Pipe 以后，上面这些操作都不需要了，可以直接在页面当中直接使用 Observable，并且不需要去取消订阅 12345&lt;md-option *ngFor='let item of memberRestlts$ | async' [value]='item' (onSelectionChange)='handleMembersSelection(item)'&gt;{{item.email}}&lt;/md-option&gt; 12345this.memberRestlts$ = this.form.get('memberSearch').valueChanges .debounceTime(300) .distinctUntilChanged() .filter(s =&gt; s &amp;&amp; s.length &gt; 1) .switchMap(str =&gt; this.service$.serachUsers(str)) 按照之前的操作，我们应当去 subscribe 一下，但是这里使用了 Async Pipe，就不需要那么多麻烦的操作 12// 直接定义一个流memberRestlts$: Observable&lt;User[]&gt; 然后让本地这个流等于我们组合后的流，然后在 HTML 模版当中便可以直接使用，别忘了加上 | async 取消订阅释放资源在 Angular 当中，我们如果使用了数据流的话，一般会在使用完毕后在 ngOnDestroy() 生命周期当中去销毁这个流以节约性能，如下 123456789101112131415// ...getUserInfoSubscription = new Subscription()ngOnInit() { this.getUserInfoSubscription.add(this._store.select(fromRoot.getUserInfo).filter(user =&gt; !!user).subscribe(user =&gt; { // ... }))}ngOnDestroy(): void { this.getUserInfoSubscription.unsubscribe()}// ... 但是又如上文我们提到过的 Async Pipe，它又是不需要我们手动的去取消订阅，所以下面我们就来看一些需要我们手动的去取消订阅释放资源和不需要我们去手动操作的实际使用场景 需要手动取消订阅释放资源的场景表单当中的场景123456789ngOnInit() { this.form = new FormGroup({...}) // 监听表单值的变化 this.valueChanges = this.form.valueChanges.subscribe(console.log)}ngOnDestroy() { this.valueChanges.unsubscribe()} 路由当中的场景1234567ngOnInit() { this.route.params.subscribe(console.log)}ngOnDestroy() { // 手动执行取消订阅的操作} Renderer 服务12345678910111213constructor( private renderer: Renderer2, private element: ElementRef) { }ngOnInit() { this.click = this.renderer .listen(this.element.nativeElement, 'click', handler)}ngOnDestroy() { this.click.unsubscribe()} interval() &amp; fromEvent()12345678910111213141516constructor(private element : ElementRef) { }interval: Subscriptionclick: SubscriptionngOnInit() { this.interval = Observable.interval(1000).subscribe(console.log) this.click = Observable .fromEvent(this.element.nativeElement, 'click') .subscribe(console.log)}ngOnDestroy() { this.interval.unsubscribe() this.click.unsubscribe()} Redux Store12345678910111213141516constructor(private store: Store) { }todos: SubscriptionngOnInit() { /** * select(key : string) { * return this.map(state =&gt; state[key]).distinctUntilChanged() * } */ this.todos = this.store.select('todos').subscribe(console.log) }ngOnDestroy() { this.todos.unsubscribe()} 无需手动释放资源场景简单来说主要分为以下两种，所以大部分情况下还是需要我们手动的去取消订阅释放资源 AsyncPipe 当组件销毁的时候，async 管道会自动执行取消订阅操作，进而避免内存泄 @HostListener 如果使用 @HostListener 装饰器，添加事件监听时，我们无法手动取消订阅 如果需要手动移除事件监听的话，可以使用以下的方式 12345// subscribethis.handler = this.renderer.listen('document', 'click', event =&gt;{...})// unsubscribethis.handler() Finite Observable当你使用 HTTP 服务或 timer Observable 对象时，你也不需要手动执行取消订阅操作 12345ngOnInit() { // 表示 1s 后发出值，然后就结束了 Observable.timer(1000).subscribe(console.log) this.http.get('http://api.com').subscribe(console.log)}","link":"/2019/06/08/Angular/12/"},{"title":"Angular 属性绑定 [] 和 {{}} 的差异","text":"当我们在 Angular 中给属性绑定一个变量的时候，主要有下面三种绑定方式 [property] = &quot;variable&quot; property = &quot;&quot; [attr.property] = &quot;xxx&quot; 下面我们就看看它们之间的区别 [[]] 和 {{}}这两种方式也是平常使用最多的，我们下面通过一个示例看看它们之间的区别 123456789101112131415@Component({ selector: \"my-test\", template: `&lt;br&gt;222222{{test}}`})export class TestComponent { @Input() test: any @Input() testTwo: string ngOnChanges(change) { console.log(this.test) console.log(this.testTwo) console.log(change) }} 然后我们来使用它 123&lt;my-test [test]=\"str\" [testTwo]=\"'[]'\"&gt;&lt;/my-test&gt;---------------------------&lt;my-test test=\"{{str}}\" [testTwo]=\"'{}'\"&gt;&lt;/my-test&gt; str 是一个字符串，并且我们通过 input 或者 button 来改变 str 的值的时候，两者在页面上的显示和控制台的打印都是正常的，看起来并没有什么差异，但是在 str 还没有赋值之前，前者打印的是 undefined，而后者打印的是空字符串，也许这样并不能看出什么，所以我们试着传递一个对象过去，这下便可以看出区别了，前者可以正常的显式我们传递的对象，比如 {a: 1, b: 2}，但是后者显式的却是 '[Object Object]' HTML attribute 和 DOM property在 Angular 中还有一种 attribute 绑定，写法为 [attr.Attribute]=&quot;variable&quot;，那么它和 [property]=&quot;variable&quot; 的区别又在哪里呢？ 在看它们两者的区别之前我们先来了解一下 HTML attribute 和 DOM property 两者的区别，这里虽然涉及到一些 HTML 当中的知识，但是仍然适用于 Angular 当中遇到的情况，在本章节当中我们约定，使用『特性』来代指 attribute ，使用『属性』来代指 property，当我们在书写 HTML 代码的时候，我们为 HTML 元素设置特性，例如 1&lt;input id=\"name\" value=\"zhangsan\" /&gt; 我们写了一个 input 标签，并给他定义了两个特性（id 和 value），当浏览器解析这段代码的时候，会把 HTML 源码解析为 DOM 对象，确切的说是解析为 HTMLInputElement 对象，HTMLInputElement 的继承关系是 1234567891011HTMLInputElement ↓HTMLElement ↓Element ↓Node ↓EventTarget ↓Object 通过查看文档会发现，HTMLInputElement 的原型上定义了很多属性和方法，例如 form，name，type，alt，checked，src，value 等等，还有从 HTMLElement 继承来的 id，title，clientTop 等等，如果仔细寻找，就不难发现其中就有我们为 input 标签定义的特性 id 和 value，这是因为当浏览器解析网页时，将 HTML 特性映射为了 DOM 的『属性』 而 Element 类还有一个 Element.attributes 属性，里面包含了所有的特性，但是 HTML attribute 和 DOM property 并不总是一对一的关系，在下面我们会看到 DOM 属性当浏览器解析完 HTML 后，生成的 DOM 是一个继承自 Object 的常规 JavaScript 对象，因此我们可以像操作任何 JavaScript 对象那样来操作 DOM 对象 12Element.foo = 'bar'Element.user = { name: 'zhangsan', age: '22'} 也可以为其添加方法，如果你想给每个 HTML 元素都添加属性或方法，甚至可以直接修改 Element.prototype，不过不建议这么操作 HTML 特性和 DOM 属性类似，除了那些规范里定义的标准特性外，HTML 也可以添加非标准的属性，例如 1&lt;input id=\"name\" value=\"zhangsan\" foo=\"bar\" /&gt; 当 HTML 特性映射为 DOM 属性时，『只映射标准属性』，访问非标准属性将得到 undefined 12const el = document.getElementById('name')el.foo === undefined 好在 DOM 对象也提供了操作特性的 API 1234Element.hasAttribute(name) // 判断某个特性是否存在Element.getAttribute(name) // 获取指定特性的值Element.setAttribute(name, value) // 设置指定特性的值Element.removeAttribute(name) // 移除指定特性 以上 API 定义在 Element 上，根据 HTML 规范，标签以及特性名是不区分大小写的，因此以下代码是一样的 123Element.getAttribute('id')Element.getAttribute('ID')Element.getAttribute('iD') 并且特性永远都是字符串或 null，如果我们为特性设置非字符串的值，则引擎会将此值转换为字符串，属性是具有类型的 12345Element.getAttribute('checked') === '' // 特性是字符串Element.checked === false // 属性是 boolean 类型的值Element.getAttribute('style') === 'color:blue' // 特性是字符串typeof Element.style === 'object' // 属性是 CSSStyleDeclaration 对象 即使都是字符串，属性和特性也可能不同，有一个例外就是 href HTML attribute，对于 href 返回 HTML 设置的值 DOM property，对于 href 返回解析后的完整 url 特性和属性的同步当标准的特性更新时，对应的属性也会更新，反之亦然，但是 input.value 的同步是单向的，只是 attribute ==&gt; property，当修改特性时，属性也会更新，但是修改属性后，特性却还是原值 12345Element.setAttribute('value', 'zhangsan') // 修改特性Element.value === 'zhangsan' // 属性也更新了 Element.value = 'newValue' // 修改属性 Element.getAttribute('value')) === 'zhangsan' // 特性没有更新 非标准特性非标准 HTML 特性并不会自动映射为 DOM 属性，当我们使用 data- 开头的特性时，会映射到 DOM 的 dataset 属性，中划线格式会变成驼峰格式 12345Element.setAttribute('data-name', 'zhangsan')Element.dataset.name === 'zhangsan'Element.setAttribute('data-age', 18)Element.dataset.age === '18' 自定义特性 VS 非规范特性HTML 允许我们自定义标签，也可以扩展标签的特性，但是我们推荐使用已经进入 HTML5 规范的自定义特性 data-*，比如我们想为div 标签增加一个 age 特性，我们可以有两种选择 12&lt;div age=\"18\"&gt;zhangsan&lt;/div&gt;&lt;div data-age=\"18\"&gt;zhangsan&lt;/div&gt; 虽然第一种代码更短，但是却有一个潜在的风险，因为 HTML 规范是一直发展变化的，也许在未来的某个版本中，age 被添加进了标准特性里面，这将会引起潜在的 bug 总结 property 指的是 DOM 中的属性，是 JavaScript 里的对象 attribute 指的是 HTML 标签上的特性，它的值只能够是字符串 DOM 中的有一个 attribute 的属性，其中就是 HTML 标签上的特性列表 两者之间的数据绑定是单向的，更改 attribute 会同步到 property，但反之则不然 更改 property 和 attribute 的值，都会将更新反映到 HTML 页面中 在 Angular 当中，由于 element 没有这些属性，中括号 [] 的属性绑定语法自然不行，而且模版编译的时候会报错，所以对于非基本属性，Angular 提供了这种 [attr.Attribute]=&quot;variable&quot; 的特性绑定语法 当然，在 property 是基本属性时，使用 [property]=&quot;variable&quot; 绑定属性，然后改变 variable 的值，对应的 attribute 也会跟着属性同步，Angular 应该是做了属性和特性的数据双向绑定的工作，所以只有 property 是基本属性，两者一样，例如 [id] 和 [attr.id] 的作用并无区别 两个需要注意的地方一个就是常见的传值的差异 123[property]=\"false\"[property]=\"{{false}}\" 特别需要注意，因为后者其实绑定的是 'false'（字符串），所以一旦用在了 if 语句当中就可能出现问题 另外一个就是 Input 标签的 maxlength 特性对应的是 maxLength 属性（注意 L 是大写），虽然是大写，但是在浏览器当中解析出来的依然是 &lt;input maxlength=&quot;10&quot; /&gt;（小写），所以写成 [attr.maxlength]、[attr.maxLength]、[maxLength] 都是可以，但是 [maxlength] 就不行，同理 minlength/minLength 是一样的 小结综上所诉，属性绑定最好还是用中括号，双大括号用于展示，如 1&lt;div&gt;{{obj | json}}&lt;/div&gt; 实际上在渲染视图之前，Angular 把这些插值表达式翻译成相应的属性绑定，还有就是，它依然可以用于执行 Angular 的模板语法，例如 123property=\"{{fun()}}\"property=\"{{a ? b : c}}\" 只是它会做多一步，把 return 的值转换成 string 参考 What is the difference between properties and attributes in HTML? .prop() vs .attr() HTML5 - 28 October 2014 Attributes and properties getAttribute() versus Element object properties?","link":"/2019/06/22/Angular/14/"},{"title":"Angular 中的变化检测机制","text":"今天在群里看到一个讨论，是关于 Angular 的变化检查机制，依稀记得在 AngularJS 当中是使用的脏检查机制，而在 Angular 2.x+ 之后的版本当中依然采用的是脏检查机制，不过使用的是进行优化过的版本，为了探明到底有啥区别，就打算抽点时间，研究研究新版本的脏检查机制，顺便记录记录，就当加深点印象了 为保持区别，文中所提到的 Angular 均为 2.x+ 的版本，而 AngularJS 则代表 1.x+ 的版本，不过本文当中的 Angular 大部分相关内容还是以 2.x+ 版本为主 之前在探讨 Angular 中的 ExpressionChangedAfterItHasBeenCheckedError 这个错误的时候也涉及到了一些 Angular 的变化检查机制的内容，所以今天就一起来深入的研究一下 Angular 当中的变化检查机制 什么是变化检测一句话概括就是『一种更改检测机制，用于遍历组件树，检查每个组件的变化，并在组件属性发生变化的时候触发 DOM 的更新』，变化检测（脏检查）的基本任务是获取程序内部状态的变化，并使其在用户界面上以某种方式可见，这种状态的变化可以来自于 JavaScript 的任何数据结构，最终呈现为用户界面中的段落、表单、链接或者按钮等 DOM 对象 然而在程序运行时发生变化情况比较复杂，我们需要确定模型中发生什么变化，以及什么地方需要更新 DOM 节点，毕竟操作 DOM 树十分昂贵，所以我们不仅需要找出待更新的地方，还需要保持操作数尽可能小，关于更多循环脏值检测可以见 The Bad Parts 数据的变化那么问题来了，既然是变化检测，那么数据在何时会变化，又是哪些因素会引起数据变化呢？基本上应用程序状态的改变可以由三类活动引起 用户输入操作，比如点击，表单提交等 请求服务端数据 定时事件，比如 setTimeout，setInterval 这几点有一个共同点，就是它们都是异步的，也就是说，所有的异步操作是可能导致数据变化的根源因素，所以每当执行一些异步操作时，我们的应用程序状态可能发生改变，而这时则需要去更新视图 通知变化在数据进行变化了之后，在 Angular 中又是谁来通知数据即将变化的呢？在 AngularJS 当中使用了观察者和监听器的概念，一个观察者是一个用来返回一个被监听的对象的值的函数，一般是由 $scope.$apply() 或者 $scope.$digest 来进行触发，而在 Angular 当中则接入了 NgZone，由它来监听 Angular 所有的异步事件，Angular 在启动时会重写（通过 Zone.js）部分底层浏览器 API，比如下面的 addEventListener 12345678910111213// this is the new version of addEventListenerfunction addEventListener(eventName, callback) { // call the real addEventListener callRealAddEventListener(eventName, function () { // first call the original callback callback() // and then run Angular-specific functionality var changed = angular2.runChangeDetection() if (changed) { angular2.reRenderUIPart() } })} 而在 Angular 当中常见的有两种方式来触发变化检测，一种方法是基于组件的生命周期钩子 123456ngAfterViewChecked() { if (this.callback &amp;&amp; this.clicked) { console.log('changing status ...') this.callback(Math.random()) }} 在开发模式下运行 Angular 会在控制台中得到一条错误日志，生产模式下则不会抛出，另一种方法是手动控制变化检测的打开或者关闭，并手动触发 123456constructor(private ref: ChangeDetectorRef) { ref.detach() setInterval(() =&gt; { this.ref.detectChanges() }, 5000)} 改善的脏检查同样是循环脏值检测，虽然 Angular 并没有类似于 AngularJS 的观察者的概念，但是跟踪数据模型属性变化的函数还是存在，它们只跟踪数据模型中的变化，而不像 AngularJS 中跟踪所有的内容，Angular 的核心是组件化，组件的嵌套会使得最终形成一棵组件树，Angular 的变化检测可以分组件进行，每个组件都有对应的变化检测器 ChangeDetector，可想而知这些变化检测器也会构成一棵树，如下图所示 另外，Angular 的数据流是自顶向下，从父组件向子组件的的单向流动，变化监测树与之相呼应，单项数据量保证变化监测的高效性和可预测性，尽管检查了父组件之后，子组件可能会改变父组件的数据使得父组件需要再次被检查，这是不被推荐的数据处理方式 在开发模式下，Angular 会进行二次检查，如果出现上述情况，二次检查就会产生如文章开头部分所提到的 ExpressionChangedAfterItHasBeenCheckedError 错误，而在生产环境中，脏检查只会执行一次，相比之下，AngularJS 采用的是双向数据流，错综复杂的数据流使得它不得不多次检查，使得数据最终趋向稳定 但是在理论上，数据可能永远不稳定，而 AngularJS 给出的策略是，脏检查超过 10 次，就认为程序有问题，不再进行检查，这是因为 $digest 循环的上限是 10 次（至于原因，可以参考 angular-digest-loop） Angular 中的变化检测首先我们需要注意的是在 Angular 中每个组件都有自己的变化检测器，这使得我们可以对每个组件分别控制如何以及何时进行变化检测 由于每个组件都有其自己的变化检测器，即一个 Angular 应用程序由一个组件树组成，所以逻辑结果就是我们也有一个变化检测器树，这棵树也可以看作是一个流向图，而数据总是从上到下流动，数据从上到下的原因是因为变化检测也总是从上到下对每一个单独的组件进行，每一次从根组件开始，单向数据流比循环脏检查更可预测，我们总是可以知道视图中使用的数据来自哪里 我们假设在组件树的某个地方触发一个事件，比如一个按钮被点击，NgZone 会进行事件的处理并通知 Angular，然后变化检测依次向下传递，另外，Angular 还提供了定制变化检测策略的能力 1234export enum ChangeDetectionStrategy { OnPush, // 表示变化检测对象的状态为 `CheckOnce` Default, // 表示变化检测对象的状态为 `CheckAlways`} 从上面的 ChangeDetectionStrategy 可以看到，Angular 有两种变化检测策略，Default 是 Angular 默认的变化检测策略，也就是之前提到的脏检查（只要有值发生变化，就全部检查，但是是经过优化后的单向数据流检查），但是也可以根据使用场景来设置更加高效的变化检测方式 onPush，就是只有当输入数据的引用发生变化或者有事件触发时，组件才进行变化检测（比如纯展示使用的 UI 组件就比较适用于这个策略） 123456789101112@Component({ template: ` &lt;h2&gt;{{vData.name}}&lt;/h2&gt; &lt;span&gt;{{vData.email}}&lt;/span&gt; `, // 设置该组件的变化检测策略为 onPush changeDetection: ChangeDetectionStrategy.OnPush})class VCardCmp { @Input() vData} 比如上面这个例子，当 vData 的属性值发生变化的时候，这个组件不会发生变化检测，只有当 vData 重新赋值的时候才会发生变化检测，当组件中的输入对象是不变量时，可采用 onPush 变化检测策略，减少变化检测的频率 换个角度来说，为了更加智能地执行变化检测，可以在只接受输入的子组件中采用 onPush 策略，当输入属性不变时，Angular 可以跳过整个变更检测子树，如果我们在 Angular 应用程序中使用不可变对象，我们所需要做的就是告诉 Angular 组件可以跳过变化检测（如果它的输入没有改变的话），正如上面的例子所示，VCardCmp 只依赖于它的输入属性，我们可以告诉 Angular 跳过这个组件的子树的变化检测 更优的变化检测Angular 每次都要检查每个组件，因为事件发生的原因也许是应用程序状态已经改变，但是如果我们能够告诉 Angular 只对那些改变状态的应用程序部分运行变化检测，那不是很好吗？事实证明，有些数据结构可以给我们什么时候发生变化的一些保证，那就是 Immutables 和 Observables Immutables比如我们拥有一个组件 VCardApp 使用 v-card 作为子组件，其具有一个输入属性 vData，并且我们可以使用 changeData 方法改变 vData 对象的 name 属性（并不会改变该对象的引用） 12345678910111213141516@Component({ template: '&lt;v-card [vData]=\"vData\"&gt;&lt;/v-card&gt;'})class VCardApp { constructor() { this.vData = { name: 'zhangsan', email: 'zhangsan@mail.com' } } changeData() { this.vData.name = 'lisi' }} 当某些事件导致 changeData 执行时，vData.name 发生改变并传递至 v-card 中，v-card 组件的变化检测器检查给定的数据新 vData 是否与以前一样，在数据引用未变但是其参数改变的情况下，Angular 也需要对该数据进行变化监测 这就是 immutable 数据结构发挥作用的地方，Immutable 为我们提供不可变的对象，这意味着如果我们使用不可变的对象，并且想要对这样的对象进行更改，我们会得到一个新的引用（保证原始对象不变） 1234567var vData = Immutables.create({ name: 'lisi'})var vData2 = vData.set('name', 'zhangsan')vData === vData2 // false Observables与不可变的对象不同，当进行更改时 Observables 不会给我们提供新的引用，而是发射我们可以订阅的事件来对他们做出反应，比如下面这个示例，一个购物车示例，每当用户将产品放入购物车时，我们需要在用户界面中显示一个小计数器，以便用户可以看到购物车中的产品数量 123456789101112131415@Component({ template: '{{counter}}', changeDetection: ChangeDetectionStrategy.OnPush})class CartBadgeCmp { @Input() addItemStream: Observable&lt;any&gt; counter = 0 ngOnInit() { this.addItemStream.subscribe(() =&gt; { this.counter++ // application state changed }) }} 该组件有一个 counter 属性和一个输入属性 addItemStream，当产品被添加到购物车时，这是一个被触发的事件流，另外，我们设置了变化检测策略为 OnPush，只有当组件的输入属性发生变化时，变化检测才会执行，如前所述，引用 addItemStream 永远不会改变，所以组件的子树从不执行变更检测 当整个树被设置成 OnPush 后，我们如何通知 Angular 需要对这个组件进行变化检测呢？正如我们所知，变化检测总是从上到下执行的，所以我们需要的是一种可以检测树的整个路径到发生变化的组件的变化的方法，我们可以通过依赖注入访问组件的 ChangeDetectorRef，这个注入来自一个叫做 markForCheck 的 API，它标记从组件到根的路径，以便下次更改检测的运行 12345678constructor(private cd: ChangeDetectorRef) { }ngOnInit() { this.addItemStream.subscribe(() =&gt; { this.counter++ // application state changed this.cd.markForCheck() // marks path })} 下面是在可观察事件被触发后，变化检测开始前 现在当执行更改检测时，它将从上到下进行 并且一旦更改检测运行结束，它将恢复 OnPush 整个树的状态 参考 Change And Its Detection In JavaScript Frameworks ANGULAR CHANGE DETECTION EXPLAINED change detection in Angular Tuning Angular Change Detection ExpressionChangedAfterItHasBeenCheckedError TAKING ADVANTAGE OF OBSERVABLES IN ANGULAR Angular Change Detection - How Does It Really Work? Change And Its Detection In JavaScript Frameworks","link":"/2019/07/22/Angular/16/"},{"title":"BFC","text":"今天我们来深入的了解一下 CSS 当中的 BFC 概念，关于这个东西在平常可能会经常听说到，但是它到底是一个什么样的设定呢？所以今天就抽些时间来深入的了解一下它，但是在此之前，我们先来看看 FC 的概念 FC当然这里的 FC 指的并不是任天堂的红白机，而是 Formatting Contexts，它是 W3C CSS2.1 规范 中的一个概念，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 它与盒模型之间的关系可谓息息相关，所以我们就先来简单的了解一下盒模型，需要注意的是，本文当中只是浅显的了解一下 BFC 相关概念以及一些入门知识，想深入了解的可以参考上面的规范，里面有详细的描述 盒子模型的结构 盒子模型其实就是由以下 4 个盒子组成 content box，必备，由 content area 和 4 条 content/inner edge 组成 padding box，可选，由 padding 和 4 条 padding edge 组成，若 padding 宽度设置为 0，则 padding edge 与 content edage 重叠 border box，可选，由 border 和 4 条 border edge 组成，若 border 宽度设置为 0，则 border edge 与 padding edage 重叠 margin box，可选，由 margin 和 4 条 margin/outer edge 组成，若 margin 宽度设置为 0，则 margin edge 与 border edage 重叠 一般所说的盒模型有两种情况，一个是标准盒子模型，另一种是怪异盒子模型（IE 盒子模型），两者的区别就在于计算 width 和 height 的时候是否包含 padding/margin/border，从上面可以看出，margin、border、padding、content 分别定义了元素四种边，然后每种类型的边的四条边定义了一个盒子，分别是 content box、padding box、border box、margin box，而决定块盒在包含块中与相邻块盒的垂直间距的便是 margin-box，这个 margin-box 是始终存在的，即使它的 margin 为 0 比如一个元素 &lt;div&gt;&lt;/div&gt;，会生成一个块级的元素，同时元素也生成了一个块级盒子，如果不设置 div 的 margin 值，但是可以在浏览器生成的 computed style 中看到它的 margin 值仍然为 0 的，特别需要注意的是：当 &lt;div&gt;&lt;/div&gt; 标签被浏览器解析后会生成 div 元素并添加到 document tree 中，但 CSS 作用的对象并不是 document tree，而是根据 document tree 生成的 render tree，而盒子模型就是 render tree 的节点 CSS 作用的是盒子（box）而不是元素（element） JavaScript 无法直接操作盒子 Box（盒子模型）是 CSS 布局的对象和基本单位，直观点来说，就是一个页面是由很多个 Box 组成的，元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染 Formatting ContextsFormatting Contexts 是 W3C CSS2.1 规范（见开头部分）中的一个概念，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用，最常见的 Formatting context 有 BFC 和 IFC CSS2.1 中只有 BFC（Block Formatting Contexts） 和 IFC（Inline Formatting Contexts），CSS3 中还增加了 GFC（GridLayout Formatting Contexts） 和 FFC（Flex Formatting Contexts），本章当中我们主要介绍 BFC，其它几个我们在这里只是简单的了解 GFCGFC 直译为网格布局格式化上下文，当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间 GFC 同 table 类似，同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制 FFCFFC 直译为自适应格式化上下文，display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container），可惜这个属性只有谷歌和火狐支持，Flex Box 由伸缩容器和伸缩项目组成，通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器 设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素，伸缩容器中的每一个子元素都是一个伸缩项目，伸缩项目可以是任意数量的，伸缩容器外和伸缩项目内的一切元素都不受影响，简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局 下面我们就来看我们本章将主要介绍的 BFC BFCBFC 直译为块级格式化上下文，它是一个独立的渲染区域，只有 block-level-box 参与， 它规定了内部的 block-level-box 如何布局，并且与这个区域外部毫不相干，块级元素会自动生成一个块级盒 block-level-box，这是块级盒 block-level-box 的盒模型构成，它表明的是块级盒自身的结构构成 我们从 BFC 的原理开始看起，简单来说其实也就是 BFC 的渲染规则，主要有下面几点 普通流中的块元素（box）独占一行，然后从上往下一个接一个的排布（垂直方向），相邻元素间会有外边距折叠（垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠） 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反）（即使存在浮动也是如此） BFC 的区域不会与 float box 重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此） 计算 BFC 的高度时，浮动元素也参与计算 BFC 的生成既然 BFC 是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，而这些则由生成 BFC 的元素决定（即哪些元素会生成 BFC），我们在这里也只列举一些比较常见的，完整的列表可以参考 MDN - 块格式化上下文 float 属性不为 none，意思是，只要设置了浮动，当前元素就创建了 BFC overflow 的值不为 visible，可以让属性是 hidden、auto position 为 absolute 或 fixed display 为 inline-block，table-cell，table-caption，flex，inline-flex 关于 display：table，之所以可以生成 BFC，主要原因在于 table 会默认生成一个匿名的 table-cell 正是这个匿名的 table-cell 生成了 BFC display 值为 flow-root 的元素，新属性，简单来说给有浮动元素的父容器添加该属性可以清除浮动 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） BFC 的应用有了上面这些规则，就可以用来解决我们平常遇到过的一些问题 两列布局先看下面代码 1234567891011121314151617181920212223&lt;style&gt;body { width: 300px; position: relative;}.aside { width: 100px; height: 150px; float: left; background: #f66;}.main { height: 200px; background: #fcc;}&lt;/style&gt;&lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 效果如下： 根据规则可知，虽然存在浮动的元素 aslide，但 main 的左边依然会与包含块的左边相接触，这是因为 BFC 不会与 float box 重叠，所以我们可以将 main 生成为 BFC 即可 123.main { overflow: hidden;} 当触发 main 生成 BFC 后，这个新的 BFC 不会与浮动的 aside 重叠，这样就可以生成一个简单的两列布局，效果如下 高度坍塌这个也是一个比较常见的问题，即内部元素设置了浮动以后，外面包裹的容器，比如 div 的高度会发生坍塌，代码如下 1234567891011121314151617181920&lt;style&gt;.par { border: 5px solid #fcc; width: 300px;}.child { border: 5px solid #f66; width:100px; height: 100px; float: left;}&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果如下 发生这种情况的原因是因为内部的 child 元素使用了 float，使其脱离了文档流，故父元素的高度自然就没有了，解决办法有很多，原理只需要将父元素触发为 BFC 即可 123.par { overflow: hidden;} 效果如下： margin 重叠这个也是平常开发当中经常会遇到的问题，代码如下 123456789101112131415&lt;style&gt;p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px;}&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 效果如下 在控制台中审查元素可知，两个 p 之间的距离为 100px，发生了 margin 重叠，根据规则可知，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠，解决办法也很简单，我们可以给其中任意一个元素包裹一层容器，并触发该容器生成 BFC，那么此时的两个子元素就不属于同一个 BFC，所以就不会发生 margin 重叠的现象了 123456789101112131415161718192021&lt;style&gt;.wrap { overflow: hidden;}p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px;}&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下 通过以上几个例子可以看出，同规则一样，BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此），因为 BFC 内部的元素和外部的元素绝对不会互相影响，因此当 BFC 外部存在浮动时，它不应该影响 BFC 内部 box 的布局，BFC 会通过变窄，而不与浮动有重叠 同样的，当 BFC 内部有浮动时，为了不影响外部元素的布局，BFC 计算高度时会包括浮动的高度，同样，避免 margin 重叠也是这样的一个道理 参考 W3C CSS2.1 规范 什么是 BFC BFC 的理解 深入理解 BFC","link":"/2018/12/03/CSS/06/"},{"title":"关于子容器属性 flex 取值问题","text":"本文主要参考 CSS 伸缩盒布局模组，主要介绍的是应用在元素身上的 flex 属性取值的问题，关于 flex 布局的一些知识可以参考 flex 布局，故本文不会涉及太多 需要注意的是，如果将元素的 display 属性设置为 flex，那么其就转换为了 flex 容器，在设为 flex 容器后，其子元素的 float、clear 和 vertical-align 属性都将失效 下面我们就先来简单了解 flex 布局常用的属性和一些取值介绍，其实它主要分为两部分，一个是应用在容器上的属性，另一个是应用在子容器上的属性 容器的属性有下面六个属性是应用在容器上面的 flex-direction，属性决定主轴的方向（即项目的排列方向） row（默认值），主轴为水平方向，起点在左端 row-reverse，主轴为水平方向，起点在右端 column，主轴为垂直方向，起点在上沿 column-reverse，主轴为垂直方向，起点在下沿 flex-wrap，默认情况下，项目都排在一条线（轴线）上，如果一条轴线排不下，如何换行 nowrap（默认），不换行 wrap，换行，第一行在上方 wrap-reverse，换行，第一行在下方 flex-flow，为 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap justify-content，定义了项目在主轴上的对齐方式（左右） flex-start（默认值），左对齐 flex-end，右对齐 center， 居中 space-between，两端对齐，项目之间的间隔都相等 space-around，每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍 align-items，定义项目在交叉轴上如何对齐（上下） flex-start，交叉轴的起点对齐 flex-end，交叉轴的终点对齐 center，交叉轴的中点对齐 baseline，项目的第一行文字的基线对齐 stretch（默认值），如果项目未设置高度或设为 auto，将占满整个容器的高度 align-content，定义了多根轴线的对齐方式如果项目只有一根轴线，无效（意思就是内容分为多行，类似 line-height） flex-start，与交叉轴的起点对齐 flex-end，与交叉轴的终点对齐 center，与交叉轴的中点对齐 space-between，与交叉轴两端对齐，轴线之间的间隔平均分布 space-around，每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值），轴线占满整个交叉轴 元素的属性有下面六个属性是应用在元素身上的 order，定义项目的排列顺序，数值越小，排列越靠前，默认为 0 flex-grow，定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话） 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍（类似合并单元格） flex-shrink，定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 flex-basis，定义了在分配多余空间之前，项目占据的主轴空间 浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为 auto，即项目的本来大小 它可以设为跟 width 或 height 属性一样的值，则项目将占据固定空间 flex，是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto，后两个属性可选 align-self，允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性（父级容器指定的排列方式） 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 除了 auto，其他都与 align-items 属性完全一致 flex之前也提到过了，本章主要介绍的就是关于子容器属性上的 flex 取值问题，所以我们下面就来看看这个属性的一些特殊之处，我们都知道，其实子属性身上的 flex 属性是 flex-grow、flex-shrink、flex-basis 的缩写，flex 的默认值是以上三个属性值的组合，假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto，如下，是等同的 1234567.item {flex: 222 233 244px;}.item { flex-grow: 222; flex-shrink: 233; flex-basis: 244px;} 当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的 1234567.item {flex: none;}.item { flex-grow: 0; flex-shrink: 0; flex-basis: auto;} 当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的 1234567.item {flex: auto;}.item { flex-grow: 1; flex-shrink: 1; flex-basis: auto;} 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的 1234567.item {flex: 1;}.item { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;} 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况，注意 0% 是一个百分比而不是一个非负数字 12345678910111213141516.item-1 {flex: 0%;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 0%;}.item-2 {flex: 24px;}.item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 24px;} 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的 1234567.item {flex: 2 3;}.item { flex-grow: 2; flex-shrink: 3; flex-basis: 0%;} 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的 1234567.item {flex: 2333 3222px;}.item { flex-grow: 2333; flex-shrink: 1; flex-basis: 3222px;} flex-basis 规定的是子元素的基准值，所以是否溢出的计算与此属性息息相关，flex-basis 规定的范围取决于 box-sizing，这里主要讨论以下 flex-basis 的取值情况 auto 首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值，如果也是 auto，则使用值为 content content 指根据该子元素的内容自动布局，有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto 百分比 根据其包含块（即伸缩父容器）的主尺寸计算，如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样 实例下面我们来看一个实例加深一下印象，页面布局如下 12345&lt;div class=\"parent\"&gt; &lt;div class=\"item-1\"&gt;&lt;/div&gt; &lt;div class=\"item-2\"&gt;&lt;/div&gt; &lt;div class=\"item-3\"&gt;&lt;/div&gt;&lt;/div&gt; 应用的 CSS 如下 12345678910111213141516171819202122232425.parent { display: flex; width: 600px;}.parent&gt;div { height: 100px;}.item-1 { width: 9999px; flex: 2 1 0%; background: lightskyblue;}.item-2 { width: 100px; flex: 2 1 auto; background: turquoise;}.item-3 { flex: 1 1 200px; background: darkturquoise;} 最终效果如下 主轴上父容器总尺寸为 600px，那么子元素的总基准值是 0% + auto + 200px = 300px，其中 0% 即 0 宽度 auto 对应取主尺寸即 100px 所以剩余空间为 600px - 300px = 300px，伸缩放大系数之和为 2 + 2 + 1 = 5，那么剩余空间分配如下 item-1 和 item-2 各分配 2/5，各得 120px item-3 分配 1/5，得 60px 所以各项目最终宽度为 item-1 = 0% + 120px = 120px item-2 = auto + 120px = 220px item-3 = 200px + 60px = 260px 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 9999px，也并没有什么用，形同虚设，而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 是会用来计算基准值，而不会纳入剩余空间","link":"/2019/01/12/CSS/09/"},{"title":"CSS 当中的 display","text":"我们在之前的章节当中介绍了 CSS 当中的 float 属性，今天我们接着上回继续来看 CSS 当中的 display 属性 display 是设计 CSS 版面配置中最重要的属性，每个 HTML 元素都有一个预设的 display 值，不同的元素属性会有不同的预设值，大部分元素的 display 属性，预设值通常是 block 或 inline 其中一个，若该元素的 display 属性被标示为 block 就被称为『区块元素』，若被标示为 inline 就称为『行内元素』，但是我们在这里并不会介绍它的全部属性，而是只会介绍一些比较常用的，比如 block、inline-block、inline 和 none 等，我们就先从 none 开始看起吧 none &amp;&amp; visibility我们都知道，当元素的 display 属性被设置成 none 以后，界面上将不会显示该元素，并且该元素不占布局空间，但是我们仍然可以通过 JavaScript 来操作该元素，至于为什么会这样，其实是涉及到浏览器的渲染原理，如下 浏览器会解析 HTML 标签生成 DOM Tree，解析 CSS 生成 CSSOM，然后将 DOM Tree 和 CSSOM 合成生成 Render Tree，元素在 Render Tree 中对应 0 或多个盒子，然后浏览器以盒子模型的信息布局和渲染界面，更多内容可见 浏览器的渲染机制 而设置为 display: none 的元素则在 Render Tree 中没有生成对应的盒子模型，也就是说节点不会被加入 Render Tree 当中，因此后续的布局、渲染工作自然与它无关，但是 DOM 操作还是可以的，但是这里有个需要注意的地方，那就是我们下面将要介绍的 visibility: hidden 则会被加入 Render Tree 当中，所以如果某个节点最开始是不显示的，设为 display: none 是更优的，我们下面再来看一些与其相关的其他特性 原生默认为 None 的元素其实浏览器原生元素中有不少自带 display: none 的元素，如 link，script，style，dialog，input[type=hidden] 等 hidden 属性在 HTML5 中新增了 hidden 布尔属性，它可以让开发者自定义元素的隐藏，如下 1234/* 兼容原生不支持 hidden 属性的浏览器 */[hidden]{ display: none;} 1&lt;span hidden&gt;Hide and Seek: You can't see me!&lt;/span&gt; 后代元素不可见当父元素为设置为 display: none 后，它的后代元素都是不可见的，如下示例 123456*** START ***&lt;div style=\"display:none;\"&gt; I'm parent! &lt;div style=\"display: block\"&gt; I'm son! &lt;/div&gt;&lt;/div&gt;*** END *** 运行后可以发现，页面当中只会显示 *** START *** *** END *** 内容 无法获取焦点设置为 display: none 后，是无法获取焦点的，比如如下示例，可以使用 TAB 键来进行测试 12&lt;input type=\"hidden\"&gt;&lt;div tabindex=\"1\" style=\"display:none\"&gt;hidden&lt;/div&gt; 无法响应事件设置为 display: none 后，是无法响应任何事件的，无论是捕获、命中目标和冒泡阶段均不可以，这是由于 display: none 的元素根本不会在界面上渲染，就是连一个像素的都不占，因此自然无法通过鼠标点击命中，而元素也无法获取焦点，那么也不能成为键盘事件的命中目标，当父元素的 display 为 none 时，子元素的 display 必定为 none，因此元素也没有机会位于事件捕获或冒泡阶段的路径上，因此 display: none 的元素无法响应事件 不影响表单提交虽然我们无法看到 display: none 的元素，但当表单提交时依然会将隐藏的 input 元素的值提交上去 1234&lt;form&gt; &lt;input type=\"hidden\" name=\"id\"&gt; &lt;input type=\"text\" name=\"name\" style=\"display:none\"&gt;&lt;/form&gt; display 变化时将触发 reflow如果撇开 display: none 的话，我们都知道 block 表示元素位于 BFC 中，而 inline 则表示元素位于 IFC 中，也就是说 display 就是用于设置元素所属的布局上下文，若修改 display 值则表示元素采用的布局方式已发生变化，因此 display 变化时将触发 reflow 下面我们再来看一个经常会与 display: none 放在一起说的 visibility: hidden，虽然他们都可以隐藏元素，但是它与 display: none 最为主要的区别就是 visibility: hidden 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间，也就是说，该元素虽然被隐藏了但仍然会影响布局，它与 display: none 表现一致的行为有以下这些 和 display: none 一样无法获得焦点 和 display: none 一样不妨碍 form 表单的提交 下面我们主要来看看两者之间的一些差异点 后代元素可以选择可见与 display: none 不同的是，如果父元素为 visibility: hidden，而子元素设置为 visibility: visible 的话，子元素是会显示的，如下 123456&lt;div style=\"visibility: hidden\"&gt; I'm Parent. &lt;div style=\"visibility: visible;\"&gt; I'm Son. &lt;/div&gt;&lt;/div&gt; 可以发现运行以后，虽然 parent 是使用 visibility: hidden 隐藏了，但是如果子元素设置为 visibility: visible 仍然是可以显示的 可以在冒泡阶段响应事件由于设置为 visibility: hidden 的元素其子元素可以设置为 visibility: visible，因此隐藏的元素有可能位于事件冒泡的路径上，所以在下面代码中将鼠标移至属性为 .visible 的元素时，.hidden 会的元素响应 hover 事件显示 123456789101112131415div{ border: solid 2px blue;}.visible{ visibility: visible;}.hidden{ visibility: hidden;}.hidden:hover{ visibility: visible;} 123456&lt;div class=\"hidden\"&gt; I'm Parent. &lt;div class=\"visible\"&gt; I'm Son. &lt;/div&gt;&lt;/div&gt; visibility 变化不会触发 reflow这个我们在上面也提到过，因为 visibility: hidden 会被加入 Render Tree，而又当 visible 设置为 hidden 时，不会改变元素布局相关的属性，因此不会触发 reflow，只是静静地和其他渲染变化一起等待浏览器定时重绘界面 inline &amp;&amp; block &amp;&amp; inline-block看完了 none，下面我们再来看看 inline，block，inline-block 这三个比较类似的属性，我们先从一个问题开始看起，那就是行内元素和块级元素有什么异同呢？ 可能你觉得这是一个老掉牙的问题，但其实并没有那么简单，对于初学者来说，脑海里的第一印象是 CSS 的 display 属性，值为 inline 时为行内元素，值为 block 时为块级元素，那值为 inline-block 时呢，元素是块级行内元素吗？ 其实我们看问题的角度从一开始就错了，错误地站在了 CSS 的角度，而真正正确的是站在 HTML 的角度，因为这里的元素本质上是指的是 HTML 的 DOM 元素，所以下面我们就来深入的了解一下 inline 元素 这里需要结合我们之前介绍过的 BFC 和 IFC 相关内容来一起进行了解 inline 元素在 HTML 中，行内元素是那些仅仅占据定义元素边界的标签空间的元素，而不会去破坏内容流，一个行内元素不会在新的一行开始，而且仅仅占据必要的元素宽度空间，不会多占空间，比如下面这个例子 1&lt;p&gt;The following span is an &lt;span&gt;inline element&lt;/span&gt;&lt;/p&gt; 我们一眼就可以看出，由于 span 是行内元素，所以上面这段话是会显示在一行当中的，但是如果我们此时将 span 的 display 属性调整成 block 以后，就会发现它将会另起一行来进行展示，那么为什么会这样显示呢？ 简单来说就是，因为我们手动的指定了 span 的 display 属性为 block，就相当于告诉浏览器我们需要将一个 inline 元素，渲染成 block box 而不是 inline box，所以这里就涉及到一个新的概念 block-level，下面我们就来看看这个 block-level block-level简而言之，在概念上 inline 和 block-level 元素有以下区别 Content Model，行内元素仅仅包含数据和其他的行内元素，比如不能在 inline elements 的内部去添加 block elements Formatting，默认情况下行内元素不会在文档流的开始位置强制生成一个新行，而如果是 block 元素的话，正好与之相反，会很显著地另起一行来进行展示（但是可以使通过 CSS 来进行改变） HTML 元素通常要么是 block-level 元素，要么是 inline elements，一个 block-level 元素，会占据它的父元素，也就是容器的全部空间，从而新建了一个 block，通常从一个新的行开始，占据可用空间的全部宽度（从左到右尽可能的拉伸），但是至于为什么会这样渲染，我们就需要更为深入的来了解一下 Level 3 规范中定义的 display 属性 display 属性display 属性指明了元素渲染盒子的类型，在 HTML 中，默认 display 属性值取自 HTML 规范或浏览器/用户默认样式表中描述的行为，关于 display 值有以下几种分类，这里我们主要看前面三点 &lt;display-outside&gt;，指明了元素外部的展现类型，这基本是它在流式布局中的作用，例如 inline，block inline，这个元素生成一个或者多个行内盒子 block，这个元素生成一个块元素盒子 &lt;display-inside&gt;，指明了元素内部的展现类型，定义了布局 formatting context 的类型（假设它是一个不可替换的元素），例如 table，flex，grid table，元素就像 HTML 当中的 &lt;table&gt; 标签一样表现，它定义了一个 block-level 盒子 flex，元素表现形式是块级元素，根据 flexbox model 绘制自己的内容 grid，元素表现得像块级元素，根据 grid model 绘制自己的内容 &lt;display-legacy&gt;，CSS2 使用单关键字的语法为 display 属性设置值，在同一个 layout 模型中，为块级元素和行内元素引用分离的关键词，例如 inline-block，inline-table 等等 inline-block，元素生成一个块元素盒子，它会被周围的内容包裹，就仿佛它是一个 inline box 一样，等价于 inline flow-root inline-table，它表现地就像 HTML 标签一样，但是是一个 inline box，而不是 block-level 盒子，在 table 盒子内部是块级内容，等价于 inline table inline-flex，行内元素表现，布局内容时根据 flexbox 模型布局，等价于 inline flex inline-grid，行内元素展现，布局内容时根据 grid 模型 &lt;display-listitem&gt;，元素生成了用来存放内容的块盒子以及一个分离的 list-item 行内盒子，例如 list-item &lt;display-internal&gt;，一些布局模型，例如 table 和 ruby，它只在特定的 layout mode 下才会生效，例如 table-row-group，table-header-group 等等 &lt;display-box&gt;，是否展示 box，例如 none，contents（实验中） 通过上面的列表，我们可以大致发现 CSS 属性 display 是如何影响元素的了，它大多数情况是通过修改 &lt;display-outside&gt;，&lt;display-inside&gt; 这两个属性值去改变元素外部的流式布局和元素内部的 formatting context，其中 formatting context 会根据 model 类型进行渲染，也因此我们上面的问题也就迎刃而解了，那就是 display 值从 inline 更改为 block 的原理 本质上是改变了 &lt;display-outside&gt;，改变了元素的流式布局，也就是从生成一个 inline 盒子，变为生成一个 block 盒子 特性最后我们再来看看它们三者之间的特性差异，我们先来看看 block，它比较简单，它可以设置元素为块级元素，可应用盒子模型相关属性，默认 width 为 100%，height 自适应，margin、padding 都有效，如果没有占宽或高的子元素存在，则高度为零，这个也是平常很常见的情况 inline-block 元素是 inline + block 的合体，它的 margin、padding、width 和 height 都有效，但是 block/inline-block 元素包裹的 inline-block 元素，默认超过 width 会换行，而 hieght 则会撑开，但是可以通过 white-space: nowrap 强制不换行，但是就不能实现文本省略显示了，另外它也存在着和我们下面将要介绍的 inline 一样的问题，那就是存在 8 像素的间隔问题 关于 inline，行内元素或者通过 display: inline 修饰为行内元素的都具有行内元素的行为，多个 inline 元素会排成一行，但是它最为出名的问题那就是并列的多个 inline 元素之间会存在 8 个像素左右的间隔，比如下面这个例子 123&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt; 运行以后可以发现，在页面当中显示的时候，它们三者之前并不是仅仅靠在一起的，而是之间互有距离，那么怎么解决这个问题呢？解决办法有很多种，我们一个一个来看，第一种也是最为简便的方式，就是将它们三者放在一行当中，如下 1&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt; 第二种方式就是利用 margin-left: -8px，也就是 marginq 负值实现，也可以在外层使用 letter-spaceing 和 word-spaceing 为负值的方式实现（此种试子元素需要重置被设置属性） 1234&lt;div class=\"inline\"&gt;inline01&lt;/div&gt;&lt;div class=\"inline\"&gt;inline02&lt;/div&gt;&lt;div class=\"inline\"&gt;inline03&lt;/div&gt;&lt;div class=\"inline\"&gt;inline04&lt;/div&gt; 1234567.inline{ display: inline; background: red; margin: 0px; padding: 10px; margin-left: -8px;} 第三种方式就是在包裹 inline 元素的外层元素加上 font-size: 0px 和 -webkit-text-size-adjust: none 来进行实现 1234&lt;div class=\"overWidth\"&gt; &lt;a&gt;1&lt;/a&gt; &lt;a&gt;123456&lt;/a&gt;&lt;/div&gt; 12345678a{ background: red; font-size: 14px;}.overWidth{ font-size: 0px; -webkit-text-size-adjust: none;} 此外，inline 元素的 width 和 height 都是无效的，但是 padding 有效，并且 margin 只有左右有效，上下无效，而且 inline 元素包裹 inline 元素，外层元素的 width 和 height 会被内部的撑开，可是使用上面 overWidth 的示例来进行测试 但是如果是被 block/inline-block 元素包裹的 inline 元素，默认 width 超出会自动换行，而 height 则会撑开，如果想要实现强制不换行可以通过 white-space: nowrap 来实现，但是此时超出 width 的部分会有溢出，可以通过 overflow: hidden 和 text-overflow: ellipsis 配合实现省略显示","link":"/2018/11/29/CSS/13/"},{"title":"CSS 当中的 line-height","text":"我们在之前的章节当中介绍过了 CSS 当中的 float，display 和 position 属性，今天我们接着上回继续来看 CSS 当中另一个使用比较多的的属性，那就是 line-height，关于它的具体内容可以参考 CSS 2.1 规范 9.4.2 inline-formatting，可以参考下面这个例子来看看 line-height 的基本用法（转自 MDN） 行高是指行间的距离，而从规范上来说则是两行文字基线之间的距离，行高是作用在每一个行框盒子（line-box）上的，而行框盒子则是由内联盒子组成，因此行高与内联元素可以说是非常紧密，行高直接决定了内联元素的高度（注意，这里的内联元素不包括替换元素），对于块级元素和替换元素，行高是无法决定最终高度的，只能决定行框盒子的最小高度，那么这里就会存在几个问题了 基线是什么？ 只有两行文字才会存在两个基线，那么为什么单行文字还具有行高？ 行框盒子与内联盒子又是什么？ 什么是替换元素？ 行高的取值是如何决定的？ 不要急，让我们带着这些疑问慢慢往下看 x、x-height 以及 ex字母 x 在 CSS 里面扮演着一个很重要的角色，因为字母 x 的下边缘就是基线所在的位置，而 x-height 指的就是字母 x 的高度，ex 是一个尺寸单位，其大小是相对字母 x 的来计算的，即 1ex 就表示 1 个字母 x 的高度，如下图所示 我们在平时的开发中很少用到 ex，因为 ex 是个相对单位，对于相对的东西，我们总是感觉很难控制，但这并不表明 ex 就一点用处都没有，我们可以利用 ex 就是一个 x-height 的特性来实现图标与文字的垂直居中，这样如论字体大小如何变化，都不会影响垂直居中的效果，代码如下 1234567.icon-arrow { display: inline-block; width: 20px; height: 1ex; background: url(down.png) no-repeat center; background-size: contain;} 1234&lt;div&gt; &lt;span&gt;我是一段文本&lt;/span&gt; &lt;i class=\"icon-arrow\"&gt;&lt;/i&gt;&lt;/div&gt; 行内框盒子模型在深入展开之前，我们先来了解一下行内框盒子模型的概念，先从一个简单的示例开始，如下 1&lt;p&gt;这是一个单行文字，这里有一个&lt;span&gt;内容区&lt;/span&gt;标签。&lt;/p&gt; 运行起来以后在页面上的显示是下面这样的 在这里，我们主要了解四个概念，分别是内容区域，内联盒子，行框盒子以及包含盒子，它们的区别如下 内容区域（content area），是围绕文字的盒子，也就是底线和顶线包裹的区域，我们可以看做是图中鼠标选中文字区域的大小，实际中不一定看得到，但确实存在，内容区的大小依据 font-size 的值和字数进行变化（行内元素 display：inline 可以通过 background-color 属性显示出来） 内联盒子（inline boxs），不会让文字成块显示，而是排列成一行，由内联元素包裹的文字如 span 标签包裹的内容区，可以称之为内联盒子，而没有内联元素包裹的部分，我们可以看做是匿名内联盒子，内联盒子可以看是上图当中 span 标签内的内容区区域，而匿名内联盒子可以看做红色虚线包裹的内容 行框盒子（line boxs），每一行都是一个行框盒子，行框盒子由一个个匿名和非匿名内联盒子组成，可以看做上图当中最外面红色实线包裹的区域 包含盒子（containing box），此盒子由一个个行框盒子组成，&lt;p&gt; 标签就代表了一个包含盒子 行高、行距在了解完行内框盒子模型的概念以后，我们接着来看我们在开头部分提出的疑问，我们在上面曾提到，行高是指行间的距离，而从规范上来说则是两行文字基线之间的距离，而基线（baseline）指的是一行字横排时下沿的基础线，也就是下图当中标注红线的部分，由此我们根据下图推断出 单行文字行高为 1line-height = 内容区域高度 + 行间距高度 同样的，我们可以得出 1行间距 = line-height - 内容区域高度 由于行间距是上下均分的，所以从上图当中我们也能看出，半行间距也就是文字上部与行框盒子的顶部之间的距离，但是这里肯定会问了，line-height 明明是两基线之间的距离，单行文字哪来行高，还控制了高度？ 这里需要我们慢慢来进行梳理，行高由于其继承性，影响无处不在，即使单行文本也不例外，并且高度的表现本质上也不是行高，而是内容区域和行间距决定的，内容区域高度只与字号以及字体有关，与 line-height 没有任何关系（比如在 SimSun 字体下，内容区域高度等于 SimSun），换句话说就是在 SimSun 字体下的表现如下 1font-size + 行间距 = line-height 说完了行高，我们再来看看行距，我们还是以上图为例，在图中我们可以发现，上一行的底线和下一行的顶线之间的距离就是行距，那么它的作用到底是什么呢？我们可以想象一下在文字排版的时候，如果行与行之间的间距为 0，则文字是会紧紧贴在一起的，因此行距就是用来协助排版的，也正是因为行距的存在，所以我们给元素设置 margin 值时，要减去相应的半行距值，这样才能比较精确地还原设计图 替换元素在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的，这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的，简单来说，它们的内容不受当前文档的样式的影响，CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容，某些可替换元素，例如 &lt;iframe&gt; 元素，可能具有自己的样式表，但它们不会继承父文档的样式，CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式 CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值，不过需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align，只有可替换元素才能具有这种自带值 行内替换元素需要使用 line-height 值，从而在垂直对齐时能正确地定位元素，因为 vertical-align 的百分数值是相对于元素的 line-height 来计算的，对于垂直对齐来说，图像本身的高度无关紧要，关键是 line-height 的值，默认地，行内替换元素位于基线上，如果向替换元素增加下内边距、外边距或边框，内容区会上移 替换元素的基线是正常流中最后一个行框的基线，除非该替换元素内容为空或者本身的 overflow 属性值不是 visible，这种情况下基线是 margin 底边缘 某些 CSS 属性可用于指定可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式，这些属性的具体定义可以在 CSS Images Module Level 3 和 CSS Images Module Level 4 规范中找到 取值line-height 的取值有以下这些 取值 描述 normal normal 为 line-height 的默认值，但并不是一个固定的值，而是会受 font-family 的影响，对于微软雅黑，其值为 1.32，而对于宋体，其值为 1.141，由于不同操作系统，不同浏览器所使用的字体不一样，所以最终 line-height 的具体值会不一样，因此这个属性作用不大 &lt;number&gt; 使用数值作为行高，根据当前元素的 font-size 大小计算，大多数情况下，这是设置 line-height 的推荐方法，不会在继承时产生不确定的结果，比如 line-height: 1.5 &lt;length&gt; 长度用的最多的就是 px 与 em，em 跟数字一样，都是相对于 font-size 来计算的，以 em 为单位的值可能会产生不确定的结果，比如 line-height: 1.5em，line-height:1.5rem，line-height: 20px &lt;%&gt; 使用百分比作为行高值，相对于设置了该 line-height 属性的元素的 font-size 大小计算，与元素自身的字体大小有关，计算值是给定的百分比值乘以元素计算出的字体大小，百分比值可能会带来不确定的结果，比如 line-height: 150% 这里还有一个比较特殊的 inherit 属性，即行高继承，那么这里就存在一个问题，我们在之前提到过，行高默认具有继承性的，但是这里为什么还要多提供一个属性来给我们选择呢？ 这是因为控件元素的默认行高是 normal，而不是继承父级元素的行高，比如我们来看下面这个示例，即 line-height: 1.5、line-height: 1.5em;、line-height: 150% 之间的区别，在计算结果上是相同的，但是所影响的元素有区别 line-height: 1.5，所有可继承元素会根据 font-size 重新计算行高（也就是说其子元素都会根据自身的 font-size * 1.5 计算行高，每个子元素都要进行一次计算） line-height: 150%/1.5em，当前元素会根据 font-size 先计算行高，然后再继承给下面的元素（当前元素根据 font-size 计算行高，然后将所计算的出来的值继承给后代，也就是说只需要当前元素进行计算，而子元素不需要重新计算，并且此时子元素设置 font-size 对其 line-height 是无影响的） 这里提一点针对于全局数值使用的经验，其实简单来说，比较推荐使用数字来设置 line-height，也就是无单位的使用方式，如果是 blog 以阅读为主的网页，line-height: 1.5/1.6 较为适宜，如果是面向用户，并不是阅读为主的网页，则推荐使用匹配 20 像素的使用经验，如下 1body { font-size: 14px; line-height：1.4286 } 或者合并形式 1body { font: 14px / 1.4286 'microsoft yahei' } line-height 与图片的表现有一个比较常见的问题，也就是下面这种情况，我们在 div 标签当中嵌入一张图片，没有给 div 元素设置任何属性，仅仅只设置了 background: palegreen，代码如下 123div { background: palegreen;} 但是在页面展示的效果却是下面这样的（注意观察图片底部绿色部分） 这是因为内联元素默认基线对齐，空白标签内含有空白节点，相当于图片和一个文字对齐，根据 vertical-align: baseline，所以图片底部存在间距，这里的空白节点我们可以理解成一个字母 A，因为是基线对齐，且父元素没有设置固定高度，所以父元素高度由内容填充，由于 A 要与图片基线对齐，所以就会在下边缘，也就是下图这样的情况 这样一来是不是就可以一眼看出问题所在了，针对于这种情况，解决的办法主要有以下三种 将图片块状化，这时就无基线对齐，因为 vertical-align 属性只对内联，内联块状元素有效 使用 vertical-align：bottom 来将图片的底线对齐，或者减小行高（这时基线的位置会上移） 对于父元素使用 line-height: 0 使得行高足够小，使基线上移 另外一种比较常见的用法就是图片水平垂直居中，代码如下 123&lt;div&gt; &lt;img src=\"https://gitee.com/heptaluan/backups/raw/master/cdn/cover/15.webp\"&gt;&lt;/div&gt; 12345678div { line-height: 300px; text-align: center;}img { vertical-align: middle;} 显示效果如下 原理是当设置 text-align 的时候，内联元素文字和图片会居中显示，我们让空白节点的行高与 div 高度一致，这样就可以实现垂直居中，图片和空白节点默认基线对齐，另外我们也可以将其中的图片替换为多行文本从而实现多行文本垂直居中，代码如下 123&lt;div&gt; &lt;span&gt;这里是多行文本 ...&lt;/span&gt;&lt;/div&gt; 12345678910div { line-height: 300px; text-align: center;}span { display: inline-block; line-height: normal; vertical-align: middle;} 显示效果如下 多行文本垂直居中的原理和上面图片是一样的，我们可以把 span 看做是图片，这样就需要将 span 的元素 display 设置成 inline-block，并且重置 line-height 既可 参考 line-height vertical-align 可替换元素 CSS Images Module Level 3 CSS Images Module Level 4","link":"/2018/12/10/CSS/15/"},{"title":"CSS 当中的 z-index","text":"我们在之前的 position 章节当中介绍的固定定位部分，曾经提起过 z-index 这个属性，但是在之前我们只是简单的提及了一下，并没有深入的去了解它，所以在今天就抽点时间来深入的了解一下 CSS 当中的 z-index 层叠上下文层叠上下文（Stacking Context），是 HTML 元素的三维概念，这些 HTML 元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间 所有的盒模型元素都处于三维坐标系中，除了我们常用的横坐标和纵坐标，盒模型元素还可以沿着 z 轴层叠摆放，当他们相互覆盖时，z 轴顺序就变得十分重要，但 z 轴顺序，不完全由 z-index 决定，在层叠比较复杂的 HTML 元素上使用 z-index 时，结果可能让人觉得困惑，甚至不可思议，这是由复杂的元素排布规则导致的，我们来看下面这个图 在层叠上下文中，其子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元 层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文 每个层叠上下文完全独立于它的兄弟元素，当处理层叠时只考虑子元素 每个层叠上下文是自包含的，当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠 如何形成层叠上下文？我们这里只介绍以下这些比较常见的方式，完整的列表可以参考 MDN-层叠上下文的形成 根元素（HTML） 定位元素（relative、absolute），并且 z-index 不为 auto opacity 小于 1 时 transform 不为 none 时 z-index 不为 auto 的 flex-item 这里有一个需要注意的地方，即层叠上下文的层级是 HTML 元素层级的一个层级，因为只有某些元素才会创建层叠上下文，所以可以认为没有创建自己的层叠上下文的元素将被父元素的层叠上下文所包含，来看下面这个示例 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"div1\"&gt; &lt;h1&gt;Division Element #1&lt;/h1&gt; &lt;code&gt;position: relative;&lt;br/&gt; z-index: 5;&lt;/div&gt;&lt;div id=\"div2\"&gt; &lt;h1&gt;Division Element #2&lt;/h1&gt; &lt;code&gt;position: relative;&lt;br/&gt; z-index: 2;&lt;/div&gt;&lt;div id=\"div3\"&gt; &lt;div id=\"div4\"&gt; &lt;h1&gt;Division Element #4&lt;/h1&gt; &lt;code&gt;position: relative;&lt;br/&gt; z-index: 6; &lt;/div&gt; &lt;h1&gt;Division Element #3&lt;/h1&gt; &lt;code&gt;position: absolute;&lt;br/&gt; z-index: 4; &lt;div id=\"div5\"&gt; &lt;h1&gt;Division Element #5&lt;/h1&gt; &lt;code&gt;position: relative;&lt;br/&gt; z-index: 1; &lt;/div&gt; &lt;div id=\"div6\"&gt; &lt;h1&gt;Division Element #6&lt;/h1&gt; &lt;code&gt;position: absolute;&lt;br/&gt; z-index: 3; &lt;/div&gt; &lt;/div&gt; 1234567891011html { padding: 20px; font: 12px/20px Arial, sans-serif; }div { opacity: 0.7; position: relative; }h1 { font: inherit; font-weight: bold; }#div1, #div2 { border: 1px dashed #696; padding: 10px; background-color: #cfc; }#div1 { z-index: 5; margin-bottom: 190px; }#div2 { z-index: 2; }#div3 { z-index: 4; opacity: 1; position: absolute; top: 40px; left: 180px; width: 330px; border: 1px dashed #900; background-color: #fdd; padding: 40px 20px 20px; }#div4, #div5 { border: 1px dashed #996; background-color: #ffc; }#div4 { z-index: 6; margin-bottom: 15px; padding: 25px 10px 5px; }#div5 { z-index: 1; margin-top: 15px; padding: 5px 10px; }#div6 { z-index: 3; position: absolute; top: 20px; left: 180px; width: 150px; height: 125px; border: 1px dashed #009; padding-top: 125px; background-color: #ddf; text-align: center; } 如下图所示 层叠上下文如何影响层叠主要分为以下几种情况 元素的 background 和 borders 拥有负层叠层级（negative-stack-levels）的子层叠上下文（child-stacking-contexts） 在文档流中的（in-flow），非行内级的（non-inline-level），非定位（non-positioned）的后代元素 非定位的浮动元素 在文档流中的（in-flow），行内级的（inline-level），非定位（non-positioned）的后代元素，包括行内块级元素（inline-blocks）和行内表格元素（inline-tables） 层叠层级为 0 的子层叠上下文（child-stacking-contexts）和层叠层级为 0 的定位的后代元素 层叠层级为正的子层叠上下文 上述关于层次的绘制规则递归地适用于任何层叠上下文，看下面这个示例 123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"lev1\"&gt; &lt;span class=\"bold\"&gt;LEVEL #1&lt;/span&gt; &lt;div id=\"container1\"&gt; &lt;div class=\"lev2\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;LEVEL #2&lt;/span&gt; &lt;br /&gt;z-index: 1; &lt;div id=\"container2\"&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;div class=\"lev3\"&gt;&lt;span class=\"bold\"&gt;LEVEL #3&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"lev2\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;LEVEL #2&lt;/span&gt; &lt;br /&gt;z-index: 1; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"lev1\"&gt; &lt;span class=\"bold\"&gt;LEVEL #1&lt;/span&gt;&lt;/div&gt;&lt;div class=\"lev1\"&gt; &lt;span class=\"bold\"&gt;LEVEL #1&lt;/span&gt;&lt;/div&gt;&lt;div class=\"lev1\"&gt; &lt;span class=\"bold\"&gt;LEVEL #1&lt;/span&gt;&lt;/div&gt; 1234567div { font: 12px Arial; }span.bold { font-weight: bold; }div.lev1 { width: 250px; height: 70px; position: relative; border: 2px outset #669966; background-color: #ccffcc; padding-left: 5px; }#container1 { z-index: 1; position: absolute; top: 30px; left: 75px; }div.lev2 { opacity: 0.9; width: 200px; height: 60px; position: relative; border: 2px outset #990000; background-color: #ffdddd; padding-left: 5px; }#container2 { z-index: 1; position: absolute; top: 20px; left: 110px; }div.lev3 { z-index: 10; width: 100px; position: relative; border: 2px outset #000099; background-color: #ddddff; padding-left: 5px; } 页面展示如下 下面我们就来分几情况讨论元素是如何影响层叠的 不含 z-index 元素如何层叠当没有元素包含 z-index 属性时，元素按照如下顺序层叠（从底到顶顺序） 根元素（&lt;html&gt;）的背景和边界 位于普通流中的后代无定位块级元素，按它们在 HTML 中的出现顺序层叠 后代中的定位元素，按它们在 HTML 中的出现顺序层叠 这里需要注意一点，即普通流中的无定位块级元素『始终先于』定位元素渲染，并出现在定位元素下层，即便它们在 HTML 结构中出现的位置晚于定位元素也是如此，我们来看下面这个例子 123456789101112131415&lt;div id=\"abs1\" class=\"absolute\"&gt; &lt;b&gt;DIV #1&lt;/b&gt;&lt;br /&gt;position: absolute;&lt;/div&gt;&lt;div id=\"rel1\" class=\"relative\"&gt; &lt;b&gt;DIV #2&lt;/b&gt;&lt;br /&gt;position: relative;&lt;/div&gt;&lt;div id=\"rel2\" class=\"relative\"&gt; &lt;b&gt;DIV #3&lt;/b&gt;&lt;br /&gt;position: relative;&lt;/div&gt;&lt;div id=\"abs2\" class=\"absolute\"&gt; &lt;b&gt;DIV #4&lt;/b&gt;&lt;br /&gt;position: absolute;&lt;/div&gt;&lt;div id=\"sta1\" class=\"static\"&gt; &lt;b&gt;DIV #5&lt;/b&gt;&lt;br /&gt;position: static;&lt;/div&gt; 12345678910b { font-family: sans-serif;}div { padding: 10px; border: 1px dashed; text-align: center;}.static { position: static; height: 80px; background-color: #ffc; border-color: #996;}.absolute { position: absolute; width: 150px; height: 350px; background-color: #fdd; border-color: #900; opacity: 0.7;}.relative { position: relative; height: 80px; background-color: #cfc; border-color: #696; opacity: 0.7;}#abs1 { top: 10px; left: 10px;}#rel1 { top: 30px; margin: 0px 50px 0px 50px;}#rel2 { top: 15px; left: 20px; margin: 0px 50px 0px 50px;}#abs2 { top: 10px; right: 10px;}#sta1 { background-color: #ffc; margin: 0px 50px 0px 50px;} 以上代码运行完成以后是下面这样的 这里有一个需要注意的地方，就是上图当中的 div#5，由于其是非定位块级元素，虽然它在 DOM 顺序上处于最后，但它的渲染始终位于定位元素下面 浮动的块元素如何层叠对于浮动的块元素来说，层叠顺序变得有些不同，浮动块元素被放置于非定位块元素与定位块元素之间，它遵循以下的规律 根元素（&lt;html&gt;）的背景和边界 位于普通流中的后代无定位块级元素，按它们在 HTML 中的出现顺序层叠 浮动块元素 位于普通流中的后代无定位行内元素 后代中的定位元素，按它们在 HTML 中的出现顺序层叠 同样的，我们也来看一个示例，如下 123456789101112131415161718&lt;div id=\"abs1\"&gt; &lt;b&gt;DIV #1&lt;/b&gt;&lt;br /&gt;position: absolute;&lt;/div&gt;&lt;div id=\"flo1\"&gt; &lt;b&gt;DIV #2&lt;/b&gt;&lt;br /&gt;float: left;&lt;/div&gt;&lt;div id=\"flo2\"&gt; &lt;b&gt;DIV #3&lt;/b&gt;&lt;br /&gt;float: right;&lt;/div&gt;&lt;br /&gt;&lt;div id=\"sta1\"&gt; &lt;b&gt;DIV #4&lt;/b&gt;&lt;br /&gt;no positioning&lt;/div&gt;&lt;div id=\"abs2\"&gt; &lt;b&gt;DIV #5&lt;/b&gt;&lt;br /&gt;position: absolute;&lt;/div&gt; 1234567div { padding: 10px; text-align: center; }b { font-family: sans-serif; }#abs1 { position: absolute; width: 150px; height: 200px; top: 20px; right: 160px; border: 1px dashed #900; background-color: #fdd; }#sta1 { height: 100px; border: 1px dashed #996; background-color: #ffc; margin: 0px 10px 0px 10px; text-align: left; }#flo1 { margin: 0px 10px 0px 20px; float: left; width: 150px; height: 200px; border: 1px dashed #090; background-color: #cfc; }#flo2 { margin: 0px 20px 0px 10px; float: right; width: 150px; height: 200px; border: 1px dashed #090; background-color: #cfc; }#abs2 { position: absolute; width: 300px; height: 100px; top: 150px; left: 100px; border: 1px dashed #990; background-color: #fdd; } 以上代码运行完成以后是下面这样的 注意与上面不含 z-index 元素对比查看，下面我们就来看看我们今天的主角，z-index 如何影响层叠 z-index 如何影响层叠z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order，当元素之间重叠的时候 z-order 决定哪一个元素覆盖在其余元素的上方显示，通常来说 z-index 较大的元素会覆盖较小的一个 对于一个已经定位的元素（即 position 属性值不是 static 的元素），z-index 属性指定 元素在当前层叠上下文中的层叠层级 元素是否创建一个新的本地层叠上下文 同样的，看下面这个示例 12345678910111213141516171819202122232425&lt;div id=\"absdiv1\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;DIV #1&lt;/span&gt; &lt;br /&gt;position: absolute; &lt;br /&gt;z-index: 5;&lt;/div&gt;&lt;div id=\"reldiv1\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;DIV #2&lt;/span&gt; &lt;br /&gt;position: relative; &lt;br /&gt;z-index: 3;&lt;/div&gt;&lt;div id=\"reldiv2\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;DIV #3&lt;/span&gt; &lt;br /&gt;position: relative; &lt;br /&gt;z-index: 2;&lt;/div&gt;&lt;div id=\"absdiv2\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;DIV #4&lt;/span&gt; &lt;br /&gt;position: absolute; &lt;br /&gt;z-index: 1;&lt;/div&gt;&lt;div id=\"normdiv\"&gt; &lt;br /&gt;&lt;span class=\"bold\"&gt;DIV #5&lt;/span&gt; &lt;br /&gt;no positioning &lt;br /&gt;z-index: 8;&lt;/div&gt; 1234567div { opacity: 0.7; font: 12px Arial; }span.bold { font-weight: bold; }#normdiv { z-index: 8; height: 70px; border: 1px dashed #999966; background-color: #ffffcc; margin: 0px 50px 0px 50px; text-align: center; }#reldiv1 { z-index: 3; height: 100px; position: relative; top: 30px; border: 1px dashed #669966; background-color: #ccffcc; margin: 0px 50px 0px 50px; text-align: center; }#reldiv2 { z-index: 2; height: 100px; position: relative; top: 15px; left: 20px; border: 1px dashed #669966; background-color: #ccffcc; margin: 0px 50px 0px 50px; text-align: center; }#absdiv1 { z-index: 5; position: absolute; width: 150px; height: 350px; top: 10px; left: 10px; border: 1px dashed #990000; background-color: #ffdddd; text-align: center; }#absdiv2 { z-index: 1; position: absolute; width: 150px; height: 350px; top: 10px; right: 10px; border: 1px dashed #990000; background-color: #ffdddd; text-align: center; } 运行完以后是下面这样的 这里需要注意上面的 div#5，由于其不是定位元素，所以 z-index 是不生效的 于非浮层元素，避免设置 z-index 值，原因是定位元素一旦设置了 z-index 值，就从普通定位元素变成了层叠上下文元素，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的 z-index 值也无法覆盖其他元素的问题 实战看完了上面关于层叠上下文的一些介绍以后，我们来一个关于层叠相关的面试题，加深一下印象，它要求写出以下六个 div 元素的堆叠顺序，要求最上面的元素排在第一个位置，代码如下 12345678&lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt;&lt;/div&gt; &lt;div class=\"three\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"four\"&gt; &lt;div class=\"five\"&gt;&lt;/div&gt; &lt;div class=\"six\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.one { position: relative; z-index: 2; .two { z-index: 6; } .three { position: absolute; z-index: 5; }}.four { position: absolute; z-index: 1; .five {} .six { position: absolute; top: 0; left: 0; z-index: -1; }} 最后的答案为 .three .two .one .five .six .four，可以将各元素添加一个背景色用于测试 参考 层叠上下文 深入理解 CSS 中的层叠上下文和层叠顺序 The Z-Index CSS Property: A Comprehensive Look","link":"/2019/02/02/CSS/17/"},{"title":"样式的层叠权重值","text":"在学习 CSS 的过程当中，我们可能听说过特指度（I-C-E）这个东西，简单来说特指度表示一个 CSS 选择器表达式的重要程度，通常称为 I-C-E 计算公式，其中的 I 对应着 Id，C 对应着 class，E 对应着 Element，在针对一个 CSS 选择器表达式的时候，遇到一个 Id 就往特指度数值中加 100，遇到一个 class 就往特指度数值中加 10，遇到一个 Element 就往特指度数值中加 1 但是上面的这种计算方式是存在一定问题的，虽然在大多数情况下，按照这样的理解得出的结论是没有问题的，但是在一些比较特殊的情况之下还是存在问题的，所以今天就抽了点时间，让我们一起来深入的了解一下 CSS 当中的样式层叠权重值，既然是样式层叠权重值，那么我们就先来看看什么是权重 CSS 权重CSS 权重，我们可以简单理解为 CSS 优先级，下面是 MDN 对优先级的描述 浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值，优先级是基于不同种类选择器组成的匹配规则 我们通过一个小例子来加深理解 1&lt;p class=\"text\" id=\"text\"&gt;我是一段简单的文本。&lt;/p&gt; 1234567.text { color: red;}#text { color: blue;} 运行后可以发现，p 标签文本的颜色为蓝色，那么为什么会是蓝色呢？这就是 CSS 权重来决定的，它决定最终用哪个样式作用到 p 标签上，在网上流传的说法当中，关于选择器各级别的优先级，大家应该已经很清楚了，常见的说法是下面这样的 1!important &gt; 内联 &gt; ID &gt; 类 &gt; 标签/伪类/属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承 那么这个顺序是怎么得出来的呢？ 实际上在 CSS 2.1 规范当中关于 具体性（specificity） 的定义当中，描述是非常明确的，根据 CSS 规范，具体性越明确的样式规则，权重值越高，而计算权重值的依据，并不像是我们在开头部分所描述的 class 是 10，标签是 1，Id 是 100 之类的，虽然这样在大多数情况下能够得到正确的结果 选择器权重值的计算下面我们就根据 CSS 规范，来具体的看一下选择器权重值到底是如何进行计算的，主要有以下四点 A，如果规则是写在标签的 style 属性中（内联样式），则 A = 1，否则 A = 0，对于内联样式，由于没有选择器，所以 B、C、D 的值都为 0，即 A = 1，B = 0，C = 0，D = 0（简写为 1, 0, 0, 0） B，计算该选择器中 Id 的数量（例如 #header 这样的选择器计算为 0, 1, 0, 0） C，计算该选择器中伪类及其它属性的数量，包括类选择器、属性选择器等，不包括伪元素（例如 .logo[id='site-logo'] 这样的选择器，计算为 0, 0, 2, 0） D，计算该选择器中伪元素及标签的数量（例如 p:first-letter 这样的选择器，计算为 0, 0, 0, 2） 我们可以根据上面的规则来对应看看下面这些示例 12345678910* {} /* a = 0 b = 0 c = 0 d = 0 ==&gt; specificity = 0, 0, 0, 0 */li {} /* a = 0 b = 0 c = 0 d = 1 ==&gt; specificity = 0, 0, 0, 1 */li:first-line {} /* a = 0 b = 0 c = 0 d = 2 ==&gt; specificity = 0, 0, 0, 2 */ul li {} /* a = 0 b = 0 c = 0 d = 2 ==&gt; specificity = 0, 0, 0, 2 */ul ol+li {} /* a = 0 b = 0 c = 0 d = 3 ==&gt; specificity = 0, 0, 0, 3 */h1+*[rel=up] {} /* a = 0 b = 0 c = 1 d = 1 ==&gt; specificity = 0, 0, 1, 1 */ul ol li.red {} /* a = 0 b = 0 c = 1 d = 3 ==&gt; specificity = 0, 0, 1, 3 */li.red.level {} /* a = 0 b = 0 c = 2 d = 1 ==&gt; specificity = 0, 0, 2, 1 */#x34y {} /* a = 0 b = 1 c = 0 d = 0 ==&gt; specificity = 0, 1, 0, 0 */style='' /* a = 1 b = 0 c = 0 d = 0 ==&gt; specificity = 1, 0, 0, 0 */ 根据这样的定义，在网上有很多文章简单地把规则归纳为 针对内联样式的权重值是 1000，Id 选择器的权重值是 100，Class 选择器的权重值是 10，标签选择器的权重值是 1，整条规则中的所有选择器权重值相加得到整个样式规则的权重值，数字越大权重值越高 大多数情况下，按照这样的理解得出的结论没有问题，但是遇到下面这样的情况就出现问题了 12345/* 样式一 */body header div nav ul li div p a span em { color: red }/* 样式二 */count { color: blue } 如果按照错误的计算方法来进行计算的话，样式一的权重值是 11，样式二的权重值是 10，所以如果这两条规则用于同一个元素，则该元素应该是红色，但是实际的结果却是蓝色的，所以我们按照规范当中提到的方式再次来看看上面的示例，针对例子中的样式一权重值应该是 0, 0, 0, 11，而样式二的权重值是 0, 0, 1, 0，根据规范 计算权重值时 A, B, C, D 四组值，从左到右，分组比较，如果 A 相同，比较 B, 如果 B 相同，比较 C，如果 C 相同，比较 D，如果 D 相同，则后定义的优先 我们可以得出，样式二和样式一的 A、B 相同，而样式二的 C 大于样式一，所以不管 D 的值如何，样式二权重值都大于样式一，这就是正确的答案 特殊的 !important在按照 ABCD 四组计算比较之外，在定义样式的时候，还可以对某一个属性应用 !important，CSS 规范中规定 !important 用于单独指定某条样式中的单个属性，对于被指定的属性，有 !important 指定的权重值大于所有未用 !important 指定的规则 例如下面这个示例 12345/* 样式一 */#header nav ul li.current { color: red; font-weight: bold; }/* 样式二 */li:hover { color: blue !important; font-weight: normal; } 就整条规则而言，样式一的权重值为 0, 1, 1, 3，而样式二的权重值仅为 0, 0, 0, 2，所以应用于相同元素时，应该样式一生效，但是对于 color 这个属性，由于在样式二中用 !important 做了指定，因此 color 将应用样式二的规则，而 font-weight 则按照规定用样式一的规则 因此 !important 的作用只有在具有唯一性时才能提现，但是我们永远无法预料自己什么时候又需要覆盖一个已经指定了 !important 的属性，所以最好的办法就是不要使用 !important 这里有一个需要注意的地方，如果多条规则中都对同一个属性指定了 !important 呢？这时候 !important 的作用相互抵销，依然按照 ABCD 四组计算比较，更多详细内容可以参考 MDN 上的 例外的 !important 规则 下面是一些来自 MDN 上的一些经验法则 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important（比如引入了某些框架） 永远不要在全站范围的 CSS 上使用 !important 永远不要在你的插件中使用 !important 取而代之，你可以 更好的利用 CSS 级联属性 使用更具体的规则，在您选择的元素之前增加一个或多个元素，使选择器变得更加具体，并获得更高的优先级 比如下面这个例子 123&lt;div id=\"test\"&gt; &lt;span&gt;Text&lt;/span&gt;&lt;/div&gt; 123div#test span { color: green }span { color: red }div span { color: blue } 上面例子中，无论你 CSS 语句的顺序是什么样的，文本都会是绿色的，因为这一条规则是最具有针对性，优先级最高的（同理，无论语句顺序怎么样，蓝色的规则都会覆盖红色的规则），我们在之前提到了 !important 的相关规则和使用方式，但是在某些情况下，使用 !important 可能是无可避免的，那么我们该如何来覆盖 !important 呢，主要有下面三种方式 再添加一条带 !important 的 CSS 规则，其实就是要么给这个选择器更高的优先级（添加一个标签，Id 或 Class），或是添加一样的选择器，把它的位置放在原有声明的后面 使用相同的选择器，但是置于已有的样式之后 或者改写原来的规则，以避免使用 !important 关于 inherit除了直接指定到元素上的样式规则以外，每个属性值还有一个可能为 inherit 的值，表示元素的该样式属性继承自父级元素，与父级元素的定义一致，比如 12345&lt;ul class=\"list\"&gt; &lt;li class=\"item\"&gt; &lt;span&gt;某些文字&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 1.list .item { color: red } 在上例当中，我们将 li 的 color 样式设定为红色，但是并未针对 span 标签指定 color 属性，但是 span 中的文字会显示为红色，这就是因为 span 的 color 属性默认值为 inherit，对于 inherit 的属性，只要记住一点，即继承而来的属性值，权重永远低于明确指定到元素的定义，只有当一个元素的某个属性没有被直接指定时，才会继承父级元素的值，我们稍微调整一下 123.list .item { color: red }span { color: blue } 同样的例子，第一条规则按照 ABCD 四组计算的权重为 0, 0, 2, 0，第二条规则的权重为 0, 0, 0, 1，虽然第一条规则的权重更高，但是它是针对 li 元素的直接指定，并不是针对 span 元素定义的，所以计算 span 的 color 属性权重值时，实际上就是 inherit 的红色与直接指定的蓝色的对比，按照规则，只要有直接指定的值（蓝色），就不会再取继承的值（红色），所以 span 中的文字显示为蓝色 这条规则最典型的场景就是链接文字的颜色，由于一般浏览器自带的样式表都有针对 a 标签的颜色及下划线的直接指定，所以网页样式表中对 a 标签的父级元素指定 color 属性及 text-decoration 属性，通常不会起作用 123&lt;p class=\"txt\"&gt; &lt;a href=\"#\"&gt;父级元素设置的 color 和 text-decoration 对我不起作用&lt;/a&gt;&lt;/p&gt; 1234.txt { color: red; text-decoration: none;} 我们在浏览器可以看到，尽管我们给 a 标签的父级 p 设置了颜色红色和去除下划线，但是 a 标签依然是蓝色的和带下划线的，即使你给它们都加上 !important 也无效，但是我们可以通过下面的 reset 来改变这一点 123456789a { color: inherit; text-decoration: inherit;}.txt { color: red; text-decoration: none;} 可以看到，父级设置的样式生效了，由于我们的样式表对 a 标签直接指定了 color 和 text-decoration 属性值，覆盖了浏览器的默认样式，所以在没有特别指定 a 标签的颜色和下划线定义的前提下，会从父级元素 p 继承，因此链接会显示红色和没有下划线 特别补充，inherit 在 CSS1 规范中并未定义，所以 IE6/IE7/IE8 的 QuirksMode 不支持 关于 a 标签，我们再来看下面这个有趣的例子 1&lt;a href=\"#\"&gt;鼠标划入时，我的颜色是？&lt;/a&gt; 1234567a:hover { color: red;}a:link { color: blue;} 我们希望的效果是鼠标移入 a 标签的时候，文字变成红色的，但是实际仍然是蓝色，那么为什么会这样呢？其实，a 标签的四个伪类（:link、:hover、active、visited）的优先级是一样的，所以这时候就看它们在样式文件中的顺序了，后面的会覆盖前面的，为了避免出现这样的情况，我们在写 a 标签的伪类的时候，要注意它们的顺序，遵循 :link、:visited、:hover、:active 实例最后我们再来看一个实例，加深一下印象，如下，请问两个 p 标签的文本颜色分别是什么？ 12&lt;p class=\"blue red\"&gt;我的颜色是？&lt;/p&gt;&lt;p class=\"red blue\"&gt;我的颜色是？&lt;/p&gt; 1234567.red { color: red;}.blue { color: blue;} 你可能觉得一个颜色为红，一个为蓝，但是运行后可以发现，它们都是蓝色的，所以这里就需要注意了，class 中的类名的顺序并不会影响样式的优先级，而是由它们在样式文件中的先后顺序决定的，后面定义的优先级更高 总结 权重决定了你的 CSS 规则怎么样被浏览器解析直到生效 权重决定了哪一条规则会被浏览器应用到元素上 每个选择器都有自己的权重 权重的大小跟选择器的类型和数量有关 样式的优先级跟样式的定义顺序有关，后面的覆盖前面的 一条样式规则的整体权重值包含四个独立的部分 [A, B, C, D] A 表示内联样式，只有 1 或 0 两个值 B 表示选择器中 Id 的数量 C 表示选择器中类、属性、伪类选择器的数量 D 表示选择器中伪元素及标签的数量 比较时，从低位到高位（从 A 到 D）分别比较，高位相同时才比较低位 如果两个选择器作用到同一元素上，则权重高者生效 如果两个选择器权重相同，则最后定义的规则被计算到权重中（后面定义的 CSS 规则权重要更大，会覆盖前面的 CSS 规则） 标签选择器的权重永远都比一个类选择器的权重低，无论有多少个，除非使用 !important 有 !important 标记指定的属性权重值最高，多次指定时相互抵消，应尽量减少 !important 的使用 inherit 而来的属性定义，优先级低于任何直接指定的属性值 参考 优先级 CSS Specificity: Things You Should Know","link":"/2019/04/16/CSS/18/"},{"title":"线性表（顺序存储结构）","text":"在之前的 数据结构与算法 的章节当中，我们介绍了什么是数据结构和时间复杂度的相关概念，那么在这一章，我们就正式的开始深入的了解它们，我们就从最基本的线性表和线性表当中的顺序存储结构开始 什么是线性表线性表由零个或多个数据元素组成的有序序列，它有以下特点 它是一个序列，也就是说元素之间是先来后到的 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继 另外，线性表强调是有限的，事实上无论计算机发展到多大，它所处理的元素都是有限的 若将线性表记为 a1, a2 ... ai - 1, ai, ai + 1, ... an，则 ai - 1 领先于 ai，ai 领先于 ai + 1，称 ai - 1 是 ai 的直接前驱元素，ai + 1 是 ai 的直接后继元素，所以当线性表元素的个数 n（n &gt;= 0） 定义为线性表的长度，当 n = 0 的时候，称为空表（允许有空表） 抽象数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称，简单来说就是比如一些编程语言当中的整型，浮点型，字符型这些指的就是数据类型，例如在 C 语言当中，按照取值的不同，数据类型可以分为两类 原子类型，不可以再分解的基本类型，例如整型，浮点型，字符串型 结构类型，由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的 什么是抽象是指抽取出事物具有的普遍性的本质，它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括，抽象是一种思考问题的方法，它隐藏了繁杂的细节 什么是抽象数据类型我们对已有的数据类型进行抽象，就有了抽象数据类型（Abstract Data Type，简称 ADT），是指一个数学模型及定义在该模型上的一组操作（有点类似于编程语言当中的类），抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关 比如 1 + 1 = 2 这样一个操作，在不同 CPU 的处理上可能会不一样，但是由于其定义的数学特性相同，所以在计算机编程者看来，它们都是相同的，为了便于后续对于抽象数据类型的描述，所以采用以下格式进行描述 123456ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作endADT 比如我们来将线性表进行抽象描述 12345678910111213141516ADT 线性表（List）Data 线性表的数据对象集合为 { a1, a2, ... an } 每个元素的类型均为 DataType 其中除去第一个元素 a1 以外，每一个元素有且只有一个直接前驱元素 除了最后一个元素 an 以外，每一个素都有且只有一个直接后继元素 数据元素之间的关系是一对一的关系Operation InitList(*L) 初始化操作，建立一个空的线性表 L ListEmpty(L) 判断线性表是否为空，若线性表为空，返回 True，否则返回 False ClearList(*L) 将线性表清空 GetElem(L, i, *e) 将线性表 L 中的第 i 个位置元素值返回给 e LocateElem(L, e) 在线性表 L 中查找与给定值 e 相等的元素，如果成功则返回序号，否则返回 0 ListInsert(*L, i, e) 在线性表 L 中的第 i 个位置插入新元素 e ListDelete(*L, i, *e) 删除线性表 L 中的第 i 个位置元素，并用 e 返回其值endADT 对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中设计的关于线性表的更为复杂的操作，可以用以上基本操作的组合来进行实现 线性表的顺序存储结构线性表有两种物理存储结构，顺序存储结构和链式存储结构，物理上的存储方式事实上就是在内存中找一个初始地址，然后通过占位的形式，把一定的内存空间给占用，然后把相同数据类型的数据元素依次放在这块空地中 顺序存储结构顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素，也就是上面介绍过的 a1, a2 ... ai - 1, ai, ai + 1, ... an，顺序存储的结构代码如下 1234567#define MAXSIZE 20typedef int ElemType;typedef struct { ElemType data[MAXSIZE] int length; // 线性表当前长度} SqList; 事实上就是对数组进行了封装，增加了一个当前长度的变量，稍微总结下，顺序存储结构封装需要三个属性 存储空间的起始位置，数组 data，它的存储位置就是线性表存储空间的存储位置 线性表的最大存储容量，数组的长度（MAXSIZE） 线性表的当前长度，length 这里有个需要注意的地方，即数组的长度与线性表的当前长度需要区分一下 数组的长度是存放线性表的存储空间的总长度，一般初始化后不变（虽然可以动态扩容，但是会影响性能） 而线性表的当前长度是线性中元素的个数，是会变化的 地址计算方法假设 ElemType 占用的是 C 个存储单元（字节，比如 int 整型会占用四个字节），那么线性表中第 i + 1 个数据元素和第 i 个数据元素的存储位置关系为 123// LOC 表示获得存储位置的函数// 比如 ai 存放的是一个整型，地址在 0000 10 处，ai + 1 就存放在 0000 14 处（四个字节）LOC(ai + 1) = LO(ai) + C 所以对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出 1LOC(ai) = LOC(a1) + (i - 1) * c 可以配合下表进行理解 元素 a1 a2 … ai - 1 ai … an 空闲空间 下标 0 1 … i - 2 i - 1 … n - 1 通过上面的公式，我们可以随时计算出线性表中任意位置的地址，不管它是第一个还是最后一个都是相同的时间，所以它的存储时间性能为 O(1)，我们通常将其称为随机存储结构，下面我们来看一下针对于线性表的顺序存储结构当中有哪些操作方法和与其相对应的时间复杂度 读取操作获取线性表 List 中的第 i 个位置的元素值，只要 i 的数值在数组下标范围内，就把数组第 i - 1 下标的值返回即可，但是在 JavaScript 这种高级编程语言中，其实已经内置了很多对数组直接操作的函数，如 push、splice 等方法，但是在 C 语言这种底层语言中是没有的，所以在接下来的代码中，我们不会采用这些内置的操作函数，而是按照底层语言的实现思路和步骤，用高级语言来进行实现，下面就来看看如何使用 JavaScript 来进行实现 123456789101112// 初始条件，线性表 list 已经存在并且 i &lt;= index &lt;= list.length// 算法复杂度为 O(n)function getItem(index) { if (index &lt; 0 || index &gt; list.length - 1) { throw new Error(`ERROR`) } for (let i = 0; i &lt; list.length; i++) { if (k === index) { return list[k] } }} 插入操作线性表的顺序存储结构具有随机存储结构的特点，时间复杂度为 O(1)，在线性表 List 中的第 i 个位置插入新元素 e，实现思路如下 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度 ，则抛出异常或动态增加容量 从最后一个元素开始向前遍历到第 i 个位置，分别将他们都向后移动一个位置 将要插入元素填入位置 i 处 表长加 1 123456789101112// 初始条件，链表 list 已经存在且 1 &lt;= index &lt;= list.length// 功能，在 list 中第 index 个位置之前插入新的数据元素 datafunction insertItem(data, index) { if (index &lt; 0 || index &gt;= list.length) { throw new Error(`ERROR`) } else { for (let i = list.length - 1; i &gt; index - 1; i--) { list[i + 1] = list[i] } list[index] = data }} 删除操作删除算法的实现思路如下 如果删除位置不合理，抛出异常 取出删除元素 从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置 表长减 1 1234567891011121314151617// 初始条件，链表 list 已经存在且 1 ≤ index ≤ list.lengthfunction deleteItem(index) { if (list.length === 0) { throw new Error(`ERROR`) } if (index &lt; 0 || index &gt; list.length - 1) { throw new Error(`ERROR`) } if (index &lt; list.length - 1) { for (let k = index; k &lt; list.length - 1; k++) { list[k] = list[k + 1] } } list.length-- // return list[index] return list} 线性表顺序存储结构的优缺点线性表的顺序存储结构，在存或者读取数据的时候，不管是在哪个位置，时间复杂度均为 O(1)，而在插入或者删除的时候，时间复杂度都是 O(n)，这就可以说明，它比较适合元素个数比较稳定，不经常插入和删除元素，而更多的操作是存取数据的应用，简单的总结如下 优点 无需为表中元素之间的逻辑关系而增加额外的存储空间 可以快速的存取表中任意位置的元素 缺点 插入和删除操作需要移动大量元素 当线性表长度变化较大的时候，难以确定存储空间的容量 容易造成存储空间的碎片（因为申请空间是一整块一整块来进行申请的）","link":"/2019/12/14/Essay/05/"},{"title":"数据结构与算法","text":"最近打算趁着过年这段时间，从头的开始梳理一下数据结构与算法的相关知识，一步一步慢慢来进行学习，在这里顺便记录一下相关笔记，方便以后进行复习 主要参考的是 大话数据结构 与 数据结构与算法分析，方向也主要是偏向于 JavaScript 当中的实现 既然是数据结构与算法，那么我们就先来看看什么是数据结构 数据结构数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的科学，简单总结如下 程序设计 = 数据结构 + 算法 数据元素相互之间存在的一种或多种特定关系的集合 传统上数据结构分为逻辑结构和物理结构 逻辑结构（主要），指数据对象中数据元素之间的相互关系 物理结构（次之），数据的逻辑结构在计算机中的存储形式 逻辑结构 集合结构，集合结构中的数据元素除了同属于一个集合外，没有其他任何关系 线性结构，线性结构中的元素之间是一对一的关系 树形结构，树形结构中的数据元素之间存在一种一对多的层次关系 图形结构，图形结构的数据元素是多对多的关系 物理结构物理结构实际上研究的就是如何把数据元素存储到计算机的存储器当中，存储器主要是针对内存而言，像硬盘，软盘等外部存储器的数据组织通常用文件结构来描述 顺序存储和链式存储 顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一直的（数组） 链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的（叫号） 针对链式存储结构，其数据元素存储关系并不能反应其逻辑关系，所以需要用一个指针存放数据元素的地址，这样就可以通过地址来找到相关联数据元素的位置 算法算法并不是唯一的，同一个问题可以有多种解决问题的算法，以下是两种方式计算一到一百累加的结果 123456789let result = 0for (let i = 1; i &lt;= 100; i++) { result += i}// VSlet m = 1, n = 100let result = (m + n) * (n / 2) 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作，算法具备五个基本特征，输入，输出，有穷性，确定性和可行性 输入，具有零个或多个输入 输出，至少有一个或多个输出 有穷性，在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 确定性，每一个步骤都有明确的含义，在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果，每个步骤都应该被精确定义而无歧义 可行性，每一步都是可行的，即都能够通过执行有限次数完成 设计 正确性，指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案 可读性，目的是为了便于阅读、理解和交流 时间效率高和存储量低 算法效率的度量方法事前分析估算方法，即在计算机程序编写前，依据统计方法对算法进行估算 时间复杂度在进行算法分析时，语句总的执行次数 T(n) 是关系问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级，也就是算法的时间量度，记作 T(n) = O(f(n))，它表示随问题规模 n 的增大，算法执行时间的『增长率』和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度 其中 f(n) 是问题规模 n 的某个函数 推导大 O 阶 用常数 1 取代运行时间中的所有加法常数（例如 (1 + n) * n / 2 记作 O(1)） 在修改后的运行次数函数中，只保留最高阶项（例如单层 for 循环，记作 O(n)） 如果最高阶项存在且不是 1，则去除与这个项相乘的常数（例如双重 for 循环，记作 O(n^2)，三重则是 O(n^3)） 对于下列函数 12345for (let i = 0; i &lt; n; i++) { for (let j = i; j &lt; n; j++) { // ... }} 也是一致的，复杂度为 O(n^2)，但是还有一种比较特殊的，先来看下面这个示例 12345let i = 1, n = 100while (i &lt; n) { i = i * 2} 由于每次 i * 2 之后，就距离 n 更进一步，假设有 x 个 2 相乘后大于或等于 n，则会退出循环，所以由 2^x = n 可以得到 x = log(2)n，所以上述循环的时间复杂度为 O(logn) 函数调用的时间复杂度先看下面这个示例 1234567for (let i = 0; i &lt; 100; i++) { log(i)}function log(n) { console.log(n)} 在这种情况下，时间复杂度为 O(n)，稍微调整一下 123456789for (let i = 0; i &lt; 100; i++) { log()}function log() { for (let i = 0; i &lt; 100; i++) { console.log(i) }} 这样一来跟之前的示例是一样的，但是它的复杂度是 O(n^2) 常见的时间复杂度可以参考下表 示例 时间复杂度 简称 123456789 O(1) 常数阶 3n + 4 0(n) 线性阶 3n^2 + 4n + 5 0(n^2) 平方阶 3log(2)n + 4 0(1ogn) 对数阶 2n + 3nlog(2)n + 14 0(nlogn) nlogn 阶 n^3 + 2n^2 + 4n + 6 0(n^3) 立方阶 2^n 0(2^n) 指数阶 耗费时间从小到大依次是 1O(1) &lt; O(logn) &lt; (n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 时间曲线如下所示 算法一般要求尽量的简洁实用，但是对于 O(n^3) 之后的复杂度，由于 n 值的增大都会使得结果大的难以想象，所以一般不会去讨论它们，谁用谁傻逼 最坏情况与平均情况比如我们查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么复杂度就为 O(1)，但是也有可能这个数字在最后一个位置，那么复杂度就为 O(n) 了 平均运行时间是期望的运行时间 最坏运行时间是一种保证，在应用中是一种最重要的需求，通常除非特别指定，我们提到的『运行时间都是最坏的运行时间』 空间复杂度空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式为 1S(n) = O(f(n)) 其中 n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数 时间复杂度来指运行时间的需求 空间复杂度来指运行空间的需求 空间复杂度涉及到的较少，除非明确指明，否则我们在平常一般所讨论到的复杂度都是指时间复杂度 数据结构与算法知识梳理 最后更新于 2020-06-12 这部分内容算是针对文章当中所涉及到的数据结构与算法相关内容的一个汇总 线性表线性表由零个或多个数据元素组成的有序序列，它有以下特点 它是一个序列，也就是说元素之间是先来后到的 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继 另外，线性表强调是有限的，事实上无论计算机发展到多大，它所处理的元素都是有限的 它有两种物理存储结构，顺序存储结构和链式存储结构，物理上的存储方式事实上就是在内存中找一个初始地址，然后通过占位的形式，把一定的内存空间给占用，然后把相同数据类型的数据元素依次放在这块空地中，具体内容可以见下方列表 顺序存储结构 读取操作/插入操作/删除操作 顺序存储结构的优缺点 链式存储结构 单链表 读取操作/插入操作/删除操作 单链表整表创建（头插法/尾插法）与删除 单链表结构与顺序存储结构优缺点 静态链表 插入操作/删除操作 静态链表的优缺点 循环链表 约瑟夫问题 循环链表的特点 判断链表中是否有环 双向链表与双向循环链表 双向链表结点结构 双向链表的插入操作 双向链表的删除操作 栈和队列使用栈结构存储数据，讲究『先进后出』，即最先进栈的数据，最后出栈，而使用队列存储数据，讲究『先进先出』，即最先进队列的数据，也最先出队列，既然栈和队列都属于线性表，所以根据线性表分为顺序表和链表的特点，栈也可分为顺序栈和链表，队列也分为顺序队列和链队列 栈 栈的定义 入栈操作和出栈操作 栈的链式存储结构 进栈操作 出栈操作 JavaScript 中的栈的实现 顺序存储 链式存储 队列 队列的定义 队列的顺序存储结构 队列的链式存储结构 入队列操作 出队列操作 销毁一个队列 循环队列定义以及操作 JavaScript 中的队列实现 链式存储 顺序存储 递归递归（Recursion algorithm）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法，递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念，绝大多数编程语言支持函数的自调用，简单来说，就是函数直接或间接调用函数本身，则该函数称为『递归函数』，详细可见 递归，内容包括 什么是递归 斐波那契数列 尾调用 分治思想 汉诺塔 八皇后问题 树和二叉树在上面我们介绍了 单链表，循环链表，双向链表与双向循环链表，栈和队列 等相关知识，但是如果细心观察可以发现，我们之前介绍的种种，它们其实都是一种『一对一』 的线性结构，无论是线性表也好，或者说是栈和队列，都是一样的，所以下面我们就来看一种『一对多』 的数据结构，那就是『树结构』，内容如下 树 树的定义 结点分类 结点间的关系 树的存储结构（双亲表示法/孩子表示法） 二叉树 二叉树的定义 特殊二叉树（斜树/满二叉树/完全二叉树） 二叉树的存储结构（顺序存储结构/二叉链表） 二叉树的遍历 前序遍历/中序遍历/后序遍历/层序遍历 线索二叉树 为什么需要线索二叉树 线索二叉树的定义与遍历 树、森林与二叉树之间的转换 普通树转换为二叉树 森林转换为二叉树 二叉树转换为树、森林 树与森林的遍历 赫夫曼树 赫夫曼编码 图结构在上面的 单链表，循环链表 等链表章节当中我们知道了每个元素之间只有一个直接前驱和一个直接后继元素，同样的在 树 与 二叉树 等章节当中知道了树这种结构中，数据元素之间是层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关，但是以上这些仅仅都只是一对一，一对多的简单模型，那么如果元素之间存在多对多的关系呢，我们又该如何来处理呢？下面我们就来看看图这种结构 图结构 图的定义（无向边/有向边） 简单图/无向完全图/有向完全图/稀疏图/稠密图/网/子图 连通图/连通分量/强连通图 生成树/有向树 图的存储结构 邻接矩阵（无向图/有向图/网） 邻接表（无向图/有向图/网） 十字链表 邻接多重表 边集数组 图的遍历 深度优先遍历/广度优先遍历 马踏棋盘算法 普里姆算法/克鲁斯卡尔算法 最短路径 迪杰斯特拉算法/弗洛伊德算法 关键路径 拓扑序列/拓扑排序 关键路径的作用 AOV 网与 AOE 网的比较 查找算法在小节当中，我们会介绍一类在平常开发过程当中经常会使用的算法，那就是查找算法，关于查找算法肯定不需要多说，都是耳熟能详的，什么顺序、二分之类的就算是没有用过应该也听闻过，那么今天我们就来简单的总结整理一下查找算法的分类和一些比较常用的算法 查找算法 查找算法的分类 顺序查找/二分查找/插值查找/斐波那契查找/线性索引查找（有序） 散列表查找（无序） 二叉排序树 为什么需要二叉排序树 二叉排序树 查找/删除 平衡二叉排序树 二叉排序树存在的问题 平衡二叉排序树 平衡二叉排序树的构建过程 平衡二叉排序树的旋转（LL 型/RR 型/LR 型/RL 型） 散列表查找 散列函数设计（直接定址法/数字分析法/平方取中法/折叠法/除留余数法/随机数法） 处理散列冲突的方法（开放定址法/再散列函数法/链地址法/公共溢出区法） 排序算法排序算法算得上是在所有的算法当中应该算是应用最为广泛的一类算法，详细可见 排序算法，总共有十种方式，如下 比较排序（冒泡排序/选择排序/插入排序/希尔排序/归并排序/快速排序/堆排序） 非比较排序（计数排序/基数排序/桶排序）","link":"/2019/12/01/Essay/04/"},{"title":"循环链表","text":"我们在之前的章节当中介绍过了 线性表（单链表），对于单链表而言，由于每个结点只存储了向后的指针，到了尾部标识就停止了向后链的操作（也就是 null，空指针），所以说按照这样的方式，只能索引后继结点而不能索引前驱结点，所引起的问题也是显而易见的，比如如果不从头结点出发，就无法访问到全部结点，遇到这种情况，我们就可以采用我们今天将要介绍到的循环链表 循环链表要解决单链表里面遇到的问题其实也并不麻烦，我们只需要将单链表中的终端结点的指针（null）由空指针改为指向头结点就可以解决，这样一来整个单链表就形成了一个环，这种头尾相接的单链表也就成为了单循环链表，简称为『循环链表』，如下图所示 但是这里需要注意，并不是说循环链表一定要有头结点，其实循环链表和单链表的主要差异就在于循环的判断空链表的条件上 单链表只需要判断 head -&gt; next 是否为 null 即可 但是单链表则需要判断 head -&gt; next 是否等于 head 下面我们就来看看单循环链表的代码如何实现，其实本质上和我们在 线性表（单链表） 一节当中实现的单链表差异不大，只是在单链表的基础上，将尾节点的指针指向头结点，就构成了一个循环链表，环形链表从任意一个节点开始，都可以遍历整个链表 1this.head.next = this.head 在下面的约瑟夫问题当中我们可以看到具体的应用 约瑟夫问题下面我们来看一个比较近经典的问题，约瑟夫问题，问题是这样的 据说在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，每报数到第 3 人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止，然而约瑟夫和他的朋友并不想遵从，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第 16 个与第 31 个位置，于是逃过了这场死亡游戏 看到这个问题我们首先想到的是要用到循环链表，还有就是要计算链表中有多少个元素，这两点很重要，再有就是找到当前节点和在链表中向前移动 m 个节点，其实简单来说就是在初始化链表的时候我们定义一个当前节点，将它赋值为头节点 this.currentNode = this.head，这样在移动节点的时候就可以用它指向下一个节点，向前移动节点的时候有个地方需要注意，如果当前移动到头节点上需要再向前移动一个节点 this.currentNode.next.next 下面我们来看如何实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 使用循环链表实现解决约瑟夫环问题 * @param element */// 链表结点function Node(element) { this.element = element this.next = null}// 定义链表类function LList() { this.head = new Node('head') this.find = find this.insert = insert this.remove = remove this.findPrev = findPrev this.display = display // 在之前链表的基础上新增 this.head.next = this.head this.currentNode = this.head this.advance = advance // 从链表当前结点向前移动 n 个结点 this.count = count // 当前链表中有多少个元素}// 查找结点function find(item) { var currNode = this.head while (currNode.element != item) { currNode = currNode.next } return currNode}// 插入结点function insert(newElement, item) { var newNode = new Node(newElement) var current = this.find(item) newNode.next = current.next current.next = newNode}// 查找当前结点的上一个结点function findPrev(item) { var currNode = this.head while (!(currNode.next == null) &amp;&amp; (currNode.next.element != item)) { currNode = currNode.next } return currNode}// 删除结点function remove(item) { var prevNode = this.findPrev(item) if (prevNode.next !== null) { prevNode.next = prevNode.next.next }}// 向前移动 n 个结点function advance(n) { while (n &gt; 0) { if (this.currentNode.next.element == 'head') { this.currentNode = this.currentNode.next.next } else { this.currentNode = this.currentNode.next } n-- }}// 当前链表中有多少个元素function count() { var node = this.head var i = 0 while (!(node.next.element == 'head')) { node = node.next i++ } return i}// 输出所有结点function display() { var currNode = this.head while (!(currNode.next == null) &amp;&amp; !(currNode.next.element == 'head')) { document.write(currNode.next.element + '&amp;nbsp') currNode = currNode.next }}var llist = new LList()llist.insert('1', 'head')llist.insert('2', '1')llist.insert('3', '2')llist.insert('4', '3')llist.insert('5', '4')llist.insert('6', '5')llist.insert('7', '6')llist.insert('8', '7')llist.insert('9', '8')llist.insert('10', '9')llist.display()document.write('&lt;br&gt;')var n = 3while (llist.count() &gt; 2) { llist.advance(n) llist.remove(llist.currentNode.element) llist.display() document.write('&lt;br&gt;')} 最终结果如下 我们假设只有十个人，所以一个站在队伍的第四位，一个站在队伍的第十位，到最后会只剩下他们两个人 循环链表的特点在单链表中，我们有了头结点时，我们可以用 O(1) 的时间访问第一个结点，但对于要访问最后一个结点，我们必须要挨个向下索引，所以需要 O(n) 的时间，如果使用循环链表的话，用 O(1) 的时间就可以由链表指针访问到最后一个结点，可以参考开头部分的单循环链表示意图，但是在此之前，我们先来稍微的调整一下，不再和开头的时候一样，而是采用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了 如下图 但是相对应的，我们的判断条件也需要相对的调整一下，即判断是否为空链表的条件应该调整为判断 rear 是否等于 rear -&gt; next，循环链表的特点是无须增加存储量，仅对链接方式稍作改变，即可使得表处理更加方便灵活 判断链表中是否有环我们来看一个在平常当中经常会遇到的关于循环链表的问题，那就是如何判断链表中是否有环，有环的定义是，链表的尾节点指向了链表中的某个节点，如下图所示 我们可以发现在第六个位置的指针是指向第三个位置的，那么我们如何判断这种情况呢？下面我们就来尝试一下，链表的生成还是使用我们之前的代码，不过是简化过的，只保留几个最基本的方法方便我们测试就行，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Node(element) { this.element = element this.next = null}// 定义链表类function LList() { this.head = new Node('head') this.find = find this.insert = insert this.getHead = getHead // 循环列表，添加一个访问标记，用于判断是否存在环 this.head.next = this.head this.flag = 0}// 查找结点function find(item) { var currNode = this.head while (currNode.element != item) { currNode = currNode.next } return currNode}// 插入结点function insert(newElement, item) { var newNode = new Node(newElement) var current = this.find(item) newNode.next = current.next current.next = newNode}// 获取头结点function getHead() { return this.head}var llist = new LList()llist.insert('1', 'head')llist.insert('2', '1')llist.insert('3', '2')llist.insert('4', '3')llist.insert('5', '4')// 生成环llist.find('5').next = llist.find('2')// 获取头结点var list = llist.getHead() 有了链表以后，我们就可以来看看如何判断链表中是否有环，主要有三种方式，我们一个一个来看 哈希表第一种方法，创建哈希表，不过会占用较大的空间，不是最佳方法（时间复杂度 O(n)），它的原理是遍历链表，将链表各节点添加至哈希表中，添加前判断此节点是否已存在哈希表中，存在的话说明链表中存在环 12345678910111213function test(list) { var set = new Set() while (list) { if (set.has(list)) { console.log(`存在环`) console.log(list) return true } set.add(list) list = list.next } return set} 测试结果如下 1test(list) // 存在环，Node { element: \"2\", next: Node } 检测到节点 2 是重复项，说明存在环 访问标记另外一种方式就是给节点添加 flag 访问标记，时间复杂度 O(n)，不过这种方法不需要额外的空间 1234567891011function test(list) { while (list) { if (list.flag) { console.log(`存在环`) console.log(list) return true } list.flag = 1 list = list.next }} 遍历链表，每访问一个新节点，使其 flag 为 1，每次访问节点前先判断其 flag 是否为 1，为 1 则是已访问过的节点，说明链表中存在环，测试结果如下 123test(list) // 存在环，Node { element: \"2\", next: Node }console.log(list) 快慢指针这个也是业界流传最广的方法，设定快指针 fast，慢指针 slow，每次循环快指针 fast 移动两个位置，慢指针移动一个位置（时间复杂度 O(n)，需要额外的空间），如果在某个时候 fast === slow，表示存在环 1234567891011function test(list) { var fast = list.next.next, slow = list.next while (list) { if (fast === slow) { console.log(`存在环`) return true } fast = fast.next.next slow = slow.next }} 测试结果如下 1test(list) // 存在环","link":"/2020/02/06/Essay/09/"},{"title":"双向链表与双向循环链表","text":"在之前的章节当中，我们介绍过了 单链表 和 循环链表 相关内容，今天我们就来看看它们的升级版本，也就是所谓的双向链表与双向循环链表 双向链表在展开双向链表相关内容之前，我们先来了解一下为什么我们需要双向链表呢？我们从一个示例开始介绍，首先我们来思考这样一个问题，比如某个城市的地铁是一个环形的，就类似于我们的循环链表，比如使用下面这样的方式来表示站台与地铁行进的方向 1A ==&gt; B ==&gt; C ==&gt; D ==&gt; E ==&gt; A 现在我们假设某人从 A 站上车，最后到达了 E 站，但是他发现坐过站了，他其实要去的是 D 站，那么按照我们的循环链表的约定，他要经过的路线是 1E ==&gt; A ==&gt; B ==&gt; C ==&gt; D 可以发现需要绕很大一圈，在这种情况，双向链表就可以派上用场了 双向链表结点结构双向链表和普通链表的区别在于，在链表中一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的，一个链向下一个元素，另一个链向前一个元素，双向链表提供了两种迭代列表的方法，从头到尾，或者反过来从尾到头，在双向链表当中我们也可以访问一个特定节点的下一个或前一个元素，因为如果在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代，这也是双向链表的一个优点 结构如下 12345typedef struct DualNode { ElemType data; struct DualNode *prior; // 前驱结点 struct DualNode *next; // 后继结点} DualNode, *DuLinkList; 可以用下图来进行表示 同理，既然单链表可以有循环链表，那么双向链表当然也可以有 双向链表的插入操作双向链表的插入方法与单链表相似，但需要设置新节点的 previous 属性，关于插入方式，有两种 尾节点插入，需将其的 previous 指向其前驱，其 next 指向它的前驱的 next，其前驱的 next 指向本身 普通节点的插入，多了一步，需要将其后继的 previous 指向其本身 但是特别需要注意，顺序很重要，千万不能写反了，流程如下图所示 大体的思路如下 s -&gt; next = p; s -&gt; prior = p -&gt; prior; p -&gt; prior -&gt; next = s; p -&gt; prior = s; 这里特别需要注意的，在交换的过程中不要出现矛盾，例如第四步先被执行了，那么 p -&gt; prior 就会提前变成 s，使得插入的工作出错 双向链表的删除操作从双向链表删除一个元素，分为两证情况，即尾元素和普通元素 尾元素删除，需将其的 previous 指向 null，和其前驱的 next 指向 null 普通元素删除，和单向链表没有什么区别，只需将其前驱的 next 指向它的后继，将其后继的 previous 指向它的前驱，需要注意的一点是需将删除元素的 next、previous 都指向 null 原理如下 大体的思路如下 p -&gt; prior -&gt; next = p -&gt; next; p -&gt; next -&gt; prior = p -&gt; prior; free(p); 双向链表相对于单链表来说，是要更复杂一点，每个结点多了一个 prior 指针，所以在使用插入和删除操作的时候需要小心，不过，双向链表可以有效提高算法的时间性能，说白了就是用空间来换取时间，下面我们来看看如何用代码进行实现 代码实现本质和单链表相似，要实现双向链表，首先需要给 Node 类增加一个 previous 属性 123456// 节点类function Node(element) { this.element = element // 当前节点的元素 this.next = null // 下一个节点链接 this.previous = null // 上一个节点链接} 针对于 LinkedList 类，我们添加了一个反序的方法 12345678910// 链表类function LList() { this.head = new Node('head') // 头节点 this.find = find // 查找节点 this.findLast = findLast // 查找尾节点 this.insert = insert // 插入节点 this.remove = remove // 删除节点 this.display = display // 显示链表 this.dispReverse = dispReverse // 反序} 双向链表的 insert 方法与单链表相似，但需要设置新节点的 previous 属性，使其指向该节点的前驱，定义如下（这里使用的 find() 方法与我们之前的实现是一致的，具体实现可以参考最下方的整合代码） 12345678// 插入节点function insert(newElement, item) { var newNode = new Node(newElement) var currNode = this.find(item) newNode.next = currNode.next newNode.previous = currNode currNode.next = newNode} 双向链表的删除 remove 方法比单链表效率高，不需要查找前驱节点，只要找出待删除节点，然后将该节点的前驱 next 属性指向待删除节点的后继，设置该节点后继 previous 属性，指向待删除节点的前驱即可 12345678910// 删除节点function remove(item) { var currNode = this.find(item) if (!(currNode.next == null)) { currNode.previous.next = currNode.next currNode.next.previous = currNode.previous currNode.next = null currNode.previous = null }} 至于反序方法，同 display() 方法类似，只不过此次遍历的变成了前驱结点而已，下面是整合后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 节点function Node(element) { this.element = element // 当前节点的元素 this.next = null // 下一个节点链接 this.previous = null // 上一个节点链接}// 链表类function LList() { this.head = new Node('head') // 头节点 this.find = find // 查找节点 this.findLast = findLast // 查找尾节点 this.insert = insert // 插入节点 this.remove = remove // 删除节点 this.display = display // 显示链表 this.dispReverse = dispReverse // 反序}// 查找元素function find(item) { var currNode = this.head while (currNode.element != item) { currNode = currNode.next } return currNode}// 查找链表中的最后一个元素function findLast() { var currNode = this.head while (!(currNode.next == null)) { currNode = currNode.next } return currNode}// 插入节点function insert(newElement, item) { var newNode = new Node(newElement) var currNode = this.find(item) newNode.next = currNode.next newNode.previous = currNode currNode.next = newNode}// 显示链表元素function display() { var currNode = this.head while (!(currNode.next == null)) { console.log(currNode.next.element) currNode = currNode.next }}// 反向显示链表元素function dispReverse() { var currNode = this.findLast() while (!(currNode.previous == null)) { console.log(currNode.element) currNode = currNode.previous }}// 删除节点function remove(item) { var currNode = this.find(item) if (!(currNode.next == null)) { currNode.previous.next = currNode.next currNode.next.previous = currNode.previous currNode.next = null currNode.previous = null }}var fruits = new LList()fruits.insert('111', 'head')fruits.insert('222', '111')fruits.insert('333', '222')fruits.insert('444', '333')fruits.display()// 111// 222// 333// 444fruits.dispReverse()// 444// 333// 222// 111 至于双向循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即 1head.next = head 这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表","link":"/2020/02/17/Essay/10/"},{"title":"队列","text":"在之前的章节当中我们介绍过了 栈 的相关知识，本篇我们就接着上篇未完的内容来了解一下和栈十分相似的队列的相关知识 什么是队列简单来说，队列类似于『链表』，也是存储数据的结构，队列中数据进入队列的顺序很重要，一般来说，队列就是一群人或者事物按照排好的顺序等待接受服务或者处理，比如我们常见的排队买票就是一个典型的队列 队列的定义队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的『线性表』，与栈相反，队列是一种先进先出（First In First Out，FIFO）的线性表，与栈相同的是，队列也是一种重要的线性结构，实现一个队列同样需要顺序表或链表作为基础，如下图所示 队列既可以用链表实现，也可以用顺序表实现，跟栈相反的是，栈一般我们用『顺序表』来实现，而队列我们常用『链表』来实现，简称为『链队列』，定义如下 123456789typedef struct QNode { ElemType data; struct QNode *next;} QNode, *QueuePrt;typedef struct { // 队头、尾指针 QueuePrt front, rear;} LinkQueue; 队列的链式存储结构我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，但是需要注意的是，头结点不是必要的（在这里我们为了方便操作，选择将其添加上） 当队列为空时，front 和 rear 都指向头结点 创建一个队列创建一个队列要完成两个任务，一是在内存中创建一个头结点，二是将队列的头指针和尾指针都指向这个生成的头结点（因为此时是空队列） 12345678initQueue(LinkQueue *q) { q-&gt;front = q-&gt;rear = (QueuePtr)malloc(sizeof(QNode)); if (!q-&gt;front) exit(0); // 默认是指向 NULL 的 q-&gt;front-&gt;next = NULL;} 入队列操作总的来说分为三个步骤，如下图所示 代码如下 12345678910111213InsertQueue(LinkQueue *q, ElemType e) { QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if (p == NULL) exit(0); p-&gt;data = e; p-&gt;next = NULL; q-&gt;rear-&gt;next = p; q-&gt;rear = p;} 出队列操作出队列操作是将队列中的第一个元素移出，队头指针不发生改变，改变头结点的 next 指针即可，如下所示 但是这里有一个需要注意的地方，就是如果原队列只有一个元素，那么我们就应该处理一下队尾指针 代码如下 12345678910111213141516DeleteQueue(LinkQueue *q, ELemType *e) { QueuePtr p; if (q-&gt;front == q-&gt;rear) return; p = q-&gt;front-&gt;next; *e = p-&gt;data; q-&gt;front-&gt;next = p-&gt;next; if (q-&gt;rear == p) q-&gt;rear = q-&gt;front; free(p);} 销毁一个队列由于链队列建立在内存的动态区，因此当一个队列不再有用时应当把它及时销毁掉，以免过多地占用内存空间，方式很简单，如下 1234567DestroyQueue(LinkQueue *q) { while (q-&gt;front) { q-&gt;rear = q-&gt;front-&gt;next; free(q-&gt;front); q-&gt;front = q-&gt;rear; }} 队列的顺序存储结构之前我们提到过，在队列的实现上我们更愿意用链式存储结构来存储，那么为什么会这样呢？ 我们假设一个队列有 n 个元素，则顺序存储的队列需建立一个大于 n 的存储单元，并把队列的所有元素存储在数组的前 n 个单元，数组下标为 0 的一端则是队头，如下图所示 入队列操作其实就是在队尾追加一个元素，不需要任何移动，时间复杂度为 O(1)，而出队列则不同，因为我们已经假设下标为 0 的位置是队列的队头，因此每次出队列操作所有元素都要向前移动，所以当前的时间复杂度为 O(n) 但是这里我们可以想到，如果我们不去限制队头一定要在下标为 0 的位置，那么出队列的操作就是不是不需要移动全体元素了呢？看下面这个图 但是这样也会出现一些问题，例如按下边的情形继续入队列，就会出现数组越界的错误 但是通过上图可以发现，我们还有 0 和 1 两个下标还空着在，这就是所谓的『假溢出』 循环队列定义通过上面的例子，我们可以知道，要解决假溢出的办法就是如果后面满了，就再从头开始，也就是头尾相接的循环，也就是这里我们要说的『循环队列』，循环队列它的容量是固定的，并且它的队头和队尾指针都可以随着元素入出队列而发生改变，这样循环队列逻辑上就好像是一个环形存储空间，但要需要注意的是，在实际的内存当中，不可能有真正的环形存储区，我们只是用顺序表模拟出来的逻辑上的循环，可以通过下图来进行了解 通过上图我们可以发现，似乎循环队列的实现只需要灵活改变 front 和 rear 指针即可，也就是让 front 或 rear 指针不断加 1，即使超出了地址范围，也会自动从头开始，所以在这里我们可以采取取模运算（取余数）的方式来进行处理，因为它取到的值永远不会大于除数，如下 12(rear + 1) % QueueSize(front + 1) % QueueSize 循环队列的相关操作代码如下 123456789101112131415161718192021222324252627282930313233343536373839// 定义一个循环队列#define MAXSIZE 100typedef struct { // 用于存放内存分配基地址，这里也可以使用数组存放 ElemType *base; int front; int rear;}// 初始化一个循环队列initQueue(cycleQueue *q) { q-&gt;base = (ElemType *)malloc(MAXSIZE * sizeof(ElemType)); if (!q-&gt;base) exit(0); q-&gt;front = q-&gt;rear = 0;}// 入队列操作InsertQueue(cycleQueue *q, ElemType e) { // 队列已满，直接返回 if ((q-&gt;rear + 1) % MAXSIZE == q-&gt;front) return; q-&gt;base[q-&gt;rear] = e; q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE;}// 出队列操作DeleteQueue(cycleQueue *q, ElemType *e) { // 队列为空，直接返回 if (q-&gt;front == q-&gt;rear) return; *e = q-&gt;base[q-&gt;front]; q-&gt;front = (q-&gt;front + 1) % MAXSIZE;} JavaScript 中的队列实现最后我们再来看下在 JavaScript 当中如何实现队列，这里需要注意了，栈一般我们用『顺序表』来实现，而队列一般是采用『链表』来实现的（链队列），同样的，它也有两种方式来进行实现，分别是『链式存储』和『顺序存储』，下面我们一个一个来进行了解 链式存储代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Queue() { let Node = function (ele) { this.ele = ele this.next = null } let length = 0, front = null, rear = null this.push = function (ele) { let node = new Node(ele), temp = null if (length == 0) { front = node } else { temp = rear temp.next = node } rear = node length++ } this.pop = function () { let temp = front front = front.next length-- temp.next = null return temp } this.size = function () { return length } this.getFront = function () { return front } this.getRear = function () { return rear } this.display = function () { let text = '', temp = front while (temp) { text += temp.ele + ' ' temp = temp.next } return text } this.clear = function () { front = null rear = null length = 0 }}let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.push(4)queue.display()queue.pop()queue.push(5)queue.display() 顺序存储同栈一样，在 JavaScript 当中，我们可以使用内置的数组对象轻松实现 12345678910111213141516171819202122232425262728293031323334353637383940414243function Queue() { var arr = [] this.push = function (element) { arr.push(element) } this.pop = function () { return arr.shift() } this.getFront = function () { return arr[0] } this.getRear = function () { return arr[arr.length - 1] } this.clear = function () { arr = [] } this.size = function () { return length } this.diplay = function() { return arr.toString() }}let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.push(4)queue.display()queue.pop()queue.push(5)queue.display()","link":"/2020/03/02/Essay/12/"},{"title":"栈和队列","text":"从本章开始，我们来看两个平常可能听到的比较多的名词，那就是栈和队列，其实严格意义上来说，栈和队列也属于线性表，因为它们也都用于存储逻辑关系为『一对一』的数据，但由于它们比较特殊，所以我们在此将它们两个单独拿出来进行了解 使用栈结构存储数据，讲究『先进后出』，即最先进栈的数据，最后出栈，而使用队列存储数据，讲究『先进先出』，即最先进队列的数据，也最先出队列，既然栈和队列都属于线性表，所以根据线性表分为顺序表和链表的特点，栈也可分为顺序栈和链表，队列也分为顺序队列和链队列 因为篇幅有限，本篇主要介绍栈的相关内容，而关于队列的相关内容可以见 队列 栈的定义栈是一种重要的线性结构，也是线性表的一种具体形式，我们来列举一些生活当中比较常见的例子，比如浏览器的前进后退键，某些编辑工具的撤销功能等等，都是利用栈的基本原理实现的，它的官方定义如下 栈（Stack）是一个后进先出（Last in first out，LIFO）的线性表，它要求只在表尾进行删除和插入操作 其实简单来说，所谓的栈，其实也就是一个特殊的线性表（顺序表、链表），但是它在操作上有一些特殊的要求和限制 栈的元素必须『后进先出』 栈的操作只能在这个线性表的表尾进行 对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom） 再次强调，表尾是栈顶，表头是栈底 栈的插入和删除操作 栈的插入操作（push），叫做进栈，也称为压栈，入栈，类似子弹放入弹夹的动作 栈的删除操作（pop），叫做出栈，也称为弹栈，如同弹夹中的子弹出夹 因为栈的本质是一个『线性表』，线性表有两种存储形式，那么栈也有分为『栈的顺序存储结构』和『栈的链式存储结构』，最开始栈中不含有任何数据，叫做『空栈』，此时栈顶就是栈底，然后数据从栈顶进入，栈顶栈底分离，整个栈的当前容量变大，数据出栈时从栈顶弹出，栈顶下移，整个栈的当前容量变小 如下图所示 创建一个栈首先先来定义存储结构 1234567typedef int ElemType;typedef struct { ElemType *base; ElemType *top; int stackSize;} sqStack; 我们在这里定义了一个顺序存储的栈，它包含了三个元素 base，top，stackSize base 是指向栈底的指针变量 top 是指向栈顶的指针变量 stackSize 指示栈的当前可使用的最大容量 但是这里可以发现，我们与之前定义的方式不太一样，比如没有 data 元素存放数据，又或者为什么会有两个 ElemType 元素？其实上面定义方式对应下图 其实我们也可以像下面这样来进行声明 123456789typedef int ElemType;typedef struct { ElemType data[MAXSIZE]; // 用于标注栈顶的位置 int top; int stackSize;} 对应下图 栈的初始化操作如下 1234567891011#define STACK_INIT_SIZE 100initStack(sqStack *s) { s-&gt;base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType)); if (!s-&gt;base) exit(0); // 最开始，栈顶就是栈底 s-&gt;top = s-&gt;base; s-&gt;stackSize = STACK_INIT_SIZE;} 入栈操作和出栈操作入栈操作又叫『压栈操作』，就是向栈中存放数据，入栈操作要在『栈顶』进行，每次向栈中压入一个数据，top 指针就要 + 1，直到栈满为止 12345678910111213141516#define SATCKINCREMENT 10Push(sqStack *s, ElemType e) { // 如果栈满，追加空间 if (s-&gt;top – s-&gt;base &gt;= s-&gt;stackSize) { s-&gt;base = (ElemType *)realloc(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT) * sizeof(ElemType)); if (!s-&gt;base) exit(0); s-&gt;top = s-&gt;base + s-&gt;stackSize; // 设置栈顶 s-&gt;stackSize = s-&gt;stackSize + STACKINCREMENT; // 设置栈的最大容量 } *(s-&gt;top) = e; s-&gt;top++;} 相对应的，出栈操作就是在栈顶取出数据，栈顶指针随之下移的操作，每当从栈内弹出一个数据，栈的当前容量就 - 1，代码如下 12345Pop(sqStack *s, ElemType *e) { if (s-&gt;top == s-&gt;base) // 重合表示栈已经为空 return; *e = *--(s-&gt;top); // 先减减，在赋值} 清空一个栈所谓清空一个栈，就是将栈中的元素全部作废，但栈本身物理空间并不发生改变（注意不是销毁），因此我们只要将 s -&gt; top 的内容赋值为 s -&gt; base 即可，这样 s -&gt; base 等于 s -&gt; top，也就表明这个栈是空的了（类似于高级格式化只是但单纯地清空文件列表而没有覆盖硬盘的原理是一样的） 代码如下 123ClearStack(sqStack *s){ s-&gt;top = s-&gt;base;} 销毁一个栈销毁一个栈与清空一个栈不同，销毁一个栈是要释放掉该栈所占据的物理内存空间，因此不要把销毁一个栈与清空一个栈这两种操作混淆 12345678910DestroyStack(sqStack *s) { int i, len; len = s-&gt;stackSize; for (i = 0; i &lt; len; i++) { free(s-&gt;base); s-&gt;base++; } s-&gt;base = s-&gt;top = NULL; s-&gt;stackSize = 0;} 计算栈的当前容量计算栈的当前容量也就是计算栈中元素的个数，因此只要返回 s.top - s.base 即可，注意，栈的最大容量是指该栈占据内存空间的大小，其值是 s.stackSize，它与栈的当前容量不是一个概念 123456int StackLen(sqStack s) { // 这里需要注意，这里是两个地址相减，它的结果并不是两个地址的一个差值 // 如果两个地址是指向整形的话，它们相减是表示它们之间相隔几个元素 // 需要注意的是，两个地址的类型要相同，而且是不能相加的 return(s.top – s.base);} 栈的链式存储结构栈的链式存储结构，简称『栈链』，通常我们用的都是栈的顺序存储结构存储，所以这里我们只是简单的了解一下栈链，栈因为只是栈顶来做插入和删除操作，所以比较好的方法就是将栈顶放在单链表的头部，栈顶指针和单链表的头指针合二为一，如下图所示 初始化如下 123456789teypedef struct StackNode { ElemType data; // 存放栈的数据 struct StackNode *next;} StackNode, *LinkStackPtr;teypedef struct LinkStack { LinkStackPrt top; // top 指针 int count; // 栈元素计数器} 进栈操作对于栈链的 Push 操作，假设元素值为 e 的新结点是 s，top 为栈顶指针 12345678Status Push(LinkStack *s, ElemType e) { LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); p-&gt;data = e; p-&gt;next = s-&gt;top; s-&gt;top = p; s-&gt;count++; return OK;} 出栈操作至于链栈的出战 Pop 操作，假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可 12345678910111213141516Status Pop(LinkStack *s, ElemType *e) { LinkStackPtr p; // 判断是否为空栈 if (StackEmpty(*s)) return ERROR; *e = s-&gt;top-&gt;data; p = s-&gt;top; s-&gt;top = s-&gt;top-&gt;next; free(p); s-&gt;count--; return OK;} JavaScript 中的栈的实现最后的最后，我们再来看下在 JavaScript 当中如何实现栈的数据结构，同样的，它也有两种方式来进行实现，分别是『链式存储』和『顺序存储』，下面我们一个一个来进行了解 顺序存储这个理解起来十分简单，因为在 JavaScript 当中，我们可以使用内置的数组对象轻松实现，而且语言本身也提供来我们许多方法，直接使用就可以了，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Stack { constructor() { this.items = [] } push(value) { this.items.push(value) } pop() { return this.items.pop() } top() { return this.items[this.items.length - 1] } isEmpty() { return this.items.length === 0 } clear() { return this.items = [] } size() { return this.items.length } display() { return this.items.toString() }}var stack = new Stack()stack.push(5)stack.push(6)stack.push(7)stack.display()stack.pop()stack.top()stack.isEmpty()stack.size()stack.clear()stack.size()stack.display() 链式存储链式存储这个一般使用较少，了解即可，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function Stack() { let Node = function (ele) { this.ele = ele this.next = null } let length = 0, top = null this.push = function (ele) { let node = new Node(ele) top ? node.next = top : top = node top = node length++ } this.pop = function () { let current = top if (top) { top = current.next current.next = null length-- return current } else { return 'null stack' } } this.top = function () { return top } this.size = function () { return length } this.display = function () { let text = '' current = top while (current) { text += current.ele + ' ' current = current.next } return text } this.clear = function () { top = null length = 0 }}var stack = new Stack()stack.push(5)stack.push(6)stack.push(7)stack.display()stack.pop()stack.pop()stack.top()stack.clear()stack.display()","link":"/2020/02/22/Essay/11/"},{"title":"BF 和 KMP 算法","text":"我们在平常开发过程当中，针对字符串的处理那可以说是十分常见的了，所以我们今天就看两种字符串当中的算法，不过我们在看具体算法的实现之前，我们先来了解一下字符串的概念 字符串在计算机刚被发明的时候，主要作用是做一些科学和工程的计算工作，刚开始的计算机都是处理数值工作，直到后来引入了『字符串』的概念，这样一来计算机开始可以处理非数值的概念了（原理是用数值来模拟非数值，通过 ASCII 码表），我们先来看下『串』这样的数据结构 串（string）是由零个或多个字符组成的『有限序列』，又名叫字符串 一般记为 s = &quot;a1a2a3 ... an&quot;（n &gt;= 0） 串可以是空串，即没有字符，直接由 &quot;&quot; 表示，或者可以用希腊字母 Φ（fai）来表示 子串与主串的概念，例如 &quot;abc&quot; 是 &quot;abcdef&quot; 子串，反之则倒过来 字符串的存储结构 字符串的存储结构与线性表相同，也分顺序存储结构和链式存储结构 字符串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的 按照预定义的大小，为每个定义的字符串变量分配一个固定长度的存储区，一般用定长数组来定义 与线性表相似，既然是固定长度的存储区，就存在一个空间分配不灵活的问题，那么会考虑用链式存储结构 不同的是字符串我们一般都是连在一起表述的，所以习惯上我们通常还是会直接定义一个足够长度的存储区来存储的 字符串的比较字符串比较大小跟传统的数字比较有点差别，很容易我们可以知道数字 2 比 1 要大，可要是字符串之间的比较呢？没错，也是比较大小，但是比较的是字符串里每个字符的 ASCII 码大小，因为 &quot;a&quot; 的 ASCII 码是 97，&quot;A&quot; 的 ASCII 码是 65，所以 'abc' &gt; 'Abc' 是成立的，但是这样的比较并没有太大的意义，我们比较关注的还是两个字符串之间是否相等，这也是本章当中将要介绍的内容，即 BF 和 KMP 算法 BF 算法BF 算法，即暴力（Brute Force）算法，是普通的模式匹配算法，BF 算法的思想就是将目标串 S 的第一个字符与模式串 T 的第一个字符进行匹配 若相等，则继续比较 S 的第二个字符和 T 的第二个字符 若不相等，则比较 S 的第二个字符和 T 的第一个字符，依次比较下去，直到得出最后的匹配结果 BF 算法属于朴素的模式匹配算法，它的核心思想是 有两个字符串 S 和 T，长度为 N 和 M 首先 S[1] 和 T[1] 比较，若相等，则再比较 S[2] 和 T[2]，一直到 T[M] 为止，若 S[1] 和 T[1] 不等，则 T 向右移动一个字符的位置，再依次进行比较 该算法最坏情况下要进行 M * (N - M + 1) 次比较，所以时间复杂度为 O(M * N) C 语言版本实现如下 12345678910111213141516171819202122232425262728// 返回子串 T 在主串 S 中第 pos 个字符之后的位置，若不存在，则返回 0// T 非空，1 &lt;= pos &lt;= strlen(S)// 这里我们这里为了表述方便，字符串使用了第一个元素表示长度的方式int index(String S, String T, int pos) { int i = pos; // i 用于主串 S 中当前位置下标 int j = 1; // j 用于子串 T 中当前位置下标 // i 或 j 其中一个到达尾部即终止搜索 while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) { // 若相等则继续下一个元素匹配 if (S[i] == T[i]) { i++; j++; // 若失配则 j 回溯到第一个元素从新匹配 } else { // i 回溯到上次匹配首位的下一个元素，这是效率低下的关键 i = i - j + 2; j = 1; } } if (j &gt; T[0]) { return i - T[0]; } else { return 0; }} JavaScript 版本如下 123456789101112131415161718192021function indexOf(str, key) { let i = 0, j = 0 // 为了简洁，没有判断当 str 剩余的字符少于 key 应该终止循环，因为这样会用到 length // 原理和上方是一样的，即 str[j] 和 key[i] 对比，如果一样那么 i 和 j 都加 1，否则 j 恢复到匹配时的下一个，i 恢复到 0 while (key[i] !== undefined &amp;&amp; str[j] !== undefined) { if (key[i] === str[j]) { i++ j++ } else { j = j - i + 1 i = 0 } } if (i === 0) return -1; return j - i}s = 'ABCDABCDABDE't = 'ABCDABD'indexOf(s, t) KMP 算法下面我们再来看一种比较复杂的算法，也就是 KMP 算法 KMP，也称为 Knuth-Morris-Pratt 字符串查找算法，简称为 KMP 算法，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法 相较于 BF 算法，KMP 算法的主旨是尽量的减少指针的回溯从而使得性能得到提高（主要是文本串的指针，下面可以发现），我们先来看一下 KMP 算法 的操作流程 假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j] ），都令 i++ 和 j++，然后继续匹配下一个字符 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j] ），则令 i 不变，j = next[j]（此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next[j] 位） 换言之，将模式串 P 失配位置的 next 数组的值对应的模式串 P 的索引位置移动到失配处 是不是看上去一头雾水，没关系，下面我们来结合图片一步一步往下看，其实 KMP 算法的两个难点在于『前缀表』与『next 数组』的获取，如果搞懂了这两个概念以后，在理解起来就是非常的简单了，我们以下图文本串 S 与模式串 P 为例 我们首先可以得出模式串 P 的所有『子串』，如下图 然后在求得每一个模式串中『相等的前缀与后缀的最大长度』，所以这里我们就需要稍微提及一下前缀与后缀的概念，所谓『前缀』指除了最后一个字符以外，一个字符串的全部头部组合，而『后缀』是指除了第一个字符以外，一个字符串的全部尾部组合，可以参考下面这个例子加深印象 abcdef 的前缀 ==&gt; a、ab、abc、abcd、abcde（注意，abcdef 不是前缀） abcdef 的后缀 ==&gt; f、ef、def、cdef、bcdef（注意，abcdef 不是后缀） 公共最大长 ==&gt; 0（因为其前缀与后缀没有相同的） ababa 的前缀 ==&gt; a、ab、aba、abab ababa 的后缀 ==&gt; a、ba、aba、baba 公共最大长 ==&gt; 3（因为他们的公共前缀后缀中最长的为 aba，长度 3） 我们以上图当中标注为橙色的第五行的 abaab 为例，前缀和后缀分别如下图所示 然后我们可以得出『两者相同部分』的『最大长度』，也就是图中标注绿色的部分，由图可知为 2，然后在依据此原理，依次推算出所有子串的『相等的前缀与后缀的最大长度』，结果如下图所示 但是这里要多说一句，就是有没有什么方法可以让我们快速的获取到所有子串的『相等的前缀与后缀的最大长度』呢？方法是有的，这里我们以第四和第五行子串为例，如下图 我们假设已经求得了第四行子串的『最长公共前后缀』，它的长度为 1，如下图所示 那么我们可以思考，如何使得它的『最长公共前后缀』变长呢？没错，只需要在它后面添加一个字母就够了，也就是字母 b，如下图 也就是说，下一行添加的字母与当前行的『最长公共前后缀』的长度后面的那个字母一样，则『最长公共前后缀』的长度加 1，也就如下图所示 但是如果下一行添加的字母与当前行的『最长公共前后缀』的长度后面的那个字母不一样，则可以根据我们最开始的笨方法重新计算即可 现在再让我们回到最开始的地方，因为我们已经得到了『所有子串的相等的前缀与后缀的最大长度』，我们可以将这组序列称之为 maxL，如下图所示 然后我们便可以根据『最大长度表』来去获得我们最为重要的 next 数组了，关于 next 数组的获取，就是在我们的『最大长度表』的基础之上『整体向右移动一位』，然后初始值赋为 -1（最后一位的 0 则被忽略掉） 有了 next 数组以后，我们就可以正式的开始我们的比对过程了，如下图 如图中所示，依次从左往右开始一一比对，直到遇到不相匹配的，也就是下图这样的情况 这时可以发现，模式串的 b 与文本串的 c 失配了，所以我们就需要找出失配处模式串的 next 数组里面对应的值，这里为 0，所以就需要将索引为 0 的位置移动到失配处再次开始匹配（其他元素也是移动同样的距离） 然后继续执行我们的比对过程，但是此时可以发现，依然是不匹配的，所以我们还是需要按照之前的逻辑来进行执行 此时模式串的 a 与文本串的 c 失配了，所以我们就需要找出失配处模式串的 next 数组里面对应的值，这里为 -1，所以就需要将索引为 -1 的位置移动到失配处，再次继续向右执行 直到再次出现下图这样的情况 此时也是同理，从图中我们可以发现，当前不匹配的位置位于 next 数组当中的 2 位置处（也就是红框所在位置），所以这里依然按照我们之前的逻辑，移动到索引为 2 的置处再次开始匹配，如下图 最终直到匹配完成或者没有匹配到结果，如下 这样一来，就完成了我们的整个 KMP 算法的流程，下面我们在来看看如何用代码来进行实现，总的来说分为两个步骤，首先是先获取我们的 next 数组，然后才是去进行匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;typedef char *String;void getNext(String T, int *next) { int j = 0; int i = 1; next[1] = 0; while (i &lt; T[0]) { if (0 == j || T[i] == T[j]) { i++; j++; next[i] = j; } else { j = next[j]; } }}// 返回子串 T 在主串 S 第 pos 个字符之后的位置// 若不存在，则返回 0int KMP(String S, String T, int pos) { int i = pos; int j = 1; int next[255]; getNext(T, next); while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) { if (0 == j || S[i] == T[j]) { i++; j++; } else { j = next[j]; } } if (j &gt; T[0]) { return i - T[0]; } else { return 0; }} 但是这里还存在可以优化的空间，比如我们需要匹配的主串 S 为 aaaabcde，而子串 T 是 aaaaax，那么匹配的情况就成了下图所示 如果按照我们之前的逻辑，这里将会依次匹配 next 数组的 4, 3, 2, 1, 0，但是我们可以很明显的发现，因为 T 串的前几个字母都是一致的，完全没有必要进行比较，直接将将指针赋值过去即可，所以我们可以稍微的优化一下 123456789101112131415161718192021void getNext(String T, int *next) { int j = 0; int i = 1; next[1] = 0; while (i &lt; T[0]) { if (0 == j || T[i] == T[j]) { i++; j++; // 我们在这里进行一下判断，避免多余的操作 if (T[i] != T[j]) { next[i] = j; } else { next[i] = next[j]; } } else { j = next[j]; } }} 最后再来看一下 JavaScript 版本的实现，原理都是一样的，首先获取 next 数组，然后在根据 next 数组来进行回退操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function getNext(p) { let k = -1 let j = 0 let next = [-1] let pLen = p.length while (j &lt; pLen - 1) { // p[k] 表示前缀，p[j] 表示后缀 if (k == -1 || p[j] == p[k]) { ++j ++k // 在这里直接进行赋值操作也是可以的，但是保持一致，还是同 C 语言版本，在这里进行一下优化 if (p[j] != p[k]) { next[j] = k } else { // 因为不能出现 p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k] } } else { k = next[k] } } return next}function KMP(s, p) { let i = 0 let j = 0 let sLen = s.length let pLen = p.length let next = getNext(p) while (i &lt; sLen &amp;&amp; j &lt; pLen) { // 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++ if (j === -1 || s[i] === p[j]) { i++ j++ } else { // 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j] // 这里就是与 BF 算法不同的地方，这里仅仅只用回退 j，而不用回退 i j = next[j] } } return j === pLen ? i - j : -1}s = 'ABCDABCDABDE't = 'ABCDABD'KMP(s, t) // 4","link":"/2020/03/07/Essay/14/"},{"title":"二叉树","text":"在前一章当中，我们介绍了 树 的相关概念，但是普通的树，我们在平时使用是较少的，而一些比较特殊的树则是使用较多的，比如二叉树的使用范围就较为广泛，也最具有代表意义，因此在本章当中我们将会重点讨论二叉树 二叉树的定义二叉树（Binary Tree）是 n（n &gt;= 0）个结点的『有限集合』，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成，比如下面这个图，就一个普通的二叉树 二叉树的特点二叉树的每个结点最多有两棵子树，所以二叉树中不存在度大于二的结点，但是需要注意的是，不是都需要两棵子树，而是最多可以是两棵，没有子树或者有一棵子树也都是可以的，而且左子树和右子树是有顺序的，次序不能颠倒，即使树中某结点只有一棵子树，也要区分它是左子树还是右子树，比如下图的两种情况就是两个完全不同的二叉树 二叉树的五种基本形态分为以下五种形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 分别对应下图的五种情况，特别需要注意的是第一种空二叉树的情况 但是我们若只从形态上来考虑，拥有三个结点的普通树只有两种情况，即两层或者三层，但是对于二叉树来说，由于要区分左右，所以就演变成了下面五种形态 特殊二叉树看完了上面五种形态的二叉树，我们再来看一些特殊的二叉树 斜树顾名思义，斜树是一定要斜的，但斜也分为左右两种情况，比如下图当中的两种情况 但是需要注意的是，方向必须是在同一方向上，如下图便不能称之为斜树 满二叉树从字面上就能看出，满二叉树指的就是完美二叉树，也就是在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树，也就是下图这样的情况 满二叉树的特点有下面这些 叶子只能出现在最下一层 非叶子结点的度一定是二 在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多 注意和下面的完全二叉树进行区分 完全二叉树那么什么是完全二叉树呢？对于一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1 &lt;= i &lt;=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同，则这棵二叉树称为完全二叉树，比如下面两种情况都可以称之为完全二叉树 根据上图，我们可以很明显的看出它的特点 叶子结点只能出现在最下两层 最下层的叶子一定集中在左部连续位置（注意这里是左部） 倒数第二层，若有叶子结点，一定都在右部连续位置 如果结点度为一，则该结点只有左孩子 同样结点树的二叉树，完全二叉树的深度最小 这里特别需要注意的一点是，满二叉树『一定是』完全二叉树，但完全二叉树『不一定是』满二叉树，比如下面的一些情况，『均不是完全二叉树』 二叉树的性质在了解完二叉树的一些基本概念以后，我们来看看二叉树的性质，按分类可以归纳为五类，我们一个一个来看 性质一在二叉树的第 i 层上至多有 2 ^ (i - 1) 个结点（i &gt;= 1），这个很好理解，参考上方的二叉树图例便很可以很快的推导出来 性质二深度为 k 的二叉树至多有 2 ^ k - 1 个结点（k &gt;= 1），这个同上，不过需要注意的是 k 次方以后在减去 1，而不是 k - 1 次方，注意与性质一区分开来 性质三对任何一棵二叉树 T，如果其终端结点数为 n0，度为二的结点数为 n2，则 n0 = n2 + 1，这个理解起来稍微复杂一些，但是用的地方不多，了解一下即可，推导过程如下 首先我们再假设度为 1 的结点数为 n1，则二叉树 T 的结点总数 n = n0 + n1 + n2 其次我们发现连接数总是等于总结点数 n - 1，并且等于 n1 + 2 * n2 所以 n - 1 = n1 + 2 * n2 所以 n0 + n1 + n2 - 1 = n1 + n2 + n2 最后两边减去相同项，得出 n0 = n2 + 1 性质四具有 n 个结点的完全二叉树的深度为 ⌊log₂n⌋ + 1，这个同上，一般使用的也不是很多，了解即可，但是这里需要注意的就是这一对符号，⌈...⌉ 表示向上取整（上有起止，开口向下），而 ⌊...⌋ 则表示向下取整（下有起止，开口向上），下面我们来看看推导过程 由性质二我们可知，深度为 k 的满二叉树的结点树 n 一定是 2 ^ k - 1 那么对于满二叉树我们可以通过 n = 2 ^ k - 1 倒推得到满二叉树的深度为 k = log₂(n + 1) 由于完全二叉树前边我们已经提到，它的叶子结点只会出现在最下面的两层，那么对于倒数第二层的满二叉树我们同样很容易回推出它的结点数为 n = 2 ^ (k - 1) - 1 所以完全二叉树的结点数的取值范围是 2 ^ (k - 1) -1 &lt; n &lt;= 2 ^ k - 1 由于 n 是整数，所以 n &lt;= 2 ^ k - 1 可以看成 n &lt; 2 ^ k 同理 2 ^ (k - 1) - 1 &lt; n 可以看成 2 ^ (k - 1) &lt;= n，所以 2 ^ (k - 1) &lt;= n &lt; 2 ^ k 不等式两边同时取对数，得到 k - 1 &lt;= log₂n &lt; k 由于 k 是深度，必须取整，所以 k = ⌊log₂n⌋ + 1 性质五如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log₂n⌋ + 1）的结点按层序编号，对任一结点 i（1 &lt;= i &lt;= n）有以下性质 如果 i = 1，则结点 i 是二叉树的根，无双亲，如果 i &gt; 1，则其双亲是结点 ⌊i / 2⌋（比如 6 和 7 结点的双亲结点为 3） 如果 2i &gt; n，则结点 i 无做左孩子（结点 i 为叶子结点），否则其左孩子是结点 2i（还是以结点 6 为例，2n = 12，如果总结点 n &lt; 12，则表示结点 6 无左孩子，否则结点 6 的左孩子的结点为 12） 如果 2i + 1 &gt; n，则结点 i 无右孩子，否则其右孩子是结点 2i + 1（同上，不过这次是奇数，对应着右侧） 二叉树的存储结构在了解完二叉树的一些定义和性质以后，我们再来看看二叉树的存储结构，树结构在计算机中的存储形式很多，在前面的示例当中我们也可以发现，很难单单只用顺序存储结构或者链式存储结构来存放，但是二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构或链式存储结构都能够简单实现 二叉树的顺序存储结构就是用一维数组存储二叉树中的各个结点，并且结点的存储位置能体现结点之间的逻辑关系，比如下图的这个二叉树，就可以直接使用数组来进行表示 通过上面这个例子就可以看出完全二叉树的优越性，由于它的严格定义，所以我们就可以直接在数组当中表现出它的逻辑结构 二叉树的顺序存储结构当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是也可以按照完全二叉树编号方式修改一下，把不存在的结点用 ^（空指针 null）代替即可，如下图，虽然不是一个完全二叉树，但是依然可以使用数组来进行表示 但是我们要考虑到这样一种极端的情况，即如果是斜树，那么改如何表示呢？当然，通过上面的例子，你可能会说是下面这样的 但是我们仅仅为了存储只有三个元素的斜树，却要使用八个长度的数组，这显而易见会造成很大的浪费，那么有没有什么更好的方式来解决这样的问题呢？答案是有的，就是我们下面将要介绍的二叉链表 二叉链表既然顺序存储方式的适用性不强，那么我们就要考虑链式存储结构，二叉树的存储按照国际惯例来说一般也是采用链式存储结构的，二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表，如下图所示，中间是我们的 data，左边是左孩子指针，右边则是右孩子指针 二叉链表的结点结构定义代码如下 1234typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild;} BiTNode, *BiTree; 如果用图来表示的话，就是下面这样的","link":"/2020/03/22/Essay/16/"},{"title":"线索二叉树","text":"之所以有线索二叉树一说，那么肯定是因为普通的二叉树是存在一定缺陷的，那我们首先就来看看为什么需要线索二叉树呢？ 关于二叉树的基本概念可以参考 二叉树 和 二叉树的遍历 为什么需要线索二叉树像单链表一样，在开发过程当中当发现单链表已经无法满足我们设计的程序某些要求的时候，就发明了双向链表来弥补一样，线索二叉树也是在需求中被创造的，那么普通的二叉树到底有什么缺陷呢？其实简单来说，就是浪费空间和时间，下面我们就通过一个示例来详细了解一下，比如下面这个图 一眼看去可以发现有很多的 ^，也就是我们常说的空指针（null），这便是很明显的浪费行为，所以在这个过程当中，我们可以考虑利用 ^ 来记录该结点的前驱和后继，这样一来在查找过程当中，我们便可以快速的定位到某结点指定的前驱和后继结点，而不需要重新的整体遍历一遍 但是这时就会有一个问题了，我们在之前的 二叉树的遍历 章节当中已经了解到二叉树有多种遍历方式，不同的遍历方式都可以得到一个对应的遍历顺序，那么我们该以哪种遍历方式来进行遍历以达到可以节省 ^ 所浪费的空间呢？我们一个一个来进行尝试 前序遍历的方式我们先来看看使用前序遍历的方式来遍历上图，它执行完以后的结果是 A ==&gt; B ==&gt; D ==&gt; H ==&gt; I ==&gt; E ==&gt; C ==&gt; F ==&gt; G，如果我们将存在 ^ 的结点标注为蓝色的话就是 A，B，D，H，I，E，C，F，G 通过观察我们可以发现，如果要把这些结点的 ^ 用来存储它们唯一的前驱和后继结点是不可行的，因为它们之间毫无规律可言 中序遍历的方式下面我们再来考虑使用中序遍历的方式来看一下，它执行完以后的结果是 H ==&gt; D ==&gt; I ==&gt; B ==&gt; E ==&gt; A ==&gt; F ==&gt; C ==&gt; G，同样的，我们再来标注以下存在 ^ 的结点，结果为 H，D，I，B，E，A，F，C，G 这次我们发现它们是有规律的，即每隔一个结点，它刚好都有两个空余的 ^ 可以用来存放它的前驱和后继结点，所以我们就可以考虑使用中序遍历的方式来解决我们之前提到过的问题，如果按照中序遍历的方式来遍历之之前的问题，结果是下面这样的，图中的曲线表示该结点的前驱，直线表示该结点的后继，这样它们就可以串联起来了，所以我们可以通过定位一个结点从而快速的查找到它的前驱和后继结点 但是事情并没有那么简单，比如下面这个图，它并不是一个完全二叉树 我们还是按照中序遍历来进行标记一下，结果是 F，D，G，B，A，C，E 我们可以发现，标注为蓝色的结点还是具有空闲的指针位置，但是标记为绿色的结点却只有一个空闲的指针位置，如果是这样的话我们就面临一个问题，我们怎么去识别到底是存放指针还是线索呢？所以在这种情况下，我们可以将之前已经定义好的结构（二叉链表）稍微扩容一下，也就是变成下面这样 我们新增加了两个枚举类型的常量，ltag 和 rtag，这就是利用这两个常量来标识 lchild 和 rchild 是不是多余的空指针 ltag 为 0 时指向该结点的左孩子（还原为本来的树），为 1 时指向该结点的前驱（线索） rtag 为 0 时指向该结点的右孩子（还原为本来的树），为 1 时指向该结点的后继（线索） 遍历方式的对比在上面我们使用了前序遍历和中序遍历的方式，至于其他的方式为什么没有使用，我们可以参考下面这个汇总的结果，对比一下三者之间的差别，图中实线表示指针，指向其左、右孩子，虚线表示线索，指向其直接前驱或直接后继 在线索树上进行遍历，只要先找到序列中的第一个结点，然后就可以依次找结点的直接后继结点直到后继为空为止，那么如何在线索树中找结点的直接前驱和后继呢？我们先来看如何在线索树中找结点的直接后继，以中序线索树为例 树中所有叶子结点的右链都是线索，右链直接指示了结点的直接后继 比如结点 G 的直接后继是结点 E 树中所有非叶子结点的右链都是指针，根据中序遍历的规律，非叶子结点的直接后继是遍历其右子树时访问的第一个结点，即右子树中最左下的（叶子）结点 比如结点 C 的直接后继查找顺序是先沿右指针找到右子树的根结点 F，然后沿左链往下直到 ltag = 1 的结点即为 C 的直接后继结点 H 至于查找线索树中结点的直接前驱元素，若结点的 ltag = 1，则左链是线索，指示其直接前驱，否则在遍历左子树时访问的最后一个结点（即沿左子树中最右往下的结点）为其直接前驱结点，这里稍微提及一下，对于后序遍历的线索树中找结点的直接后继比较复杂，可分以下三种情况 若结点是二叉树的根结点，则其直接后继为空 若结点是其父结点的左孩子或右孩子且其父结点没有右子树，则直接后继为其父结点 若结点是其父结点的左孩子且其父结点有右子树，则直接后继是对其父结点的右子树按后序遍历的第一个结点 线索二叉树的定义线索二叉树其实也就是二叉树的线索化，它指的是依照某种遍历次序使二叉树成为线索二叉树的过程，其实简单来说就是一般的二叉树，只不过在遍历的过程当中添加了线索化的过程，线索化的过程就是在遍历过程中修改空指针使其指向直接前驱或直接后继的过程，仿照线性表的存储结构，我们可以在二叉树的线索链表上也添加一个头结点 head，头结点的指针域的安排是 lchild 域，指向二叉树的根结点 rchild 域，指向中序遍历时的最后一个结点 二叉树中序序列中的第一个结点 lchild 指针域和最后一个结点 rchild 指针域均指向头结点 head 简单来说就是如同为二叉树建立了一个双向线索链表，对一棵线索二叉树既可从头结点也可从最后一个结点开始按寻找直接后继进行遍历，显然这种遍历不需要堆栈 线索二叉树的遍历在线索二叉树中，由于有线索存在，在某些情况下可以方便地找到指定结点在某种遍历序列中的直接前驱或直接后继，此外，在线索二叉树上进行某种遍历比在一般的二叉树上进行这种遍历要容易得多，不需要设置堆栈，代码实现如下，不过一般使用较少，了解即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// 线索存储标志位// 0 表示指向左右孩子的指针// 1 表示指向前驱后继的线索var LINK = 0var THREAD = 1// 结构function BinaryThreadTree_inOrder(data, leftChild, rightChild) { this.data = data this.leftChild = leftChild || null this.rightChild = rightChild || null // 相对于普通二叉树新增了左右标记 this.leftTag = this.rightTag = undefined}BinaryThreadTree_inOrder.prototype = { constructor: BinaryThreadTree_inOrder, // 中序线索二叉树的遍历 inOrderTraverse_thread: function (visit) { var p = this.leftChild while (p != this) { while (p.leftTag === LINK) p = p.leftChild if (visit(p.data) === false) return while (p.rightTag == THREAD &amp;&amp; p.rightChild != this) { p = p.rightChild visit(p.data) } p = p.rightChild } }, // 中序线索化 inOrderThreading: function () { return inOrderThreading(this) }, // 在当前结点插入子树 x，p 代表当前结点 insertSubTree: function (xTree) { var s, q // x 作为 p 的左子树 if (this.leftTag === THREAD) { // s 为 p 的前驱 s = this.leftChild this.leftTag = LINK this.leftChild = xTree q = xTree while (q.leftChild &amp;&amp; q.leftTag === LINK) q = q.leftChild // 找到子树中的最左结点，并修改其前驱指向 s q.leftChild = s xTree.rightTag = THREAD // x 的后继指向 p xTree.rightChild = this // x 作为 p 的右子树 } else if (this.rightTag === THREAD) { // s 为 p 的后继 s = this.rightChild this.rightTag = LINK this.rightChild = xTree q = xTree while (q.leftChild &amp;&amp; q.leftTag === LINK) q = q.leftChild // 找到子树中的最左结点，并修改其前驱指向 p q.leftChild = this xTree.rightTag = THREAD // x 的后继指向 p 的后继 xTree.rightChild = s // x 作为 p 的左子树，p 的左子树作为 x 的右子树 } else { s = this.leftChild var t = s while (t.leftChild &amp;&amp; t.leftTag === LINK) t = t.leftChild // 找到 p 的左子树的最左结点 t 和前驱 u var u = t.leftChild this.leftChild = xTree xTree.rightTag = LINK // x 作为 p 的左子树，p 的左子树作为 x 的右子树 xTree.rightChild = s t.leftChild = xTree q = xTree while (q.leftChild &amp;&amp; q.leftTag === LINK) q = q.leftChild // 找到子树中的最左结点，并修改其前驱指向 u q.leftChild = u } }}// 二叉树中序线索化function inOrderThreading(tree) { var threadTree = new BinaryThreadTree() threadTree.leftTag = LINK threadTree.rightTag = THREAD // 右指针回指 threadTree.rightChild = threadTree var pre // 若二叉树为空，左指针回指 if (!tree) { threadTree.leftChild = threadTree } else { threadTree.leftChild = tree pre = threadTree // 中序遍历进行中序线索化 inThreading(tree) // 最后一个结点线索化 pre.rightChild = threadTree pre.rightTag = THREAD threadTree.rightChild = pre } return threadTree function inThreading(p) { if (!p) return // 左子树线索化 inThreading(p.leftChild) // 前驱线索 if (!p.leftChild) { p.leftTag = THREAD p.leftChild = pre } // 后继线索 if (!pre.rightChild) { pre.rightTag = THREAD pre.rightChild = p } pre = p // 右子树线索化 inThreading(p.rightChild) }}","link":"/2020/03/27/Essay/18/"},{"title":"树、森林与二叉树之间的转换","text":"本章我们主要来看一下树、森林和二叉树之间的相互转换以及赫夫曼树的相关概念 普通树转换为二叉树我们借助图片来进行了解，首先下图是一颗普通的树，它有三个结点，所以明显不是二叉树 如果将其转换成相应的二叉树分为两个步骤 在树中所有的兄弟结点之间加一连线 对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线 所以我们首先执行『在兄弟结点之间添加连线』 然后在去除『非长子外』的连线 最后，我们在稍微调整一下位置，就可以得出我们想要的二叉树 总结一下，基本的步骤如下 加线，在所有兄弟结点之间加一条连线 去线，对树中每个结点，只保留它与第一孩子结点的连线，删除它与其他孩子结点之间的连线 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明 森林转换为二叉树同样的还是借助图片来进行了解，首先下图是三颗普通的树，三棵树构造在一起就成了一个森林 如果将其转换成相应的二叉树分为两个步骤 先将森林中的每棵树变为二叉树 再将各二叉树的根结点视为兄弟从左到右连在一起，就形成了一颗二叉树 所以我们首先将森林中的每棵树变为二叉树，方式和我们之前实现的方式是一致的 然后将它们的『根结点』依次连在一起 最后老规矩，在稍微调整一下位置 总结一下，基本的步骤如下 把每棵树转换为二叉树 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来 二叉树转换为树、森林二叉树转换为普通树本质上就是之前的逆过程，步骤也就是反过来做而已，判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是『只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树』，如下，是一个二叉树 第一步，若结点 x 是其双亲 y 的左孩子，则把 x 的右孩子，右孩子的右孩子等等等等，依次都与 y 用连连连接起来，如下 第二步，去掉所有双亲到右孩子之间到连线（也就是之前到逆向） 最后老规矩，调整一下，就变成了我们之前的森林 树与森林的遍历简单来说，树的遍历分为两种方式，一种是先根遍历，另一种是后根遍历 先根遍历，先访问树的根结点，然后再依次先根遍历根的每棵子树 后根遍历，先依次遍历每棵子树，然后再访问根结点 比如下面这棵树 我们按照两种遍历方式如下 先根遍历结果为 A ==&gt; B ==&gt; E ==&gt; F ==&gt; C ==&gt; G ==&gt; D ==&gt; H ==&gt; I ==&gt; J后根遍历结果为 E ==&gt; F ==&gt; B ==&gt; G ==&gt; C ==&gt; H ==&gt; I ==&gt; J ==&gt; D ==&gt; A 相对于森林的遍历也分为前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历依次访问森林的每一棵树，这里有一个需要注意的地方，注意比较下面两个图，前面一个是一棵树，而后面那颗则是树转换为二叉树以后的模样 仔细观察我们可以发现 树、森林的前根（序）遍历和二叉树的前序遍历结果相同 树、森林的后根（序）遍历和二叉树的中序遍历结果相同 这样一来，我们就可以将对树和森林遍历这种复杂问题转换为一种相对比较简单的处理方式 赫夫曼树在数据膨胀、信息爆炸的今天，数据压缩的意义不言而喻，谈到数据压缩，就不能不提赫夫曼（Huffman）编码，赫夫曼编码是首个实用的压缩编码方案，即使在今天的许多知名压缩算法里，依然可以见到赫夫曼编码的影子 另外，在数据通信中，用二进制给每个字符进行编码时不得不面对的一个问题是如何使电文总长最短且不产生二义性，根据字符出现频率，利用赫夫曼编码可以构造出一种不等长的二进制，使编码后的电文长度最短，且保证不产生二义性 关于赫夫曼编码的内容会在最后进行介绍，在此之前，我们先来了解一下什么是赫夫曼树，先来看下面这个计算成绩的示例 12345678if(a &lt; 60) printf(\"不及格\")else if(a &lt; 70) printf(\"及格\")else if(a &lt; 90) printf(\"良好\")else printf(\"优秀\") 如果我们将其转化为二叉树的显示方式，是下面这样的 如果按照上面这个流程，比如某个同学的成绩是 85 分的话，则需要进行三次判断才能得出他的成绩，那么我们是否可以稍微的调整一下，让这个判断流程减少一些呢，那就有了下图这样的二叉树 如果我们把判断流程改为像上图这样，那么可以发现效果有比较明显的改善，即我们只需要两次判断就可以得出我们想要的结果，但是我们如何区分到底应该采用哪种判断流程呢？所以这种情况要按实际情况来进行考虑，如下图 可以发现，一个班级的成绩一般来说，达到良好的人数应该占班级总人数的绝大数，有了这个概念以后，我们就可以先把这两棵二叉树简化成『叶子结点带权』的二叉树（树结点间的连线相关的数叫做权，Weight），就是把我们对应分数的所占比例给带入到二叉树当中，结果如下图 针对于上图，我们需要介绍几个基本的概念，如下 结点的路径长度，表示从根结点到该结点的路径上的连接数 树的路径长度，表示树中每个叶子结点的路径长度之和 结点带权路径长度，表示结点的路径长度与结点权值的乘积 树的带权路径长度（WPL，Weighted Path Length），表示的是树中所有叶子结点的带权路径长度之和 如果 WPL 的值越小，说明构造出来的二叉树性能越优 有了这些概念以后，我们就可以来分别计算上诉两种情况 针对第一种情况，它的 WPL 是 5 * 1 + 15 * 2 + 70 * 3 + 10 * 3 = 275 针对第二种情况，它的 WPL 是 10 * 1 + 70 * 2 + 15 * 3 + 5 * 3 = 210 可以发现，针对成绩的判断流程，采取后面的一种方式是更为合理的，那么现在问题来了，因为在一棵树的所有构成形状当中，有各种各样的构成方式，那么我们如才能何构造出最优的赫夫曼树呢（也就是所谓的最优二叉树）？看下面流程 假设有一片森林，如上图所示，有四颗小树（只有一个根结点的树），它们的权也分别标注了出来，然后我们挑选出权值最小的两棵树，小的放左边，大的放右边，然后模拟出一个新的结点作为新二叉树的根，这个新的结点连接着它们两个，如下所示，而新的树的权值为它的左右孩子的权值之和 然后同理操作，继续在剩余树林当中挑选出权值最小的那一颗，按照我们之前的逻辑继续连接，也就是下面这样 依次执行下去，最后的结果如下 这样就形成了一颗赫夫曼树，也就是所谓的最优二叉树，因为如果用其他的方式使用 ABCD 来进行构造所形成的二叉树的 WPL 是不会小于上图当中所实现的方式的 赫夫曼编码在之前的章节当中，我们已经介绍了赫夫曼树的基本原理和构造方式，而赫夫曼编码可以很有效地压缩数据（通常可以节省 20% ~ 90% 的空间，具体压缩率依赖于数据的特性），下面我们来看几个经常会遇到的名词 定长编码，比如像 ASCII 编码就是定长编码，如果我们有一百个字符，并且都是 A 的话，那么则需要八百位才能存放的下 变长编码，单个编码的长度不一致，可以根据整体出现频率来调节，比如我们要发生的信息都是 A，那么我们可以使用 0 或者 1 来代表 A（因为这个规则我们已经事先约定好了） 前缀码，所谓的前缀码，就是没有任何码字是其他码字的前缀，比如我们的赫夫曼编码（其实就是非前缀码，但是业界之中都叫前缀码） 下面我们来看看如何用代码进行实现，我们首先来定义哈夫曼树节点 HuffmanTreeNode 123456function HuffmanTreeNode(weight, char) { this.l = null // 左子树 this.r = null // 右子树 this.weight = weight || 0 // 字符的度量值，也就是字符在文本中出现的频次 this.char = char || '' // 字符} 然后我们再来定义一个最小堆 heapMin，主要用于在创建哈夫曼树过程中获取度量值 weight（字符出现的频次）最小的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 定义一个最小堆对象 */var heapMin = function () { this.set = []}/** * 调整堆使其满足最小堆性质 */heapMin.prototype.adjust = function (index) { let len = this.set.length let l = index * 2 + 1 let r = index * 2 + 2 let min = index let node = null if (l &lt;= len - 1 &amp;&amp; this.set[min].weight &gt; this.set[l].weight) { min = l } if (r &lt;= len - 1 &amp;&amp; this.set[min].weight &gt; this.set[r].weight) { min = r } if (min != index) { node = this.set[index]; this.set[index] = this.set[min] this.set[min] = node this.adjust(min) }}/** * 插入一个元素 */heapMin.prototype.push = function (node) { this.set.push(node) for (let i = Math.floor(this.set.length / 2); i &gt;= 0; i--) { this.adjust(i) }}/** * 移除最小元素 */heapMin.prototype.pop = function () { let node node = this.set.shift() this.adjust(0) return node}/** * 获取当前堆大小 */heapMin.prototype.size = function () { return this.set.length}/** * 堆是否为空 */heapMin.prototype.empty = function () { return this.set.length === 0 ? true : false} 再来定义哈夫曼编码对象 HuffmanCode 1234function HuffmanCode() { this.codeTable = [] // 当前的编码表 this.huffmanTree = null // 当前的哈夫曼树} 生成字符频次最小堆，因为 JavaScript 中的数组实质上是一个散列数组，因此我们可以将字符直接作为键进行索引 123456789101112131415161718192021222324/** * 统计字符出现的频次，生成字符频次最小堆 * * options 要进行编码的字符串 * 返回值 返回一个字符串出现频次的最小堆 */HuffmanCode.calcHeap = function (str) { let heap = new heapMin() let set = [] for (let i = str.length - 1; i &gt;= 0; i--) { if (set[str[i]]) { set[str[i]].num++ } else { set[str[i]] = { num: 1, char: str[i] } } } Object.values(set).forEach((value) =&gt; { heap.push(new HuffmanTreeNode(value.num, value.char)) }) return heap} 创建哈夫曼树 123456789101112131415161718192021222324252627/** * 创建哈夫曼树 * * options 要进行哈夫曼编码的字符串 * return 哈夫曼编码树 */HuffmanCode.prototype.createHuffmanTree = function (str) { let heap = HuffmanCode.calcHeap(str) while (heap.size() &gt; 1) { let min1 = heap.pop() let min2 = heap.pop() let parent = new HuffmanTreeNode(min1.weight + min2.weight, '') if (min1.weight &lt; min2.weight) { parent.l = min1 parent.r = min2 } else { parent.l = min2 parent.r = min1 } heap.push(parent) } this.huffmanTree = heap.pop()} 递归哈夫曼树，生成编码表 1234567891011121314/** * 递归哈夫曼树，生成编码表 * * node 当前要递归的结点 * arr 编码表 * code 编码字符串 */HuffmanCode.traverseTree = function (node, arr, code) { if (node.l !== null &amp;&amp; node.r != null) { HuffmanCode.traverseTree(node.l, arr, code + '0') HuffmanCode.traverseTree(node.r, arr, code + '1') } arr[node.char] = code} 哈夫曼编码 123456789101112131415/** * 哈夫曼编码 */HuffmanCode.prototype.encode = function (str) { this.createHuffmanTree(str) let res = [] HuffmanCode.traverseTree(this.huffmanTree, this.codeTable, '') for (let i = str.length - 1; i &gt;= 0; i--) { res.push(this.codeTable[str[i]]) } return res.join('')} 哈夫曼解码 1234567891011121314151617181920212223242526/** * 哈夫曼解码，编码前的字符串 */HuffmanCode.prototype.decode = function (str) { if (this.huffmanTree === null) { console.error('Please create HuffmanTree!'); } let node = this.huffmanTree let res = [] for (let len = str.length, i = 0; i &lt; len; i++) { if (str[i] === '0') { node = node.l } else { node = node.r } if (node.l === null &amp;&amp; node.r === null) { res.push(node.char) node = this.huffmanTree } } return res.join('')} 测试 123456let huffmanCode = new HuffmanCode()huffmanCode.encode('赫夫夫夫夫夫曼编编编编编编编编编编码')console.log(huffmanCode)huffmanCode.decode('0011111111111100001010101010010')","link":"/2020/04/02/Essay/19/"},{"title":"图结构","text":"我们在之前的 单链表，循环链表 等链表章节当中我们介绍了每个元素之间只有一个直接前驱和一个直接后继元素，同样的，在 树 与 二叉树 等章节当中介绍了在树这种结构中，数据元素之间是层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关，但是以上这些仅仅都只是一对一，一对多的简单模型 那么如果元素之间存在多对多的关系呢，我们又该如何来处理呢，所以今天我们就来看看另外一种名为图的结构 图的定义图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为 G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合，比如下图，就是一个图结构 对于图的定义，我们需要明确几个注意的地方 线性表中我们把数据元素叫元素，树中叫结点，而在图中数据元素我们称之为顶点（Vertex） 线性表可以没有数据元素，称为空表，树中可以没有结点，叫做空树，而图结构强调顶点集合 V 要有穷非空 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，不过需要注意，边集可以是空的 关于图的各种定义概念十分之多，我们一个一个来进行了解 无向边若顶点 Vi 到 Vj 之间的边没有方向，则称这条边为无向边（Edge），用无序偶（Vi, Vj）来表示，需要注意的是，无序偶的顺序是随意的，比如写成（Vj, Vi）也是可行的 比如上图当中 G1 是一个无向图，G1 = {V1, E1}，其中 V1 = {A, B, C, D} E1 = {(A, B), (B, C), (C, D), (D, A), (A, C)} 有向边若从顶点 Vi 到 Vj 的边有方向，则称这条边为有向边，也成为弧（Arc），用有序偶 &lt;Vi, Vj&gt; 来表示，Vi 称为弧尾，Vj 称为弧头，需要注意的是，有序偶的顺序不能是随意的，需要与方向指向对应，如下图 比如上图 G2 是一个无向图，G2 = {V2, E2}，其中 V2 = {A, B, C, D} E2 = {&lt;B, A&gt;, &lt;B, C&gt;, &lt;C, A&gt;, &lt;A, D&gt;} 简单图在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图，简单图也是使用最为广泛的，比如下面两个反面示例，它们都不属于简单图 无向完全图在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图，含有 n 个顶点的无向完全图有 n * (n - 1) / 2 条边，如下图所示 有向完全图在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图，含有 n 个顶点的有向完全图有 n * (n - 1) 条边，如下图所示 稀疏图和稠密图这里的稀疏和稠密是模糊的概念，一般使用较少，而且都是相对而言的，通常认为边或弧数小于 n * logn（n 是顶点的个数）的图称为稀疏图，反之称为稠密图 网有些图的边或弧带有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight，与带权树概念是一致的），带权的图通常称为网（Network），如下图所示 子图假设有两个图 G1 = (V1, E1) 和 G2 = (V2, E2)，如果 V2 ⊆ V1，E2 ⊆ E1，则称 G2 为 G1 的子图（Subgraph），比如下图这样的情况，右边的图均称为左图的子图 无向图的顶点与边之间的关系对于无向图G = (V, E)，如果边 (V1, V2) ∈ E，则称顶点 V1 和 V2 互为邻接点（Adjacent），即 V1 和 V2相邻接，边 (V1, V2)依附（incident）于顶点 V1 和 V2，或者说边 (V1, V2) 与顶点 V1 和 V2相关联，顶点 V 的度（Degree）是和 V 相关联的边的数目，记为 TD(V)，如下图中的顶点 A 与 B 互为邻接点，边 (A, B) 依附于顶点 A 与 B 上，所以顶点 A 的度为 3 有向图的顶点与边之间的关系对于有向图G = (V, E)，如果有 &lt;V1,V2&gt; ∈ E，则称顶点 V1邻接到顶点 V2，顶点 V2邻接自顶点 V1，以顶点 V 为头的弧的数目称为 V 的入度（InDegree），记为 ID(V)，以 V 为尾的弧的数目称为 V 的出度（OutDegree），记为 OD(V)，因此顶点 V 的度为 TD(V) = ID(V) + OD(V)，下图顶点 A 的入度是 2，出度是 1，所以顶点 A 的度是 3 路径无向图G = (V, E) 中从顶点 V1 到顶点 V2 的路径（Path），下图用蓝线列举了从顶点 B 到顶点 D 的四种不同路径 如果 G 是有向图，则路径也是有向的，比如下图用蓝线列举顶点 B 到顶点 D 的两种路径，而顶点 A 到顶点 B 就不存在路径 回路或环路径的长度是路径上的边或弧的数目，第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle），序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环，比如下面这个图当中左侧是简单环，右侧则不是简单环，因为右图当中的 C 重复出现了 连通图在无向图G 中，如果从顶点 V1 到顶点 V2 有路径，则称 V1 和 V2 是连通的，如果对于图中任意两个顶点 Vi 和 Vj 都是连通的，则称 G 是连通图（ConnectedGraph），比如下图当中，左侧不是连通图（因为 E，F 独自在一块，没有一个顶点和 ABCD 相连通），而右侧则是连通图 连通分量无向图中的极大连通子图（比如上图当中右侧就是左侧的子图） 称为连通分量，但是需要注意的是 首先要是子图，并且子图是要连通的 连通子图含有极大顶点数（比如下图右侧虽然是上图左侧的子图，但是它并不是极大的，但是左侧却是极大连通子图，所以也就是连通分量） 具有极大顶点数的连通子图包含依附于这些顶点的所有边 强连通图在有向图G 中，如果对于每一对 Vi 到 Vj 都存在路径，则称 G 是强连通图，有向图中的极大强连通子图称为有向图的强连通分量，下图左侧并不是强连通图（因为并不是每个顶点都存在路径），而右侧则是，并且右侧是左侧的极大强连通子图，也是左侧的强连通分量 生成树最后我们再来看连通图的生成树定义，所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n - 1 条边，比如下图，它只是一个普通的图，它还不是一棵树，因为它有八个顶点，但是却有九条边，如果要满足生成树的话则需要是七条边 如果我们想要它变成生成树，则需要剔除两条边，如下 但是像下面这样，它却并不是一颗生成树（虽然它满足条件，但是它是两个子图，没有连在一起） 有向树如果一个有向图恰有一个顶点入度为 0，其余顶点的入度均为 1，则是一棵有向树，比如下图，左侧是一个普通的有向图，只需要将其简单的修剪就成为了右侧的森林（因为它们分别是两颗有向树），因为对于中间那个图来说，因为仅仅只有一个顶点 B 入度为 0，而最后一个图当中的 F 也是同理 总结 图按照有无方向可以分为无向图和有向图 无向图是由顶点和边构成 有向图是由顶点和弧构成，弧分为弧尾和弧头，指向是从弧尾指向弧头 图按照边或者弧的多少可以分为稀疏图和稠密图（基于 n * logn 来区分，相对的概念） 如果任意两个顶点之间都存在边，就将其称之为完全图，有向的话就称为有向完全图，若无重复边（顶点除外），称之为简单图（图中的顶点之间有依附这个概念） 无向图顶点的边称之为度，跟这个顶点有多少关联的边，我们就称这个顶点有多少度，而有向图会把其区分为入度和出度，如果图上的边或者弧带有权的话就将其称之为网 如果图中两个顶点之间存在路径，我们可以说这两个顶点是连通的，而图中任意两个顶点都是连通的话，则称为连通图，有向的就将其称之为强连通图 如果图中有子图，若子图极大连通，则称为连通分量，有向的则称之为强连通分量 无向图可以构成一颗生成树，特点是有 n 个顶点，有 n - 1 条边（但不是所有情况都能够构成生成树，它们必须要连成一块） 有向图如果只有一个顶点入度为 0，其余顶点的入度均为 1，则是一棵有向树，一个有向图由若干个有向树构成森林","link":"/2020/04/05/Essay/20/"},{"title":"普里姆算法和克鲁斯卡尔算法","text":"本章我们来看两个关于图的算法，也算是为我们接下来将要介绍的 最短路径 和 关键路径 做一些铺垫，它们分别是『普里姆算法』和『克鲁斯卡尔算法』，它们的目的都是生成『最小生成树』，它们两者的实现原理是比较相似的，只不过一个通过边，而另一个主要是通过顶点来实现的，下面我们就一个一个来进行介绍 普里姆算法普里姆算法（Prim），是图论中的一种算法，可在加权连通图里搜索最小生成树，意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小，我们通过一个简单的示例来了解一下为什么需要『普里姆算法』，如下 图中的顶点我们可以将其想象成一个一个的村庄，而我们的目标就是让所有的村庄都连通起来，并且消耗的资源最少，当然实现的方式有很多种，比如下面这样 通过计算可以发现，它的成本为 11 + 26 + 20 + 22 + 18 + 21 + 24 + 19 = 161，不过如果我们仔细观察的话，可以发现这种连通方式是十分消耗资源的，所以我们稍微调整一下，就有了下面这种方式 通过计算发现其成本为 8 + 12 + 10 + 11 + 17 + 19 + 16 + 7 = 100，这样看起来似乎成本小了不少，但是有没有消耗更少的连通方式呢，方法是有的 这一次的成本为 8 + 12 + 10 + 11 + 16 + 19 + 16 + 7 = 99，可以发现，这一次便是最优的解决方式，那么问题就来了，我们该如何从多种方式当中来选取最优的方案呢，所以这就有了普里姆算法，下面我们就通过一个示例来了解，到底什么是普里姆算法，如下 我们选择从 0 开始出发构造我们的 MST，我们约定，蓝色顶点为蓝点集合（表示暂时还未遍历的点），黑色顶点为黑点集合（表示已经遍历过的点），红色边为最短边，灰色边为淘汰边，下面我们就开始从 0 进行遍历，所以出发点由蓝色变成黑色，如下 下面我们把和顶点 0 与相邻顶点之间的连线改变成紫色 我们第一步就是找与它相邻的边当中权值最小的，可以很明显的发现，是顶点 2，所以我们的目标就是 2 号顶点 下面一步就比较复杂，因为和顶点 2 相邻的有 1，3，4，5，但是 1 和 0 相连，3 也和 0 相连，但是我们在这里约定，『若是一个蓝点与多个黑点有边相连，则取权值最小的边作为紫边』，所以这时我们就需要比较 (0, 1) 和 (1, 2) 之间的边的权值，可以发现 (1, 2) 的权值更小，同理 (0, 3) 的边比 (2, 3) 的边的权值也更小，所以就有了如下的情况 我们选择剔除掉 (0, 1) 和 (2, 3) 之间的边（因为它们的权值更大），接着我们将与 2 相连的边调整为了紫色，接下来同理，我们继续寻找紫边当中权值最小的，可以发现是 (2, 5)，所以我们的目标就是 5 号顶点，如下 接下来同理，我们比较 (0, 3)，(3, 5)，(2, 4) 和 (4, 5)，结果如下 继续寻找权值最小的边，为 (5, 3)，所以变成如下的情况 接下来同理，继续选择权值较小的边，因为两边一致，所以我们随便挑选一条 继续比较 (1, 4) 和 (2, 4)，可以发现 (1, 4) 的更小 所以最终的结果如下 下面我们看如何用代码来进行实现，大致思想是 设图 G 顶点集合为 U，首先任意选择图 G 中的一点作为起始点 a，将该点加入集合 V 再从集合 U - V 中找到另一点 b 使得点 b 到 V 中任意一点的权值最小，此时将 b 点也加入集合 V 以此类推，现在的集合 V = { a, b }，再从集合 U - V 中找到另一点 c 使得点 c 到 V 中任意一点的权值最小，此时将 c 点加入集合 V，直至所有顶点全部被加入 V 此时就构建出了一颗 MST，因为有 N 个顶点，所以该 MST 就有 N - 1 条边，每一次向集合 V 中加入一个点，就意味着找到一条 MST 的边 在此之前，我们可以将上面的图片当中的数据转化为图片的格式，如下（可以点击放大查看） 下面来看如何用代码实现，关于图结构的生成可以参考我们在 图的存储结构 当中介绍过的邻接矩阵的实现，这里依然采用的是之前的实现方式，这里我们主要来看算法的实现 1234567891011121314151617181920212223242526272829303132function MiniSpanTree_Prim() { let min, i, j, k let adjvex = [] // 保存相关顶点下标 let lowcost = [] // 保存相关顶点间的权值 for (i = 0; i &lt; G.numVertexes; i++) { lowcost[i] = G.arc[0][i] // 将 v0 顶点与之有边的权的权值存入数组 adjvex[i] = 0 // 初始化都为 v0 的下标 } for (i = 1; i &lt; G.numVertexes; i++) { min = 65535 j = 0 k = 0 while (j &lt; G.numVertexes) { if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min) { // 如果权值不为 0 且小于 min min = lowcost[j] k = j } j++ } lowcost[k] = 0 // 将当前顶点的权值设置为 0，表示此顶点已完成任务 console.log('(%s, %s, %d)', G.vexs[adjvex[k]], G.vexs[k], min) // 打印当前顶点边中权值最小边，和权值 for (j = 0; j &lt; G.numVertexes; j++) { // 循环所有顶点 if (lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j]) { // 若下标为 k 顶点各边权值小于此前这些顶点未被加入生成树权值 lowcost[j] = G.arc[k][j] // 将较小权值存入 lowcost adjvex[j] = k } } }}createMGraph()MiniSpanTree_Prim() 克鲁斯卡尔算法无论是普里姆算法（Prim）还是克鲁斯卡尔算法（Kruskal），他们考虑问题的出发点都是为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能的小，普里姆算法是以『某顶点为起点』，逐步找各个顶点上最小权值的边来构建最小生成树的 但是现在我们换一种思考方式，我们从边出发，直接去找『最小权值的边』来构建生成树，这也是克鲁斯卡尔算法的精髓，还是老规矩，我们通过图片来进行了解，如下，我们使用红点来表示顶点 然后按照权值递增的顺序依次连接 (0, 2)，(3， 5)，(1， 4) 和 (2, 5)，我们将其也标注为红色，如下 由于边 (0, 3) 的两个顶点在同一棵树上，所以舍去，而边 (2, 4) 和 (1, 2) 的长度相同，可以任选一条加入，最后结果如下 最后我们来看如何用代码进行实现，我们还是以上面的示例为例，先将图转换成一个边集数组，如下 但是这一次，我们需要借助于一个 parent 数组来进行实现，初始化如下 下面是完成后的 parent 数组的变化，如下 图中加粗的线连接而成的就是一颗最小生成树，下面来看代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Edge() { this.begin = 0 this.end = 0 this.weight = 0}function Kruskal() { let n, m let parent = [] // 定义一数组用来判断边与边是否形成环路 let edges = [] // 定义边集数组 for (let i = 0; i &lt; G.numVertexes; i++) { // 因为是无向图所以相同的边录入一次即可，若是有向图改为 0 for (let j = i; j &lt; G.numVertexes; j++) { if (G.arc[i][j] != 0 &amp;&amp; G.arc[i][j] != 65535) { let edge = new Edge() edge.begin = i edge.end = j edge.weight = G.arc[i][j] edges.push(edge) } } } edges.sort((v1, v2) =&gt; { return v1.weight - v2.weight }) // 打印所有边 console.log(edges) for (let i = 0; i &lt; G.numVertexes; i++) { parent[i] = 0 } for (let i = 0; i &lt; edges.length; i++) { n = Find(parent, edges[i].begin) m = Find(parent, edges[i].end) // 假如 n 与 m 不等，说明此边没有与现有生成树形成环路 if (n != m) { parent[n] = m console.log(\"(%s,%s) %d\", G.vexs[edges[i].begin], G.vexs[edges[i].end], edges[i].weight) } }}// 查找连线顶点的尾部下标function Find(parent, f) { while (parent[f] &gt; 0) { f = parent[f] } return f}createMGraph()Kruskal() 总结对比以上两个算法可以发现，当我们当图当边数比较少的时候，『克鲁斯卡尔算法』效率会比较高（也就是稀疏图），而当顶点比较少，但是边却比较多的图而言（也就是稠密图），这时就可以采用『普里姆算法』来进行实现","link":"/2020/04/22/Essay/23/"},{"title":"图的遍历","text":"在之前的章节当中，我们介绍了 图结构 和 图的存储结构，所以可以得知 图的存储结构 主要有五种方式，有两种使用较多的『邻接矩阵』和『邻接表』，另外还有三种使用较少的『十字链表』，『邻接多重表』和『边集数组』，本章我们主要来看一下图的遍历 图的遍历在之前介绍过的二叉树的遍历当中，我们提到来四种遍历方式，它们分别是『前序遍历』，『中序遍历』，『后序遍历』和『层序遍历』，针对于二叉树而言，因为根结点只有一个，并且所有的结点都只有一个双亲，所以我们实现起来不算太过困难 但是针对图的遍历，因为它的任一顶点都可以和其余的所有顶点相邻接，所以极有可能存在重复走过某个顶点或漏了某个顶点的遍历过程，所以对于图的遍历，如果要避免以上情况，那就需要科学地设计遍历方案，通常有两种遍历方案，它们是『深度优先遍历』和『广度优先遍历』，下面我们就一个一个来进行了解 深度优先遍历深度优化遍历（DepthFirstSearch），也有称为深度优化搜索，简称为 DFS，我们以下面这个图为例 如果我们想要进行遍历，我们可以约定右手原则，即在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号，如果走到终点的时候发现分叉路都是已经被标记过的，则执行回退操作，一直回退到起点，比如针对上图，它的执行流程是 我们首先从 A 出发开始进行遍历，按照我们的右手原则（比如上例当中就是我们面对着 A），它会依次经过 A，B，C，D，E，最终到达 F 处 到达 F 以后可以发现，A 和 E 都是已经被标记过了，所以它会走向 G，这时发现 B 和 D 也都是已经标记过了，所以会走向 H 到达 H 以后会发现，E，D，G 都是已经标记过了，所以这时就会回退到 G 到位置，同理此时可以发现 B，D，F 也都是标记过了，所以依次经过 F，E，一直会回退到 D 到位置 到达 D 到位置以后会发现 C 是被标记过到，但是 I 是没有标记过到，所以会走向 I，下一步同理，发现 B 和 C 都是被标记过到，所以会往回走，在依次经过 D，C，B 回到 A 到位置上 回到 A 到位置上以后就算是结束遍历过程，这就是『深度优先遍历』 简单总结一下可以发现，『深度优先遍历』其实就是一个『递归』的过程，如果再细心观察，可以发现，其实整个遍历过程就像是一棵树的『前序遍历』，我们将上面到流程简单总结一下其实就是下图这样到流程 深度优先遍历的代码实现下面我们来看看如何进行实现，图结构的生成可以参考我们在 图的存储结构 当中介绍过的邻接矩阵的实现，所以在这里我们只介绍遍历方法，以邻接矩阵为例 1234567891011121314151617181920212223242526272829303132// 访问标志数组，遍历时使用let visited = []// 邻接矩阵的深度优先递归算法function DFS(i) { // 访问过的顶点设置为 TRUE visited[i] = true console.log('打印顶点:', G.vexs[i]) for (let j = 0; j &lt; G.numVertexes; j++) { if (G.arc[i][j] == 1 &amp;&amp; !visited[j]) { console.log(G.vexs[i], '-&gt;', G.vexs[j]) // 对未访问的顶点进行递归 DFS(j) } }}// 邻接矩阵的深度遍历操作function DFSTraverse() { for (let i = 0; i &lt; G.numVertexes; i++) { // 初始化所有顶点状态都是未访问过状态 visited[i] = false; } for (let i = 0; i &lt; G.numVertexes; i++) { // 若是连通图，只会执行一次 if (!visited[i]) DFS(i) }} 马踏棋盘算法马踏棋盘问题（又称骑士周游或骑士漫游问题）是算法设计的经典问题之一，题目是这样的，国际象棋的棋盘为 8 * 8 的方格棋盘，现将马放在任意指定的方格中，按照马走棋的规则将马进行移动，要求每个方格只能进入一次，最终使得马走遍棋盘 64 个方格，如下图所示，当马在棋盘上任意一点当时候，它的走法会有八种 在此之前，我们先来了解两个概念 回溯法 之前在 递归 章节中我们解决八皇后问题的时候，我们曾经提到过回溯法，简单来说就是一条路走到黑，碰壁了再回来一条路走到黑，如此循环 一般和递归可以很好的搭配使用，还有深度优先搜索（DFS） 哈密尔顿路径 图 G 中的哈密尔顿路径指的是经过图 G 中每个顶点，且『只经过一次的一条轨迹』 如果这条轨迹是一条闭合的路径（从起点出发不重复地遍历所有点后仍能回到起始点），那么这条路径称为『哈密尔顿回路』 关于马踏棋盘问题，主要的解决方案有两种，一种是基于『深度优先搜索』的方法，另一种是基于『贪婪算法』的方法 第一种基于深度优先搜索的方法是比较常用的算法，深度优先搜索算法也是数据结构中的经典算法之一，主要是采用递归的思想，一级一级的寻找，遍历出所有的结果，最后找到合适的解 第二种基于贪婪的算法则是制定贪心准则，一旦设定不能修改，他只关心局部最优解，但不一定能得到最优解 我们先来简单的分析一下，其实可以分为两种情况 在四角，马踏日走只有两个选择 在其余部分，马踏日走有四、六、八不等的选择 所以我们可以在外层另外加上两层，确保 8 * 8 方格中的每一个格子都有 8 中不同的选择，为了确保每个格子能走日字，而且选择的可能性等同，初始化除了最外两层格子标记没有被访问，最外两层中每个格子都标记为已被访问即可达到目标，如下图所示 如上，为了确保每个格子能走日字，而且选择的可能性等同，初始化除了最外两层格子标记没有被访问，最外两层中每个格子都标记为已被访问即可达到目标，并且每一个表格中马在访问时都有 8 种不同的选择，这 8 种不同的选择都会在其相应的 x 和 y 坐标上进行追加标记，如下所示 x y 2 1 1 2 -1 2 -2 1 -2 -1 -1 -2 1 -2 2 -1 先来看第一种实现方式，递归求解（回溯法求解），列出所有的解，并从中找出从 (2, 2) 位置出发的合适解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int chessboard[12][12] = {0};// 标记马已走的方格数int cnt = 0; // 标记马走完全程的具体方案数 int sum = 0;// 初始马当前位置向其周围相邻八个日字的 x, y 的偏移量int move[8][2] = {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}};// 输出马踏棋盘的解void PrintChess();// 马踏棋盘递归过程void Horse(int x, int y);int main(void) { int i, j; for (i = 0; i &lt; 12; i++) { for (j = 0; j &lt; 12; j++) { if (i == 0 || i == 1 || i == 10 || i == 11 || j == 0 || j == 1 || j == 10 || j == 11) { // 在 8 * 8 的外层再加上两层，确保 8 * 8 方格中的每一个格子都有 8 种不同的日字选择 chessboard[i][j] = -1; } } } // 从起始位置开始求得所有解 chessboard[2][2] = ++cnt; // 递归调用当前当前位置附近的 8 个日字，看看是否满足条件 Horse(2, 2); return 0;}// 马永远踏的是 x, y 位置，而不是 a, bvoid Horse(int x, int y) { // 临界值，马走日字全部踏完，成功求出问题解 if (cnt &gt;= 64) { sum++; PrintChess(); return; } for (int i = 0; i &lt; 8; i++) { int a = x + move[i][0]; // 拿到当前马位置相邻的 8 个日字的 x 坐标 int b = y + move[i][1]; // 拿到当前马位置相邻的 8 个日字的 y 坐标 // 判断当前马位置相邻的日字是否已被访问 if (chessboard[a][b] == 0) { cnt++; chessboard[a][b] = cnt; // 标志已被访问 Horse(a, b); // 从当前马的位置继续往下访问 cnt--; chessboard[a][b] = 0; // 回溯回来修改其相邻的日字的访问情况 } }}// 输出马踏棋盘的解void PrintChess() { cout &lt;&lt; endl &lt;&lt; \"马踏棋盘第 \" &lt;&lt; sum &lt;&lt; \"组解为:\" &lt;&lt; endl; int i, j; for (i = 2; i &lt; 10; i++) { for (j = 2; j &lt; 10; j++) { cout &lt;&lt; \" \" &lt;&lt; chessboard[i][j]; } cout &lt;&lt; endl; }} 再来看看贪心算法求解，列出从 (2, 2) 位置出发的合适解，局部最优 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;/* typedef struct{ int x; // 记录当前马位置的 x 坐标 int y; // 记录当前马位置的 y 坐标 int i; // 记录从当前马的位置前往下一个日字的序号 i (0 &lt; i &lt; 8) }StackHorse; */// 申请一个栈空间（里面存储的就是 x，y，i 三个具体的变量值）来标记马走的具体位置int StackHorse[100][3] = {0};// 记录 8 * 8 棋盘马走的具体脚印int chessboard[12][12] = {0};// 标记马已走的方格数int cnt = 1;// 初始马当前位置向其周围相邻八个日字的 x, y 的偏移量int move[8][2] = {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}}; // 输出马踏棋盘的解void PrintChess();// 马踏棋盘递归过程void Horse(int x, int y);int main(void) { int i, j; // 初始化马踏棋盘的具体值（0 代表未被访问，1 代表已被访问，-1 代表新加的最外面两层） for (i = 0; i &lt; 12; i++) { for (j = 0; j &lt; 12; j++) { if (i == 0 || i == 1 || i == 10 || i == 11 || j == 0 || j == 1 || j == 10 || j == 11) { chessboard[i][j] = -1; } } } // 从 (2, 2) 的位置开始跑，求得马踏棋盘的一组解 Horse(2, 2); PrintChess(); return 0;}// 非递归求一组解的过程void Horse(int x, int y) { int top = 0, i = 0; int a, b; // 记录当前马位置附近的日字坐标 chessboard[x][y] = 1; // 标记当前起始位置已被访问 // 记录当前马的位置 StackHorse[top][0] = StackHorse[top][1] = 2; while (cnt &lt; 64) { for (; i &lt; 8; i++) { a = x + move[i][0]; b = y + move[i][1]; // 如果当前马位置附近的日字没有被访问，跳出循环 if (chessboard[a][b] == 0) { break; } } // 能够访问当前马位置附近的日字 if (i &lt; 8) { chessboard[a][b] = ++cnt; StackHorse[top][2] = i; // 记录访问当前马位置附近的日字序号 (0 &lt; i &lt; 8) top++; // top 指向新的栈顶 StackHorse[top][0] = a; // 向新的栈顶放入马踏入的 x 坐标 StackHorse[top][1] = b; // 向新的栈顶放入马踏入的 y 坐标 x = a; // 标记新的 x y = b; // 标记新的 y i = 0; // 从栈顶马位置开始寻找附近的 8 个日字 } else { // 没有在当前马位置附近找到符合条件的日字 cnt--; // 回溯 chessboard[x][y] = 0; top--; // 出栈 x = StackHorse[top][0]; // 拿到当前马位置的 x 坐标 y = StackHorse[top][1]; // 拿到当前马位置的 y 坐标 i = StackHorse[top][2]; // 拿到当前马位置前往下一日字的序号 i++; // 继续搜索从当前马位置访问的日字序号的下一位置继续访问 } }}// 输出马踏棋盘的解void PrintChess() { cout &lt;&lt; \"马踏棋盘一组解为:\" &lt;&lt; endl; int i, j; for (i = 2; i &lt; 10; i++) { for (j = 2; j &lt; 10; j++) { cout &lt;&lt; \" \" &lt;&lt; chessboard[i][j]; } cout &lt;&lt; endl; }} 广度优先遍历广度优先遍历（BreadthFirstSearch），又称为广度优先搜索，简称 BFS，是最简便的图的搜索算法之一，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果，换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止，我们可以对照下图来进行理解 要实现对上图的广度遍历，我们可以利用队列来实现，比如我们以 A 为起点，流程如下 广度优先遍历的代码实现同深度优先遍历一样，我们这里也只介绍遍历算法的实现，原理是借助队列来进行实现 1234567891011121314151617181920212223242526272829303132333435363738394041// 邻接矩阵 的广度遍历算法function BFSTraverse() { // 初始化队列 let queue = [] for (let i = 0; i &lt; G.numVertexes; i++) { // 初始化所有顶点状态都是未访问过状态 visited[i] = false } // 对每一个顶点做循环 for (let i = 0; i &lt; G.numVertexes; i++) { // 如果没有访问过就处理 if (!visited[i]) { // 访问过的顶点设置为TRUE visited[i] = true console.log('打印顶点：', G.vexs[i]) // 将此顶点入队列 queue.push(i) // 退出条件为当前队列不为空 while (queue.length != 0) { queue.shift() for (let j = 0; j &lt; G.numVertexes; j++) { // 判断其他顶点若与当前顶点存在边且未访问过 if (G.arc[i][j] == 1 &amp;&amp; !visited[j]) { visited[j] = true console.log(G.vexs[i], '-&gt;', G.vexs[j]) console.log('打印顶点：', G.vexs[j]) // 将此顶点放入队列 queue.push(j) } } } } }}","link":"/2020/04/14/Essay/22/"},{"title":"图的存储结构","text":"在上一章当中，我们介绍了 图结构 的基本定义和一些相关概念，在图结构当中的定义概念十分之多，但是很多概念之间都是互相关联的，如果没有了解可以先行了解一下，在有了这些基础之上，本章我们就来看看图的存储结构 图的存储结构图的存储结构相比较线性表与树来说就复杂很多，因为对于线性表来说，是一对一的关系，所以用数组或者链表均可简单存放，而树结构是一对多的关系，所以我们要将数组和链表的特性结合在一起才能更好的存放，但是对于图结构，它是多对多的情况，图上的任何一个顶点都可以被看作是第一个顶点，任一顶点的邻接点之间也不存在次序关系，比如下面这几个图 我们仔细观察可以发现，其实它们都是同一个图，只是表现的形式不一样而已，因为任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系（内存物理位置是线性的，而图的元素关系是平面的），如果用多重链表来描述倒是可以做到，但是如果单独使用多重链表可能会导巨大的浪费（如果各个顶点的度数相差太大，就会造成巨大的浪费） 所幸，业界当中已经有前辈帮我们整理出来了五种不同的存储结构，它们分别是『邻接矩阵』，『邻接表』，『十字链表』，『邻接多重表』和『边集数组』，其中的『邻接矩阵』和『邻接表』是使用最为广泛的，所以我们会重点来进行讲解，其他另外三个了解即可 邻接矩阵（无向图）考虑到图是由『顶点』和『边或弧』两部分组成，所以可以就很自然地考虑到分为两个结构来分别存储，顶点因为不区分大小、主次，所以用一个一维数组来进行存储，而边或弧由于是顶点与顶点之间的关系，可以考虑采用二维数组来存储，所以我们也就有了邻接矩阵，图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息，如下图所示 我们可以设置两个数组，顶点数组为 vertex[4] = { V0, V1, V2, V3 }，边数组 arc[4][4] 为对称矩阵（0 表示不存在顶点间的边，1 表示顶点间存在边） 所谓对称矩阵就是 n 阶矩阵的元满足 a[i][j] = a[j][i]（0 &lt;= i, j &lt;= n），即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的（也就是上图当中分隔线所隔开的两部分），有了这个二维数组组成的对称矩阵，我们就可以很容易地知道图中的信息，比如要判定任意两顶点是否有边无边就非常容易了 而且如果想要知道某个顶点的度，其实就是这个顶点 Vi 在邻接矩阵中第 i 行（或第 i 列）的『元素之和』，而顶点 Vi 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，arc[i][j] 为 1 就是『邻接点』 邻接矩阵（有向图）看完了无向图的邻接矩阵，我们再来看看有向图，如下图 通过上图我们可以发现，顶点数组 vertex[4] = { V0, V1, V2, V3 }，弧数组 arc[4][4] 也是一个矩阵，但因为是有向图，所以这个矩阵并不对称，例如由 V1 到 V0 有弧，我们可以得到 arc[1][0] = 1，而 V0 到 V1 没有弧，因此 arc[0][1] = 0 另外有向图是有讲究的，要考虑『入度』和『出度』，顶点 V1 的入度为 1，正好是第 V1『列』的各数之和，顶点 V1 的出度为 2，正好是第 V1『行』的各数之和，所以简单来说就是，对于有向图，行数之和为『出度』，列数之和为『入度』 邻接矩阵（网）在图的术语中，我们提到了网这个概念，事实上也就是每条边上带有『权』的图就叫网 这里 ∞ 表示一个计算机允许的、大于所有边上权值的值 邻接矩阵的实现下面我们来看如何用代码进行实现，我们以下图为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 定义邻接矩阵let Arr2 = [ [0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0],]// 定义顶点数，定义边数let numVertexes = 9, numEdges = 14// 定义图结构 function MGraph() { this.vexs = [] // 顶点表 this.arc = [] // 邻接矩阵，可看作边表 this.numVertexes = null // 图中当前的顶点数 this.numEdges = null // 图中当前的边数}let G = new MGraph() // 创建图使用// 创建图function createMGraph() { G.numVertexes = numVertexes // 设置顶点数 G.numEdges = numEdges // 设置边数 // 录入顶点信息 for (let i = 0; i &lt; G.numVertexes; i++) { G.vexs[i] = 'V' + i } console.log(G.vexs) // 邻接矩阵初始化 for (let i = 0; i &lt; G.numVertexes; i++) { G.arc[i] = [] for (j = 0; j &lt; G.numVertexes; j++) { G.arc[i][j] = Arr2[i][j] } } console.log(G.arc)}// 调用createMGraph() 邻接表我们仔细观察可以发现，如果对于边数相对顶点较少的图，还是依然使用这种存储结构的话，无疑是对存储空间的极大浪费，如下图 因此我们可以考虑另外一种存储结构方式，例如把数组与链表结合一起来存储，这种方式在图结构也适用，我们称为『邻接表』（AdjacencyList） 无向图如果是『无向图』，邻接表的处理方法是这样 图中顶点用一个一维数组存储，当然顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息 图中每个顶点 Vi 的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储 如下图所示 有向图若是『有向图』，邻接表结构也是类似的，我们先来看下『把顶点当弧尾』建立的邻接表，这样很容易就可以得到每个顶点的出度 但也有时为了便于确定顶点的入度或『以顶点为弧头』的弧，我们可以建立一个有向图的『逆邻接表』 此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现 网最后我们再来看一下所谓的『网』，其实对于带权值的『网图』，完全可以在边表结点定义中再增加一个数据域来存储权值即可 下面我们再来看下『十字链表』，『邻接多重表』和『边集数组』，这些一般使用较少，了解即可 十字链表邻接表固然优秀，但也有不足，例如对有向图的处理上，有时候需要再建立一个逆邻接表，所以我们可以考虑把邻接表和逆邻接表结合起来，这就是我们将要介绍的『十字链表』（Orthogonal List） 接着我们重新定义边表结点结构 可以结合下图进行理解 十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 Vi 为尾的弧，也容易找到以 Vi 为头的弧，因而容易求得顶点的出度和入度，十字链表除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此在有向图的应用中，十字链表也是非常好的数据结构模型 邻接多重表前面我们介绍了有向图的优化存储结构，下面我们来看看如何针对无向图的邻接表来进行优化，如果我们在无向图的应用中，关注的重点是『顶点』的话，那么邻接表是不错的选择，但如果我们更关注的是『边』的操作，比如对已经访问过的边做标记，或者删除某一条边等操作，邻接表就显得不那么方便了，如下图所示 比如我们若要删除 (V0, V2) 这条边，就需要对邻接表结构中边表的两个结点进行删除操作 因此，我们也仿照十字链表的方式，对边表结构进行改装，重新定义的边表结构如下 其中 iVex 和 jVex 是与某条边依附的两个顶点在顶点表中的下标，iLink 指向依附顶点 iVex 的下一条边，jLink 指向依附顶点 jVex 的下一条边，也就是说在邻接多重表里边，边表『存放的是一条边』，而『不是一个顶点』，也就是下图所示 边集数组边集数组是由『两个一维数组』构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成，也就是下图这样","link":"/2020/04/09/Essay/21/"},{"title":"最短路径","text":"在之前的 普里姆算法和克鲁斯卡尔算法（最小生成树算法） 章节当中我们曾提到过，介绍这两个算法是为了我们接下来将要介绍的最短路径和关键路径做一些铺垫，那么今天我们就来正式的来了解一下什么是最短路径，以及它涉及到的两种算法『迪杰斯特拉算法（Dijkstra）』和『弗洛伊德算法（Floyd）』 最短路径正如字面意思一样，最短路径主要用于计算一个节点到其他所有节点的最短路径，主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止，在网图和非网图中，最短路径的含义是不同的 网图是两顶点经过的边上权值之和最少的路径 非网图是两顶点之间经过的边数最少的路径 我们通常把路径起始的第一个顶点称为源点，最后一个顶点称为终点，最短路径在现实当中使用也是较为广泛的，比如我们的乘车问题，如果路径最短，花费最少都是可以通过计算得来的，比如下面这个示例，如何求得 V0 到 V8 之间的最短路径呢？ 其实上面这个例子十分简洁，稍微整理一下就可以得出结果，它是下面这样的 但是在实际情况当中是非常复杂的，仅依观察算等方式是计算不出结果的，所以这个时候我们就需要借住一些算法来帮我们进行计算，下面我们先看看迪杰斯特拉算法是如何实现的 迪杰斯特拉算法其实如果我们自己来计算的话，也并不是一下子就求出了 V0 到 V8 的最短路径，而是一步步求出它们之间顶点的最短路径，比如 V0 到 V2 的距离我们通过计算可知，从 V0 出发经过 V1 在到达 V2 是比 V0 直接抵达 V2 划算一些的，按照类似的逻辑，我们在过程中不断的基于已经求出的最短路径的基础之上，再来求得更远顶点的最短路径，最终得到你要的结果 其实这就是『迪杰斯特拉算法』的实现原理，下面我们来看看如何具体实现，不过老规矩，我们将上图转换为邻接矩阵是下面这样的 我们还需要借助三个数组，如下 名称 初始化值 D（临时存放当前路径，会不断的覆盖它） 0 1 5 N N N N N N P（存放前驱结点） 0 0 0 0 0 0 0 0 0 final（当前最近的顶点） 1 0 0 0 0 0 0 0 0 完成以后数组的值为下 名称 当前值 D（临时存放当前路径，会不断的覆盖它） 0 1 4 7 5 8 10 12 16 P（存放前驱结点） 0 0 1 4 2 4 3 6 7 final（当前最近的顶点） 1 1 1 1 1 1 1 1 1 注意对比其中值的变化情况，创建图的函数 createMGraph() 可以见 图的存储结构 当中邻接矩阵的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859let Pathmatirx = [] // 用于存储最短路径下标的数组，下标为各个顶点，值为下标顶点的前驱顶点let ShortPathTable = [] // 用于存储到各点最短路径的权值和function Dijkstra() { let k, min let final = [] // 初始化（类似与上面那三个数组） for (let v = 0; v &lt; G.numVertexes; v++) { final[v] = 0 ShortPathTable[v] = G.arc[0][v] Pathmatirx[v] = 0 } ShortPathTable[0] = 0 final[0] = 1 // 初始化操作 for (let v = 1; v &lt; G.numVertexes; v++) { min = 65535 // 寻找离 V0 最近的顶点 for (let w = 0; w &lt; G.numVertexes; w++) { if (!final[w] &amp;&amp; ShortPathTable[w] &lt; min) { k = w // w 顶点离 V0 顶点更近 min = ShortPathTable[w] } } // 将目前找到的最近的顶点置位 1 final[k] = 1 // 修正当前最短路径及距离 for (let w = 0; w &lt; G.numVertexes; w++) { // 说明找到了更短的路径，修改 Pathmatirx[w] 和 ShortPathTable[w] if (!final[w] &amp;&amp; (min + G.arc[k][w] &lt; ShortPathTable[w])) { ShortPathTable[w] = min + G.arc[k][w] Pathmatirx[w] = k } } }}function PrintVn(Vn) { // 打印 V0 到 Vn 最短路径 console.log(\"%s-%s 最小权值和: %d\", G.vexs[0], G.vexs[Vn], ShortPathTable[Vn]); // 打印最短路线 let temp = Vn, str = '' while (temp != 0) { str = '-&gt;' + G.vexs[temp] + str temp = Pathmatirx[temp] } str = 'V0' + str console.log('最短路线：' + str)}createMGraph()Dijkstra()PrintVn(8) 弗洛伊德算法通过上面的示例我们可以发现，迪杰斯特拉算法是一个按路径长度递增的次序产生最短路径的算法，时间复杂度为 O(n^2)，n 为顶点个数，如果是从其他顶点开始，那么在原有算法的基础上再来一次循环，此时的时间复杂度为 O(n^3)，但是这里我们暂时按照最优解，也就是 O(n^2) 来计算，但是下面我们将要介绍的弗洛伊德算法它的复杂度却是 O(n^3)，通过对比可以发现性能远远没有之前一种算法高效，那么我们为什么还要介绍它呢？ 这是因为『迪杰特斯拉算法』求的是『一个顶点到所有顶点的最短路径』，而『弗洛伊德算法』是求『所有顶点到所有顶点的最短路径』，并且弗洛伊德算法实现起来也是非常简洁和优雅的，一目了然，我们还是以上面的例子来进行讲解，转换为邻接矩阵以后如下图所示 不过这一次我们只截取前面的一部分，如下 如上图，我们的 D0 这个二维数组，也就是左图的一个邻接矩阵的表示方式，只不过我们这里只截取来前三行，而 D1 则是利用下面这个公式转换而来的，同样也只是截取显示来前三行 1D1[0][2] = min{ D0[0][2], D0[0][1] + D[1][2] } 简单来说，min 的作用也就是求两者直接的最小值，然后赋予给 D1（因为它是一个无向图，所以说也就是对称的图），但是这是只有三个顶点的情况，如果我们的顶点多了以后，在整理起来就变得十分麻烦，所以这时候我们就需要另外一个辅助数组来帮助我们进行处理，也就是我们的 P 数组，它的作用主要是用来存放前驱结点，针对于上面的例子，它比较简单，因为它只有三个顶点，所以它要么走 (0, 2)，要么就是走 (0, 1) 和 (1, 2) 下面我们来看看如何用代码进行实现，在最后我们会详细介绍 P 数组的原理，老规矩，我们需要用到的也就是邻接矩阵和初始化的 P 数组，如下 下图是运行完以后的结果，也就是在运行了八次以后的结果（注意左上角的 D8 和 P8） 下面我们就来详细的看看 P 数组的含义，我们暂时以 V0 来进行介绍，在运行完了以后，它的值是 0 1 1 1 1 1 1 1 1，这就说明，(0, 1) 的前驱结点是 V1，(0, 2) 的前驱结点也是 V1，同理如果想从 V0 走到 V8，也要从 V1 开始，因为只有这样才是最短路径 再比如说是 V2，它的值为 1 1 2 4 4 4 4 4 4，第一位的 1 说明 V2 的前驱结点是 V1，也就是说如果从 V0 出发想要到达 V2，最优的走法是经过 V1 在到达 V2，而不是直接抵达 V2，再来看它后面的值，可以发现都是 4，这说明如果要通过 V2 到达 V3，V5，V6，V7，V8 则都是需要经过 V4 再比如 V3 对应的前几位也都是 4，这就说明如果需要以最短路径到达 V3，则都需要经过 V4 这个顶点，而这也就正是 P 数组的用处，最后我们再来看看代码该如何实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Pathmatirx = [] // 二维数组 表示顶点到顶点的最短路径权值和的矩阵let ShortPathTable = [] // 二维数组 表示对应顶点的最小路径的前驱矩阵function Floyd() { // 初始化 Pathmatirx ShortPathTable for (let v = 0; v &lt; G.numVertexes; ++v) { Pathmatirx[v] = [] ShortPathTable[v] = [] for (let w = 0; w &lt; G.numVertexes; ++w) { ShortPathTable[v][w] = G.arc[v][w] Pathmatirx[v][w] = w } } for (let k = 0; k &lt; G.numVertexes; ++k) { for (let v = 0; v &lt; G.numVertexes; ++v) { for (let w = 0; w &lt; G.numVertexes; ++w) { if (ShortPathTable[v][w] &gt; (ShortPathTable[v][k] + ShortPathTable[k][w])) { // 如果经过下标为 k 顶点路径比原两点间路径更短，当前两点间权值设为更小的一个 ShortPathTable[v][w] = ShortPathTable[v][k] + ShortPathTable[k][w] // 路径设置经过下标为 k 的顶点 Pathmatirx[v][w] = Pathmatirx[v][k] } } } }}function PrintAll() { for (let v = 0; v &lt; G.numVertexes; ++v) { for (let w = v + 1; w &lt; G.numVertexes; w++) { console.log('V%d - V%d weight: %d', v, w, ShortPathTable[v][w]) k = Pathmatirx[v][w] console.log(' Path: %d', v) while (k != w) { console.log(' -&gt; %d', k) k = Pathmatirx[k][w] } console.log(' -&gt; %d', w) } }}createMGraph()Floyd()PrintAll()","link":"/2020/05/06/Essay/24/"},{"title":"二叉排序树","text":"我们在上一章的 查找算法 当中介绍了算法的分类和一些比较常用的算法，比如二分，插值等等，但是它们的使用都需要一个前提条件，那就是『元素必须是有序的』，那么如果对于无序列表，我们又需要怎么来进行处理呢？这也就是我们今天将要介绍到的『二叉排序树』 为什么需要二叉排序树这里既然提到了二叉排序树，那我们就先来看看为何需要『二叉排序树』？针对于无序序列，比如我们的顺序存储结构，我们都知道，如果需要删除其中的一个元素，那么我们首先应该取出删除元素，然后从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置，可想而知，这样的操作的效率是十分低下的，如下所示 比如我们想要删除掉 104 这个元素，那么在将它删除掉了以后，它后面所有掉元素都需要向前移动一个位置，以保证存储结构的完整，当然也有说那是不是可以换一种删除方式呢，方法的确有很多种，比如下面这种 我们将待删除的 104 和末尾的 109 互换位置，然后将结构的长度缩减一位也可以达到我们的目的，虽然可以达到我们的目的，但是由于这样的序列它是无序的，所以就造成查找的效率很低，那么有没有一种插入和删除的效率还不错，又可以高效率查找的算法呢，那就是我们下面将要介绍的『二叉排序树』 二叉排序树在之前的章节当中，我们曾经介绍过了 二叉树的的定义 和 二叉树的遍历，但是在之前的内容当中我们并没有涉及到针对二叉树的一些查找和删除等操作，仅仅只是涉及到了遍历和插入操作，那么在今天我们就来看看如何在二叉树当中进行查找和删除等操作，不过在展开之前，我们需要先来了解一下，什么是二叉排序树呢？我们先来看下面这个图 我们可以考虑将这个数据集排列成二叉树的方式，但是做一点小小的约束，我们约定『它只允许在左结点存储比父结点更小的值，右结点存储比父结点更大的值』，依照这个原则，我们就有了下面这个二叉树 上面这个图就可以称之为二叉排序树，二叉排序树（Binary Sort Tree）又称为『二叉查找树』，它是一棵空树，或者是具有下列性质的二叉树 若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值 若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值 它的左、右子树也分别为二叉排序树（递归） 它既然被称为排序树，那么肯定是与排序有关的，比如针对上面这个例子，如果我们采用中序遍历的方式，我们就可以得到一个从小到大排好顺序的一个序列，也就是说我们存储的数据，虽然它是无序的，但是如果按照二叉排序树的方式来进行存储，那么我们只需要通过中序遍历的方式就可以得到一个有序的序列，但是我们构造这么一个二叉排序树的目的不单单只是为了排序这么简单，而是为了提高查找，插入和删除的效率 查找下面我们就来看看如何在二叉排序树当中进行查找操作，原理同插入操作是类似的，本质上都是利用递归来进行的，这个方法首先会检验 node 的合法性，如果为 null，直接退出，并返回 fasle，如果传入的 key 比当前传入 node 的 key 值小，它会继续递归查找 node 的左侧结点，反之，查找右侧结点，如果找到相等结点，直接退出，并返回 true 下面我们就来看看如何实现，代码如下，也就是在我们之前的 二叉树的建立 的基础上进行扩充 1234567891011121314// 查找给定的值find(key) { var node = this.root while (node != null) { if (key &lt; node.key) { node = node.left } else if (key &gt; node.key) { node = node.right } else { return node } } return null} 在这里我们多看一步，那就是如何查找最小、最大值呢？其实也很简单，其实在之前二叉树的建立的部分我们也略微提及过，那就是查找二叉树的最小值和最大值就是二叉树左右两侧最边缘部分的那个结点（最左侧或者最右侧），我们只需要将根节点传入 minNode 或 maxNode 方法，然后通过循环判断 node 是否为最左侧或者最右侧的节点（如果是的话，此时的值是为 null 的），下面我们来看看如何实现 1234567891011121314151617// 获取二叉树的最小值getMin(node) { node = node || this.root while (node.left != null) { node = node.left } return node.key}// 获取二叉树最大值getMax(node) { node = node || this.root while (node.right != null) { node = node.right } return node.key} 删除最后我们再来看最为复杂的情况，那就是删除结点，我们可以对照下图来看，一一捋清楚它的各种情况 按照移除的方式不同，我们可以大致将其分为三种情况 需要移除的节点是一个叶子节点（比如上面的 46，99 等），这种情况下，直接删除就可以了，因为它不会对整颗二叉排序树的特点造成影响 需要移除的节点仅有一个子节点（只有左子树或者右子树），这种情况也直接删除，然后将其的左子树或者右子树连接到它的双亲那里就可以了（比如直接删掉 67，然后将它的左子树 46 连接到 70 即可） 需要移除的节点包含两个子节点（也就是最为复杂的情况，既有左子树又有右子树的情况），我们这里比如需要删除 105，按照我们的中序遍历方式来看的话，那么替代它的最好的就是它的直接前驱或者后继，也就是 104 或者 108 所以如果直接删除 105 的话，可以使用 104 来顶替它的位置，而 103 来顶替 104 的位置 如果使用 108 来顶替的话，同样的道理，如果 108 存在右子树的话，只需要将其连接到 110 的左子树上即可 因为 108 大于 105 的所有左子树，同理 104 也是小于 115 所有的左子树 有一个需要注意的就是，104 是不会存在右子树的，如果存在则需要替换的目标就是它的右子树了，而不会是 104（同理 108 也不会存在左子树） 下面来看代码如何实现，其中，也就是移除包含两个子节点的节点是最复杂的情况，它包含左侧节点和右侧节点，对它进行移除主要需要三个步骤 需要找到它右侧子树中的最小节点来代替它的位置 将它右侧子树中的最小节点移除 将更新后的节点的引用指向原节点的父节点 1234567891011121314151617181920212223242526272829303132// 删除给定的值remove(key) { this.root = this.removeNode(this.root, key)}// 真正删除的函数removeNode(node, key) { if (node == null) { return null } if (key &lt; node.key) { node.left = this.removeNode(node.left, key) return node } else if (key &gt; node.key) { node.right = this.removeNode(node.right, key) return node } else { if (node.left == null &amp;&amp; node.right == null) { node = null return node } else if (node.left == null) { return node.right } else if (node.right == null) { return node.left } else { var minNode = this.getMin(node.right) node.key = minNode.key node.right = this.removeNode(node.right, minNode.key) return node } }} 完整代码下面是整合以后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Node { constructor(key) { this.key = key this.left = null this.right = null }}class BinaryTree { constructor() { this.root = null } // 插入数据 insert(key) { var newNode = new Node(key) if (this.root == null) { this.root = newNode } else { var current = this.root while (true) { if (key &lt; current.key) { if (current.left) { current = current.left } else { current.left = newNode break } } else if (key &gt; current.key) { if (current.right) { current = current.right } else { current.right = newNode break } } } } } // 中序遍历 centerSort(node) { if (node) { this.centerSort(node.left) console.log(node.key) this.centerSort(node.right) } } // 前序遍历 prevSort(node) { if (node) { console.log(node.key) this.prevSort(node.left) this.prevSort(node.right) } } // 后续遍历 nextSort(node) { if (node) { this.nextSort(node.left) this.nextSort(node.right) console.log(node.key) } } // 获取二叉树的最小值 getMin(node) { node = node || this.root while (node.left != null) { node = node.left } return node.key } // 获取二叉树最大值 getMax(node) { node = node || this.root while (node.right != null) { node = node.right } return node.key } // 查找给定的值 find(key) { var node = this.root while (node != null) { if (key &lt; node.key) { node = node.left } else if (key &gt; node.key) { node = node.right } else { return node } } return null } // 删除给定的值 remove(key) { this.root = this.removeNode(this.root, key) } // 真正删除的函数 removeNode(node, key) { if (node == null) { return null } if (key &lt; node.key) { node.left = this.removeNode(node.left, key) return node } else if (key &gt; node.key) { node.right = this.removeNode(node.right, key) return node } else { if (node.left == null &amp;&amp; node.right == null) { node = null return node } else if (node.left == null) { return node.right } else if (node.right == null) { return node.left } else { var minNode = this.getMin(node.right) node.key = minNode.key node.right = this.removeNode(node.right, minNode.key) return node } } }}","link":"/2020/06/12/Essay/27/"},{"title":"平衡二叉排序树","text":"在上一节当中，我们介绍了 二叉排序树 以及它的查找和删除等操作，但是它其实是存在一定问题的，至于到底是什么问题，下面我们慢慢来看 二叉排序树存在的问题比如我们现在有这样一个序列，5, 9, 3, 7, 1, 4, 6, 8, 2，将它转换为二叉排序树，是下面这个样子的 看上去还不错的样子，比如我们要查找 9 这个元素，两次对比后就可以得到结果，但是如果我们将序列调整为 1, 2, 3, 4, 5, 6, 7, 8, 9，那么它就成了下面这样的 可以发现，此时竟然成为了一颗右斜树，但是它的确也是一颗二叉排序树，而如果这时如果我们再去查找 9 这个元素的话，效率可想而知，所以我们可以发现，不同的二叉树，它的查找效率是不一样的，所以我们就需要想办法找到一个合适的方式，不管提供的序列是什么样子的，都可以生成一个查找效率尽量高的二叉排序树，那就是我们下面将要介绍的『平衡二叉排序树』（AVL 树） 平衡二叉排序树由名字就可以知道，我们的平衡二叉排序树它是一颗高度平衡的二叉树，意思就是要么它是一颗空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值『不超过一』 用官方的话来进行描述就是，我们将二叉树上的结点上的左子树的深度的值减去右子树的深度的值称为『平衡因子 BF』（BalanceFactor），平衡二叉树就是一棵二叉树上所有结点的平衡因子的绝对值小于等于 1 的树（所以它只有三个值，1，0，-1），比如下面这个就是『平衡二叉排序树』 而下面这个就不符合条件，因为平衡二叉排序树首先要是一棵树，接着需要是一颗二叉排序树，下面这个明显不符合二叉排序树的概念 在来看下面这个例子 它其实也不是平衡二叉排序树，因为比如结点 9，它的左子树和右子树的差的绝对值已经大于 1 了，再来看最后一个图 它就是一颗平衡二叉排序树了 平衡二叉排序树的构建过程下面我们来看平衡二叉排序树是如何一步一步构建出来的，我们以序列 3, 2, 1, 4, 5, 6, 7, 10, 9, 8 为例，它构造出来的二叉排序树是下面这样的 让我们抛开上图，一步一步从头开始进行操作，首先是根结点 3，和它的两个左子树元素 2 和 1，那么就会是下面这样的 可以发现，这个时候就已经存在问题了，因为结点 3 的平衡因子已经为 2 了（2 - 0 = 2），所以在插入结点 1 的时候我们就应该来适当的进行调整，调整的方式为『如果平衡因子是正数，且大于 1，那么对应的整颗子树就对应的向右进行旋转（顺时针）』，就变成来下面这样 下面我们在继续来进行添加，我们在依次插入结点 4 和 5，如下 此时又出现问题了，3 的平衡因子为 -2，而又是因为它的不平衡连带导致现在的根结点 2 也不平衡了，所以我们需要来对结点 3 进行处理，调整的方式为『如果平衡因子是负数，并且小于 -1，那么对应的整颗子树就对应的向左进行旋转（逆时针）』，所以就成了下面这样 下面我们继续操作，插入结点 6，变成了下面这样 这时可以发现，4，5，6 都是符合的，但是结点 2 却不符合了，所以我们此时需要调整结点 2，可以发现它的平衡因子是负数，所以左旋转，也就成了下面这样 但是此时可以发现，旋转以后作为新的根结点的 4，它有三个子结点了，这明显不符合我们二叉树的原理的，所以此时我们就需要针对结点 3 来进行处理，因为我们之前曾经提到过，一个结点的右子树的最左边的那个孩子，事实上可以放在这个结点的左子树的最右边的孩子位置，所以就变成了下面这样，此时又变成了平衡二叉树 下面继续插入结点 7，如下 老规矩，发现结点 5 的平衡因子为 -2，所以左转，就变成了下面这样 继续插入结点 10 和 9 又发现问题，结点 9 的插入导致了结点 4，6，7 的 BF 值均为 -2，但是这里注意，结点 10 的 BF 是为 1 的，所以这时如果按照我们之前的逻辑，负数向左旋转，我们可以尝试一下来调整结点 7，结果如下 这下发现麻烦大了，结点 9 竟然成为了结点 10 的右孩子，所以我们的尝试是不对的，因为我们可以注意，在之前的情况当中的 BF 值要么全部为正，要么全部为负，而这一次的情况是有正也有负，所以我们需要针对这种特殊的情况来单独进行处理，所以这里，我们需要按照步骤来走，先来处理结点 10，因为它的 BF 为正，所以向右旋转，就变成了下面这样 此时的 BF 就全部为负了，我们在按照我们之前的逻辑来处理结点 7，也就是向左旋转，就得到了下面这样 这时发现就是平衡的了，所以可以再次插入我们最后的结点 8，如下 这时可以发现，结点 4，6 的 BF 都为 -2，而结点 9 的 BF 却是为 1 的，所以按照我们之前的逻辑需要先将结点 9 进行右转，然后此时的 BF 值就统一成负数了，这时在进行左转就得到了我们的最终结果，这里也就直接跳过了，逻辑与上方是一样的，最后可以得到下面这样的结果 平衡二叉排序树的旋转上面看完了流程，下面我们来大致的总结一下，其实简单来说，平衡二叉树的构建过程基于二叉排序树的构建过程，不过只是在插入节点的过程中，一旦出现不平衡现象（即某节点的平衡因子大于 1 或小于 -1），就找出最小不平衡子树，进行『旋转』操作，调整最小不平衡子树中各节点的链接关系，使之成为新的平衡子树 在二叉排序树中插入节点而失去平衡的情况下，对最小不平衡子树进行调整，总共有四种『旋转』类型（LL 型，RR 型，LR 型，RL 型），分别对应不同的不平衡情况，其中 LL 型和 RR 型只需要一次旋转，而 LR 型和 RL 型则需要两次旋转，每种类型又可进一步细分为三种情况，总共 4 × 3 = 12 种情况，具体如下图所示 LL 型最小不平衡子树的根结点平衡因子值大于 1 且与根结点左孩子节点的平衡因子符号相同 RR 型最小不平衡子树的根结点平衡因子值小于 -1 且与根结点右孩子节点的平衡因子符号相同 LR 型最小不平衡子树的根结点平衡因子值大于 1 且与根结点左孩子节点的平衡因子符号不相同 RL 型最小不平衡子树的根结点平衡因子值小于 -1 且与根结点右孩子节点的平衡因子符号不相同） 代码实现本质上与我们的排序二叉树的实现方式类似，只不过多了一个平衡因子的参数，首先建立二叉树节点进行定义 123456constructor(num) { this.value = num // 存储数据 this.height = 1 // 平衡因子（多了一个这个参数） this.leftChild = null // 左孩子节点 this.rightChild = null // 右孩子节点} 下面是整合后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195class AVLTree { constructor(num) { this.value = num // 存储数据 this.height = 1 // 平衡因子（多了一个这个参数） this.leftChild = null // 左孩子节点 this.rightChild = null // 右孩子节点 } addNum(num) { let result = this // 创建节点 每一个节点都是一颗树 let point = new AVLTree(num) if (point.value &gt; this.value) { if (this.rightChild == null) { this.rightChild = point } else { result.rightChild = this.rightChild.addNum(num) } // 该树下面的左右节点平衡值 let balanceFactor = this.getBalance(this.rightChild, this.leftChild) //差值过大 不平衡 if (balanceFactor == 2) { if (point.value &gt; this.rightChild.value) { result = this.RR() } else { result = this.RL() } } } else if (point.value &lt; this.value) { if (this.leftChild == null) { this.leftChild = point } else { result.leftChild = this.leftChild.addNum(num) } let balanceFactor = this.getBalance(this.leftChild, this.rightChild) if (balanceFactor == 2) { if (point.value &lt; this.leftChild.value) { result = this.LL() } else { result = this.LR() } } } else { throw '输入了重复的值' } this.height = this.getMax(this.leftChild, this.rightChild) + 1 return result } deleteNum(num) { var result = this if (num &gt; this.value) { result.rightChild = this.rightChild.deleteNum(num) } else if (num &lt; this.value) { result.leftChild = this.leftChild.deleteNum(num) } else { if (num !== this.value) { throw '输入了没有的值' } if (result.leftChild !== null) { let current = result.leftChild // 不停的找到左节点的最右子节点 while (true) { if (current.rightChild) { current = current.rightChild } else { break } } result.value = current.value result.leftChild = result.leftChild.deleteNum(current.value) } else if (result.rightChild !== null) { let current = result.rightChild while (true) { if (current.leftChild) { current = current.leftChild } else { break } } result.value = current.value result.rightChild = result.rightChild.deleteNum(current.value) } else { // 最后子叶节点 console.log('delete' + result) return null } } // 再平衡 if (result.getBalance(result.leftChild, result.rightChild) == 2) { if (result.getHeight(result.leftChild.rightChild) - result.getHeight(result.leftChild.leftChild) == 1) { result = result.LR() } else { result = result.LL() } } else if (result.getBalance(result.leftChild, result.rightChild) == -2) { if (result.getHeight(result.rightChild.leftChild) - result.getHeight(result.rightChild.rightChild) == 1) { result = result.RL() } else { result = result.RR() } } else { console.log('is balance') } result.height = this.getMax(this.leftChild, this.rightChild) + 1 return result } getMax(a, b) { let aHeight, bHeight if (!a) { aHeight = 0 } else { aHeight = a.height } if (!b) { bHeight = 0 } else { bHeight = b.height } return aHeight &gt; bHeight ? aHeight : bHeight } getBalance(a, b) { let aValue, bValue if (!a) { aValue = 0 } else { aValue = a.height } if (!b) { bValue = 0 } else { bValue = b.height } return aValue - bValue } getHeight(a) { if (a) { return a.height } return 0 } RR() { let a = this let b = this.rightChild a.rightChild = b.leftChild b.leftChild = a a.height = a.getMax(a.rightChild, a.leftChild) + 1 b.height = b.getMax(b.rightChild, b.rightChild) + 1 return b } RL() { let a = this a.rightChild = a.rightChild.LL() a = a.RR() return a } LL() { let a = this let b = this.leftChild a.leftChild = b.rightChild b.rightChild = a a.height = a.getMax(a.rightChild, a.leftChild) + 1 b.height = b.getMax(b.rightChild, b.rightChild) + 1 return b } LR() { let a = this a.leftChild = a.leftChild.RR() a = a.LL() return a }}function createTree(arr) { let result arr.forEach((child, index) =&gt; { if (index === 0) { result = new AVLTree(child) } else { result = result.addNum(child) } }) return result}var arr = [1, 3, 5, 7, 15, 24, 56, 11, 33, 42, 2, 4, 6, 12]var tree = createTree(arr)","link":"/2020/06/18/Essay/28/"},{"title":"散列表查找","text":"之前我们在 查找算法 的章节当中介绍了一些比较常见的查找算法，比如对于数组 a[]，如果我们要在其中查找 key 关键字的记录，可以使用顺序表查找的方式，一个一个挨着排查，也可以使用有序表的一些查找方式，比如二分，插值等 但是如果序列是无序的呢，针对于无序序列，我们之前也介绍过了 二叉排序树 的方式来进行查找，但是二叉排序树的生成过程比较复杂，那么有没有一种针对不太复杂的无序序列，使用起来更为简便的形式呢，那就是我们今天所要介绍的『散列表查找』 散列表查找散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用，散列使用的数据结构叫做『散列表』，散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)，这里我们把这种对应关系 f 称为散列函数，又称为哈希（Hash）函数 采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间成为散列表或哈希表（Hash table），在散列表上插入、删除和提取数据的速度都是非常快的，当存储记录时，通过散列函数计算出记录的散列地址，而当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录 本章主要包括三部分内容，即如何构造哈希函数和冲突的处理，以及最后的代码实现 散列函数设计构造哈希函数的原则是 函数本身便于计算 计算出来的地址分布均匀，即对任一关键字 k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突 下面我们来看一些业界前辈总结的一些比较好的设计方式 直接定址法例如有一个从 1 到 100 岁的人口数字统计表，其中『年龄』作为关键字，哈希函数取关键字自身，即 f(key) = key，也就是下图这样 又或者现在要统计的是 1980 年以后出生的人口数，那么我们也可以对出生年份这个关键字可以变换为用年份减去 1980 的值来作为地址，即 f(key) = key – 1980，也就是下面这样 数字分析法数字分析法通常适合处理『关键字位数比较大』的情况，例如我们现在要存储某家公司员工登记表，如果用手机号作为关键字，那么我们发现『抽取』后面的四位数字作为散列地址是不错的选择 平方取中法平方取中法是将『关键字平方』之后取中间若干位数字作为散列地址，比如 1234^2 = 1522756 的，所以我们可以考虑使用 227 来作为关键字 折叠法折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长取后几位作为散列地址，比如我们的关键字是 9876543210 的话，我们就可以将其分割成为相等的几部分（位数如果不够可以使用 0 来进行填充），也就是 987，654，321，000，然后把这几部分进行相加，它们的结果是 1962，所以我们就可以采用 962 来作为关键字 除留余数法需要注意的是，这个方法也是『最常用』的构造散列函数方法，对于散列表长为 m 的散列函数计算公式为 1f(key) = key mod p（p &lt;= m，mod 是取模的意思） 事实上，这个方法不仅可以对关键字直接取模，也可以通过折叠、平方取中后再取模，例如下表，我们对有 12 个记录的关键字构造散列表时，就可以用 f(key) = key mod 12 的方法 但是 p 的选择是关键，如果对于这个表格的关键字，p 如果还是选择 12 的话，那就不是一个很好的方式了 不过针对上面这种情况，如果我们把 p 改为 11 也是可以的，如下 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址，即 f(key) = random(key)，这里的 random 是随机函数，当关键字的长度不等时，采用这个方法构造散列函数是比较合适的 总结我们可以视不同的情况采用不同的散列函数，在现实中，我们应该视不同的情况采用不同的散列函数，下面是一些需要考虑的方向 计算散列地址所需的时间 关键字的长度 散列表的大小 关键字的分布情况 记录查找的频率 处理散列冲突的方法通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题，创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致，下面我们就来看几种常用的解决冲突方法 开放定址法所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，它的公式是 fi(key) = (f(key) + di) MOD m (di = 1, 2 ... m - 1)，比如我们的关键字集合为 { 12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48 }，如果使用的是『除留余数法（m = 12）』，下面是散列表的排列形式 需要注意，此时我们需要添加元素 37，但是发现 37 % 12 = 1 的，而此时 1 的位置已经存在元素了，所以就发生了冲突，所以此时我们可以调用公式 fi(key) = (f(1) + 1) MOD 12，它的结果是 2，所以它填充在 2 的位置，也就下面这样 最终完成后是下面这样 但是我们可以发现，开放定址法虽然好，但是比较盲目，因为它是线性查找方式，逐渐递增的（即每次只增加一个位置），所以我们可以修改 di 的取值方式，例如使用平方运算来尽量解决『堆积』问题 1fi(key) = (f(key) + di) MOD m（di = 1², -1², 2², -2² ... q², -q², q &lt;= m / 1） 还有一种方法是，在冲突时对于位移量 di 采用『随机函数』计算得到，我们称之为『随机探测法』 1fi(key) = (f(key) + di) MOD m（di 是由一个随机函数获得的数列） 再散列函数法这种方法是同时构造多个不同的哈希函数 fi(key) = RHi(key)（i = 1, 2, 3 ... k），当哈希地址 fi(key) = RHi(key) 发生冲突时，再计算 fi(key) = RH2(key) ... 直到冲突不再产生，这种方法不易产生聚集，但增加了计算时间 链地址法这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行，链地址法适用于经常进行插入和删除的情况 我们还是以之前的示例为例，我们假设集合为 { 12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 37 }，同样使用除留余数法求散列表是下面这样的 公共溢出区法这种方法的基本思想是，将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表，还是以上面的例子为例，结果是下面这样的 代码实现最后，我们来看看如何用代码进行实现，在 JavaScript 当中，我们采用数组来进行设计散列表，数组的长度是预先设定的，如有需要，可以随时增加，所有元素根据和该元素对应的键，保存在数组的特定位置，使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是 0 到散列表的长度 散列函数会将每个键值映射为一个唯一的数组索引，然而键的数量是无限的，数组的长度是有限的，一个更现实的目标是让『散列函数尽量将键均匀地映射到数组中』，即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞（collision），当碰撞发生时，我们需要利用一定的方法去解决碰撞，也就是上面所介绍的几种方式 HashTable 类我们使用 HashTable 类来表示散列表，该类包含计算散列值的方法、向散列中插入数据，读取数据和显示散列表中数据分布等方法 1234567891011function HashTable() { this.table = new Array(137) this.simpleHash = simpleHash this.showDistro = showDistro this.put = put this.get = get this.buildChains = buildChains // 如果使用线性探测法，则需要额外添加一个数组 this.values = []} 散列函数散列函数的选择依赖于键值的数据类型，如果键是整型，最简单的散列函数就是以数组的长度对键取余，而选择针对字符串类型的散列函数比较困难，一种比较简单的散列函数是针对字符串中每个字符的 ASCII 码值相加然后再除以数组长度，将得出的余数做为散列值 1234567function simpleHash(data) { var total = 0 for (var i = 0; i &lt; data.length; ++i) { total += data.charCodeAt(i) } return total % this.table.length} put() 和 showDistro() 两个方法一个用来将数据存入散列表，而另一个则是用来显示散列表中的数据 12345678910111213function put(data) { var pos = this.simpleHash(data); this.table[pos] = data}function showDistro() { var n = 0 for (var i = 0; i &lt; this.table.length; ++i) { if (this.table[i] != undefined) { print(i + ': ' + this.table[i]) } }} 但是使用比较简单的散列函数时，它的数据并不是均匀分布的，而是向数组的两端集中，并且数据很大概率将会产生碰撞而不会全部显示出来，所以这里我们也可以采用另外一种方式，那就是『霍纳算法』 霍纳算法是一种比较好的散列函数算法，计算时仍然先计算字符串中各字符的 ASCII 码值，不过求和时每次要乘以一个质数，为了避免碰撞，首先要确保散列表中用来存储数据的数组其大小是个质数，这一点和计算散列值时使用的取余运算有关，数组的长度应该在 100 以上，这是为了让数据在散列表中分布得更加均匀 12345678910111213141516171819202122function betterHash(string, arr) { // 质数 const H = 37 var total = 0 for (var i = 0; i &lt; string.length; ++i) { total += H * total + string.charCodeAt(i) } total = total % arr.length return parseInt(total)}// 接受键和数据作为参数的 put() 方法function put(key, data) { // 使用霍纳算法 var pos = this.betterHash(key) this.table[pos] = data}// 读取存储在散列表中的数据function get(key) { return this.table[this.betterHash(key)]} 碰撞处理当散列函数对于不同的输入产生同样的散列值时，就产生了碰撞，这里我们主要来看两种碰撞解决办法『开链法』和『线性探测法』，关于开链法，当碰撞发生时，仍然将键存储到通过散列算法产生的索引位置上，但实际上每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了（即用二维数组实现） 123456// 创建二维数组function buildChains() { for (var i = 0; i &lt; this.table.length; ++i) { this.table[i] = new Array() }} 使用了开链法后，我们要重新定义 put() 和 get() 方法，新的 put() 方法将键值散列，散列后的值对应数组中的一个位置，先尝试将数据放到该位置上的数组中的第一个单元格，如果该单元格里已经有数据了则 put() 方法会搜索下一个位置，直到找到能放置数据的单元格，并把数据存储进去，它既保存数据，也保存键值，该方法使用链中两个连续的单元格，第一个用来保存键值，第二个用来保存数据 1234567891011121314function put(key, data) { var pos = this.betterHash(key) var index = 0 if (this.table[pos][index] == undefined) { this.table[pos][index] = key this.table[pos][index + 1] = data } else { while (this.table[pos][index] != undefined) { ++index } this.table[pos][index] = key this.table[pos][index + 1] = data }} 新的 get() 方法先对键值散列，根据散列后的值找到散列表中相应的位置，然后搜索该位置上的链，直到找到键值，如果找到，就将紧跟在键值后面的数据返回 123456789101112function get(key) { var index = 0 var pos = this.betterHash(key) if (this.table[pos][index] == key) { return this.table[pos][index + 1] } else { while (this.table[pos][index] != key) { index += 2 } return this.table[pos][index + 1] }} 最后我们再来看下『线性探测法』，线性探测法隶属于一种更一般化的散列技术，也就是『开放寻址散列』，当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空，如果为空，就将数据存入该位置，如果不为空，则继续检查下一个位置，直到找到一个空的位置为止，关于选择哪种实现方式 当存储数据使用的数组特别大时，选择线性探测法要比开链法好 如果数组的大小是待存储数据个数的 1.5 倍，那就使用开链法 如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探测法 使用线性探测法需要为 HashTable 类增加一个新的数组，用来存储数据，数组 table 和 values 并行工作，当将一个键值保存到数组 table 中时，将数据存入数组 values 中相应的位置上，即在 HashTable 的构造函数中加入下面一行代码 this.values = []，然后再来重写我们的 put() 和 get() 方法 1234567891011121314151617181920212223function put(key, data) { var pos = this.betterHash(key) if (this.table[pos] == undefined) { this.table[pos] = key this.values[pos] = data } else { while (this.table[pos] != undefined) { pos++ } this.table[pos] = key this.values[pos] = data }}function get(key) { var hash = this.betterHash(key) for (var i = hash; this.table[hash] != undefined; i++) { if (this.table[hash] == key) { return this.values[hash] } } return undefined}","link":"/2020/06/22/Essay/29/"},{"title":"矩形包围盒碰撞检测","text":"最近在项目当中遇到一个需求，也是一个我们平常十分常见的操作，那就是框选操作，但是对于正常元素来说，我们只需要计算框选框是否包裹了当前的目标元素就可以知道当前元素是否选中，但是项目中的元素会存在旋转的情况，所以计算起来就会有些复杂了，所以就抽了些时间深入的了解了一下，也在这里记录记录 最终代码可见 转向包围盒（OBB） 这个在线示例 问题由来需求如下，也就是我们平常接触到的框选操作，但是元素可能是旋转的，可以如下图所示 如上图，A 元素我们可以认为是鼠标操作生成的拖拽框，B 元素是我们的目标元素，问题就是如何判断当前 A 元素与 B 元素是否相交，周末研究了一番后发现，这应该是属于 2D 图形碰撞检测的范畴，在游戏开发场景当中遇到较多，但是在这里我们也可以采用相同的逻辑来进行解决 在 2D 游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测，因为这两种形状的碰撞检测速度是最快的，其中矩形包围盒又可以分为两种，如下 轴对齐包围盒（AABB，Axis Aligned Bounding Box） 转向包围盒（OBB，Oriented Bounding Box） AABB 与 OBB 的区别在于，AABB 中的矩形的其中一条边和坐标轴平行，OBB 的计算复杂度要高于 AABB，根据不同的使用场景，可以用不同的方案，但是本章当中我们不会太过深入，仅仅来看矩形包围盒，也就是『轴对齐包围盒』与『转向包围盒』这两种情况，但是在具体展开之前，我们先来看看向量的相关内容 向量向量作为一种数学工具，在碰撞检测中发挥很大作用，我们的计算都是通过向量来完成，所以先来了解一些向量的相关知识 向量的代数表示向量的代数表示指在指定了一个坐标系之后，用一个向量在该坐标系下的坐标来表示该向量，兼具了符号的抽象性和几何形象性，因而具有最高的实用性，被广泛采用于需要定量分析的情形，对于自由向量，将向量的起点平移到坐标原点后，向量就可以用一个坐标系下的一个点来表示，该点的坐标值即向量的终点坐标 12345678910// 二维平面向量class Vector2d { constructor(vx = 1, vy = 1) { this.vx = vx this.vy = vy }}const vecA = new Vector2d(1, 2)const vecB = new Vector2d(3, 1) 下面我们再来看看向量之间的运算 加法向量的加法满足平行四边形法则和三角形法则，两向量相加还是一个向量，如下，分别是 x 与 y 两个分量的相加 123456// 向量的加法运算static add(vec, vec2){ const vx = vec.vx + vec2.vx const vy = vec.vy + vec2.vy return new Vector2d(vx, vy)} 减法两个向量 a 和 b 的相减得到的向量可以表示为 a 和 b 的起点重合后，从 b 的终点指向 a 的终点的向量 123456// 向量的减法运算static sub(vec, vec2){ const vx = vec.vx - vec2.vx const vy = vec.vy - vec2.vy return new Vector2d(vx, vy)} 大小向量的大小，是其各个分量的平方和开方 1234// 获取向量长度length(){ return Math.sqrt(this.vx * this.vx + this.vy * this.vy)} 点积从代数角度看，先对两个数字序列中的每组对应元素求积，再对所有积求和，结果即为点积 1234// 向量的数量积static dot(vec, vec2){ return vec.vx * vec2.vx + vec.vy * vec2.vy} 旋转向量的旋转可以用旋转矩阵求解 12345678// 向量的旋转 static rotate(vec, angle){ const cosVal = Math.cos(angle) const sinVal = Math.sin(angle) const vx = vec.vx * cosVal - vec.vy * sinVal const vy = vec.vx * sinVal + vec.vy * cosVal return new Vector2d(vx, vy)} 在了解完向量相关内容以后，我们就可以来使用向量来表示我们的基本矩形，定义一个矩形需要中心坐标 x 和 y、两边长宽 w 和 h，还有中心的旋转角度 rotation 12345678910export class Rect { // x 和 y 是矩形中心的坐标，w 和 h 是宽高，r 是旋转角度，单位为 deg constructor(x = 0, y = 0, w = 1, h = 1, r = 0) { this.x = x this.y = y this.w = w this.h = h this.r = r }} 在了解完上面的内容以后，下面我们就来具体看看两矩形相交的情况 轴对齐包围盒（AABB）也就是如下图所示的情况 针对于两个『无旋转』的矩形相交，我们应该如何来进行判断碰撞呢？比如我们定义了两个矩形，并且第一个物体的碰撞外形以某种形式进入了第二个物体的碰撞外形，在这种情况之下，我们就可以认为两者碰撞，也就是当两个矩形进入对方的区域时就会发生碰撞，针对于这种情况，也就是上面我们提到的 AABB 类型来说很容易判断，因为它们是与坐标轴对齐的 对于每个轴我们要检测两个物体的边界在此轴向是否有重叠，因此我们只需要简单地检查两个物体的『水平边界』以及『垂直边界』是否重合，如果『水平边界和垂直边界都有重叠』那么我们就认为两者是碰撞的 将这一概念转化为代码也是很直白的，我们对两个轴都检测是否重叠，如果都重叠就返回碰撞，因为都是不旋转的元素，所以这里我们不用考虑 rotation 这个参数 12345678910111213141516171819202122// selectionRect 拖拽框// element 元素节点// scroll 是否需要计算滚动条距离function AABB(selectionRect, element, scroll) { var rect = element.getBoundingClientRect() var elementRect = { y: rect.top + scroll.y, x: rect.left + scroll.x, h: rect.height, w: rect.width } if ( selectionRect.x &lt; elementRect.x + elementRect.w &amp;&amp; selectionRect.x + selectionRect.w &gt; elementRect.x &amp;&amp; selectionRect.y &lt; elementRect.y + elementRect.h &amp;&amp; selectionRect.h + selectionRect.y &gt; elementRect.y ) { return true } else { return false }} 我们检查『第一个物体的最右侧是否大于第二个物体的最左侧』并且『第二个物体的最右侧是否大于第一个物体的最左侧』，垂直的轴向与此相似，所以我们就可以根据此方法来判断两个矩形是否相交，这种方式的碰撞检测相对是比较简单的，下面我们再来看看比较复杂的情况，也就是转向包围盒（OBB） 转向包围盒（OBB）这种情况也就是我们开头部分所看到的情形 针对于这种情况，两个矩形的 OBB 检测我们可以使用分离轴定理（Separating Axis Theorem）来进行解决，所谓分离轴定理，即通过判断任意两个矩形在『任意角度下的投影是否均存在重叠』来判断是否发生碰撞，若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞，因为矩形的对边平行，所以只要判断四条对称轴上的投影即可（这也可以扩展到任意多边形） 比如下图当中的四周轴线之上对应的红蓝线条 至于如何投影？我们在这里来补充一些向量点积的几何意义 在欧几里得空间中，点积可以直观地定义为 A·B = |A||B|cosθ，其中 |A|cosθ 是 A 到 B 的投影，如果 B 是单位向量，那么 A·B 就是 A 到单位向量 B 的投影，如果放到矩形上，我们将矩形 4 个顶点都投影到对称轴上，分别将其点乘即可 其实归纳一下判定方式，简单的来说就是 如果两个多边形在所有轴上的投影都发生重叠，则判定为碰撞，否则没有发生碰撞 下面我们来看看如何用代码来进行实现，当然 OBB 存在多种的表达方式，我们这里使用比较常见的一种方式，即一个中心点、2 个矩形的边长、两个旋转轴（该轴垂直于多边形自身的边，用于投影计算），也就是我们在上面向量章节当中定义的矩形的扩展形式，代码如下所示，注意这里就需要使用 rotation 这个参数了 12345678910class OBB { constructor(centerPoint, width, height, rotation) { this.centerPoint = centerPoint this.extents = [width / 2, height / 2] this.axes = [new Vector2(Math.cos(rotation), Math.sin(rotation)), new Vector2(-1 * Math.sin(rotation), Math.cos(rotation))] this._width = width this._height = height this._rotation = rotation }} 其所依赖的 Vector2 这个类如下所示 123456789101112class Vector2 { constructor(x, y) { this.x = x || 0 this.y = y || 0 } sub(v) { return new Vector2(this.x - v.x, this.y - v.y) } dot(v) { return this.x * v.x + this.y * v.y }} 然后基于这个数据结构，进行 OBB 之间的相交测试，我们为 OBB 扩展一个方法，即返回在任意轴上的投影半径 123getProjectionRadius(axis) { return this.extents[0] * Math.abs(axis.dot(this.axes[0])) + this.extents[1] * Math.abs(axis.dot(this.axes[1]))} 这里我们需要注意 Vector2.dot 这个方法，也就是我们在上面提到的点积 若 b 为单位矢量，则 a 与 b 的点积即为 a 在方向 b 的投影 在有了这些了解以后我们就可以来进行相交检测，由上面的判定方式，我们可以得出，两个矩形之间的碰撞检测需要判断四次（即每个投影轴一次），完整检测代码如下所示 123456789101112const detectorOBBvsOBB = (OBB1, OBB2) =&gt; { var nv = OBB1.centerPoint.sub(OBB2.centerPoint) var axisA1 = OBB1.axes[0] if (OBB1.getProjectionRadius(axisA1) + OBB2.getProjectionRadius(axisA1) &lt;= Math.abs(nv.dot(axisA1))) return false var axisA2 = OBB1.axes[1] if (OBB1.getProjectionRadius(axisA2) + OBB2.getProjectionRadius(axisA2) &lt;= Math.abs(nv.dot(axisA2))) return false var axisB1 = OBB2.axes[0] if (OBB1.getProjectionRadius(axisB1) + OBB2.getProjectionRadius(axisB1) &lt;= Math.abs(nv.dot(axisB1))) return false var axisB2 = OBB2.axes[1] if (OBB1.getProjectionRadius(axisB2) + OBB2.getProjectionRadius(axisB2) &lt;= Math.abs(nv.dot(axisB2))) return false return true} 我们在这里拿两个 OBB 的中心点连线在坐标轴上的投影长度和两个矩形投影半径之和进行对比，如果半径之后都小于或者等于中心连线之后才判定为碰撞，否则判定为分离状态 完整代码如下，在线示例可以参考文章开头部分的链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// OBB 算法class OBB { constructor(centerPoint, width, height, rotation) { this.centerPoint = centerPoint this.extents = [width / 2, height / 2] this.axes = [new Vector2(Math.cos(rotation), Math.sin(rotation)), new Vector2(-1 * Math.sin(rotation), Math.cos(rotation))] this._width = width this._height = height this._rotation = rotation } getProjectionRadius(axis) { return this.extents[0] * Math.abs(axis.dot(this.axes[0])) + this.extents[1] * Math.abs(axis.dot(this.axes[1])) }}class Vector2 { constructor(x, y) { this.x = x || 0 this.y = y || 0 } sub(v) { return new Vector2(this.x - v.x, this.y - v.y) } dot(v) { return this.x * v.x + this.y * v.y }}const detectorOBBvsOBB = (OBB1, OBB2) =&gt; { var nv = OBB1.centerPoint.sub(OBB2.centerPoint) var axisA1 = OBB1.axes[0] if (OBB1.getProjectionRadius(axisA1) + OBB2.getProjectionRadius(axisA1) &lt;= Math.abs(nv.dot(axisA1))) return false var axisA2 = OBB1.axes[1] if (OBB1.getProjectionRadius(axisA2) + OBB2.getProjectionRadius(axisA2) &lt;= Math.abs(nv.dot(axisA2))) return false var axisB1 = OBB2.axes[0] if (OBB1.getProjectionRadius(axisB1) + OBB2.getProjectionRadius(axisB1) &lt;= Math.abs(nv.dot(axisB1))) return false var axisB2 = OBB2.axes[1] if (OBB1.getProjectionRadius(axisB2) + OBB2.getProjectionRadius(axisB2) &lt;= Math.abs(nv.dot(axisB2))) return false return true}const OBB1Options = { x: 355, y: 430, w: 350, h: 150, r: 0}const OBB2Options = { x: 575, y: 295, w: 350, h: 150, r: 220}const OBB1 = new OBB(new Vector2(OBB1Options.x, OBB1Options.y), OBB1Options.w, OBB1Options.h, OBB1Options.r * Math.PI / 180)const OBB2 = new OBB(new Vector2(OBB2Options.x, OBB2Options.y), OBB2Options.w, OBB2Options.h, OBB2Options.r * Math.PI / 180)console.log(detectorOBBvsOBB(OBB1, OBB2)) 参考 2D collision detection 方向包围盒（OBB）碰撞检测 碰撞检测的向量实现","link":"/2020/11/28/Essay/31/"},{"title":"浏览器输入网址到页面展示所经历的过程","text":"最后更新于 2019-12-22 这其实是一个比较久远的面试题，原本针对于这个问题，参考了网上各种博文，查阅了许多资料，然后洋洋洒洒的整理出了好多步骤，自以为大致了解了整个过程，直到看到了 What happens when… 这篇文章以后，我决定把原文内容全部删除掉，直接搬运这篇文章的内容，然后从新的整理成自己比较好理解的方式放到这里，方便自己以后没事来复习复习，内容有所调整，主要是方便自己理解，如果想了解更为详细的流程可以参考原文 问题是这样的，当你在浏览器中输入 baidu.com 并且按下回车之后发生了什么？这个问题乍一眼看上去可能比较简单，发生什么？不就是在浏览器当中显现出对应的页面吗，虽然看上去是这样的，但是其实背后发生的事情却是非常之多的，大致的梳理一下分为以下这些，当然其中抛开了一些比如键盘输入，解析输入值等硬件处理的过程，我们在本章当中主要看的是数据传递过程和浏览器渲染相关部分的内容 DNS 查询 ARP 过程 使用套接字 HTTP 协议 HTTP 服务器请求处理 浏览器 HTML 解析 CSS 解析 页面渲染 GPU 渲染 后期渲染与用户引发的处理 DNS 查询 首先浏览器会搜索自身的 DNS 缓存，看看自身的缓存中有没有 baidu.com 这个域名已经缓存的地址，这个缓存的时间大概只有一分钟，如果使用的是 Chrome 浏览器的话可以通过 chrome://net-internals/#dns 来查看浏览过的网站的 DNS 缓存有没有失效 如果浏览器没有找到缓存，或者说这个缓存已经失效，则会检查域名是否在本地 Hosts 里，如果找到，则它会停止搜索，然后解析也会到此结束 如果在 Hosts 文件内也没有找到对应的配置项，那么浏览器就会发起一个 DNS 的系统调用，就会向本地主控 DNS 服务器（也就是你的宽带运营商提供，通常是本地路由器或者 ISP 的缓存 DNS 服务器）发送一条 DNS 查询请求 接下来查询本地 DNS 服务器 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP 查询 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询 ARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址，所以首先查询 ARP 缓存，如果缓存命中，我们返回结果，即目标 IP 为 MAC，如果缓存没有命中，则 查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内，是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口 查询选择的网络接口的 MAC 地址 我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求 12345// ARP Request:Sender MAC: interface:mac:address:hereSender IP: interface.ip.goes.hereTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)Target IP: target.ip.goes.here 根据连接主机和路由器的硬件类型不同，可以分为几种情况，但是我们这里只看最简单的一种，也就是和路由器是直接连接的方式（其他方式可以参考原文），此时路由器会返回一个 ARP Reply 12345// ARP Reply:Sender MAC: target:mac:address:hereSender IP: target.ip.goes.hereTarget MAC: interface:mac:address:hereTarget IP: interface.ip.goes.here 现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议 如果 ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回 它流程大致是下面这样的 根域（拿到 com 域） com 域 DNS 服务器（拿到 baidu.com） baidu.com 的 DNS 服务器（域名的注册商提供，万网，新网等） 结果发送给运营商的 DNS 服务器（就拿到了 baidu.com 这个域名对应的 IP 地址） 结果返回操作系统内核，同时缓存起来（当然，这个缓存可能会失效，有时间长短 ） 内核从服务器上拿到这个 IP 地址，就把这个结果返回给浏览器 最终浏览器拿到了 www.baidu.com 对应的 IP 地址 使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（HTTP 协议默认端口号是 80， HTTPS 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP 流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment，目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取 TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个 IP packet 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的 MAC 地址以及网关（本地路由器）的 MAC 地址，像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址 到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输 以太网 WiFi 蜂窝数据网络 这里我们就不探讨传输方式的差异，以比较常见的光纤或以太网为例，在这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理 最终封包会到达管理本地子网的路由器，在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器，一路上经过的这些路由器会从 IP 数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地，IP 数据报头部 time to live（TTL）域的值每经过一个路由器就减 1，如果封包的 TTL 变为 0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃 上面的发送和接受过程在 TCP 连接期间会发生很多次（也就是经典的三次握手与四次挥手的流程） 客户端选择一个初始序列号（ISN），将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号 服务器端接收到 SYN 包，如果它可以建立连接 服务器端选择它自己的初始序列号 服务器端设置 SYN 位，表明自己选择了一个初始序列号 服务器端把（客户端 ISN + 1）复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包 客户端通过发送下面一个封包来确认这次连接 自己的序列号 + 1 接收端 ACK + 1 设置 ACK 位 数据通过下面的方式传输 当一方发送了 N 个 Bytes 的数据之后，将自己的 SEQ 序列号也增加 N 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号 关闭连接时 要关闭连接的一方发送一个 FIN 包 另一方确认这个 FIN 包，并且发送自己的 FIN 包 要关闭的一方使用 ACK 包来确认接收到了 FIN HTTP 协议如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求 1234GET / HTTP/1.1Host: baidu.comConnection: close[其他头部] 其他头部当中包含了一系列的由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来，HTTP/1.1 定义了关闭连接的选项 close，发送者使用这个选项指示这次连接在响应结束之后会断开，例如 1Connection: close 不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 close 选项，在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了，服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的 12200 OK[响应头部] 然后是一个换行，接下来有效载荷（payload），也就是 www.baidu.com 的 HTML 内容，服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用 如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应 12304 Not Modified[响应头部] 这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容，在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 HTML 页面引入的所有资源（Images，CSS，favicon.ico 等等）全部都获取完毕，如果 HTML 引入了 www.baidu.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名 HTTP 服务器请求处理HTTPD（HTTP Daemon）在服务器端处理请求/响应，最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS HTTPD 接收请求 服务器把请求拆分为以下几个参数 HTTP 请求方法（GET，POST，HEAD，PUT，DELETE，CONNECT，OPTIONS 或者 TRACE）直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法 域名 baidu.com 请求的路径或页面为 /（因为我们没有请求 baidu.com 下的指定的页面，因此 / 是默认的路径） 服务器验证 baidu.com 接受 GET 方法 服务器验证该用户可以使用 GET 方法（根据 IP 地址，身份信息等） 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 /，所以会访问首页文件 服务器会使用指定的处理程序分析处理这个文件 浏览器当服务器提供了资源之后（HTML，CSS，JavaScript，Images 等），浏览器会执行下面的操作 解析，HTML，CSS，JavaScript 渲染，会依次执行以下流程 1构建 DOM 树 ==&gt; CSSOM ==&gt; Render Tree ==&gt; 渲染 ==&gt; 布局 ==&gt; 绘制 HTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成 8kb 大小的分块传输，HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树 解析树是以 DOM 元素以及属性为节点的树，DOM 是文档对象模型的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部（如 JavaScript）的接口，树的根部是 Document 对象，整个 DOM 和 HTML 文档几乎是一对一的关系 由于 HTML 不能使用常见的自顶向下或自底向上方法来进行分析，所以浏览器创造了专门用于解析 HTML 的解析器，解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段，标记化（tokenization）和树的构建 解析结束之后浏览器开始加载网页的外部资源（CSS，Images，JavaScript 文件等），此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于异步（deferred）模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本，之后文档的状态会变为 complete，浏览器会触发 load 事件 CSS 解析 根据 CSS词法和句法 分析 CSS 文件和 &lt;style&gt; 标签包含的内容以及 style 属性的值 每个 CSS 文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的 CSS 规则，和对应 CSS 语法的对象 CSS 解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器 页面渲染 通过遍历 DOM 节点树创建一个渲染树（DOM Tree + CSSOM，这里是泛指），并计算每个节点的各个 CSS 样式值，然后构建每个节点的坐标 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见 CSS 2 和 CSS Current Work GPU 渲染 在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU 当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算 后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行 JavaScript 代码或与用户交互，类似 Flash 和 Java 的插件也会运行，尽管我们请求的主页（/）里面可能没有，但是这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制 如果全部完成以后，至此就把一个完整的页面呈现给了用户","link":"/2017/11/07/HTTP/01/"},{"title":"域名发散与收敛","text":"在正式展开之前，我们先来了解一下 Performance 接口，简单来说，它可以获取到当前页面中与性能相关的信息，主要用于 网页监控与程序性能，但是在本章当中就不详细展开了，具体的可以参考链接，有个概念即可 域名发散在 PC 时代为了突破浏览器的域名并发限制，遵循这样一条定律『HTTP 静态资源采用多个子域名』，目的是充分利用现代浏览器的多线程并发下载能力，由于浏览器的限制，每个浏览器，允许对每个域名的连接数一般是有上限的，附一张网上流传甚广的图 域名发散出现的原因其实是在以前，服务器的负载能力差，网速慢，设备差，稍微流量大一点 Server 就崩溃了，为了保护你的服务器不崩溃，浏览器要对 max connections 有所限制，如果每个用户的 max connections 不限制的话， 结果就是服务器的负载能力会低至冰点（另外也有说是关于 DDOS），所以 PC 时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速 假设现在浏览器对每个域名连接数为 1，那么现实情况是 浏览器解析完我们的文档之后开始发起请求，对文件进行加载，然后一个一个文件 在 max connections 下进行排队下载，但如果我们使用了域名分散之后，使用多个 domain 进行资源的下载，就有 这样完全可以省略掉排队的时间.提升网页加载的速度 域名收敛这里首先会涉及到一个问题，为什么你手机打开网页时，白屏时间会这么长？一个网页白屏时间是由下面几部分决定的 所以，网页的优化就可以从上述几个部分开始，这里我们要提及的就是 DNS 优化，即域名收敛，那么什么是域名收敛呢？顾名思义，域名收敛的意思就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下，上面也说到了，域名发散可以突破浏览器的域名并发限制，那么为要反其道而行之呢？ 因为因地制宜，不同情况区别对待，域名发散是 PC 时代的产物，而现在进入移动互联网时代，通过无线设备访问网站，App 的用户已占据了很大一部分比重，而域名收敛正是在这种情况下提出的，这里就不能不提到 HTTP 请求了，简单来说就是 DNS 域名解析 发起 TCP 的 3 次握手 建立 TCP 连接后发起 HTTP 请求 服务器响应 HTTP 请求 … 在这里第一步，也是关键的第一步 DNS 解析，在移动端的 HTTP 请求耗时中，DNS 解析占据了大部分时间，在深入了解 DNS 解析之前，先科普一下 域名结构 域名结构或者叫命名空间，是一个树状结构，有树就得有根，这个根是一个点 &quot;.&quot;（dot），以 www.example.com 为例，完整的形式应该是 www.example.com.（注意最后有一个点），就是根结点 root ，只不过平时是浏览器或者系统的解析器自动帮我们补全了，我们要想获取根域都有那些，可以在终端下直接使用 dig 命令（需要安装 dig 指令），如下 根节点之后就是顶级域名，就是 .cn，.com，.gov 这些，顶级域划分为通用顶级域 （com、org、net 等）和国家与地区顶级域（cn、hk、us、tw 等），我们可以继续使用 dig 查看一下 顶级域名的解析路径，加上 + trace 参数选项，意思是追踪 DNS 解析过程，如下 可以看到是先到根节点，再查找到 com ，就是根结点会告知下一个结点 com 在哪，就是 com. 172800 IN NS [a-m].gtld-servers.net，顶级域之后就是我们熟知的一级域名，譬如 www.example.com 中的 example 就是一级域 NS上面两张 dig 命令贴图中间出现了很多次 NS ，NS 即是 NameServer，大部分情况下又叫权威名称服务器简称权威，什么是权威呢，通俗点讲其实是某些域的权威，也就是权威上面有这些域的最新，最全的数据，所有这些域的数据都应该以此为准（只有权威可以增删改这些域的数据），就像上面 dig com + trace 的结果可以看到，com 的权威是上面的 13 个根域，同理，所有的顶级域（cn、org、net 等等）的权威都是根域 DNS 解析大致的了解了域名结构以后，我们就来正式的看一看所谓的 DNS 解析，其实简单来说，上面章节当中所描述的过程就是 DNS 解析的一个大致过程，即『迭代解析』一个完整的 DNS 解析过程如下（摘自 域名收敛–前端优化） 首先拿到 URL 后，浏览器会寻找本地的 DNS 缓存，看看是否有对应的 IP 地址，如果缓存中存在那就好了，如果没有，那就得向 DNS Server 发送一个请求，找到你想要的 IP 地址 首先他会向你的 ISP（互联网服务提供商）相关的 DNS servers 发送 DNS query，然后这些 DNS 进行递归查询（recursive），所谓的递归查询，就是能够直接返回对应的 IP 地址，而不是其他的 DNS server 地址 如果上述的 DNS Servers 没有你要的域名地址，则就会发送迭代查询，即会先从 root nameservers 找起， 即是假如你要查询 www.example.com ，会先从包含根结点的 13 台最高级域名服务器开始 接着，以从右向左的方式递进，找到 com，然后向包含 com 的 TLD（顶级域名）nameservers 发送 DNS 请求，接着找到包含 example 的 DNS server 现在进入到了 example.com 部分，即是现在正在询问的是权威服务器，该服务器里面包含了你想要的域名信息，也就是拿到了最后的结果 record 递归查询的 DNS Server 接受到这 record 之后，会将该 record 保存一份到本地，如果下一次你再请求这个 domain 时，我就可以直接返回给你了，由于每条记录都会存在 TLL ，所以 server 每隔一段时间都会发送一次请求，获取新的 record 最后，再经由最近的 DNS Server 将该条 record 返回， 同样，你的设备也会存一份该 record 的副本 之后，就是 TCP 的事了，下面是一张萌萌的简化图 梳理一下，迭代查询的过程如下 . ==&gt; com. ==&gt; .exampl.com. ==&gt; www.example.com. ==&gt; IP adress 关于 TTLTTL 是 Time To Live 的缩写，该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量，TTL 是 IPv4 包头的一个 8 bit 字段，简单的说它表示 DNS 记录在 DNS 服务器上缓存时间 DNS 解析其实是一个很复杂的过程，在 PC 上，我们采用『域名发散』策略，是因为在 PC 端上，DNS 解析通常而言只需要几十 ms ，完全可以接受的，而移动端，2G/3G/4G/WIFI 网络，而且移动 4G 容易在信号不理想的地段降级成 2G ，通过大量的数据采集和真实网络抓包分析（存在 DNS 解析的请求），DNS 的消耗相当可观，2G 网络大量 5 ~ 10s，3G 网络平均也要 3 ~ 5s，下面附上在 2G/3G/4G/WIFI 情况下 DNS 递归解析的时间 （ms） 因为在增加域的同时，往往会给浏览器带来 DNS 解析的开销，所以在这种情况下，提出了『域名收敛』，减少域名数量可以降低 DNS 解析的成本，下图是手机端页面加载数和域名分散数的关系 在 2 个域名分散条件下，网页的加载速度提升较大，而第 3 个以后就比较慢了， 所以，一般来说，域名分散的数量最好在 3 以下 HTTPDNS上面过程如果顺利，本地 DNS 有缓存，也就是几十 ms 到几百 ms 的事情，不顺利，几秒到十几秒都有可能，严格来讲，DNS 才是我们发出去的第一个请求，所以减少开销就两条路 第一个就是减少 DNS 的请求 第二个就是缩短 DNS 解析路径 第一个就是做域名收敛的主要原因，相比于 PC 是对于域名的并发限制，无线上来说对并发的要求会弱很多（一般尽量是第一屏，后面使用懒加载） 第二个就是缩短解析路径，这里所说的缩短解析路径其实就说各级的缓存，本机的缓存，LocalDNS 的缓存，不过他们或多或少也不靠谱，尤其是运营商的 LocalDNS 给你劫持一下，篡改一下都是常有的事情，于是这个情况下，就有了 HTTPDNS，HTTPDNS 是为了解决移动端 DNS 解析请求而生的，顺便解决 DNS 劫持，合并请求和缓存结果进而提高解析质量 结论在移动网络环境下，减少非必要 DNS 请求，将相关域名收敛成一个，可以尝到缓存的红利，进而可以减少打开页面时间，移动端减少 DNS 解析时间有两种方式 减少 DNS 请求 缩短 DNS 解析路径 从上面的各种网络环境下 DNS 解析时间对比，减少 DNS 请求是我们做域名收敛的主要原因，HTTPDNS 的诞生不仅可以合并请求，缩短 DNS 解析路径，还有防止运营商劫持等功效 关于 SPDY单纯的在移动端采用域名收敛并不能很大幅度的提升性能，很重要的一点是，在移动端建连的消耗非常大，而 SPDY 协议可以完成多路复用的加密全双工通道，显著提升非 wifi 环境下的网络体验，当域名收敛配合 SPDY 才能最大程度发挥他们的效用，达到事半功倍 所谓 SPDY 就是一种开放的网络传输协议，由 Google 开发，用来发送网页内容，基于传输控制协议（TCP）的应用层协议 ，是 HTTP 2.0 的前身 SPDY 的作用就是，在不增加域名的情况下，解除最大连接数的限制，主要的特点就是多路复用，他的目的就是致力于取消并发连接上限，那么相比 HTTP，SPDY 具体的优势在哪里呢 多路复用 请求优化SPDY 规定在一个 SPDY 连接内可以有无限个并行请求，即允许多个并发 HTTP 请求共用一个 TCP 会话，这样 SPDY 通过复用在单个 TCP 连接上的多次请求，而非为每个请求单独开放连接，这样只需建立一个 TCP 连接就可以传送网页上所有资源，不仅可以减少消息交互往返的时间还可以避免创建新连接造成的延迟，使得 TCP 的效率更高 此外，SPDY 的多路复用可以设置优先级，而不像传统 HTTP 那样严格按照先入先出一个一个处理请求，它会选择性的先传输 CSS 这样更重要的资源，然后再传输网站图标之类不太重要的资源，可以避免让非关键资源占用网络通道的问题，提升 TCP 的性能 支持服务器推送技术服务器可以主动向客户端发起通信向客户端推送数据，这种预加载可以使用户一直保持一个快速的网络 SPDY 压缩了 Http 头舍弃掉了不必要的头信息，经过压缩之后可以节省多余数据传输所带来的等待时间和带宽 强制使用 SSL 传输协议Google 认为 Web 未来的发展方向必定是安全的网络连接，全部请求 SSL 加密后，信息传输更加安全，看看 SPDY 的作用图 参考 SPDY 协议介绍 H5 性能最佳实践 HttpDNS 服务详解 DNS（wiki） 域名收敛 域名收敛–前端优化(二) 域名发散–前端优化(三)","link":"/2017/12/01/HTTP/03/"},{"title":"浏览器缓存机制","text":"最后更新于 2020-07-26 浏览器缓存是性能优化的一个重要手段，对于理解缓存机制而言也是很重要的，所以今天我们就抽些时间来简单的梳理一下 Web 缓存所谓 Web 缓存，是一种保存 Web 资源副本并在下次请求时直接使用该副本的技术，Web 缓存可以分为这几种，浏览器缓存、CDN 缓存、服务器缓存、数据库数据缓存等 因为可能会直接使用副本免于重新发送请求或者仅仅确认资源没变无需重新传输资源实体，Web 缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力 缓存的流程简单来说，浏览器在请求一个资源时，使用缓存的流程大概如下 首先浏览器会判断，这个资源是否有缓存，没有的话，正常请求 如果有缓存的话，浏览会判断缓存是否过期 如果缓存没有过期，则直接使用，此时就是 200（from cache），通过上次缓存留下的 Cache-Control，max-age 和 Expires 这里需要注意的是，Cache-Control 的优先级高于 Expires，下面会详细介绍 如果浏览器的缓存过期了，它会请求服务器，服务器会校验缓存的数据是否真的发生了更改 如果服务器端发现数据没有变，就会返回一个 304 告诉浏览器，你请求的数据 Not Modified，可以继续用缓存，同时浏览器会更新缓存首部的过期时间等信息 这里浏览器发起请求时，会用到上次缓存首部的 Last-Modified/E-tag 具体做法是取出上次缓存的 Last-Modified 的值，放在本次请求头的 If-Modified-Since 中 取出上次缓存的 E-tag 的值，放在本次请求头中的 If-None-Match 中 服务器会据此判断资源是否发生过修改，浏览器中的缓存是否依然可用 如果服务器端修改了上次缓存的内容，则直接返回 200，并携带新的内容 大致流程如下图所示 强缓存和协商缓存浏览器 HTTP 缓存可以分为『强缓存』和『协商缓存』，强缓存和协商缓存最大也是最根本的区别是 强缓存命中的话不会发请求到服务器（比如 chrome 中的 200 from memory cache） 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified） 所以通过强缓存和协商缓存，我们可以将上图调整为 而浏览器 HTTP 缓存由 HTTP 报文的首部字段决定 浏览器对于请求资源，拥有一系列成熟的缓存策略，按照发生的时间顺序分别为存储策略，过期策略，协商策略，其中存储策略在收到响应后应用，过期策略和协商策略则在发送请求前应用，简单来说 缓存参数下面表格表示的就是 HTTP Header 中与缓存有关的 key key 描述 存储策略 过期策略 协商策略 Pragma HTTP/1.0 字段，指定缓存机制 ✔️ ✔️ Cache-Control 指定缓存机制，覆盖其它设置 ✔️ Expires HTTP/1.0 字段，指定缓存的过期时间 ✔️ Last-Modified 资源最后一次的修改时间 ✔️ ETag 唯一标识请求资源的字符串 ✔️ 而缓存协商策略用于重新验证缓存资源是否有效，有关的 key 如下 key 描述 If-Modified-Since 缓存校验字段，值为资源最后一次的修改时间，即上次收到的 Last-Modified 值 If-Unmodified-Since 同上，处理方式与之相反 If-Match 缓存校验字段，值为唯一标识请求资源的字符串，即上次收到的 ETag 值 If-None-Match 同上，处理方式与之相反 下面就按控制强缓存的字段按优先级介绍 PragmaPragma 是 HTTP/1.1 之前版本遗留的通用首部字段，仅作为于 HTTP/1.0 的向后兼容而使用，虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现，RFC 中该字段只有 no-cache 一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度，因为它优先级最高，『当存在时一定不会命中强缓存』 Cache-ControlCache-Control 是一个通用首部字段，也是 HTTP/1.1 控制浏览器缓存的主流字段，和浏览器缓存相关的是如下几个响应指令 指令 参数 说明 private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它） public 可省略 表明响应可以被任何对象（包括发送请求的客户端，代理服务器，等等）缓存 no-cache 可省略 缓存前必需确认其有效性 no-store 无 不缓存请求或响应的任何内容 max-age=[s] 必需 响应的最大值 max-age设置缓存的存在时间（单位为 s），相对于发送请求的时间，只有响应报文首部设置 Cache-Control 为非 0 的 max-age 或者设置了大于请求日期的 Expires 才有可能命中强缓存，当满足这个条件，同时响应报文首部中 Cache-Control 不存在 no-cache、no-store 且请求报文首部不存在 Pragma 字段，才会真正命中强缓存 no-cache表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存，Chrome 硬性重新加载（Command + shift + R）会在请求的首部加上 Pragma：no-cache 和 Cache-Control：no-cache no-store表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据 public表明响应可以被浏览器、CDN 等等缓存 private响应只作为私有的缓存，不能被 CDN 等缓存，如果要求 HTTP 认证，响应会自动设置为 private ExpiresExpires 是一个响应首部字段，它指定了一个 日期/时间，在这个 时间/日期 之前，HTTP 缓存被认为是有效的，无效的日期比如 0，表示这个资源已经过期了，如果同时设置了 Cache-Control 响应首部字段的 max-age，则 Expires 会被忽略，它也是 HTTP/1.1 之前版本遗留的通用首部字段，仅作为于 HTTP/1.0 的向后兼容而使用 下面再来看看控制协商缓存的字段 Last-Modified/If-Modified-SinceIf-Modified-Since 是一个请求首部字段，并且只能用在 GET 或者 HEAD 请求中，Last-Modified 是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间，当带着 If-Modified-Since 头访问服务器请求资源时，服务器会检查 Last-Modified 如果 Last-Modified 的时间早于或等于 If-Modified-Since 则会返回一个不带主体的 304 响应，否则将重新返回资源，需要注意的是，如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有 etag 实体标签条件首部，那么只有这两个条件都满足时，才能返回 304 NotModified 响应，语法格式如下 123If-Modified-Since: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMTLast-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT ETag/If-None-MatchETag 是一个响应首部字段，它是根据实体内容生成的一段 Hash 字符串，标识资源的状态，由服务端产生，If-None-Match 是一个条件式的请求首部，如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的 ETag，则当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的 200 响应，否则服务器会返回不带实体的 304 响应，ETag 优先级比 Last-Modified 高，同时存在时会以 ETag 为准，语法格式如下 12345If-None-Match: &lt;etag_value&gt;If-None-Match: &lt;etag_value&gt;, &lt;etag_value&gt;, …If-None-Match: * ETag 属性之间的比较采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的，例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的，因为 ETag 的特性，所以相较于 Last-Modified 有一些优势 某些情况下服务器无法获取资源的最后修改时间 资源的最后修改时间变了但是内容没变，使用 ETag 可以正确缓存 如果资源修改非常频繁，在秒以下的时间进行修改，Last-Modified 只能精确到秒 整体流程 优先级若同时存在各种缓存头时，各缓存头优先级及生效情况如下 强缓存和对比缓存同时存在，如果强缓存还在生效期则强制缓存覆盖对比缓存，对比缓存不生效 如果强缓存不在有效期，对比缓存生效，即 强缓存优先级 &gt; 对比缓存优先级 pragma 和 cache-control 类似，前者是 HTTP/1.0 内容，后者是 HTTP/1.1 内容 并且 pragma 优先级 &gt; cache-control 优先级，不过前者目前基本不使用 强缓存 expires 和 cache-control 同时存在时，则 cache-control 会覆盖 expires expires 无论有没有过期都无效，即 cache-control 优先级 &gt; expires 优先级 对比缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified Last-Modified 不会生效，即 ETag优先级 &gt; Last-Modified 优先级 针对于一般的项目，由于 CSS 和 JavaScript 在打包时加了 md5 值，建议直接使用强缓存，并且 expires 和 cache-control 同时使用，建议设置时长为 7 天较为妥当，图片文件由于没有加 md5 值，建议采用对比缓存，HTML 文件也建议采用对比缓存 浏览器的不同表现需要注意的是，当我们不设置 cache-control，只设置对比缓存，在不同浏览器下会有不同的表现，chrome 会直接从本地缓存获取，其他会请求服务器返回 304，这时候有两种方式让他们的响应一致 设置 cache-control: public, max-age = 0，这里的 public 是关键 因为默认值是 private，表示其他代理都不要缓存，只有服务器缓存，而 max-age 又为 0 所以每次都会发起 200 的请求，设置 public 的意思就是允许其他各级代理缓存资源，因此如果资源没改变会返回 304 直接设置 max-age = 1000，即是一秒之后内容过期，目的是触发浏览器缓存，也能达到想要 304 的效果 如何让浏览器不缓存静态资源实际上，工作中很多场景都需要避免浏览器缓存，除了浏览器隐私模式，请求时想要禁用缓存，还可以设置请求头 Cache-Control: no-cache, no-store, must-revalidate，当然，还有一种常用做法，即给请求的资源增加一个版本号，比如 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=2.1.1\"/&gt; 这样做的好处就是你可以自由控制什么时候加载最新的资源，不仅如此，HTML 也可以禁用缓存，即在页面的 &lt;head&gt; 节点中加入 &lt;meta&gt; 标签 1&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache，no-store，must-revalidate\"/&gt; 上述虽能禁用缓存，但只有部分浏览器支持，而且由于代理不解析 HTML 文档，故代理服务器也不支持这种方式 总结Expires/Cache-Control 用来设置缓存时间，即资源有效时间（状态码 200（from cache）），可避免请求发送到服务器，Last-Modified/ETag 用来判断资源是否被修改了（状态码 304（not change）），可避免传输相同的资源内容，造成带宽和时间的浪费，使用原则如下 需要兼容 http 1.0 的时候需要使用 Expires，不然可以考虑直接使用 Cache-Control 需要处理一秒内多次修改的情况，或者其他 Last-Modified 处理不了的情况，才使用 ETag，否则使用 Last-- Modified 对于所有可缓存资源，需要指定一个 Expires 或 Cache-Control，同时指定 Last-Modified 或者 Etag 可以通过标识文件版本名、加长缓存时间的方式来减少 304 响应","link":"/2019/11/12/HTTP/04/"},{"title":"Node.js 中的 co 模块","text":"Node.js 中的 co 模块主要用于 Generator 函数的自动执行，可以使我们以同步的形式编写异步代码 实例一先来看两个对比实例，传统方式下，sayhello 是一个异步函数，执行 helloworld 会先输出 'world' 再输出 'hello' 1234567891011121314151617181920setTimeout(() =&gt; { console.log('!')}, 0)function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello) })}function helloworld() { sayhello() console.log('world')}helloworld()// 'world'// 'hello'// ! 这是因为 Promise 是基于任务队列机制的（详细可以参考 JavaScript 并发模型），即当前代码执行完的时候才会触发，但是会在下一个 EventLoop 之前执行（注意与 setTimeout 区分开来） 实例二我们将上面的示例换一种写法，调整成 Promise + Generator 的方式来试试，也就是模拟一下 co 当中的实现方式 123456789101112131415161718192021function co(gen) { var it = gen() var ret = it.next() ret.value.then(function (res) { it.next(res) })}function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello) })}co(function* helloworld() { yield sayhello() console.log('world')})// 'hello'// 'world' 我们模拟实现了 co 函数，首先生成一个迭代器，然后执行一遍 next()，得到的 value 是一个 Promise 对象，promise.then() 里面再执行 next()，运行后可以发现，结果就是我们想要的先输出 'hello' 再输出 'world' 从上面示例可以看出，Generator 函数体可以挂载在 yield 语句处，直到下一次执行 next()，我们本章当中将要介绍的 co 模块的思路也就是利用了 Generator 的这个特性，将异步操作跟在 yield 后面，当异步操作完成并返回结果后，再触发下一次 next() ，当然，跟在 yield 后面的异步操作需要遵循一定的规范 thunks 和 promises 从上面示例我们也可以简单的推算出 co 的主要功能有下面这些 异步流程控制，依次执行 Generator 函数内的每个位于 yield 后的 Promise 对象，并在 Promise 的状态改变后，把其将要传递给 reslove 函数的结果或传递给 reject 函数的错误返回出来，可供外部来进行传递值等操作，这些 Promise 是串行执行的 若 yield 后是 Promise 对象的数组或属性值是 Promise 对象的对象，则返回出结构相同的 Promise 执行结果数组（对象），并且这些 Promise 是并行执行的 co 自身的返回值也是一个 Promise 对象，可供继续使用 run由上面的示例我们可以发现，Generator 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权，有两种方法可以做到这一点 回调函数，将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权 Promise 对象，将异步操作包装成 Promise 对象，用 then 方法交回执行权 在看 co 源码之前，我们先来尝试着自己实现一下，也就是稍微完善一下上面的方法 123456789101112131415161718192021// 第一版function run(gen) { var gen = gen() function next(data) { var result = gen.next(data) if (result.done) return // 判断 result.value 是否是 Promise，如果是就添加 then 函数，不是就直接执行 if (isPromise(result.value)) { result.value.then(data =&gt; { next(data) }) } else { result.value(next) } } next()}function isPromise(obj) { return typeof obj.then == 'function'} 上面我们已经完成了一个基本版的启动器函数，支持 yield 后跟回调函数或者 Promise 对象，但是并不完善，比如我们没有针对 Generator 进行错误捕获，所以我们可以考虑将其封装成一个 Promise 的形式 123456789101112131415161718192021222324252627282930313233343536373839404142// 第二版function run(gen) { var gen = gen() return new Promise((resolve, reject) =&gt; { function next(data) { try { var result = gen.next(data) } catch (e) { return reject(e) } if (result.done) { return resolve(result.value) } var value = toPromise(result.value) value.then(data =&gt; { next(data) }, e =&gt; { reject(e) }) } next() })}function isPromise(obj) { return typeof obj.then == 'function'}function toPromise(obj) { if (isPromise(obj)) return obj if (typeof obj == 'function') return thunkToPromise(obj) return obj}function thunkToPromise(fn) { return new Promise(function (resolve, reject) { fn(function (err, res) { if (err) return reject(err) resolve(res) }) })} 在这一版当中，我们返回了一个 Promise 当 result.done 为 true 的时候，我们将该值 resolve(result.value) 如果执行的过程中出现错误，被 catch 住，我们会将原因 reject(e) 其次，我们会使用 thunkToPromise 将回调函数包装成一个 Promise，然后统一的添加 then 函数 最后，我们再来看看 co 源码当中具体是如何实现的 co源码实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// co 的核心代码如下function co(gen) { // 保持当前函数的上下文 var ctx = this; // 截取 co 输入的参数，剔除 arguments 中的第一个参数，即 gen 对象，剩余参数作为 gen 的入参 var args = slice.call(arguments, 1) // co 函数整个的返回值是一个 promise 实例，包装了传递的 generator 函数内所有 promise 的执行 // 这也是它为什么可以使用 then 和 catch 的根源 return new Promise(function (resolve, reject) { // 判断传入的 gen 是否为函数，如果是则执行，将结果赋值给 gen 对象 if (typeof gen === 'function') gen = gen.apply(ctx, args); // 根据 generator 函数执行结果是否存在 next 字段，判断 gen 是否为 generator 迭代器对象 // 若不是，则调用 resolve 返回最外层的 promise 对象状态 if (!gen || typeof gen.next !== 'function') return resolve(gen); // 如果是 generator 迭代器对象，开始控制 gen.next() 方法的调用 // 调用入口函数，成功方法 onFulfilled(); // 入口函数，将传递进来的 generator 函数执行到第一个 yield 处来开启第一次的异步调用 // 另外也用作内部使用，作为 resolve 方法，处理异步结果，并继续调用下一个 promise function onFulfilled(res) { var ret; try { // res 为此次调用的 Peomise 结果 // 利用 generator 函数的特性，调用 next() 方法的参数，会作为 yield 的返回值 // 并将异步操作的结果返回给 ret.value ret = gen.next(res); } catch (e) { // 如果发生错误，则把 Peomise 状态指为 rejected，并且把错误结果返回出去 return reject(e); } // 将 generator 函数执行 next() 后的结果再次传入 next() 方法，实现串行调用 next(ret); } // 上面的 onFulfilled 函数作为内部的成功方法，下面这个则作为失败方法 // 实现和上面类似 function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } // 首先需要明确，generator 函数在执行完毕后会返回 { done: true, value: undefined } function next(ret) { // 如果执行完成，直接调用 resolve 把 promise 置为成功状态 if (ret.done) return resolve(ret.value); // 然后把 yield 的值（ret.value）转换成 promise（ctx 为上面保存的 this） // 支持 promise，generator，generatorFunction，array，object var value = toPromise.call(ctx, ret.value); // 成功转换就可以直接给新的 promise 添加 onFulfilled, onRejected // 当新的 promise 状态变成结束态（成功或失败），就会调用对应的回调，整个 next 链路就执行下去了 // 之所以可以一直 next() 下去，这是因为上面的 ret.value 是一个 Peomise 对象 // 当 return value.then(onFulfilled, onRejected) 以后，意味着又要去执行上面的 onFulfilled 了 // 然后会在 onFulfilled 里面再次去调用 next(ret) // 这样就会一直循环下去，直到完成整个链的操作 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 如果以上情况都没发生，则参数为非 thunk 函数和 promise 对象 // 那么就将 promise 对象的状态改为 rejected，从而终止执行 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')); } });} 核心代码入口是 onFulfilled，无论如何第一次的 next(ret) 是一定要执行的，因为 generator 必须要 next() 一下的，但是 co 实际上有两种调用方式，分为有参数和无参数的，很明显以上是无参数的 generator 执行器，那么有参数的 wrap 呢？co 为我们提供了简单的包装 123456789// 为有参数的 generator 调用，提供简单包装co.wrap = function (fn) { createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() { // 把 arguments 给 fn 当参数 return co.call(this, fn.apply(this, arguments)); }}; 通过 call 和 apply 的组合使用来传递 arguments 辅助函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 将传入的参数对象转换为 Promise 对象function toPromise(obj) { if (!obj) return obj; // 如果 obj 已经是 Promise 对象，则直接返回 if (isPromise(obj)) return obj; // 如果 generator 是函数或对象，则直接把 obj 作为参数传入 co 函数，并返回 if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果 obj 是函数，则直接视为符合 thunk 规范的函数直接转换为 Promise // 关于 thunk 函数可以参考 阮一峰老师的 Thunk 函数的含义和用法 if ('function' == typeof obj) return thunkToPromise.call(this, obj); // 如果是数组，把数组中每个元素转化为内部 Promise，然后使用 Promise.all 并行计算 if (Array.isArray(obj)) return arrayToPromise.call(this, obj); // 如果是对象，则遍历对象中的每个 key 对应的 value，然后使用 Promise.all 并行计算 if (isObject(obj)) return objectToPromise.call(this, obj); // 最后返回 return obj;}// 这里的 obj 为数组// 所以使用 Array.map 方法，分别对数组中的每一个元素递归执行 toPromise 方法// 再利用 Promise.all 方法，在所有给定的可迭代完成时执行 resolve（或者第一个代码失败）并返回结果function arrayToPromise(obj) { return Promise.all(obj.map(toPromise, this));}// thunk 转为 promisefunction thunkToPromise(fn) { var ctx = this; return new Promise(function (resolve, reject) { fn.call(ctx, function (err, res) { if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); }); });}// 这里的 obj 为对象function objectToPromise(obj) { // results 是将用于返回的对象，使用和 obj 相同的构造函数 var results = new obj.constructor(); // Object.keys 方法用于返回对象的所有的属性名 var keys = Object.keys(obj); // 用于保存所有对象属性的 Promise 的数组 var promises = []; // 利用 for 循环来实现并行的异步调用 for (var i = 0; i &lt; keys.length; i++) { var key = keys[i]; // 转换为 Promise 对象 var promise = toPromise.call(this, obj[key]); // 如果是 promise 对象，直接调用 defer 函数，添加到 promises 数组中，否则直接将结果返回给 result[key] if (promise &amp;&amp; isPromise(promise)) defer(promise, key); else results[key] = obj[key]; } // 将 Promise 数组传入 Promise.all，待 defer 函数中 results 对象的属性都赋值完毕后，返回最终的 results 对象 // 使得后续调用的 then() 可以获得此处的 results return Promise.all(promises).then(function () { return results; }); // key 对应的元素成功转化为 Promise 对象后，调用 Promise 的 resovle 方法 // 以便在 results 中获取每个 Promise 对象成功执行后的结果 function defer(promise, key) { results[key] = undefined; promises.push(promise.then(function (res) { results[key] = res; })); }} 经过上面这些步骤，我们可以得到 yield 后面只能是函数、Promise 对象、Generator 函数、Generator 迭代器对象、数组（元素仅限之前的 4 类）和 Object（对应 value 仅限定之前的 4 类），现在可以把 co 串行调用 generator 函数中 yield 的过程总结如下 首先进入最外层的 Promise 通过入口 onFilfilled() 方法，将 generator 函数运行至第一个 yield 处，执行该 yield 后边的异步操作，并将结果传入 next 方法 如果 next 中传入结果的 done 为 true（已经完成），则返回最外层 Promise 的 resolve 如果 next 中传入结果的 done 为 fasle（表示还没执行完），则返回 value（即 yield 后边的对象）然后查看是否可以转化为内部 Promise 对象。如无法转化则抛出错误，返回最外层 Promise 的 reject 若能转化为 Promise 对象，则通过 then(onFilfilled, onRejected) 开始执行 在 onFilfilled() 或者 onRejected() 内部调用再次调用 next() 方法，实现串行执行 yield，并将 yield 后边的对象传递给 next()，依次重复（实现链式调用） 所有 yield 执行返回，将最后的 return 值返回给最外层 Promise 的 resovle 方法，结束 co 对 generator 函数的调用 参考 co co 4.6源码解析 Thunk 函数的含义和用法 co 和 koa 异步流程控制：7 行代码学会 co 模块","link":"/2019/01/02/Node/02/"},{"title":"什么是 Node.js","text":"其实在工作过程中一直有个想法，就是好好地深入的去学习一下 Node.js，无奈各种工作，家庭，生活和一些其他的原因导致此事一直搁浅，之前也有零零散散的学过，但是都算不得上深入，框架的使用也都只是停留在会用的阶段，底层的实现也没有知根知底的去探个究竟 所以打算在这 2019 年剩下的一段时间里，静下心来好好地学一下 Node.js，补充一下相关知识和一些流行框架的内容，应该会是一个系列文章，记录的就是在学习 Node.js 过程当中的一些笔记，心得和想法吧，刚好也看到了 如何正确的学习 Node.js 这篇文章，就以这个为起点，从头开始吧 什么是 Node.js按照官方的说法是 12345Node.js® is a JavaScript runtime built on Chrome&apos;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js&apos; package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 简单的总结一下，主要有下面这几点 Node.js 不是语言或者框架，也不是 JavaScript 的应用，它只是一个 JavaScript 运行时环境 它构建在 Chrome's V8 的 JavaScript 引擎之上（Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用） 特点是事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model） 用自己的话来说就是 Node.js 不是一门语言也不是框架，它是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作和 I/O、文件读写、操作数据库等能力，一般主要用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（如 API、即时聊天、微服务）等 基本原理如下图，简要的介绍了 Node.js 是基于 Chrome V8 引擎构建的，由事件循环（EventLoop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了 核心概念主要分为三个部分 Chrome V8 引擎 EventLoop 事件循环 Thread Pool 线程池 简单的梳理一下 Chrome V8 是 JavaScript 引擎，而 Node.js 又内置 Chrome V8 引擎，所以它使用的 JavaScript 语法 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事，这就意味着，所有任务需要排队，如果前一个任务结束，才会执行后一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着 由 EventLoop 将 I/O 任务放到线程池里 换一个维度来看，如下图 同样的，我们也来简单的梳理一下 Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因） 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行 在解决并发问题上，异步是最好的解决方案，可以简单的理解为排队和叫号的机制，排队的时候，等待就可以了，而取号的过程，则是由 EventLoop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务，之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需在进程或者线程当中切换上下文，所以非常高效，但它在执行具体任务的时候是多线程的 关于更多的应用场景的介绍可以参考 Node.js 应用场景 异步流程控制Node.js 的核心就是异步流程控制，如下图是 Node.js 解决异步流程问题的演进 红色代表 Promise，是使用最多的，无论 async 还是 generator 都可用 蓝色是 Generator，过度期当中使用的 绿色是 Async 函数，也是接下来的趋势 所以推荐使用 Async 函数加 Promise 组合 简单来说，就是以下三点 callback Promise Async/Await 下面一个一个来看 Callback &amp;&amp; EventEmitter在这里我们主要看两个点，即 Callback 和 EventEmitter，先来看看 Callback，在 Node.js 当中推崇回调函数使用 Error-first 的写法，也就是错误优先的回调写法，它有两条规则 回调函数的第一个参数返回的 error 对象，如果 error 发生了，它会作为第一个 err 参数返回，如果没有，一般做法是返回 null 回调函数的第二个参数返回的是任何成功响应的结果数据，如果结果正常，没有 error 发生，err 会被设置为 null，并在第二个参数就出返回成功结果数据 123function(err, res) { // process the error and result} 关于 EventEmitter，在 Node.js 当中使用的是事件驱动模型，当 webserver 接收到请求，就把它关闭然后进行处理，再去服务下一个 web 请求，当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户 这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作（也就是所谓的事件驱动 IO），在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数，也就是下图这样 事件模块是 Node.js 内置的对发布订阅模式（publish/subscribe）的实现，通过 EventEmitter 属性，提供了一个构造函数，该构造函数的实例具有 on 方法，可以用来监听指定事件，并触发回调函数，任意对象都可以发布指定事件，被 EventEmitter 实例的 on 方法监听到，下面是一个简单的示例 1234567891011const EventEmitter = require('events')class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter()myEmitter.on('event', () =&gt; { console.log('触发了一个事件')})myEmitter.emit('event') 如果同时绑定了多个事件监听器，则事件监听器回调函数是会被先后调用，而事件参数则作为回调函数参数传递，本质上就是发布订阅模式的实现，下面是一个简单的发布订阅模式的手动实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Target { constructor() { this.list = {} } // 订阅 lister(type, fn) { if (this.list[type]) { this.list[type].push(fn) } this.list[type] = [fn] } // 发布 trigger(type, ...args) { this.list[type].forEach(list =&gt; { list(...args) }) } // 删除 remove(type, fn) { let fns = this.list[type] if (!fns) return false if (fn) { for (let i = 0; i &lt; fns.length; i++) { let _fn = fns[i] if (_fn === fn) { fns.splice(i, 1) } } } }}// 使用const target = new Target()const clickHandle = function(e) { console.log(`click, ${e}`) }const dbClickHandle = function(e) { console.log(`dbClick, ${e}`) }target.lister('click', clickHandle)target.lister('dbclick', dbClickHandle)target.remove('click', clickHandle)target.trigger('click', 'zhangsan')target.trigger('click', 'lisi')target.trigger('dbclick', 'wangwu') PromisePromise 意味着一个还没有完成的操作，但在未来会完成的，Promise 最主要的交互方法是通过将函数传入它的 then 方法从而获取得 Promise 最终的值，要点有三个 递归，每个异步操作返回的都是 Promise 对象 状态机，三种状态转换，只在 Promise 对象内部可以控制，外部不能改变状态 全局异常处理 定义如下 1234567var promise = new Promise(function (resolve, reject) { if (/* everything turned out fine */) { resolve('Stuff worked!') } else { reject(Error('It broke')) }}) 每个 Promise 定义都是一样的，在构造函数里传入一个匿名函数，参数是 resolve 和 reject，分别代表成功和失败时候的处理，如下 123456promise.then(function (text) { console.log(text) return `Promise`.reject(new Error('Error'))}).catch(function (err) { console.log(err)}) 它的主要交互方式是通过 then 函数，如果 Promise 成功执行 resolve 了，那么它就会将 resolve 的值传给最近的 then 函数，作为它的 then 函数的参数，如果出错 reject，那就交给 catch 来捕获异常，更多内容可以参考下面几个链接 Node.js 最新技术栈之 Promise 篇 理解 Promise 的工作原理 Promise 迷你书 终极解决方案 Async/AwaitAPI 的介绍就不详细展开了，我们下面就看两个实际的用法，第一个是一段 Koa 2 应用里的一段代码 12345678910exports.list = async (ctx, next) =&gt; { try { let students = await Student.getAllAsync() await ctx.render('students/index', { students: students }) } catch (err) { return ctx.api_error(err) }} 它做了三件事 通过 await Student.getAllAsync() 来获取所有的 students 信息 通过 await ctx.render 渲染页面 由于是同步代码，使用 try/catch 做的异常处理 第二个是一个读取文件的操作，采用 await + promise 的写法 123456789const Promise = require('bluebird')const fs = Promise.promisifyAll(require('fs'))async function test() { const contents = await fs.readFileAsync('myfile.js', 'utf8') console.log(contents)}test()","link":"/2019/09/01/Node/05/"},{"title":"中间件","text":"我们本章来探讨一下 Koa.js 当中的中间件，在使用 Koa.js 的过程当中，经常会接触到中间件这个概念，之前在学习 Redux 的过程当中，里面也有一个中间件（middleware）的概念，所以就打算抽点时间，整理一下中间件的相关概念，关于 Redux 当中的 middleware 会另起篇幅来进行介绍 什么是中间件 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的 上面是 维基百科 当中对于中间件的解释，看上去可能比较抽象，其实简单的总结来说，所谓中间件，就是处在服务业务与用户应用中间的软件（架构），主要用来将具体业务和底层逻辑解耦的组件 在深入展开之前，我们先来看看中间件的洋葱模型 中间件的洋葱模型关于洋葱模型，也不说复杂了，直接通过几个例子来了解一下到底什么是中间件的洋葱模型，先以 express 为例 12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express')var app = express()app.use(function middleware1(req, res, next) { console.log('A middleware1 开始') next() console.log('B middleware1 结束')})app.use(function middleware2(req, res, next) { console.log('C middleware2 开始') next() console.log('D middleware2 结束')})app.use(function middleware3(req, res, next) { console.log('E middleware3 开始') next() console.log('F middleware3 结束')})app.get('/', function handler(req, res) { res.send('ok') console.log('======= G =======')})if (module.parent) { module.exports = app} else { app.listen(8080)}// =============================================// 控制台输出结果为A middleware1 开始C middleware2 开始E middleware3 开始======= G =======F middleware3 结束D middleware2 结束B middleware1 结束 运行结果的示意图如下 123456789101112131415161718192021 -------------------------------------- | middleware1 | | ---------------------------- | | | middleware2 | | | | ------------------- | | | | | middleware3 | | | | | | | | | next next next ——————————— | | |请求 ——————————————————&gt; | handler | — 收尾工作-&gt; |响应 &lt;————————————————— | G | | | | | A | C | E ——————————— F | D | B | | | | | | | | | ------------------- | | | ---------------------------- | --------------------------------------顺序 A -&gt; C -&gt; E -&gt; G -&gt; F -&gt; D -&gt; B \\---------------/ \\----------/ ↓ ↓ 请求响应完毕 收尾工作 在 Redux 的里面也有一个中间件（middleware）的概念，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function middleware1(store) { return function (next) { return function (action) { console.log('A middleware1 开始') next(action) console.log('B middleware1 结束') }; };}function middleware2(store) { return function (next) { return function (action) { console.log('C middleware2 开始') next(action) console.log('D middleware2 结束') }; };}function middleware3(store) { return function (next) { return function (action) { console.log('E middleware3 开始') next(action) console.log('F middleware3 结束') } }}function reducer(state, action) { if (action.type === 'MIDDLEWARE_TEST') { console.log('======= G =======') } return {}}var store = Redux.createStore( reducer, Redux.applyMiddleware( middleware1, middleware2, middleware3 ))store.dispatch({ type: 'MIDDLEWARE_TEST' }) 运行结果的示意图如下 123456789101112131415161718192021 -------------------------------------- | middleware1 | | ---------------------------- | | | middleware2 | | | | ------------------- | | | | | middleware3 | | | | | | | | | next next next ——————————— | | |dispatch —————————————&gt; | reducer | — 收尾工作-&gt;|nextState &lt;————————————— | G | | | | | A | C | E ——————————— F | D | B | | | | | | | | | ------------------- | | | ---------------------------- | --------------------------------------顺序 A -&gt; C -&gt; E -&gt; G -&gt; F -&gt; D -&gt; B \\---------------/ \\----------/ ↓ ↓ 更新 state 完毕 收尾工作 当然，在 Koa.js 当中也是一样的 123456789101112131415161718192021222324252627282930313233343536373839const Koa = require('koa')let app = new Koa()const middleware1 = async (ctx, next) =&gt; { console.log('A middleware1 开始') await next() console.log('B middleware1 结束') }const middleware2 = async (ctx, next) =&gt; { console.log('C middleware2 开始') await next() console.log('D middleware2 结束')}const middleware3 = async (ctx, next) =&gt; { console.log('E middleware3 开始') await next() console.log('F middleware3 结束')}app.use(middleware1)app.use(middleware2)app.use(middleware3)app.use(async(ctx, next) =&gt; { ctx.body = 'hello world' console.log('======= G =======')})app.listen(3000)// A middleware1 开始// C middleware2 开始// E middleware3 开始// ======= G =======// F middleware3 结束// D middleware2 结束// B middleware1 结束 可以发现，结果是一致的，至于为什么会出现以上的结果，这也就是本篇文章需要说到的地方，在 Koa.js 当中，是通过一个中间件引擎 koa-compose 模块来实现的，也就是 Koa.js 实现洋葱模型的核心引擎 Koa.js 的切面Koa.js 的切面是由中间件机制实现的，一个中间件一般有两个切面，遵循先进后出的切面执行顺序，类似入栈出栈的顺序，可以参考下图 中间件原理通过之前的洋葱模型可以看出，中间件的在 await next() 前后的操作，很像数据结构的一种场景，就是先进后出的『栈』，同时又有统一上下文管理操作数据，在 Koa.js 当中最为人所知的便是基于『洋葱模型』的 HTTP 中间件处理流程 Koa.js 当中的洋葱模式可以拆解成以下几个元素 生命周期 中间件 中间件在生命周期中 前置操作 等待其他中间件操作 后置操作 所以综上所述，我们也可以总结出一下中间件的相关特性 有统一的 Context 操作先进后出（栈数据结构） 有控制先进后出的机制的 next() 方法 有提前结束机制 这样子我们可以单纯用 Promise 做个简单的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let context = { data: []}async function middleware1(ctx, next) { console.log('A middleware1 开始') ctx.data.push(1) await next() console.log('B middleware1 结束') ctx.data.push(6)}async function middleware2(ctx, next) { console.log('C middleware2 开始') ctx.data.push(2) await next() console.log('D middleware2 结束') ctx.data.push(5)}async function middleware3(ctx, next) { console.log('E middleware3 开始') ctx.data.push(3) await next() console.log('F middleware3 结束') ctx.data.push(4)}Promise.resolve(middleware1(context, async () =&gt; { return Promise.resolve(middleware2(context, async () =&gt; { return Promise.resolve(middleware3(context, async () =&gt; { console.log('======= G =======') return Promise.resolve() })); }));})) .then(() =&gt; { console.log('end') console.log('context = ', context) })// A middleware1 开始// C middleware2 开始// E middleware3 开始// ======= G =======// F middleware3 结束// D middleware2 结束// B middleware1 结束// end// context = { data: [ 1, 2, 3, 4, 5, 6 ] } 我们可以简单的梳理一下上述示例的执行流程 生命周期就是 Promise.resolve 的嵌套 中间件就是 middleware1、middleware2 和 middleware3 中间件在生命周期中，就是 Promise.resolve(middleware) 嵌套中执行中间件 middleware1 前置操作是 A 等待嵌套的 middleware2 middleware2 前置操作是 C 等待嵌套的 middleware3 middleware3 前置操作是 E middleware3 前置操作是 F middleware2 后置操作是 D middleware1 后置操作是 B 实现通过上一节中的中间件原理，我们可以看出，单纯的使用 Promise 嵌套是可以直接实现中间件流程的，虽然可以实现，但是 Promise 嵌套会产生代码的可读性和可维护性的问题，也带来了中间件扩展问题，所以需要把 Promise 嵌套实现的中间件方式进行高度抽象，达到可以自定义中间件的层数，在这种情况下，我们就可以采用 async/await 来进行实现，我们先来理清实现过程当中需要的步骤 中间件队列 处理中间件队列，并将上下文 Context 传进去 中间件的流程控制器 next() 异常处理 根据上一节的中间的原理，我们可以抽象出 每一个中间件需要封装一个 Promise 利用洋葱模型的先进后出操作，对应 promise.resolve() 的前后操作 1234567891011121314151617181920212223242526272829303132333435363738function compose(middleware) { if (!Array.isArray(middleware)) { throw new TypeError(`Middleware stack must be an array!`) } return function (ctx, next) { let index = -1 return dispatch(0) function dispatch(i) { if (i &lt; index) { return Promise.reject(new Error(`next() called multiple times.`)); } index = i let fn = middleware[i] if (i === middleware.length) { fn = next } if (!fn) { return Promise.resolve() } try { return Promise.resolve(fn(ctx, _ =&gt; { return dispatch(i + 1) })) } catch (err) { return Promise.reject(err) } } }} 下面就让我们来简单是试用一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445let middleware = []let context = { data: []}middleware.push(async (ctx, next) =&gt; { console.log('A middleware1 开始') ctx.data.push(1) await next() console.log('B middleware1 结束') ctx.data.push(6)})middleware.push(async (ctx, next) =&gt; { console.log('C middleware2 开始') ctx.data.push(2) await next() console.log('D middleware2 结束') ctx.data.push(5)})middleware.push(async (ctx, next) =&gt; { console.log('E middleware3 开始') ctx.data.push(3) await next() console.log('F middleware3 结束') ctx.data.push(4)})const fn = compose(middleware)fn(context) .then(_ =&gt; { console.log('end') console.log('context = ', context) })// A middleware1 开始// C middleware2 开始// E middleware3 开始// F middleware3 结束// D middleware2 结束// B middleware1 结束// end// context = { data: [ 1, 2, 3, 4, 5, 6 ] }","link":"/2019/10/19/Node/12/"},{"title":"Redux、Flux 和 React-Redux 三者之间的区别","text":"在之前的章节 Flux 与 Redux 当中，我们介绍了 Flux 与 Redux 的一些基本概念和它们之间的一些区别，今天我们在来看看另外一个和它们比较类似的 React-Redux，然后在简单汇总一下，比较一下它们三者之间的区别，不过在看 React-Redux 的内容之前，我们先来简单的回顾一下上一章的内容 Flux 传统的 Redux 简化了 Flux 的流程，一般 Flux 的流程是 view 触发 action 中的方法 action 发送 dispatch store 接收新的数据进行合并，触发 view 中绑定在 store 上的方法 通过修改局部 state，改变局部 view ReduxRedux 就是 Flux 思想在 React 当中的实现，它的流程是 view 直接触发 dispatch 将 action 发送到 reducer 中后，根节点上会更新 props，改变全局 view Redux 将 view 和 store 的绑定从手动编码中提取出来，形成了一个统一的规范最后放在了自己的体系中 而在基本的 Redux 流程中，action 只是充当了一个类似于 topic 之类的角色（类似 type 属性），reducer 会根据这个 topic 确定需要如何返回新的数据 数据的结构处理也从 store 中移到了 reducer 中 Redux 数据流如下图所示 总之记住一句话 Redux 的基本原理实际上就是围绕着 store 进行的 这个 store 不是 Flux 中的 store，而是 Redux 提供的 createStore 方法创建的 store createStore 方法接收 reducer 函数和初始化的数据（currentState），并将这两个参数并保存在 store 中 createStore 时传入的 reducer 方法会在 store 的 dispatch 被调用的时候再被调用，接收 store 中的 state 和action，根据业务逻辑修改 store 中的 state Storestore 中包含 subscribe()、dispatch()、getState() 和 replaceReducer() 这四个方法 其中，subscribe 和 dispatch 顾名思义就是订阅和发布的功能 subscribe 接收一个回调（listener），当 dispatch 触发时，执行 reducer 函数去修改当前数据（currentState），并执行 subscribe 传入的回调函数（listener） 而 getState 是获取当前 store 的 state(currentState) 至于 replaceReducer方法，就是动态替换 reducer 函数（一般使用较少） Middleware下面我们再来简单的了解一下 Redux 中的 middleware，Redux 中的 middleware 简单来说只是针对于 dispatch 方法做了 middleware 处理，也就是说，只接受一个 action 对象，例如官方示例中的 123456const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, loggerMiddleware)(createStore)store = createStoreWithMiddleware(rootReducer, initialState) Redux 的 middleware 用 reduceRight 的方法，将 applyMiddleware 方法中的参数串起来，原始的 dispatch 方法会最后执行，比如下图所示 而如果需要自定义 middleware 只需要注意这个 middleware 只接收一个 action，执行后也需要返回一个 action，如果需要执行下一步，调用 next(action) 即可 关于中间件的概念，我们会在 中间件 这一章当中详细的来进行介绍 React-Redux在简单回顾完了 Flux 与 Redux 的一些基本概念之后，下面我们就来看看 React-Redux，其实简单来说 React-Redux 是对 Redux 流程的一种封装，使其可以适配与 React 的代码结构，React-Redux 首先提供了一个 Provider 组件（用来包裹），可以将从 createStore 返回的 store 放入 Context 中，使子集可以获取到 store 并进行操作 123&lt;Provider store={store}&gt; {() =&gt; &lt;App /&gt;}&lt;/Provider&gt; 大致逻辑如下 首先 React-Redux 提供了 connect 方法，将原始根节点包装在 Connect 下，在 Connect 中的 state 存储不可变对象，并将 state 对象中的 props 和 store 中的 dispatch 函数传递给原始根节点 Connect 在 componentDidMount 中，给 store 添加 listener 方法（handleChange），每当 store 中的 dispatch 被调用时执行 handleChange 而 handleChange 会去修改 state 中的 porps，使原始根节点重新 render，并且 Connect 已经在 shouldComponentUpdate 实现了 PureRender 功能 handleChange 更新 state 中的 props 逻辑主要由三个函数构成，这三个函数都由 connect 方法传入（前两个参数用的较多） 12345connect( mapStateToProps, mapDispatchToProps, mergeToProps)(App) 第一个函数接收 store 中 state 和 props，使页面可以根据当前的 store 中 state 和 props返回新的 stateProps 第二个函数接收 store 中的 dispatch 和 props，使页面可以复写 dispatch 方法，返回新的 dispatchProps 第三个函数接收前两个函数生成的 stateProps 和 dispatchProps，在加上原始的 props 合并成新的 props 并传给原始根节点的 props React-Redux 中的流程如下图 首先 view 触发 dispatch 然后进入 reducer，修改 store 中的 state ，再将新的 state 和 props 传入 handleChange 中，生成更符合页面的 props，最后传给原始根节点重新 render，下面我们就深入的来了解一下 React-Redux 当中的相关概念，React-Redux 将所有组件分成了以下两大类 UI 组件（presentational component） 容器组件（container component） 下面我们就分别来看这两类组件 UI 组件UI 组件有以下几个特征 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用 this.state 这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 因为不含有状态，UI 组件又称为纯组件，即它像纯函数一样，纯粹由参数决定它的值 容器组件容器组件的特征恰恰相反 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API 总之，只要记住一句话，UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑 在 React-Redux 当中比较常用的 API 就两个，一个是提供的一个组件 &lt;Provider&gt;，另一个就是 connect() 方法 connect()React-Redux 提供 connect 方法，用于从 UI 组件生成容器组件，connect 的意思就是将这两种组件连起来 1234567891011121314151617181920212223242526272829303132333435import { connect } from 'react-redux'const mapStateToProps = (state) =&gt; { return { inputValue: state.inputValue, list: state.list }}const mapDispatchToProps = (dispatch) =&gt; { return { handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } dispatch(action) }, handleSubmit() { const action = { type: 'add_todo_item' } dispatch(action) }, handleDelete(index) { const action = { type: 'delete_todo_item', index } dispatch(action) } }}export default connect(mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect 方法接受两个参数，mapStateToProps 和 mapDispatchToProps，它们定义了 UI 组件的业务逻辑，前者负责输入逻辑，即将 state 映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 action connect() 方法有两个比较重要的参数，mapStateToProps 和 mapDispatchToProps（都是函数） mapStateToProps官方解释如下 如果你传入了这个参数，那么这个组件将会注册 Redux 的 store 的更新信息（简单的可以理解为虚拟 DOM 那样，即变化了会自动更新） 即意味着无论什么时候 store 更新了，mapStateToProps 函数将会被调用 mapStateToProps 的返回值必须是一个 plain object（简单的对象），这个对象将和组件的 props 融合，也就是说返回的对象中的 key 将自动成为组件的 props 中的成员（就比如上例中的 App 组件中的参数） 如果不想订阅 store 的更新，可以不用传入该参数，此时使用 null 来占位即可（不能不传） 抛开官方那些比较繁琐的解释，本质上 mapStateToProps() 就是一个函数，它的作用就是建立一个从（外部的）state 对象到（UI 组件的）props 对象的映射关系，作为函数 mapStateToProps 执行后应该返回一个对象，里面的每一个键值对就是一个映射 123456const mapStateToProps = (state) =&gt; { return { inputValue: state.inputValue, list: state.list }} 这个函数内部返回的键值对可以被 connect() 传入的参数组件所拿到（上例中的 App），即 App 组件当中可以拿到传递过去的参数（state）（当作 props 来使用），而 &lt;/Provider&gt; 中传递的 store 之所以可以被全局使用，也是依靠的这个函数（间接的通过参数传递过去了），然后最重要的一点就是，它可以得到全局唯一的 store 中的 state mapDispatchToPropsmapDispatchToProps 是 connect 函数的第二个参数，用来建立 UI 组件的参数到 store.dispatch 方法的映射，也就是说，它定义了哪些用户的操作应该当作 action，传给 store，官方解释如下 如果传入了第二个参数，并且是一个函数，那么这个函数将获得 dispatch 方法（可以发出 action，也可以导致 state（store） 改变） 即 connect() 方法第一个参数来获得 state（但是不能修改），第二个参数可以用来修改 state（但是最终都传递回了 App 组件） 它接收参数 dispatch（dispatch 是 store 中用来分发命令的 API，这里简化了），返回一个总的 actions 清单对象 1234567891011121314151617const mapDispatchToProps = (dispatch) =&gt; { return { handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } dispatch(action) }, handleSubmit() { const action = { type: 'add_todo_item' } dispatch(action) }, }} &lt;Provider&gt;connect 方法生成容器组件以后，需要让容器组件拿到 state 对象，才能生成 UI 组件的参数，React-Redux 提供 Provider 组件，可以让容器组件拿到 state 12345678910111213import React from 'react'import ReactDOM from 'react-dom'import TodoList from './TodoList'import { Provider } from 'react-redux'import store from './store'const App = ( &lt;Provider store={store}&gt; &lt;TodoList /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); 在上面的示例当中，Provider 在根组件外面包了一层，这样一来 App 的所有子组件就默认都可以拿到 state 了","link":"/2019/04/02/React/02/"},{"title":"Redux 中的 Middleware","text":"之前在学习 Koa.js 当中的 中间件 部分时，曾经接触到过中间件这个概念，也了解洋葱模型这个概念，所以在今天我们就来深入的了解一下 Redux 当中与其十分类似的 middleware 什么是 Middleware所谓中间件，就是处在服务业务与用户应用中间的软件（架构），主要用来将具体业务和底层逻辑解耦的组件，在 Node.js 当中，middleware 是 req 和 res 之间的中间层，可以用来处理很多事情，但是在 Redux 里面，middleware 又是什么呢？在 Redux 的 middleware 的文档里面有这样一句话 It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 不难理解，在 Redux 里的 middleware 是发送 action 和 action 到达 reducer 之间的第三方扩展，也就是中间层，middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，简单的来说就是，middleware 是架在 action 和 store 之间的一座桥梁 为什么要引入 Middleware我们先来看一个简单的同步数据流的例子，如下图 当我们点击了 button 以后，在回调中 dispatch 一个 action，然后 reducer 收到 action 后，更新 state 并通知 view 重新渲染，一个很常规的同步数据流动的场景，但是如果我们现在的需求有所变动，比如需要打印每一个 action 信息用来调试，又或者需要在点击了 button 以后进行一些别的操作等等 面对多种多样的业务需求，单纯的修改 dispatch 或 reducer 的代码显然不是很理想的选择，我们需要的是可以组合的，自由插拔的插件机制，所以，在这种情况下，我们就会用上 middleware，如下图 每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware，实现变化多样的的功能，但是在本章当中我们不会过多关注它的内部实现原理，这一部分内容我们在之前的 Redux 源码初探 章节当中已经梳理过了，所以在本章当中，我们重点关注以下几个问题 middlewares 是如何工作的？ Redux 是如何让 middlewares 串联起来的？ 在 middleware 中调用 dispatch 会发生什么？ 我们自己的 middlewares 该怎么写？ 下面我们就一个一个来看 Middlewares 是如何工作的？在此之前，我们先简单的介绍一下箭头函数的用法，因为后面我们会经常遇到类似的写法，如下示例 12345678910111213// 一个标准的闭包函数function A() { var i = 0 return function() { return ++i }}// 我们使用箭头函数来进行改写var A = (i = 0) =&gt; { return _ =&gt; ++i }// 又因为仅有一个返回，所以我们可以省略 return 和 大括号var A = (i = 0) =&gt; _ =&gt; ++i 下面我们就正式开始，我们首先先来简单的定义一个日志中间件，如下 123456// loggerexport default store =&gt; next =&gt; action =&gt; { console.log('dispatch', action) next(action) console.log('finish', action)} 在 Redux 当中提供了 applyMiddleware 这个 API 用来加载 middleware，我们将其与我们上面定义的 logger 中间件放到一起来进行对比介绍，如下图所示 函数式编程思想设计 Middlewaremiddleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的 柯里化，applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值，这样设计的好处在于 易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合 compose 的方式，很容易形成 pipeline 来处理数据流 共享 store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，在 applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的 另外，我们可以发现 applyMiddleware 的结构也是一个多层柯里化的函数，借助 compose ，applyMiddleware 可以用来和其他插件一起加强 createStore 函数 12345678910import { createStore, applyMiddleware, compose } from 'redux'import rootReducer from '../reducers'import DevTools from '../containers/DevTools'const finalCreateStore = compose( // Middleware you want to use in development: applyMiddleware(d1, d2, d3), // Required! Enable Redux DevTools with the monitors you chose DevTools.instrument())(createStore) 给 Middleware 分发 Store创建一个普通的 store 通过如下方式 1let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null) 上面代码执行完后，applyMiddleware 函数陆续获得了三个参数，第一个是我们的 middlewares 数组，[mid1, mid2, mid3, ...]，第二个 next 是 Redux 原生的 createStore，最后一个是 reducer 我们从对比图中可以看到，applyMiddleware 利用 createStore 和 reducer 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量，middlewareAPI 就是对比图中红色箭头所指向的函数的入参 store 123456var middlewareAPI = { getState: store.getState, dispatch: (action) =&gt; dispatch(action)}chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) map 方法让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍，即执行红色箭头指向的函数（简单来说就是使用 middlewareAPI 作为参数将 middleware 包装一层），在执行完后，获得 chain 数组 [f1, f2, ... , fx, ...,fn]，它保存的对象是图中绿色箭头指向的匿名函数（中间件序列），因为闭包，所以每个匿名函数都可以访问相同的 store，即 middlewareAPI 但是这里存在一个问题，middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？ 我们用 applyMiddleware 是为了改造 dispatch 的，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware，所以必须用匿名函数包裹 dispatch（闭包机制），这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化 组合串联 Middlewares1dispatch = compose(...chain)(store.dispatch) compose 将 chain 中的所有匿名函数 [f1, f2, ... fx, ... fn] 组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, ... fx, ... fn] 从右到左依次执行（注意这里使用的是 reduceRight，所以顺序是从右到左，与数组的 reduce 区分开来） Redux 中 compose 的实现是下面这样的 123function compose(...funcs) { return arg =&gt; funcs.reduceRight((composed, f) =&gt; f(composed), arg)} compose(...chain) 返回的是一个匿名函数，函数里的 funcs 就是 chain 数组，当调用 reduceRight 时，依次从数组的右端取一个函数 fx 拿来执行，fx 函数的参数 composed 就是前一次 fx + 1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch，所以当 compose 执行完后，我们得到的 dispatch 是这样的 1dispatch = f1(f2(f3(store.dispatch))) 这个时候再调用新的 dispatch，每个 middleware 的代码就会依次执行 在 Middleware 中调用 Dispatch 会发生什么？经过 compose 之后，所有的 middleware 算是串联起来了，可是还有一个问题，在之前我们提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，所以就可以拿到 store 的 dispatch 方法，那么在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？ 12345678910111213const logger = store =&gt; next =&gt; action =&gt; { console.log('dispatch', action) next(action) // &lt;== console.log('finish', action)}// 对比const logger = store =&gt; next =&gt; action =&gt; { console.log('dispatch', action) store.dispatch(action) // &lt;== console.log('finish', action)} 在之前我们已经介绍过，通过匿名函数的方式 middleware 中拿到的 dispatch 和最终 compose 结束后的新 dispatch 是保持一致的，所以在 middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next() 的效果则是进入下一个 middleware，如下图所示 在正常情况下（图左），当我们 dispatch 一个 action 时，middleware 通过 next(action) 一层一层处理和传递 action 直到 Redux 原生的 dispatch，如果某个 middleware 使用 store.dispatch(action) 来分发 action，就发生了右图的情况，相当于从外层重新再来一遍 在 Middleware 中调用 Dispatch 的应用场景我们知道，如果在中间件当中不调用 next 的话，中间件就不会串起来执行的，不过有些特殊的 action，比如异步请求的 action，它们的目的地并不是原生的 dispatch，而是对异步请求的 action 进行拦截，在请求完数据后利用新的 dispatch 发送更新 UI 的 action，这个 action 就可以把所有的中间价走一遍了 我们可以来模拟一个异步请求到服务器获取数据，成功后弹出一个自定义的 Message 的中间件，我们使用 redux-thunk 这个中间件 1234const thunk = store =&gt; next =&gt; action =&gt; typeof action === 'function' ? action(store.dispatch, store.getState) : next(action) 没有看错，整个源码的核心只有这一点点，redux-thunk 做的事情就是判断 action 类型是否是函数，若是则执行 action，若不是则继续传递 action 到下个 middleware，我们首先来设计一个请求的 action 123456789101112131415const getThenShow = (dispatch, getState) =&gt; { const url = 'http://xxx.json' fetch(url) .then(response =&gt; { dispatch({ type: 'SHOW_MESSAGE_FOR_ME', message: response.json(), }) }, e =&gt; { dispatch({ type: 'FETCH_DATA_FAIL', message: e, }) })} 这个时候只要在业务代码里面调用 store.dispatch(getThenShow)，redux-thunk 就会拦截并执行 getThenShow 这个 action，getThenShow 会先请求数据，如果成功则会 dispatch 一个显示 Message 的 action，否则 dispatch 一个请求失败的 action，这里的 dispatch 就是通过 redux-thunk 这个 middleware 传递进来的 我们可以简单的总结一下，在 middleware 中使用 dispatch 的场景一般是，接受到一个定向 action，这个 action 并不希望到达原生的 dsipatch，存在的目的是为了触发其他新的 action，往往用在异步请求的需求当中 自定义的 Middlewares 该怎么写？实现很简单，我们先来定义一个 callTraceMiddleware 的中间件用来追踪函数的调用过程 1234567// callTraceMiddleware.jsexport default function callTraceMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; { console.trace() return next(action) }} 然后在调用中间件部分添加中间件 12345const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, loggerMiddleware, callTraceMiddleware)(createStore) 这样我们运行在浏览器窗口就可以看到打印的函数调用轨迹 总结applyMiddleware 机制的核心在于组合 compose，将不同的 middlewares 一层一层包裹到原生的 dispatch 之上，而为了方便进行 compose，需对 middleware 的设计采用柯里化的方式，达到动态产生 next 方法以及保持 store 的一致性 由于在 middleware 中可以像在外部一样轻松访问到 store，因此可以利用当前 store 的 state 来进行条件判断，用 dispatch 方法拦截老的 action 或发送新的 action 参考 Middleware Redux Middleware 详解 Redux 学习之何为 Middleware？ 解读 Redux 中间件的原理","link":"/2019/12/13/React/05/"},{"title":"Vuex 框架核心流程","text":"本文章节如下 首先先来看看 Vuex 的整体流程 然后介绍一些比较常见的 API 的用法 最后则是介绍一下初始化装载与注入的过程 至于源码的部分，则是会下一篇章节当中来进行介绍 流程图Vuex 的整个执行流程如下（转自网络） Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环，围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能 Vue Components Vue 组件，HTML 页面上负责接收用户操作等交互行为 执行 dispatch 方法触发对应 action 进行回应 dispatch 操作行为触发方法，是唯一能执行 action 的方法 actions 操作行为处理模块，负责处理 Vue Components 接收到的所有交互行为，包含同步或者异步的操作 支持多个同名方法，按照注册的顺序依次触发，向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作 该模块提供了 Promise 的封装，以支持 action 的链式触发 commit 状态改变提交操作方法，对 mutation 进行提交 是唯一能执行 mutation 的方法 mutations 状态改变操作方法，是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错 该方法只能进行同步操作，且方法名只能全局唯一，操作之中会有一些 Hook 暴露出来，以进行 state 的监控等 state 页面状态管理容器对象，集中存储 Vue components 中 data 对象的零散数据 全局唯一，以进行统一的状态管理，页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新 getters state 对象读取方法，图中没有单独列出该模块，应该被包含在了 render 中 Vue Components 通过该方法读取全局 state 对象 总结如下 Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理 若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state 通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新 目录结构 目录 介绍 module 提供 module 对象与 module 对象树的创建功能 plugins 提供开发辅助插件，如时光穿梭功能，state 修改的日志记录功能等 helpers.js 提供 action、mutations 以及 getters 的查找 API index.js 是源码主入口文件，提供 store 的各 module 构建安装 mixin.js 提供了 store 在 Vue 实例上的装载注入 util.js 提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法 下面我们就来看看其中的一些 API 的用法，比如之前介绍过的 State，Getter，Mutation 和 action 等，Vuex 使用单一状态树，每个应用将仅仅包含一个 store 实例，从 store 实例中读取状态最简单的方式就是在计算属性当中返回某个状态 StateVuex 通过 store 选中，将状态从根组件注入到每一个子组件当中 123456new Vue({ el: '#app', store, components: { Counter }, template: `&lt;div&gt;&lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;`}) 子组件可以通过 this.$store 访问到该 store 的实例 12345678const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count() { return this.$store.state.count } }} Getter简单的来说，可以将其理解为 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，它接收 state 作为『第一个参数』 12345678910111213const store = new Vuex.store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false }, ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } }}) 外部调用 1store.getters.doneTodos // [{ id: 1, text: '...', done: true }] 也可以接受其他的 getter 作为『第二个参数』 1234567891011121314151617getters: { // ... doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length }}store.getters.doneTodosCount // 1// 在组件当中使用computed: { doneTodosCount() { return this.$store.getters.doneTodosCount }} 也可以返回一个函数，来实现给 getter 传参 12345678getters: { // ... getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) }}store.getters.getTodoById(2) // { id: 2, text: '...', done: false } Mutation更改 Vuex 的 store 中的状态的唯一方法就是提交 mutation，非常类似于事件 每个 mutation 都有一个事件类型（type）和一个回调函数（handler） 回调函数就是进行状态更改的地方，并且接收 state 作为第一个参数 12345678910const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment(state) { state.count++ } }}) 需要注意 不能直接调用 mutation handle 应当以相应的 type 调用 store.commit 方法 1store.commit('increment') 同时可以向 store.commit 传入额外的参数，即 mutation 的载荷（payload） 1234567891011121314151617// ...mutations: { increment(state, payload) { state.count += payload.amount; }}store.commit('increment', { amount: 10})// 等同于store.commit({ type: 'increment', payload: 10}) Mutation 的提交 必须是同步函数（若是异步，则可能存在当 mutation 触发的时候，回调函数还没有被调用的情况） mutation 的提交可以使用 this.$store.commit('...') 或者可以使用 mapMutations 辅助函数将组建中的 methods 映射为 store.commit 调用，如下所示 123456789101112131415161718import { mapMutations } from 'Vuex';export default { // ... methods: { ...mapMutations([ // 将 this.increment() 映射为 this.$store.commit('increment') 'increment', // 将 this.incrementBy(amount) 映射为 this.$store.commit('incrementBy', amount) 'incrementBy' ]), ...mapMutations({ // 将 this.add() 映射为 this.$store.commit('increment') add: 'increment' }) }} Action 提交的是 mutation，而不是直接变更状态 可以包含任意异步操作 一个简单的 action 123456789101112131415const store = new Vuex.store({ state: { count: 0 }, mutations: { increment(state) { state.count++ } }, actions: { increment(context) { context.commit('increment') } }}) action 函数接受一个与 store 实例具有相同方法和属性的 Context 对象，因此可以调用 context.commit 提交一个 mutation 分发 Actionaction 通过 store.dispatch 方法触发 1store.dispatch('increment') 之所以这样使用，是因为 mutation 必须同步执行，而 action 则不必如此，可以在其内部执行异步操作 123456789101112131415161718actions: { increment({ commit }) { setTimeout(_ =&gt; { commit('incrementAsync') }, 1000) }}// 同时也支持载荷方式store.dispatch('incrementAsync', { amount: 10})// 等同于store.dispatch({ type: 'incrementAsync', amount: 10}) 组件当中 Action 的分发同 Mutation 类似，可以使用 this.$store.dispatch('...') 或者使用 mapActions 辅助函数 组合 Action因为 store.dispatch 返回的是一个 Promise 对象，所以可以使用 then() 方法来进行处理，亦或是可以使用 async/await 1234567891011// 假设 gotData() 与 gotOtherData() 均返回 Promiseactions: { async actionA({ commit }) { commit('gotData', await gotData()) }, async actionB({ commit }) { // 等待 actionA 完成 await dispatch('actionA') commit('gotOtherData', await gotOtherData()) }} 初始化装载与注入下面我们就来看看 Vuex 到底是如何在项目当中进行装载与注入的，首先是入口文件，先来看入口处的 export 函数到底导出了哪些东西，详细可以见官方 vuejs/vuex 需要注意的是，可能版本不同而导致内容有所不同，但是我们关心的仅仅是几个核心方法 123456789// https://github.com/vuejs/vuex/blob/dev/src/index.jsexport default { Store, install, mapState, mapMutations, mapGetters, mapActions} 装载与注入我们一般在使用 Vuex 的时候如下所示 123456789101112131415161718192021// store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 创建并导出 store 对象export default new Vuex.Store()// index.js 文件引入import Vue from 'vue'import App from './../pages/app.vue'import store from './store.js'new Vue({ el: '#root', router, store, // &lt;== 这里注入 render: h =&gt; h(App)}) 除了 Vue 的初始化代码，只是多了一个 store 对象的传入，我们来看下源码中的实现方式 12345678// store.js// 定义局部变量 Vue，用于判断是否已经装载和减少全局作用域查找let Vue// 判断若处于浏览器环境下且加载过 Vue，则执行 install 方法if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) { install(window.Vue)} 若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法 12345678910111213// store.jsexport function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue)} 下面是 applyMixin 的源码，如果是 2.x 以上的版本，可以使用 Hook 的形式进行注入，即在 beforeCreated 钩子前插入初始化代码（vuexInit） 123456789101112131415161718192021222324252627282930313233export default function (Vue) { const version = Number(Vue.version.split('.')[0]) if (version &gt;= 2) { Vue.mixin({ beforeCreate: vuexInit }) } else { // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = {}) { options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) } } /** * Vuex init hook, injected into each instances init hooks list. */ function vuexInit() { const options = this.$options // 将初始化 Vue 根组件时传入的 store 设置到 this 对象的 $store 属性上 // 子组件从其父组件引用 $store 属性，层层嵌套进行设置 if (options.store) { this.$store = typeof options.store === 'function' ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { this.$store = options.parent.$store } }} 这也就是为什么我们在 Vue 的组件中可以通过 this.$store.xxx 来访问到 Vuex 的各种数据和状态的原因了，因为在任意组件中执行 this.$store 都能找到装载的那个 store 对象，如下图所示，页面的结构为 对应的 store 流向","link":"/2018/08/13/Vue/03/"},{"title":"使用 Webpack 来构建 Vue 项目","text":"在本章当中，我们不使用官方提供的 Vue-Cli，而是从头开始搭建，一步一步实现一个简易脚手架，理解 Vue-Cli 到底是怎么实现的（顺路了解一下 Webpack 在 Vue 项目中的使用） 源码可以见 基于 vue-cli 整合的一个个人脚手架 需要注意的是，Webpack 和 Vue 的版本均在 2.0 以上 创建目录大致目录结构如下 12345├── index.html ==&gt; 根本件，最后用于展示 App.vue 组件├── main.js ==&gt; 入口文件├── App.vue ==&gt; vue 组件├── pacjage.json ==&gt; 工程配置文件（依赖，配置）└── webpack.config.js ==&gt; webpack 配置文件 首先新建一个 HTML 文件，添加一个 id 为 box 的容器 12// html&lt;div id='box'&gt;&lt;/div&gt; 然后在 main.js 文件中添加一点内容，用于最后的渲染 123456789// main.jsimport Vue from 'vue'import App from './App.vue'new Vue({ el: '#box', // 关于 h =&gt; h(App) 见最下方 render: h =&gt; h(App)}) 接下来来安装 Webpack 和 webpack-dev-server，再配置一下 Webpack，先简单的指定一下入口和出口文件 123456789101112// webpack.config.jsmodule.exports = { // 入口文件 entry: './main.js', // 出口文件 output: { filename: 'bundle.js', // 当前路径 path: __dirname }}; 然后就可以在我们的 index.html 中引入出口文件中指定的 JavaScript 这里是 bundle.js，但是目录中不使用 webpack -p 的话是不存在这个文件的 Webpack 会在编译执行的时候为我们自动生成该文件 12// index.html&lt;script src='./bundle.js'&gt;&lt;/script&gt; 关于出口文件，如果想指定输出的目录，可以按照下面这样来设置 123456789101112output: { // 如果目录，如果不存在则会去新建 path: path.resolve(__dirname, './src'), // 设置静态目录（可以从这个目录下直接进行读取） publicPath: '/src/', // 文件名称 filename: 'bundle.js'}, 配置 vue-loader如果需要解析像 App.vue 这样的文件，使其变成正常可以访问的代码，我们需要引入 vue-loader 来处理，这个时候我们就可以在 Webpack 中配置我们的相关 loader 了（这也是 Webpack 最核心的东西），在 webpack.config.js 中添加 1234567891011module: { // 所有的 loader 都配置在这里 rules: [ // 下面这句的意思是 使用 vue-loader 来解析处理以 .vue 结尾的文件 // 如果多个 loader 的话，中间可以使用 ! 来连接，比如 style!css { test: /\\.vue$/, loader: 'vue-loader' } ]} 配置完 Webpack 以后就可以来安装 vue-loader 以及其相关的一些组件了，单单使用 vue-loader 编译写入 .vue 文件是不够的，因为在 .vue 文件当中主要分为三大块，如下所示 12345&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 每一部分都需要相对应的 loader 来进行处理，这时就需要同时安装以下 loader 123456789// 处理模版vue-template-compiler ==&gt; 编译 vue 的 template 部分（之前使用的是 vue-html-loader） // 处理 css，因为 css 分为 .css 文件和行内样式，需要同时加载css-loader ==&gt; 编译写入 cssvue-style-loader ==&gt; 编译 vue 的样式部分// 处理 js，关于 babel 部分见下方vue-hot-reload-api ==&gt; 使 webpack 对 vue 实现热替换 可以使用以下命令来进行安装 1npm install vue-template-compiler css-loader vue-style-loader vue-hot-reload-api --save-dev 配置 babel众所周知，现在浏览器对 ES6 语法的支持还不是很完善，这个时候也就需要使用 Babel 来解析 ES6 语法，先来配置 Webpack 12345678910111213141516171819202122module: { rules: [ // 规则和上面类似，需要注意的就是多了一个 exclude // 意思是 匹配除了 /node_modules/ 和 bower_components 之外的所有 .js 文件 // 关于 options 选项，如果在根目录下的 .babelrc 配置了，这里就不需要了，两者是一样的 // 关于 .babelrc 见最后 { test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { // 先配置一个前置 presets: ['es2015'], // 还需要一个插件来使每次改变的时候，实时编译 plugins: ['transform-runtime'] } } } ]} Babel 需要的相关组件如下 123456789babel-loader ==&gt; 主程序babel-core ==&gt; 编译核心（语法层面）babel-plugin-transform-runtime ==&gt; 实时编译插件babel-perset-es2015 ==&gt; es6 语法babel-runtime ==&gt; 上面几个程序需要这个组件来运行（babel 执行环境） 最后来汇总一下所有涉及到的依赖 1234567891011121314151617181920212223242526272829303132vue-loader ==&gt; 编译写入 .vue 文件// 处理 .vue 中的模版vue-template-compiler ==&gt; 编译 vue 的 template 部分，（之前使用的是 vue-html-loader） // 处理 css，因为 css 分为 .css 文件和行内样式，需要同时加载css-loader ==&gt; 编译写入 cssvue-style-loader ==&gt; 编译 vue 的样式部分// 处理 jsvue-hot-reload-api ==&gt; 使 webpack 对 vue 实现热替换// 使用 babel 来处理 es6 语法babel-loader ==&gt; 主程序babel-core ==&gt; 编译核心（语法层面）babel-plugin-transform-runtime ==&gt; 实时编译插件babel-perset-es2015 ==&gt; es6 语法babel-runtime ==&gt; 上面几个 babel 程序需要这个组件来运行（babel 执行环境）// 处理文件和图片file-loader ==&gt; 用于打包文件和图片，默认情况下生成文件的文件名是文件名与 md5 哈希值的组合// webpackwebpack ==&gt; webpack 主程序webpack-dev-server ==&gt; webpack 执行环境// vuevue ==&gt; 这个就不用多说了// 可选url-loader ==&gt; 实际上是对 file-loader 的封装（见最后）webpack-merge ==&gt; 开发环境和生产环节的 webpaak 配置文件的配置合并 启动安装和配置完成以后，这个时候就可以来启动程序了，但是如果想在命令行直接使用类似 npm run dev 命令的话，就需要配置一下 package.json 文件，在 scripts 标签下设置 1234567// 设置 scripts 即可// --inline 自动刷新// --hot 热载// --port 设定端口（在端口被占用的情况下可以利用这个参数来指定，默认的为 8080）'scripts': { 'dev': 'webpack-dev-server --inline --hot'} 然后就可以使用 npm run dev 命令来启动服务了，如果在控制台中看到 1Project is running at http://localhost:8080/ 这个时候就表明启动成功了，可以访问 http://localhost:8080/ 来查看效果了，如果配置全部正确的话，就可以在浏览器中看到对应的内容了，修改内容直接保存，浏览器也会自动跟着刷新，如果在最后运行的时候发现控制台出现如下内容 12345[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available.Either pre-compile the templates into render functions, or use the compiler-included build.// ... 这个就主要涉及到了 Vue 的运行时构建和独立构建的区别，简单来说，就是在独立构建的时候可以使用用 template 选项，而在运行时构建则不行，只能通过模板来编译转成 render 函数，两者区别如下 独立构建包含模板编译器，运行时构建不包含模板编译器 模板编译器的作用就是将 template 选项编译成 render 函数，render 函数是渲染的关键 鉴于以上两点，使用运行时构建时，不能出现 template 选项 因为此时没有模板编译器，但是有一种情况除外，即 webpack + vue-loader 情况下单文件组件中出现 template 是可以的 使用 Vue-Cli 生成项目时，会提醒使用哪种构建方式，npm 包默认导出的是运行时构建 如果需要使用独立构建，需要在 Webpack 中配置 alias 目前暂时发现的两者的应用场景上的区别有 需要注意 Vue 实例化时的方式，运行时构建方式下实例化 Vue 时，不要出现 template 属性 index.html 中不要出现 template 或者是通过 vue-router 渲染的 route-view 以上区别讨论的场景均为使用 webpack + vue-loader 单文件组件下 解决办法也很简单，只需在 Webpack 配置中设置一下 Vue 的别名即可 12345resolve: { alias: { 'vue': 'vue/dist/vue.js' }} h =&gt; h(App)在 vuejs 中，可以把 h 函数仅是作为 createElement 函数的缩写，所以上述代码可以理解为 123render: function (createElement){ return createElement(app)} render 方法 12345678render: function (createElement) { return createElement( // tag name 标签名称 'h' + this.level, // 子组件中的阵列 this.$slots.default )} 也是 2.0 新增的函数，可以直接给绑定节点渲染一个 Vue 组件，如果在 1.x 的版本下，就应该使用 123456789new Vue({ el: '#app', components: { App }});// html&lt;div id='app'&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; .babelrc和 .bowerrc 是一样的原理，都是用来配置文件，只需要在根目录新建一个名为 .babelrc 文件，然后添加 1234{ 'presets': ['es2015', 'stage-0'], 'plugins': ['transform-runtime']} 就可以达到和上面一样的效果 url-loaderurl-loader 是对 file-loader 的上层封装，比如可以在 Webpack 中对图片的加载器进行配置 1234{ test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'} 这样一来，在小于 8K 的图片将直接以 base64 的形式内联在代码中，可以减少一次 HTTP 请求，所以在处理一般小图片的时候就可以使用 url-loader 来转为 base64，其他情况照常使用 file-loader webpack 中的 loader 和 pluginWebpack 是一个模块打包器（module bundler），提供了一个核心，核心提供了很多开箱即用的功能，同时它可以用 loader 和 plugin 来扩展，Webpack 常用配置包括 devtool、entry、output、module、resolve、plugins、externals 等，这里我们主要介绍 Webpack 常用的 loader 和 plugin Webpack 允许我们使用 loader 来处理文件，loader 是一个导出为 function 的 Node.js 模块，可以将匹配到的文件进行一次转换，同时 loader 可以链式传递 使用方式一般 loader 的使用方式分为三种，第一种，在 webpack.config.js 中配置（较多） 12345678910module.exports = { module: { rules: [ { test: /\\.txt$/, use: 'raw-loader' } ] }} 第二种，通过命令行参数方式 1webpack --module-bind 'txt=raw-loader' 第三种，通过内联使用 1import txt from 'raw-loader!./file.txt'; 一些比较常用的 loader 样式有 style-loader、css-loader、less-loader、sass-loader 等 文件有 raw-loader、file-loader 、url-loader 等 编译有 babel-loader、coffee-loader 、ts-loader 等 校验测试有 mocha-loader、jshint-loader 、eslint-loader 等 比如下面配置，可以匹配 .scss 的文件，分别经过 sass-loader、css-loader、style-loader 的处理 123456789101112131415module.exports = { module: { rules: [ { test: /\\.scss$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { sourceMap: true, modules: true } }, { loader: 'sass-loader', options: { sourceMap: true } } ], exclude: /node_modules/ } ] }} style-loader，将创建一个 style 标签将 CSS 文件嵌入到 HTML 中 css-loader，处理其中的 @import 和 url() sass-loader，转化 sass 为 CSS 文件，并且包一层 module.exports 成为一个 js module 其他一些相关 loader 介绍 vue-loader、coffee-loader、babel-loader 等可以将特定文件格式转成 JavaScript 模块 将其他语言转化为 JavaScript 语言和编译下一代 JavaScript 语言（ES6） file-loader、url-loader 可以处理（静态）资源 file-loader 可以复制和放置资源位置，并可以指定文件名模板，用 Hash 命名更好利用缓存 url-loader 可以将小于配置 limit 大小的文件转换成内敛 data url 的方式，减少请求 raw-loader 可以将文件以字符串的形式返回 imports-loader、exports-loader 等可以向模块注入变量或者提供导出模块功能，常见场景是 jQuery 插件注入 $，imports-loader?$=jQuery 禁用 AMD，imports-loader?define=false 等同于 var $ = require('jQuery') 和 var define = false; expose-loader 暴露对象为全局变量","link":"/2018/09/12/Vue/05/"},{"title":"JavaScript 中的事件","text":"所谓事件，说的就是用户或浏览器自身执行的某种动作，诸如 click、load、mouseover 等，事件处理程序响应某个事件的函数就叫事件处理程序（或事件侦听器） HTML 事件处理程序1&lt;input type=\"button\" value=\"click me\" onclick=\"alert(1)\"&gt; 在 HTML 中指定事件处理程序有个缺点，即 HTML 与 JavaScript 代码紧密耦合，如果要更换处理程序，就要改动两个地方 HTML 代码和 JavaScript 代码 DOM 0 级事件处理程序123btn.onclick = function () { // ...} 以这种方式添加的事件处理程序会在事件流的『冒泡阶段』被处理 1btn.onclick = null // 删除事件处理程序 DOM 2 级事件处理程序定义了两个方法 addEventListener() 和 removeEventListener()，它们接收三个参数，依次为要处理的事件名，做为事件处理程序的函数，布尔值（true 表示捕获阶段，false 表示冒泡阶段） 123btn.addEventListener('click', 'show', false)btn.removeEventListener('click', 'show', false) 普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个，几个需要注意的地方 eventName 的值均不含 on，例如注册鼠标点击事件 eventName 为 click 处理函数中的 this 依然指的是指当前 DOM 元素 通过 addEventListener 添加的事件处理程序，只能通过 removeEventListener 来删除（也就是说 addEventListener 添加的匿名函数将无法被删除） IE 事件处理程序123attachEvent() // 添加事件detachEvent() // 添加事件 接收相同的两个参数，事件处理程序的名称和事件处理程序的函数，不使用第三个参数的原因是 IE8 及更早版本只支持冒泡型事件，所以 attachEvent 添加的事件都会被添加到冒泡阶段 123btn.attachEvent('onclick', show)btn.detachEvent('onclick', show) 注意，通过 attachEvent 添加的事件第一个参数是 onclick 而非标准事件中的 click，它和 DOM 0 级事件处理程序的主要区别在于事件处理程序的『作用域』 采用 DOM 0 级处理方式，事件处理程序会在其所属元素的作用域内运行，而使用 attachEvent，事件处理程序会在全局作用域内运行，因此 this 等于 window 123456var btn = document.getElementById('btn')btn.attachEvent('onclick', function () { // 此处 this 是 window alert(this)}) 跨浏览器的事件处理程序事件对象 在触发 DOM 上的事件的时候都会产生一个对象，也就是事件对象 event，DOM 中的事件对象有以下一些比较常用的属性和方法 type 属性，用于获取事件的类型 target 属性，用于获取事件目标 stopPropagation() 方法，用于阻止事件冒泡 preventDefault() 方法，阻止事件的默认行为 兼容方法如下 12345678910111213141516171819202122232425262728293031323334353637383940414243var eventHandle = { // 添加 addEvent: function (el, type, fn) { if (el.addEventListener) { el.addEventListener(type, fn, false) } else if (el.attachEvent) { el.attachEvent('on' + type, fn) } }, // 删除 removeEvent: function (el, type, fn) { if (el.removeEventListener) { el.removeEventListener(type, fn, false) } else if (el.detachEvent) { el.detachEvent('on' + type, fn) } }, // 事件对象 getEvent: function (e) { return e ? event : window.event }, // 事件监听的元素 getElement: function (e) { return e.target || e.srcElement }, // 阻止冒泡 stopBubble: function (e) { if (e &amp;&amp; e.stopPropagation) { e.stopPropagation() } else { window.event.cancelBubble = true } }, // 阻止默认行为 stopDefault: function (e) { if (e &amp;&amp; e.preventDefault) { e.preventDefault() } else { window.event.returnValue = false } return false }} 关于 event event 代表事件的状态，例如触发 event 对象的元素、鼠标的位置及状态、按下的键等等 event 对象只在事件发生的过程中才有效 firefox 里的 event 跟 IE 里的不同，IE 里的是全局变量，随时可用，firefox 里的要用参数引导才能用，是运行时的临时变量，在 IE/Opera 中是 window.event，在 Firefox 中是 event，而事件的对象，在 IE 中是 window.event.srcElement，在 Firefox 中是 event.target，Opera 中两者都可用，比如下面两句效果是相同的 12345function a(e) { var e = e ? evt : ((window.event) ? window.event : null) // firefox 下 window.event 为 null, IE 下 event 为 null var e = e || window.event} 在 jQuery 当中阻止事件冒泡的方法如下 12345// 阻止事件冒泡e.stopPropagation()// 阻止事件默认行为e.preventDefault() return false 等效于同时调用 e.preventDefault() 和 e.stopPropagation() 事件委托使用事件委托技术能让你避免对特定的每个节点添加事件监听器，事件监听器是被添加到它们的父元素上，事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件，也就是利用冒泡的原理，把事件加到父级上，触发执行效果，可以提高性能，来看下面这个示例，我们需要在鼠标移入的过程当中触发每个 li 来改变它们的背景颜色 12345&lt;ul &gt; &lt;li&gt;111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt;&lt;/ul&gt; 12345678for(var i = 0; i &lt; li.length; i++) { li[i].onmouseover = function () { this.style.background = 'red' } li[i].onmouseout = function () { this.style.background = '' }} 利用循环可以达到我们的目的，但是如果说我们可能有很多个 li 用 for 循环的话就比较影响性能了（譬如有几十上百个 li），所以在这种情况下，我们可以尝试使用用事件委托的方式来进行实现 1234567891011121314151617ul.onmouseover = function (ev) { var ev = ev || window.event var target = ev.target || ev.srcElement if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red' }}ul.onmouseout = function (ev) { var ev = ev || window.event var target = ev.target || ev.srcElement if (target.nodeName.toLowerCase() == 'li') { target.style.background = '' }} 还有另外一个好处，就是新添加的元素还会有之前的事件，比如我们要实现一个点击 btn 动态的添加 li 的效果，相比利用 for 循环来实现，利用事件委托机制也可以达成我们的目标 12345678910111213141516171819202122ul.onmouseover = function (ev) { var ev = ev || window.event var target = ev.target || ev.srcElement if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red' }}ul.onmouseout = function (ev) { var ev = ev || window.event var target = ev.target || ev.srcElement if (target.nodeName.toLowerCase() == 'li') { target.style.background = '' }}btn.onclick = function () { iNow++ var li = document.createElement('li') li.innerHTML = iNow oUl.appendChild(li)} 事件流，冒泡与捕获所谓事件流，即为了描述事件的传播而规定的一个事件传播方向，分为两个阶段，事件捕获和事件冒泡，正常情况下，事件先从最外层的元素向内捕获，然后从最内层的元素往外层传播，事件的触发一定是按照事件流的顺序而来 DOM 0 级1234567btn.onclick = function () { alert(1)}btn.onclick = function () { alert(2)} 只能监听冒泡阶段，如果给同一个对象，同一个事件名绑定多个监听，后面的会覆盖掉之前的（这里需要注意 this 指向的是触发事件的 DOM 元素），IE 6/7/8 中事件只能冒泡到 document，不能继续冒泡到 window 对象上 所以一般不能给 window 添加 click 事件 DOM 2 级123btn.addEventListener('click', function () { // ...}, false) 最后一个参数，true 表示捕获阶段，而 false 则表示为冒泡阶段，几个注意事项 所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到 window 对象 如果不是最内层的元素同时绑定有捕获和冒泡事件，改变事件绑定的先后顺序，不会影响执行结果，依然是先捕获后冒泡 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行 this 指向的是触发事件的元素（也就是事件传播到的这个元素） 一个比较完整的案例，页面布局如下 1234567&lt;div id='box1'&gt; &lt;div id='box2'&gt; &lt;div id='box3'&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 测试相关代码如下 12345678910111213141516171819202122232425262728293031box2.onclick = function () { alert('A')}box2.onclick = function () { alert('B')}box2.addEventListener('click', function () { alert('C')}, false)box2.addEventListener('click', function () { alert('D')}, false)box2.addEventListener('click', function () { alert('E')}, true)box2.addEventListener('click', function () { alert('F')}, true)box3.addEventListener('click', function () { alert('G')}, false)box3.addEventListener('click', function () { alert('H')}, true) 执行后的结果依次为 E ==&gt; F ==&gt; G ==&gt; H ==&gt; B ==&gt; C ==&gt; D 自定义事件我们不仅可以分配事件处理程序，还可以从 JavaScript 生成事件，不仅可以生成出于自身目的而创建的全新事件，还可以生成例如 click 和 mousedown 等内建事件，内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类，根是内建的 Event 类，我们可以像下面这样来创建 Event 对象 1event = new Event(name, options) name，事件类型，表示所创建事件的名称，可以是像 click 这样的字符串，或者是我们自定义的类似 my-event 这样的参数 options，字典类型的参数，接受以下字段 bubbles，可选，布尔类型，默认值为 false，表示该事件是否冒泡 cancelable，可选，布尔类型，默认值为 false，表示该事件能否被取消，如果为 true，那么默认行为就会被阻止 composed，可选，布尔类型，默认值为 false，指示事件是否会在影子 DOM 根节点之外触发侦听器 下面我们来创建一个支持冒泡且不能被取消的 look 事件的示例 123456789var myEvent = new Event('look', { bubbles: true, cancelable: false})document.dispatchEvent(myEvent)// 事件可以在任何元素触发，不仅仅是 documentmyDiv.dispatchEvent(myEvent) 但是这种方式存在一定的局限性，那就是无法传递参数，如果我们想要传递参数的话，则可以使用 CustomEvent，从技术上讲 CustomEvent 和 Event 一样，除了一点不同，即在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 detail，具体用法和上面的 Event 对象十分类似，语法如下 1var myEvent = new CustomEvent(eventname, options) 其中 options 可以是 1234567{ detail: { ... }, bubbles: true, // 是否冒泡 cancelable: false // 是否取消默认事件} 其中 detail 可以存放一些初始化的信息，可以在触发的时候调用，其他属性就是定义该事件是否具有冒泡等等功能，下面是一个简单的示例 123456789el.addEventListener('hello', function(e) { console.log(e.detail.name) // zhangsan})el.dispatchEvent(new CustomEvent('hello', { detail: { name: 'zhangsan' }})) 关于 CustomEvent 有一个坑就是，如果需要在事件处理函数（addEventListener）当中使用 event.preventDefault() 的话，则需要在 CustomEvent 当中指定 cancelable: true，否则 event.preventDefault() 调用将会被忽略，如下 12345678el.dispatchEvent(new CustomEvent('hello', { // 没有这个标志，preventDefault 将不起作用 cancelable: true}))el.addEventListener('hello', function (event) { // 如果这里需要使用 event.preventDefault() 的话}) 另外还有一点关于 CustomEvent 需要注意的就是，事件中的事件是同步的，通常事件是在队列中处理的，也就是说如果浏览器正在处理 onclick，这时发生了一个新的事件，例如鼠标移动了，那么它会被排入队列，相应的 mousemove 处理程序将在 onclick 事件处理完成后被调用 值得注意的例外情况就是，一个事件是在另一个事件中发起的，例如使用 dispatchEvent，这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序，例如在下面的代码中，menu-open 事件是在 onclick 事件执行过程中被调用的，它会被立即执行，而不必等待 onclick 处理程序结束 12345678910button.onclick = function () { alert(1) button.dispatchEvent(new CustomEvent('menu-open', { bubbles: true })) alert(2)}// 在 1 和 2 之间触发document.addEventListener('menu-open', () =&gt; alert('nested')) 输出顺序为 1 ==&gt; nested ==&gt; 2，但是这里需要注意的是，其中的配置项 bubbles: true 是必须的，否则无法触发，如果想让 onclick 不受 menu-open 或者其它嵌套事件的影响，优先被处理完毕，那么我们就可以将 dispatchEvent 放在 onclick 末尾，或者将其包装到零延迟的 setTimeout 中 1234567button.onclick = function () { alert(1) setTimeout(() =&gt; menu.dispatchEvent(new CustomEvent('menu-open', { bubbles: true }))) alert(2)} 现在 dispatchEvent 在当前代码执行完成之后异步运行，包括 mouse.onclick，因此事件处理程序是完全独立的，输出顺序变成 1 ==&gt; 2 ==&gt; nested 总结 DOM 0 级添加到冒泡阶段 DOM 0 级同名事件会发生覆盖 true 表示捕获阶段，false 表示冒泡阶段，会先执行捕获 DOM 2 级同名事件不会覆盖，按先后顺序执行 DOM 2 级最内层的元素不区分冒泡和捕获，按先后顺序执行（无论是 DOM 0 级还是 DOM 2 级） 通用的 Event(name, options) 构造器接受任意事件名称和一个字典类型的参数（bubbles/cancelable/composed） 对于自定义事件，我们应该使用 CustomEvent 构造器，它有一个名为 detail 的附加选项可以用来传递参数，然后所有处理程序可以以 event.detail 的形式来访问它 参考 Event CustomEvent 事件参考 事件简介","link":"/2016/12/12/JavaScript/01/"},{"title":"JavaScript 中的原型和原型对象","text":"我们首先先来看一张图，如下 关于 JavaScript 中的原型，本质上来说其实就是 prototype、__proto__ 和 constructor 的三者之间的关系，上图第一眼看上去感觉十分复杂，但是其实说的也就是两句话的事，如下 12function Foo() { }var f1 = new Foo() 下面我们就来逐一分析他们之间的关系 实例对象通过构造函数的 new 操作创建的对象是实例对象，可以用一个构造函数，构造多个实例对象 123456function Foo() { }var f1 = new Foovar f2 = new Fooconsole.log(f1 === f2) // false prototype构造函数有一个 prototype 属性，指向『实例对象的原型对象』，通过同一个构造函数实例化的多个对象具有相同的原型对象，经常使用原型对象来实现继承 1234567891011function Foo() { }Foo.prototype.a = 1var f1 = new Foovar f2 = new Fooconsole.log(Foo.prototype.a) // 1console.log(f1.a) // 1console.log(f2.a) // 1 proto实例对象有一个 __proto__ 属性，指向『该实例对象对应的原型对象』（需要注意，实例对象也是对象） 12345function Foo() { }var f1 = new Fooconsole.log(f1.__proto__ === Foo.prototype) // true 不过需要注意是，如果实例对象 f1 是通过 Object.create() 创建的话，结果就不一样了 123456function Foo() { }var f1 = Object.create(Foo)console.log(f1.__proto__ === Foo.prototype) // falseconsole.log(f1.__proto__ === Foo) // true constructor原型对象有一个 constructor 属性，指向『该原型对象对应的构造函数』 123function Foo() { }console.log(Foo.prototype.constructor === Foo) // true 由于实例对象可以继承原型对象的属性，所以实例对象也拥有 constructor 属性，同样指向原型对象对应的构造函数 1234function Foo() { }var f1 = new Fooconsole.log(f1.constructor === Foo) // true constructor 属性返回对创建此对象的数组函数的引用，它是不会影响任何 JavaScript 的内部属性的 看下面一段代码 12345function Foo() { }Foo.prototype.constructor === Foo // true var a = new Foo()a.constructor === Foo // true 看起来 a.constructor === Foo 为 true 则意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样，实际上，.constructor 引用同样被委托给了 Foo.prototype，而 Foo.prototype.constructor 默认指向 Foo，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性 如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性，思考下面的代码 12345678function Foo() { }Foo.prototype = {} // 创建一个新原型对象，这个操作相当于重写了函数的原型，不推荐这么操作var a1 = new Foo()a1.constructor === Foo // false a1.constructor === Object // true a1 并没有 .constructor 属性，所以它会委托 prototype 链上的 Foo.prototype，但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype，这个对象有 .constructor 属性，指向内置的 Object() 函数，当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举的属性 1234567891011121314function Foo() { }// 创建一个新原型对象Foo.prototype = {}// 需要在 Foo.prototype 上修复丢失的 .constructor 属性 // 新对象属性起到 Foo.prototype 的作用 Object.defineProperty(Foo.prototype, 'constructor', { enumerable: false, writable: true, configurable: true, // 让 .constructor 指向 Foo value: Foo}) 实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用，.constructor 并不是一个不可变属性，它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改），此外，你可以给任意 prototype 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值 所以这是一个非常不可靠并且不安全的引用，通常来说要尽量避免使用这些引用，但是有的时候，为了将实例的构造器的原型对象暴露出来，比如写了一个插件，别人得到的都是你实例化后的对象，如果想扩展下对象，就可以用 instance.constructor.prototype 去修改或扩展原型对象 1234567891011121314151617var a, b(function () { function A(arg1, arg2) { this.a = 1 this.b = 2 } A.prototype.log = function () { console.log(this.a) } a = new A() b = new A()})()a.log() // 1b.log() // 1 因为 A 在闭包里，所以现在我们是不能直接访问 A 的，那如果我们想给类 A 增加新方法，那么就可以通过访问 constructor 就可以了 1234567// a.constructor.prototype 在 chrome 和 firefox 中可以通过 a.__proto__ 直接访问a.constructor.prototype.log2 = function () { console.log(this.b)}a.log2() // 2b.log2() // 2 或者我们想知道 a 的构造函数有几个参数？ 1a.constructor.length 或者再复杂点，我想知道 a 的构造函数的参数名是什么 12a.constructor.toString().match(/\\(.*\\)/).pop().slice(1, -1).split(',')// ['arg1', 'arg2'] 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，以此类推，一直找到最顶层为止 12345678910function Foo() { }Foo.prototype.name = 'zhangsan'var f1 = new Foof1.name = 'lisi'console.log(f1.name) // lisidelete f1.nameconsole.log(f1.name) // zhangsan 在上面的例子中，我们给实例对象 f1 添加了 name 属性，当我们打印 f1.name 的时候，结果自然为 lisi，但是当我们删除了 f1 的 name 属性时，再次读取 f1.name 的时候，就会发现在 f1 对象中已经找不到 name 属性了，所以就会从 f1 的原型，也就是 f1.__proto__ 对应的 Foo.prototype 当中去进行查找，所幸的是我们找到了 name 属性，结果为 zhangsan 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是 1234var obj = new Object()obj.name = 'zhangsan'console.log(obj.name) // zhangsan 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype，那 Object.prototype 的原型又是指向哪里的呢？我们可以打印一下 123Object.prototype.__proto__ // nullObject.prototype.__proto__ === null // true null 表示没有对象，即该处不应该有值，所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思，所以查找属性的时候查到 Object.prototype 就可以停止查找了，这也就是开头部分的图片当中所表达的这个意思，来看下面这个示例 12345678910111213141516171819202122232425262728var a = { x: 1, y: { z: 2 }}var b = {}b.__proto__ = a// a 和 b 都是对象（通过new Object() 生成，这里是简写）// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），所以 b.x 是不存在的// 然后原则上应该去 Object.prototype 上查找，但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找// 所以 b.x 为 1，b.y 为 { z: 2 }console.log(a.x)console.log(b.x)// 然后把 b.x 重新赋值为 22// 因为是基本类型，所以 a.x 是不变的b.x = 22console.log(a.x)console.log(b.x)// 这个同上面那个类似// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址// 其中一个变化的话自然会引起另外一个变化b.y.z = 33console.log(a.y.z)console.log(b.y.z) 自定义对象123456789101112131415161718192021// 1. 默认情况下function Foo() { }var foo = new Foo()Foo.prototype.__proto__ === Object.prototype // true 理由同上// 2. 其他情况 // 第一种情况function Bar() { } // 这时我们想让 Foo 继承 BarFoo.prototype = new Bar()Foo.prototype.__proto__ === Bar.prototype // true// 第二种情况// 我们不想让 Foo 继承谁，但是我们要自己重新定义 Foo.prototype（实际过程当中不建议这样操作）Foo.prototype = { a: 10, b: -10}// 这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 Foo.prototype.__proto__ === Object.prototype // true 以上两种情况都等于完全重写了 Foo.prototype，所以 Foo.prototype.constructor 也跟着改变了，于是乎 constructor 这个属性和原来的构造函数 Foo() 也就切断了联系 基于原型的一个实例最后我们来看一个具体的实例和它的几个变种方式来巩固一下之前的知识点，如下 12345678910111213141516function obj(name) { if (name) { this.name = name } return this}obj.prototype.name = 'name2'var a = obj('name1')var b = new objconsole.log(a.name) // name1console.log(window.name) // name1console.log(b.name) // name2 一般函数直接调用，默认 this 指向全局 window/global，通过 obj('name1') 调用，返回 this 引用，并传递给 a，此时 a 等于 window 对象，即可输出 name 值，new 操作，在没有参数的情况下 new obj 等价于 new obj() ，实例化一个对象，这时 this 指向 obj，要拿到 b.name 的值，需要保证 name 属性存在 属性查找原则是先查找当前实例有没有属性，如果有就直接使用，如果没有，就到原型上去找，在没有就接着原型链一步一步往上，这里为了和 a.name 作属性区别，使用了 if (name) 有条件的构建 this 的属性 name，所以，现在 name 属性提供给 a 使用，原型上的 name 提供给 b 使用 实例变体一123456789101112131415161718192021// 去掉 if 判断function obj(name) { // if(name) { this.name = name // } return this}obj.prototype.name = 'name2'var a = obj('name1')var b = new objconsole.log(a.name) // name1console.log(window.name) // name1console.log(b.name) // undefined// 这时，b 实例已经有属性 name，但是参数 name 是为 undefined 的（因为没有传递参数）// 所以这时可以把 this.name 属性删掉，这样就能去原型找 name 了delete b.nameconsole.log(b.name) // name2 实例变体二 试试传个参数12345678910111213function obj(name) { this.name = name return this}obj.prototype.name = 'name2'var a = obj('name1')var b = new obj('myname')console.log(a.name) // name1console.log(window.name) // name1console.log(b.name) // myname 总结记住以下几点 函数（Function 也是函数）是 new Function 的结果，所以函数可以作为实例对象，其构造函数是 Function()，原型对象是 Function.prototype 对象（函数也是对象）是 new Object 的结果，所以对象可以作为实例对象，其构造函数是 Object()，原型对象是 Object.prototype Object.prototype 的原型对象是 null __proto__ 是每个对象都有的一个属性，而 prototype 是函数才会有的属性 __proto__ 指向的是构造该对象的构造函数的原型，而 prototype 指向的，是以当前函数作为构造函数构造出来的对象的原型对象 __proto__ 并不存在于你正在使用的对象中，实际上，它和其他的常用函数（toString()、isPrototypeOf()，等等）一样，存在于内置的 Object.prototype 中（它们是不可枚举的） __proto__ 看起来很像一个属性，但是实际上它更像一个 getter/setter __proto__ 的实现大致上是类似下面这样的 12345678910Object.defineProperty(Object.prototype, '__proto__', { get: function () { return Object.getPrototypeOf(this) }, set: function (o) { // ES6 中的 setPrototypeOf() Object.setPrototypeOf(this, o) return o }}) 明确以下三点 通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性 Object.prototype 这个对象，它的 __proto__ 指向的是 null 通过 Object.create(null) 创建出来的对象没有 __proto__，如下 123var obj = Object.create(null)obj.__proto__ // undefined 参考 JavaScript 中 proto 和 prototype 的区别和关系？ JavaScript 中 Prototype、proto、Constructor、Object、Function 关系介绍 一张图理解 prototype、proto 和 constructor 的三角关系 proto VS. prototype in JavaScript JavaScript 面向对象 全面理解面向对象的 JavaScript","link":"/2017/04/08/JavaScript/09/"},{"title":"Object.defineProperty()","text":"Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象 12345// obj 需要定义属性的对象// prop 需定义或修改的属性的名字// descriptor 将被定义或修改的属性的描述符// return 返回传入函数的对象，即第一个参数 objObject.defineProperty(obj, prop, descriptor) 对象里目前存在的属性描述符有两种主要形式『数据描述符』和『存取描述符』 数据描述符是一个拥有可写或不可写值的属性 存取描述符是由一对 getter-setter 函数功能来描述的属性 描述符必须是两种形式之一，不能同时是两者，并且数据描述符和存取描述符不能混合使用，在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读，但是从 ES5 开始，所有属性都具备了属性描述符 12345678910111213141516var myObject = { a: 2}Object.getOwnPropertyDescriptor(myObject, 'a')/*{ value: 2, writable: true, enumerable: true, configurable: true}*/ 如你所见，这个普通的对象属性对应的属性描述符（也被称为数据描述符，因为它只保存一个数据值），不仅仅只有一个 2，它还包含了另外三个特性，writable（可写），enumerable（可枚举），configurable（可配置），在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty() 来添加一个新属性或者修改一个已有属性（如果它是 configurable），并对特性进行设置 12345678910var myObject = {}Object.defineProperty(myObject, 'a', { value: 2, writable: true, configurable: true, enumerable: true})myObject.a // 2 我们使用 defineProperty() 给 myObject 添加了一个普通的属性并显式的指定了一些特性，然而，一般不会使用这种方式，除非你想修改属性描述符 默认情况下，使用 Object.defineProperty() 增加的属性值是不可改变的 Writablewritable 决定是否可以修改属性的值 123456789101112var myObject = {}Object.defineProperty(myObject, a, { value: 2, writable: false, // 不可写 configurable: true, enumerable: true})myObject.a = 3myObject.a // 2 如你所见，我们对于属性值的修改静默失败（silently failed），如果在严格模式（use strict）下，还会导致出错，简单来说，你可以把 writable: false 看作是属性不可改变，相当于空操作的 setter（后面会提到） Configurable只有属性是可配置的，就可以使用 defineProperty() 方法来修改属性描述符 123456789101112131415161718192021222324var myObject = { a: 2}myObject.a = 3myObject.a // 3Object.defineProperty(myObject, 'a', { value: 4, writable: true, configurable: false, // 不可配置 enumerable: true})myObject.a // 4myObject.a = 5myObject.a // 5Object.defineProperty(myObject, 'a', { value: 6, writable: true, configurable: true, enumerable: true}) // TypeError 最后一个 defineProperty() 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错 注意，把 configurable 修成为 false 是单向操作，无法撤销 但是有一个例外，即便属性是 configurable: false ，我们还是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true 除了无法修改，configurable: false 还会禁止删除这个属性 12345678910111213141516171819202122var myObject = { a: 2}myObject.a // 2delete myObject.amyObject.a // undefinedObject.defineProperty(myObject, 'a', { value: 2, writable: true, configurable: false, enumerable: true})myObject.a // 2delete myObject.amyObject.a // 2 如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的，在本例中，delete 只用来直接删除对象的（可删除）属性，如果对象的某个属性是某个对象或者函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象或者函数就可以被垃圾回收（是一个删除对象属性的操作，仅此而已） Enumerable这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for-in 循环，如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它，相对地，设置成 true 就会让它出现在枚举中，如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable: false 简单总结一下 Writable 如果在 Object.defineProperty() 中定义了 writable: false，重新给对象赋值的话是无效的 严格模式（use strict）下，还会导致出错 Configurable 如果在 Object.defineProperty() 中定义了 configurable: false，可以重新给对象赋值 但是不管是不是处于严格模式，不能再重新使用 Object.defineProperty 来重新配置属性，这样的操作会导致报错 把 configurable 修成为 false 的操作是单向操作，是无法撤销的！（同时也会禁止删除这个属性） 但是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true（同样是单向操作） Enumerable 如果在 Object.defineProperty() 中定义了 enumerable: false，属性就不会出现在对象的属性枚举中 比如说 for-in 循环，虽然仍然可以正常访问它 不变性有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现，很重要的一点是，所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性，如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的 123myImmutableObject.foo // [1, 2, 3]myImmutableObject.foo.push(4)myImmutableObject.foo // [1, 2, 3, 4] 对象常量结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性（不可修改、重定义或者删除） 1234567var myObject = {}Object.defineProperty(myObject, 'FAVORITE_NUMBER', { value: 42, writable: false, configurable: false}) 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions() 12345678var myObject = { a: 2}Object.preventExtensions(myObject)myObject.b = 3myObject.b // undefined 在非严格模式下，创建属性 b 会静默失败，在严格模式下，将会抛出 TypeError 错误 密封Object.seal() 会创建一个密封（seal）的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions() 并把所有现有属性标记为 configurable: false，所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值） 冻结Object.freeze() 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal() 并把所有数据访问属性标记为 writable: false，这样就无法修改它们的值 [[Get]]先看以下代码 12345var myObject = { a: 2}myObject.a // 2 myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样，在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用，[[Get]]()），对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值 然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为（遍历可能存在的 [[Prototype]] 链，也就是原型链），如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined， 12345var myObject = { a: 2}myObject.b // undefined 注意，这种方法和访问变量时是不一样的，如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常， 1234567var myObject = { a: undefined } myObject.a // undefined myObject.b // undefined 从返回值的角度来说，这两个引用没有区别 — 它们都返回了 undefined，然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理，由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以 [[Get]] 操作返回了 undefined [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作，[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素） 属性是否是访问描述符？如果是并且存在 setter 就调用 setter 属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常 如果都不是，将该值设置为属性的值 Getter 和 Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取，在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上，getter 是一个隐藏函数，会在获取属性值时调用，setter 也是一个隐藏函数，会在设置属性值时调用 当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为访问描述符（和数据描述符相对），对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性 1234567891011121314151617181920var myObject = { // 给 a 定义一个 getter get a() { return 2 }}Object.defineProperty( myObject, // 目标对象 'b', // 属性名 { // 描述符 get: function () { // 给 b 设置一个 getter return this.a * 2 }, enumerable: true // 确保 b 会出现在对象的属性列表中 })myObject.a // 2myObject.b // 4 不管是对象文字语法中的 get a() { ... }，还是 defineProperty() 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值 123456789var myObject = { // 给 a 定义一个getter get a() { return 2 }}myObject.a = 3myObject.a // 2 由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误，而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的 为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作，通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为） 12345678910111213var myObject = { // 给 a 定义一个 getter get a() { return this._a_ }, // 给 a 定义一个 setter set a(val) { this._a_ = val * 2 }}myObject.a = 2myObject.a // 4 如何监听对象和数组的属性改变最后我们再来看一个稍微有些扩展的内容，那就是如何监听对象和数组的属性改变，也算是一个老生常谈的问题，下面我们就来看看如何实现 监听对象属性改变其实我们实现的方式主要依赖的还是上面介绍到的 Object.defineProperty，它可以接受的第三个参数可以取 get/set 并各自对应一个 getter/setter 的方法，这样一来在对象属性改变的时候我们就可以知道属性的值变化了 123456789101112131415var a = { obj: 0 }Object.defineProperty(a, 'obj', { get: function () { console.log('get：' + obj) return obj }, set: function (value) { obj = value console.log('set:' + obj) }})a.obj = 2 // set: 2console.log(a.obj) // get：2 但是这种方式有个缺点就是在 IE8 及更低版本 IE 是无法使用的，因为这个特性是没有 polyfill 的，所以无法在不支持的平台实现，但是随着版本的更新，现在我们可以使用 ES6 提供的 Proxy 代理来处理，本质原理都是一样的，都是利用 get/set 来监听对象属性的变化 1234567891011121314var user = {}var proxy = new Proxy(user, { get(target, property) { return target[property] }, set(target, property, value) { target[property] = value }})proxy.name = 'zhangsan'console.log(user)// {name: 'zhangsan'} 监听数组的变化监听数组的变化相对来说就没有监听对象那么轻松了，因为没有对应的 get/set 方法来供我们使用，但是我们可以定义一个新的数组，然后让其继承原生的 Array，然后重写其中我们需要监听的方法即可（pop，push 等），如下是 ES6 当中的实现方式 12345678910111213141516171819class NewArray extends Array { constructor(...args) { // 调用父类 Array 的 constructor super(...args) } push(...args) { console.log(`监听到数组变化`) // 调用父类方法 return super.push(...args) }}let arr = [1, 2]let newArr = new NewArray(...arr)console.log(newArr) // [1, 2]newArr.push(3) // 监听到数组变化console.log(newArr) // [1, 2, 3] 关于 ES5 以下实现上面我们介绍了 ES6 当中的数组监听方法的实现，那么 ES6 以下还能实现吗？这里就需要注意了，在 ES5 及以下的 JavaScript 因为无法完美的继承数组，所以虽然可以实现，但是是存在一定缺陷的，因为 Array 构造函数执行时不会对传进去的 this 做任何处理，不止 Array，String，Number，Regexp，Object 等等 JavaScript 的内置类都不行 数组其响应式的 length 属性以及内部的 [[class]] 属性我们无法在 JavaScript 层面实现，这就导致我们无法去用任何一个对象来模仿一个数组，但是可以使用非标准属性 __proto__ 来实现，如下 123456789101112131415161718192021// 首先获取 Array 原型const oldMethod = Object.create(Array.prototype)const newMethod = []['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method =&gt; { // 在 newMethod 上进行方法的重写 // 这里需要注意的是重写的方法是定义在 newMethod 的属性上而不是其原型属性（newMethod.__proto__ 没有改变） newMethod[method] = function () { console.log(`监听到数组的变化`) return oldMethod[method].apply(this, arguments) }})let list = [1, 2]// 将需要监听的数组的原型指针指向我们重新定义的新对象list.__proto__ = newMethodlist.push(3)// 如果不设定指向，则默认使用原生的方法let list2 = [1, 2]list2.push(3) 参考 《You Don’t Know JavaScript》 《JavaScript 高级程序设计》 MDN - Object.defineProperty()","link":"/2017/05/02/JavaScript/12/"},{"title":"Function.prototype.bind()","text":"要想改变被调用函数的上下文，可以使用 call 或 apply 方法，但如果重复使用就会很不方便，因为每次都要把上下文对象作为参数传递，而且还会使代码变得不直观，针对这种情况，我们可以使用 bind 方法来永久地绑定函数的上下文，使其无论被谁调用，上下文都是固定的 基本语法bind 方法的定义见 ECMAScript 15.3.4.5 Function.prototype.bind() ，使用方式如下 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数，bind 返回的绑定函数也能使用 new 操作符创建对象（这种行为就像把原函数当成构造器），提供的 this 值被忽略，同时调用时的参数被提供给模拟函数，bind 方法与 call、apply 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数 还可以写成 fn.bind(obj, arg1)(arg2) 一句话概括就是，该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 bind 方法的第一个参数作为 this，传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数 12345678910111213141516171819202122var someuser = { name: 'abc', func: function () { console.log(this.name) }}var foo = { name: 'foobar'}foo.func = someuser.funcfoo.func() // 输出 foobar foo.func1 = someuser.func.bind(someuser)foo.func1() // 输出 abc func = someuser.func.bind(foo)func() // 输出 foobar func2 = funcfunc2() // 输出 foobar 上面代码直接将 foo.func 赋值为 someuser.func，调用 foo.func() 时，this 指针为 foo，所以输出结果是 foobar，foo.func1 使用了 bind 方法，将 someuser 作为 this 指针绑定到 someuser.func，调用 foo.func1() 时，this 指针为 someuser，所以输出结果是 abc 全局函数 func 同样使用了 bind 方法，将 foo 作为 this 指针绑定到 someuser.func，调用 func() 时，this 指针为 foo，所以输出结果是 foobar，而 func2 直接将绑定过的 func 赋值过来，与 func 行为完全相同 使用 bind 绑定参数表bind 方法还有一个重要的功能，那就是绑定参数表，如下例所示 1234567891011var person = { name: 'foo', says: function (act, obj) { console.log(this.name + ' ' + act + ' ' + obj) }}person.says('loves', 'bar') // 输出 foo loves bar fooLoves = person.says.bind(person, 'loves')fooLoves('you') // 输出 foo loves you 可以看到，fooLoves 将 this 指针绑定到了 person，并将第一个参数绑定到 loves，之后在调用 fooLoves 的时候，只需传入第三个参数，这个特性可以用于创建一个函数的捷径，之后我们可以通过这个捷径调用，以便在代码多处调用时省略重复输入相同的参数，也就是下面会说到的 currying 理解 bind尽管 bind 很优美，还是有一些令人迷惑的地方，例如下面的代码 12345678910111213141516var someuser = { name: 'abc', func: function () { console.log(this.name) }}var foo = { name: 'foobar'}func = someuser.func.bind(foo)func() // 输出 foobar func2 = func.bind(someuser)func2() // 输出 foobar 全局函数 func 通过 someuser.func.bind 将 this 指针绑定到了 foo，调用 func() 输出了 foobar ，我们试图将 func2 赋值为已绑定的 func 重新通过 bind 将 this 指针绑定到 someuser 的结果， 而调用 func2 时却发现输出值仍为 foobar， 即 this 指针还是停留在 foo 对象上，这是为什么呢？要想解释这个现象，我们必须了解 bind 方法的原理，让我们看一个 bind 方法的简化版本（不支持绑定参数表） 123someuser.func.bind = function(self) { return this.call(self)} 假设上面函数是 someuser.func 的 bind 方法的实现，函数体内 this 指向的是 someuser.func，因为函数也是对象，所以 this.call(self) 的作用就是以 self 作为 this 指针调用 someuser.func 123456789// 将 func = someuser.func.bind(foo) 展开func = function() { return someuser.func.call(foo) }// 再将 func2 = func.bind(someuser) 展开func2 = function() { return func.call(someuser)} 从上面展开过程我们可以看出，func2 实际上是以 someuser 作为 func 的 this 指针调用了 func，而 func 根本没有使用 this 指针，所以第二次 bind 是没有效果的 bind 与 currying比如我们有一个函数 123function add(a, b, c) { return a + b + c} add 函数的作用是把参数 a, b, c 进行拼接（或者说相加），但是有的时候不需要一次把这个函数都调用完成，而是调用一次把前两个参数传完了以后，然后得到了这样的一个函数，再去调用，并且每次传入第三个值 1234// 由于我们不需要改变它的 this，所以随便传入一个 undefined/null ，但是我们提供了额外的参数 100var func = add.bind(null, 100)func(1, 2) // 103 然后我们拿到这样一个 bind 函数以后，相当于这个 100 就会固定赋值给第一个参数，也就是这里的 a 参数， 然后在调用的时候传入 1 和 2 参数，1 和 2 就会分别给 b 和 c，所以，最后的结果为 103 像这样的使用方式，我们就可以称之为函数的柯里化应用（关于柯里化的详细内容，在闭包章节当中会详细介绍，可以参考 函数的柯里化） bind 与 new123456789function foo() { this.b = 100 return this.a}var func = foo.bind({ a: 1 })func() // 1new func() // {b: 100} 我们声明了一个全局变量 b，并且把它的值赋为 100，然后返回全局变量 a，这样我们直接调用的话，那么 this 就会指向 bind 这样的一个参数，所以 return this.a 就会返回 1，如果使用了 new，那么针对于 ruturn，如果不是对象，将会把 this 做为返回值，并且 this 会被初始化为默认的一个空对象，这个对象的原型为 foo.prototype 所以说，我们用 new 去调用的话，这种情况下，即使我们使用了 bind 方法，但是这个 this 依然会指向没有 bind 的时候所指向的（正常状态），这样一个空对象的 b 属性会被赋值为 100，然后整个这个对象会做为返回值返回，所以就会忽略这样一个 return bind 实现最后我们再来尝试一下手动的实现 bind 方法，通过上文的了解我们可以发现，其实要实现 bind 就是实现以下功能 一个是绑定函数里面的 this（或者说改变函数里面的 this 指向） 另一个就是把函数拆分为不同的子函数，即柯里化功能 还有就是在 new 调用的时候，忽略掉 bind 的作用（通过 instanceof 判断函数是否通过 new 调用，来决定绑定的 Context） 其实在使用 bind 的时候，无非就分为两种情况，一种是直接调用，另一种就是 new 调用，如下所示 12345678910function foo(c) { this.b = 100 console.log(c) return this.a}var func = foo.bind({a: 1}, 20)func() // 20 1new func() // 20 {b: 100} 先来看一个简单的实现方式 12345678910Function.prototype.bind = Function.prototype.bind || function (context) { // 保存 this const self = this // 保存第一部分参数（拆分） const args = Array.prototype.slice.call(arguments, 1) return function () { // 合并参数（实现 currying 功能） return self.apply(context, args.concat(Array.prototype.slice.call(arguments))) }} 然后再来看一个较为完善的实现，采用了 ES6 的方式来进行实现，避免了使用 slice 去截取参数等一系列操作 1234567891011Function.prototype.myBind = function (oThis, ...args) { const thisFn = this let fToBind = function (...params) { // 判断是否通过 new 调用，如果是 new 调用就绑定到 this 上，否则就绑定到传入的 oThis 上 const context = this instanceof fToBind ? this : Object(oThis) // 老规矩，利用 apply 绑定 this 指向并且传递参数 return thisFn.apply(context, ...args, ...params) } fToBind.prototype = Object.create(thisFn.prototype) return fToBind} 再来对比看一下完整的实现方式，摘选自 MDN 123456789101112131415161718192021222324252627282930313233343536373839404142if (!Function.prototype.bind) { // 传入的 oThis 就是 foo.bind({a: 1}, 20) 中传入的对象 {a: 1} Function.prototype.bind = function (oThis) { if (typeof this !== \"function\") { throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\") } // 调用数组方法，剔除掉第一个参数，得到剩余参数 var aArgs = Array.prototype.slice.call(arguments, 1), // 这里的 this 指向函数对象 foo fToBind = this, fNOP = function () { }, // 最后返回的就是这个对象，其实就是 fToBind.apply() // 在不调用 func 的情况下，func 本质就是返回的 apply() 函数 fBound = function () { // 这里的 this 指的是调用 bind 后 func 的执行环境 // 第一点，见最后 return fToBind.apply(this instanceof fNOP ? this : oThis, // 这里的 arguments 和上面的不一样，这里是 func() 的执行环境 // 比如 foo.bind({a: 1}, 20) 中剩余的参数 20 和调用 func(b, c) 时的参数 b 和 c // 这里就利用 aArgs.concat() 连接了起来，实现了柯里化的功能 // 单单执行 bind 的时候是空数组（类数组对象），因为 arguments 是指向 实参 对象的引用 // 只有在函数调用的时候，传入了实参以后，才会有 arguments 对象 aArgs.concat(Array.prototype.slice.call(arguments))) } // 第二点，见最后 fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound }} 比较好理解的地方都直接标记在注释当中了，现在就剩下比较饶的两点，一个一个来看，简单来说就是分为以下两种情况，第一种就是直接调用的情况 正常调用的时候，即 func()，此时 func() 中的 this 是指向 window 的，所以 this instanceof fNOP 为 false 此时执行的是 fToBind.apply(oThis, ...)，这里的 oThis 也就是传入 bind() 的第一个参数对象 {a: 1} 所以这时 foo() 函数中的 this 就可以指向这个参数对象（{a: 1}） 而 bind() 后剩余的参数（比如 bind({a: 1}, 20) 中的 20）和 fBound 的一些自己的参数，这个就是通过最后的 aArgs.concat() 拼接完成的 第二种就是 new 调用的情况 当在对 func() 使用 new 的时候，本质上 func() 就是作为构造函数在使用了，所以此时的 this 指向的是一个空对象（见最后） 这时的 this instanceof fNOP 就为 true 了，而此时执行的也就是 fToBind.apply(this, ...) 所以这时的 this 就作为 foo() 函数中调用的 this，也就不再指向 bind() 后的参数对象了，而是作为函数体内正常的 this 使用 这也就忽略掉 bind 的作用了（即 new 了以后，this 和 bind() 后绑定的参数没有关系了） 关于 this 指向的是一个空对象当一个函数被作为一个构造函数来使用（使用 new 关键字），它的 this 与即将被创建的新对象绑定（见 构造函数中的 this），当构造器返回的默认值是一个 this 引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回 this（不指定，则默认为一个空对象） 12345function foo() { console.log(this.__proto__ === foo.prototype) // true}new foo() 关于 fNOP.prototype = this.prototype在之前的代码中有这么一段 123456fNOP = function () { },// ...fNOP.prototype = this.prototypefBound.prototype = new fNOP() 之所以会拷贝一个 fNOP 的 prototype 给 fBound，由于是拷贝所以修改 fBound 的 prototype 不会影响到 fNOP 的 prototype，其实这两种方法是等价的 123456fNOP.prototype = this.prototypefBound.prototype = new fNOP()// ==&gt; 两者是相等的fBound.prototype = Object.creat(this.prototype) 如果直接使用 fBound.prototype = this.prototype 的话，那么在改变 func 的 prototype 的时候，foo 的 prototype 也会跟着变，所以不推荐","link":"/2017/05/07/JavaScript/13/"},{"title":"JavaScript 中的函数","text":"一般来说，一个函数是可以通过外部代码调用的一个子程序（或在递归的情况下由内部函数调用），像程序本身一样，一个函数由称为函数体的一系列语句组成，值可以传递给一个函数，函数也可以返回一个值 函数的定义在 JavaScript 中，函数是头等（first-class）对象，因为它们可以像任何其他对象一样具有属性和方法，它们与其他对象的区别在于函数可以被调用，简而言之，它们是 Function 对象，下面是一个简单的函数定义方式 12345function fn1() { alert('fn1')}typeof fn1 // function 在 JavaScript 中函数就是对象，只不过函数是一个非常特殊的对象，是一个 Function 类的实例，其实在内存中存储的操作是通过一个键值对来存储的，函数的名称仅仅是一个键，它的值是指向了内存中的一个对象，这个对象就是 Function 的一个对象，我们又声明一个变量 fn2，它是通过函数的拷贝来完成赋值的，两个引用并没有指向同一个对象 123456789101112var fn2 = fn1// fn1 两个的值是虽然相等，但是指向不同的空间fn2()// fn1 的值改变了以后，不会影响 fn2 的值fn1 = function () { alert('fnn1')}fn2() // 这里修改了 fn1 的内容，fn2 未做修改，故还是 fn1fn1() // fnn1 函数虽然是一个对象，但是却和对象有一些区别，对象是通过引用的指向完成对象的赋值的，而函数确实通过对象的拷贝来完成的，所以 fn1 虽然改变了，但是并不会影响 fn2，对于对象而言，是通过引用的指向来完成赋值的，此时修改 o1 或者 o2 会将两个值都完成修改 123456// o1 和 o2 其实指向了同一块空间，当修改 o2 的值的时候，o1 的也会改变var o1 = new Object()var o2 = o1o2.name = 'abc'alert(o1.name) // abc 函数对象对象字面量产生的对象连接到 Object.prototype， 函数对象连接到 Function.prototype（该原型对象本身连接到 Object.prototype） 1Function.prototype.__proto__ === Object.prototype // true 每个函数在创建的时候会有两个附加属性，函数上下文和实现函数行为的代码，每个函数对象在创建的时候也会带有一个 constructor 属性，它的值是一个拥有 constructor 属性且值即为该函数的对象 函数调用调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数，除了声明的时候定义的形式参数，每个函数接收两个附加的参数 this 和 arguments，参数 this 的值取决于调用的模式，在 JavaScript 中一共有四种调用模式 方法调用模式 函数调用模式 构造调用模式 apply/call 调用模式 当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配的时候不会导致程序错误，主要分为以下几种情况 如果实际参数过多，超出的参数值将会被忽略 如果实际参数过少，缺失的部分将会被替换为 undefined 而且需要注意的是，对参数的值不会进行类型检查，即任何类型的值都可以被传递给参数 函数没有重载比如下面这个例子 12345678910function sum(num1, num2) { return num1 + num2}function sum(num1) { return num1 + 100}sum(10) // 110sum(10, 20) // 110 换一种写法，可以看的更清楚些 12345678910var sum = function (num1, num2) { return num1 + num2}var sum = function (num1) { return num1 + 100}sum(10) // 110sum(10, 20) // 110 可以发现，下面一个 sum 方法会将上面的同名方法覆盖掉，所以只会执行下面的方法，特别指出，函数的参数和调用没用关系，如果函数只有一个参数，但是却传入了两个参数，仅仅只会匹配一个，函数是对象，不存在重载，只会存在覆盖，后面定义的会覆盖前面所定义的 1234567891011/** * 如下定义方式等于定义了一个 * function fn(num1, num2) { * alert(num1 + num2) * } * * 所以通过以下的例子，充分说明了函数就是一个对象 */var fn = new Function('num1', 'num2', 'alert(num1 + num2)')fn(12, 22) // 34 函数的值传递由于函数是对象，所以可以直接把函数通过参数传递进来 123456789101112131415161718function callFun(fun, arg) { // 第一个参数就是函数对象 return fun(arg)}function sum(num) { return num + 100}function say(str) { alert(str)}// 调用了 say 函数callFun(say, 'abc')// 调用了 sum 函数callFun(sum, 20) 作为返回值来传递（也就是所谓的闭包） 12345678910111213function fn1(arg) { var rel = function (num) { return arg + num } return rel}// 此时 f 是一个函数对象，可以完成调用// 在外部调用的时候，更改函数内部的值var f = fn1(20)f(20) //40f(11) //31 函数中的 arguments在函数对象中有一个属性叫做 arguments，通过这个属性可以获取相应的参数值，这个属性是一个类数组对象，其实就是传递进来的参数的一个集合 123456function say(num) { alert(num) // 1 alert(arguments.length) // 3}say(1, 2, 3) arguments.callee()在 arguments 这对象中有一个 callee 的方法，arguments.callee(arg) 可以实现反向的调用（已经不再推荐使用） 12345678910function factorial(num) { if (num &lt;= 1) { return 1 } else { // 此时和函数名耦合在一起 return num * factorial(num - 1) }}factorial(5) // 120 以上是一个求阶乘的函数，递归调用的函数名称和原有函数名耦合在一起，如果将这个函数名称更改以后，递归就会失效 12345678var fn = factorial// 此时不会报错fn(5) // 120factorial = nullfn(5) // 报错 此时由于 fn 函数依然使用 factorial 这个名称来调用，但是 factorial 已经指向 null 了，所以会报错，如上情况就需要使用 arguments.callee 方法来调用 1234567891011function factorial(num) { if (num &lt;= 1) { return 1 } else { // 以下就实现了函数名的解耦，在 JavaScript 中通常都是使用这种方式来做递归 return num * arguments.callee(num - 1) }}fn(5) // 120 函数中的 this当需要创建一个函数对象的时候，设置函数对象的属性和方法需要通过 this 关键字来引用，但是特别注意 this 关键字在调用的时候会根据不同的调用对象而变得不同 123456789101112131415var color = 'red'function showColor() { alert(this.color)}function Circle(color) { this.color = color this.showColor = showColor}var c = new Circle('yellow')c.showColor() // yellowshowColor() // red 使用 c 来调用 showColor 方法，等于调用了 showColor 方法，此时的 this 是 c，所以是 yellow，直接调用 showColor，此时调用的对象等于是 window，showColor 的 this 就是 window，所以就会在 window 中寻找 color 函数的返回值当一个函数被调用的时候，它从第一个语句开始执行，并在遇到关闭函数体的 } 时结束，从而是的函数把控制权交还给调用该函数的程序部分，return 语句可用来使函数提前返回，当 return 被执行的时候，函数立即返回而不再执行余下的语句，一个函数总是有一个返回值，如果没有指定返回值，则返回 unfefined 如果函数在前面加上 new 前缀的方式来调用，且返回值不是一个对象，则返回 this（该新对象），简单的总结就是，如果一个构造函数不写 return 语句，则系统会自动帮你返回一个对象，但是如果写了 return 语句，则 如果 return 的是一个基本类型的值，则会忽略这个 return，该返回什么还是返回什么，但是会阻止构造函数接下来的执行 如果 return 了一个引用类型，则原有的 return 会被覆盖 一些函数的实例下面我们来几个比较常见的排序的示例，在平常开发当中也是经常会遇到的 实例一12345678function sortByNum(a, b) { return a - b}var arr = [1, 2, 11, 33, 12, 190]arr.sort() // 1, 11, 12, 190, 2, 33arr.sort(sortByNum) // 1, 2, 11, 12, 33, 190 实例二123456789101112131415161718192021222324252627function Person(name, age) { this.name = name this.age = age}var p1 = new Person('zhangsan', 12)var p2 = new Person('lisi', 15)var p3 = new Person('wangwu', 18)var ps = [p1, p2, p3]function sortByName(obj1, obj2) { if (obj1.name &gt; obj2.name) { return 1 } else if (obj1.name == obj2.name) { return 0 } else { return -1 }}function sortByAge(obj1, obj2) { return obj1.age - obj2.age}ps.sort(sortByName)ps.sort(sortByAge) 使用如上的方式来处理排序，带来的问题是需要为每一个属性都设置一个函数，显得不是很灵活，所以可以通过函数的返回值来调用，实现函数排序功能 1234567891011121314function sortByProperty(propertyName) { var sortFun = function (obj1, obj2) { if (obj1[propertyName] &gt; obj2[propertyName]) { return 1 } else if (obj1[propertyName] == obj2[propertyName]) { return 0 } else { return -1 } }}ps.sort(sortByProperty('name'))ps.sort(sortByProperty('age'))","link":"/2017/10/08/JavaScript/21/"},{"title":"ES6 中的 Class","text":"在 ES6 中的 Class 其实可以看作是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 Class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已，比如下面这个例子 12345678910111213141516171819202122// ES6 写法class Person { constructor(name) { this.name = name } say() { console.log(this.name) }}// ES5 写法function Person(name) { this.name = name}Person.prototype.say = function() { console.log(this.name)}// 两种写法的结果是一致的var p = new Person('zhangsan')p.say() // zhangsan 我们可以看到 ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法，不过需要注意的是，『Class 的内部所有定义的方法，都是不可枚举的（non-enumerable）』，比如在上面的例子当中 1234567// ES6 当中Object.keys(Person.prototype) // []Object.getOwnPropertyNames(Person.prototype) // ['constructor', 'sayHello']// ES5 当中Object.keys(Person.prototype) // ['say']Object.getOwnPropertyNames(Person.prototype) // ['constructor', 'sayHello'] 静态方法静态方法一般用来提供一些工具方法，所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为『静态方法』 123456789101112131415161718// ES6 中class Person { static say() { console.log(`hello`) }}// ES5 中function Person() { }Person.say = function () { console.log(`hello`)}// 两者执行结果是一致的Person.say() // hellovar p = new Person()p.say() // p.say is not a function 静态属性Class 内部『只有静态方法，没有静态属性』，静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性，以前，我们添加静态属性只可以这样 12345// ES6 中class Foo { }Foo.prop = 1Foo.prop // 1 然而现在有一个提案，对实例属性和静态属性都规定了新的写法，而且 Babel 已经支持，所以现在我们可以写成 123456// 暂未统一实现class Person { static prop = 1}Person.prop // 1 对应到 ES5 就是 12345function Person() {}Person.prop = 1Person.prop // 1 私有方法ES6『不提供』私有方法，只能通过变通方法模拟实现，一种做法是在命名上加以区别 12345678910111213class Widget { // 公有方法 foo(baz) { this._bar(baz) } // 私有方法 _bar(baz) { return this.snaf = baz } // ...} 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的 12345678910111213class Widget { // foo 是公有方法，内部调用了 bar.call(this, baz) // 使得 bar 实际上成为了当前模块的私有方法 foo(baz) { bar.call(this, baz) } // ...}function bar(baz) { return this.snaf = baz} 有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值 12345678910111213141516const bar = Symbol('bar')const snaf = Symbol('snaf')export default class myClass { // 公有方法 foo(baz) { this[bar](baz) } // 私有方法 [bar](baz) { return this[snaf] = baz } // ...} 私有属性与私有方法一样，ES6『不支持』私有属性，但是可以通过 WeakMap 来实现私有属性 1234567891011121314151617181920212223const privateData = new WeakMap()class Person { constructor(name, age) { privateData.set(this, { name, age }) } getName() { return privateData.get(this).name } getAge() { return privateData.get(this).age }}const p = new Person('zhangsan', 20)p.name // undefinedp.getName() // zhangsan getters &amp; setters与 ES5 一样，在 Class 的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 1234567891011121314151617181920212223class People { constructor(name) { this.name = name } get name() { return this._name.toUpperCase() } set name(name) { this._name = name } sayName() { console.log(this.name) }}var p = new People('zhangsan')console.log(p.name) // ZHANGSANconsole.log(p._name) // zhangsanp.sayName() // ZHANGSAN 因为定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的 继承我们先来看看 ES5 当中比较推荐的继承方法，寄生组合式继承 1234567891011121314151617function Parent(name) { this.name = name}Parent.prototype.sayName = function () { console.log(this.name)}function Child(name, age) { Parent.call(this, name) this.age = age}Child.prototype = Object.create(Parent.prototype)var child1 = new Child('zhangsan', '18')child1.sayName() // zhangsan 这种方式的继承只调用了一次 Parent 构造函数，并且可以避免在 Parent.prototype 上面创建不必要的、多余的属性，与此同时，原型链还能保持不变，所以还能够正常使用 instanceof 和 isPrototypeOf 下面我们再来看看 ES6 当中的继承，Class 通过关键字 extends 来继承一个类，并且可以通过 super 关键字来引用父类，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多 1234567891011121314151617181920212223class Parent { constructor(name) { this.name = name } sayName() { console.log(this.name) }}class Child extends Parent { constructor(name, grade) { super(name) this.grade = grade } sayGrade() { console.log(this.grade) }}var child1 = new Child('zhangsan', '18')child1.sayName() // zhangsan 这里有几个需要注意的地方 super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this) 子类必须显式的在 constructor 方法中调用 super 方法，否则新建实例时会报错，这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工，如果不调用 super 方法，子类就得不到 this 对象 如果子类没有定义 constructor 方法，这个方法会被默认添加，也就是说不管有没有显式定义，任何一个子类都有 constructor 方法 在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错（因为只有 super 方法才能返回父类实例） Object.getPrototypeOf 方法可以用来从子类上获取父类（判断一个类是否继承了另一个类） 子类的 __proto__在 ES6 中，父类的静态方法，可以被子类继承，比如下面这个例子 12345678910class Foo { static classMethod() { return 'hello' }}class Bar extends Foo {}Bar.classMethod() 这是因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链 子类的 __proto__ 属性，表示构造函数的继承，总是指向父类 子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性 即 123456class Parent { }class Child extends Parent { }console.log(Child.__proto__ === Parent) // trueconsole.log(Child.prototype.__proto__ === Parent.prototype) // true 细心观察可以发现，相比寄生组合式继承，ES6 的 Class 多了一个 Object.setPrototypeOf(Child, Parent) 的步骤 继承目标extends 关键字后面可以跟多种类型的值 1class B extends A { } 上面代码的 A，只要是一个有 prototype 属性的函数，就能被 B 继承，由于函数都有 prototype 属性（一般情况下，排除一些箭头函数或者 bind(null) 之类的操作），因此 A 可以是任意函数，除了函数之外，A 的值还可以是 null，当 extend null 的时候 1234class A extends null { }console.log(A.__proto__ === Function.prototype) // trueconsole.log(A.prototype.__proto__ === undefined) // true super 关键字 使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 super 作为函数调用时 super 作为函数调用时，代表父类的构造函数（子类的构造函数必须执行一次 super 函数） 虽然代表了父类的构造函数，但是 super 内部的 this 指的是子类的实例（相当于 Father.prototype.constructor.call(this)） 作为函数时，super() 只能用在『子类』的构造函数之中，用在其他地方就会报错 super 作为对象调用时 在普通方法中，指向父类的原型对象，在静态方法中，指向父类（与父类静态方法相呼应） 当 super 指向父类的原型对象时，定义在父类实例上的方法或属性，是无法通过 super 调用的（定义在 prototype 上的则可以取到） 通过 super 调用父类的方法时，super 会绑定子类的 this 通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性，如下代码 123456789101112131415161718192021class A { constructor() { this.x = 1 }}class B extends A { constructor() { super() this.x = 2 // 等同于对 this.x 赋值为 3 super.x = 3 // 而当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined console.log(super.x) // undefined console.log(this.x) // 3 }}let b = new B() 总结 Class 的内部所有定义的方法，都是不可枚举的 类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式 一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加 不存在变量提升（hoist） 类的方法内部如果含有 this，它默认指向类的实例 class 中的方法有三种类型：构造函数、静态方法、原型方法 class 内部只有静态方法，没有静态属性","link":"/2017/09/20/JavaScript/19/"},{"title":"parseInt() 与 parseFloat()","text":"在 JavaScript 中，parseInt() 和 parseFloat() 的函数功能都是将所谓的数字字符串转化为一个真正的数值，但是两者在使用之上还是存在一定的区别的，它们两者之间的区别如下 parseFloat(string)，parseFloat() 函数可解析一个字符串，并返回一个浮点数，指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串 parseInt(string, radix)，parseInt() 函数可解析一个字符串，并返回一个整数，radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析 差异parseInt 和 parseFloat 都是将字符串类型转换为 number 类型，两者区别在于 parseFloat 会将 . 号转换为浮点数，而 parseInt 直接忽略停止转换 比如当处理 '5.12asc' 时，parseInt 直接转换为 5，parseFloat 则会转换为 5.12，parseInt 还可以指定第二位参数来指定转换结果的进制（2, 8, 16）（范围为 2 - 36） parseFloat 与 NANparseFloat 会将它的字符串参数解析成为浮点数并返回，如果在解析过程中遇到了正负号（+ 或 -）、数字（0 - 9）、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数 同时参数字符串首位的空白符会被忽略，如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN，根据 #parseFloat 可知，当调用 parseFloat 函数，是先转成字符串，再转为数字，如果不能转为数字，则返回 NaN，大体意思就是 如果返回的是基本类型，则将此返回值转为字符串，再尝试将字符串转为数字，如果不能转成数字则返回 NaN 如果 toString 方法返回的不是基本类型，则继续调用 valueOf 方法，如果返回的是基本类型，则将其转为字符串，再将字符串转为数字返回 如果 valueOf 方法返回的也不是基本类型，则返回 NaN map(parseInt)一个经典的问题 12// 下面的语句返回什么['1', '2', '3'].map(parseInt) 你可能觉的会是 [1, 2, 3]，但实际的结果是 [1, NaN, NaN]，通常使用 parseInt 时，只需要传递一个参数，但实际上 parseInt 可以有两个参数，第二个参数是进制数，可以通过语句 'alert(parseInt.length) === 2' 来验证 map 方法在调用 callback 函数时，会给它传递三个参数，当前正在遍历的元素，元素索引，原数组本身，第三个参数 parseInt 会忽视，但第二个参数不会，也就是说 parseInt 把传过来的索引值当成进制数来使用，从而返回了 NaN，只需要稍微调整一下，正确的传递进制索引即可 12// 返回 [1, 2, 3]['1', '2', '3'].map(item =&gt; parseInt(item, 10)) parseFloat() 精度的问题只有字符串中的第一个数字会被返回，开头和结尾的空格是允许的，需要注意的是，如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN，如果只想解析数字的整数部分，请使用 parseInt() 方法 12345678910111213parseFloat('10') // 10parseFloat('10.00') // 10parseFloat('10.33') // 10.33parseFloat('34 45 66') // 34parseFloat(' 60 ') // 60parseFloat('40 years') // 40parseFloat('He was 40') // NaN 通过以上一些实例，我们对 parseFloat 的基本用法大致应该了解一些了，下面我们来看一些平常可能会遇到的问题，如下 1234var num = parseFloat('233333.9') - parseFloat('0.2')// 233333.69999999998console.log(num) 很明显结果并不是我们想要的样子，那么为什么会造成这种情况呢？其实最主要的原因就在于能被计算机读懂的是二进制，而不是十进制，我们来把 0.2 转换为二进制看一看 10.2 ==&gt; 0.0011 0011 0011 0011 … 这样一看问题就很明显了，因为它是一个无限循环的小数，所以我们在平常过程当中需要做的就是尽量避免这样的情况发生，如果无法避免的话，可以采用以下几种方式来进行处理 12345678910// 第一种，四舍五入Math.round(parseFloat('233333.9') - parseFloat(0.2))// 第二种，保留几位小数num.toFixed(2) // toFixed(n) 中的 n 代表保留几位 // 第三种，扩大一定的倍数，对结果在缩小这个倍数var num1 = parseFloat('233333.9') * 1000000000000var num2 = parseFloat('0.2') * 1000000000000var num3 = (num1 - num2) / 1000000000000 另外还可以使用一些第三方库来进行解决，比如 bignumber 如何判断 0.1 + 0.2 与 0.3 相等下面我们再来深入的探讨一下这个经典的面试题，也就是上面我们所提到的精度丢失的问题，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天我们就来具体看一下背后的原因 数字类型ECMAScript 中的 Number 类型使用 IEEE754 标准 来表示整数和浮点数值，所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容，在 IEEE754 中，规定了四种表示浮点数值的方式 单精确度（32 位） 双精确度（64 位） 延伸单精确度 与延伸双精确度 像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数 浮点数转二进制在展开这个问题之前，我们需要先了解计算机内部是如何表示数的，在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数，我们先来看下 1020 用十进制的表示，它是下面这样的 11020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0 而 1020 用二进制表示则是下面这样的 11020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 所以我们可以得到 1020 的二进制为 1111111100，那如果是 0.75 用二进制表示呢？同理应该是 10.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 … 因为使用的是二进制，所以这里的 abcd … 的值的要么是 0 要么是 1，那怎么算出 abcd … 的值呢，我们可以两边不停的乘以 2 算出来，解法如下 10.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 … 两边同时乘以 2 11 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3 … 所以 a = 1，而剩下的 10.5 = b * 2^-1 + c * 2^-2 + d * 2^-3 … 再同时乘以 2 11 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3 … 所以 b = 1，也就是说 0.75 用二进制表示就是 0.ab，也就是 0.11，然而不是所有的数都像 0.75 这么好算，我们来算下 0.1 1234567891011120.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 … 0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 … （a = 0）0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 … （b = 0）0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 … （c = 0）1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 … （d = 1）1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 … （e = 1）0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 … （f = 0）0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 … （g = 0）1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 … （h = 1）…… 我们可以发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011 …，而这是一个无限循环的二进制小数，这一点我们使用上面的 parseFloat() 也可以得知 12// 0.0001100110011001100110011001100110011001100110011001101parseFloat(0.1).toString(2) 但是我们可以发现，这里的结果为什么又不是一个无限循环的数了呢？而这个就要说起浮点数的存储 浮点数的存储虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式，这个标准认为，一个浮点数（Value）可以这样表示 1Value = sign * exponent * fraction 看起来很抽象的样子，其实简单理解的话就是科学计数法，比如 -1020，用科学计数法表示就是 1-1 * 10^3 * 1.02 对应到上面的话，sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02，而对于二进制也是一样，以 0.1 的二进制 0.00011001100110011 … 这个数来说可以表示为 11 * 2^-4 * 1.1001100110011 … 其中 sign 就是 1，exponent 就是 2^ - 4，fraction 就是 1.1001100110011 …，而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成 1V = (-1)^S * (1 + Fraction) * 2^E 这里你可能会想，如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了，我们来一点点看，在上面的例子中，其中的 (-1)^S 表示符号位，当 S = 0，V 为正数，当 S = 1 时，V 为负数 再看 (1 + Fraction)，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分，最后我们再来看看 2^E 如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1，对应二进制是 1 * 1.1001100110011 … * 2^-4，E 的值就是 -4，也就是说 E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？ 我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127 ~ 127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题，对应的当取值的时候，我们再减去 127 所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127 所以，如果要存储一个浮点数，我们存 S，Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准 在这个标准下 我们会用 1 位存储 S，0 表示正数，1 表示负数 用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023 用 52 位存储 Fraction 举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011 … * 2^-4，Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011 … 对应 64 个字节位的完整表示就是 10 01111111011 1001100110011001100110011001100110011001100110011010 同理，0.2 表示的完整表示是 10 01111111100 1001100110011001100110011001100110011001100110011010 所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数 浮点数的运算关于浮点数的运算，一般由以下五个步骤完成 对阶 尾数运算 规格化 舍入处理 溢出判断 我们来简单看一下 0.1 和 0.2 的计算 首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011 … * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110 … * 2^-3，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011 … * 2^-3 接下来是尾数计算 1234 0.1100110011001100110011001100110011001100110011001101+ 1.1001100110011001100110011001100110011001100110011010———————————————————————————————————————————————————————— 10.0110011001100110011001100110011001100110011001100111 我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3，将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2 括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了，再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果就变成了 11.0011001100110011001100110011001100110011001100110100 * 2^-2 本来还有一个溢出判断，但是在这里我们就不过多涉及了，所以最终的结果存成 64 位就是 10 01111111101 0011001100110011001100110011001100110011001100110100 将它转换为 10 进制数就得到 0.30000000000000004440892098500626，因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3 解决方法其实通过上面的介绍我们可以发现，二进制能精确地表示位数有限且分母是 2 的倍数的小数，比如 0.5，0.5 在计算机内部就没有舍入误差，所以 0.5 + 0.5 === 1 而在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在，虽然允许误差存在，但是『永远不要直接比较两个浮点的大小』 一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差，如果非要计算一些浮点数，可以采用第三方库，比如之前提到过的 bignumber 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望 1234567891011121314151617{ let x = new BigNumber(0.1) let y = new BigNumber(0.2) let z = new BigNumber(0.3) console.log(z.equals(x.add(y))) // 0.3 === 0.1 + 0.2, true console.log(z.minus(x).equals(y)) // true console.log(z.minus(y).equals(x)) // true}{ let x = 0.2 console.log(x * x === 0.04) // false let y = new BigNumber(0.2) let r = y.mul(y) // 0.04 console.log(r.equals(new BigNumber(0.04))) // true} 总结 为什么 0.1 + 0.2 不等于 0.3，因为计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数 并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差 具有舍入误差的运算结可能会符合我们的期望，原因可能是负负得正，相互抵消这样的效果 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 bignumber 这样的浮点数运算库","link":"/2017/04/15/JavaScript/10/"},{"title":"JSON.parse() && JSON.stringify()","text":"对于这两个方法，在以前的工作当作也仅仅只是使用，但是并没有去深入研究，只是简单的知道一个是将对象或者数组转为 JSON 字符串，另外一个就是反过来转换 JSON 的，但是深入了解以后却发现东西还是有点多的，特别是还支持第二个参数配置，于是便查阅资料深入了解一下，在这里记录记录 顺便安利一个扩展知识 JSON 解析器 JSON.parse()JSON.parse() 用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象，提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 1234var json = '{\"result\": true, \"count\": 42}'// { result: true, count: 42 }JSON.parse(json) 语法如下 1JSON.parse(text[, reviver]) 如果被解析的 JSON 字符串是非法的，则会抛出一个语法错误异常（需要注意，JSON.parse() 不允许最后一个键值对后面存在逗号），如果指定了 reviver 函数，则解析出的 JavaScript 值（解析值）会经过一次转换后才将被最终返回（返回值） 意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数，在调用过程中，当前属性所属的对象会作为 this 值，当前属性名和属性值会分别作为第一个和第二个参数传入 reviver 中，如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值 需要注意的是 当遍历到最顶层的值（解析值）时，传入 reviver 函数的参数会是空字符串 &quot;&quot;（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了） 当前的 this 值会是 {&quot;&quot;: 修改过的解析值}，在编写 reviver 函数时，要注意到这个特例（这个函数的遍历顺序依照从最内层开始，按照层级顺序，依次向外遍历） 下面是两个示例 123456789101112131415161718192021222324// 如果到了最顶层，则直接返回属性值，否则将属性值变为原来的 2 倍JSON.parse('{\"p\": 5}', function (k, v) { if(k === '') return v return v * 2 })// { p: 10 }JSON.parse(' {\"1\": 1, \"2\": 2, \"3\": {\"4\": 4, \"5\": {\"6\": 6}}} ', function (k, v) { // 输出当前的属性名，从而得知遍历顺序是从内向外的 console.log(k) // 最后一个属性名会是个空字符串 // 返回原始属性值，相当于没有传递 reviver 参数 return v})// 1// 2// 4// 6// 5// 3 // \"\" JSON.stringify() JSON.stringify() 的总体用法可以参考上图，下面我们慢慢来看，该方法可以将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串，如果指定了 replacer 是一个函数，则可以替换值，或者如果指定了 replacer 是一个数组，可选的仅包括指定的属性，基本语法如下 1JSON.stringify(value[, replacer [, space]]) 关于可选参数 replacer 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 如果该参数为 null 或者未提供，则对象所有的属性都会被序列化 关于可选参数 space 指定缩进用的空白字符串，用于美化输出（pretty-print） 如果参数是个数字，它代表有多少的空格（上限为 10），该值若小于 1，则意味着没有空格 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格 如果该参数没有提供（或者为 null）将没有空格 关于序列化，有下面五点注意事项 非数组对象的属性『不能保证以特定的顺序』出现在序列化后的字符串中 布尔值、数字、字符串的包装对象在序列化过程中会『自动转换成对应的原始值』 undefined、任意的函数以及 Symbol 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 null，此外 NaN 和 Infinity 格式的数值及 null 也都会被当做 null 来进行处理 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误，这也就是为什么去实现深拷贝时，遇到循环引用的对象会抛出错误的原因 所有以 Symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们 其他类型的对象，包括 Map/Set/WeakMap/WeakSet 仅会序列化可枚举的属性，也就是说『不可枚举的属性会被忽略』 所以我们在使用该方法进行对象拷贝的时候就需要注意了，下面来看几个示例加深一下印象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849JSON.stringify({}) // '{}'JSON.stringify(true) // 'true'JSON.stringify('foo') // '\"foo\"'JSON.stringify([1, 'false', false]) // '[1, \"false\", false]'JSON.stringify({ x: 5 }) // '{\"x\": 5}'JSON.stringify(NaN) // 'null'JSON.stringify(null) // 'null'JSON.stringify(Infinity) // 'null'// \"{\"x\": 5, \"y\": 6}\"JSON.stringify({ x: 5, y: 6 })// '[1, \"false\", false]'JSON.stringify([new Number(1), new String('false'), new Boolean(false)])// '{}'JSON.stringify({ x: undefined, y: Object, z: Symbol('') })// '[null, null, null]' JSON.stringify([undefined, Object, Symbol('')])// '{}'JSON.stringify({ [Symbol('foo')]: 'foo' })// '{}'JSON.stringify({ [Symbol.for('foo')]: 'foo' }, [Symbol.for('foo')])// undefined JSON.stringify( { [Symbol.for('foo')]: 'foo' }, function (k, v) { if (typeof k === 'symbol') { return 'a symbol' } })// 不可枚举的属性默认会被忽略// \"{\"y\": \"y\"}\"JSON.stringify( Object.create( null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } } )) JSON.stringify() 的 replacer 参数replacer 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化 如果返回一个数值，转换成相应的字符串被添加入 JSON 字符串 如果返回一个字符串，该字符串作为属性值被添加入 JSON 如果返回一个布尔值，&quot;true&quot; 或者 &quot;false&quot; 被作为属性值被添加入 JSON 字符串 如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法（除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串） 如果返回 undefined，该属性值不会在 JSON 字符串中输出 需要注意的是，不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代 1234567891011var foo = { foundation: 'Mozilla', model: 'box', week: 45, transport: 'car', month: 7 }var jsonString = JSON.stringify(foo, (key, value) =&gt; { if (typeof value === 'string') { return undefined } return value})// {\"week\": 45, \"month\": 7}console.log(jsonString) 如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化） 1234var foo = { foundation: 'Mozilla', model: 'box', week: 45, transport: 'car', month: 7 }// 只保留 week 和 month 属性值console.log(JSON.stringify(foo, ['week', 'month'])) 关于 toJSON 方法需要注意的是，如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为（即为调用 toJSON 方法后的返回值会被序列化） 123456789var obj = { foo: 'foo', toJSON: function () { return 'bar' }}JSON.stringify(obj) // '\"bar\"'JSON.stringify({ x: obj }) // '{\"x\":\"bar\"}' 此外 JSON.stringify() 还将会正常序列化 Date 对象，如下所示 12// {\"now\": \"2018-03-01T08:42:34.893Z\"}JSON.stringify({ now: new Date() }) 原因是因为 Date 对象内部已经部署了 toJSON() 方法（同 Date.toISOString()），因此 Date 对象会被当做字符串处理 使用 JSON.stringify 来格式化对象在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观，我们可以利用 replacer 和 space 参数来对其进行格式化 1234567891011121314151617181920212223242526272829303132333435// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理var foo = function (key, value) { if (typeof value === 'function' || typeof value === 'symbol') { return value.toString() } else if (typeof value === 'undefined') { return 'undefined' } else { return value }}var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex }, address: null } } }JSON.stringify(json, foo, 2)// {// \"bar\": \"aaa\",// \"foo\": {// \"age\": \"Symbol(23)\"// },// \"baz\": \"undefined\",// \"o\": {// \"name\": \"zhangsan\",// \"userInfo\": {// \"sex\": 0,// \"getSex\": \"function () { return this.sex }\",// \"address\": null// }// }// }","link":"/2017/07/06/JavaScript/18/"},{"title":"JavaScript 中的继承","text":"在一些基于类的语言（比如 Java）当中，继承（inheritance/extends）提供了两个有用的服务，如果一个新的类与一个已存在的类大部分相似，那么你只需说明其不同点即可，JavaScript 是一门弱类型语言，从不需要类型转换，它可以模拟那些基于类的模式，同时它也支持其他更具表现力的模式 在基于类的语言中，对象是类的实例，并且类可以用另一个类继承，JavaScript 是一门基于原型的语言，这意味着对象也是可以直接从其他对象继承，在 JavaScript 当中比较常见的继承方法有类式继承和原型继承 类式继承（构造函数继承）JavaScript 在 ES5 当中其实是没有类的概念的，所谓的类也是模拟出来的，特别是当我们是用 new 关键字的时候，就使得类的概念就越像其他语言中的类了，类式继承在子类的构造函数中执行父类的构造函数，并为其绑定子类的 this，让父类的构造函数把成员属性和方法都挂到子类的 this 上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参 1234567891011121314151617181920function Parent(name) { this.name = [name]}Parent.prototype.getName = function () { return this.name}function Child() { // 执行父类构造方法并绑定子类的 this，使得父类中的属性能够赋到子类的 this 上 Parent.call(this, 'zhangsan')}const child1 = new Child()const child2 = new Child()child1.name[0] = 'foo'console.log(child1.name) // ['foo']console.log(child2.name) // ['zhangsan']child2.getName() // 报错，因为找不到 getName() 但是上面这种方式是存在一定缺点的，那就是类式继承是继承不到父类原型上的属性和方法 原型继承原型继承有别于类式继承，因为继承不在对象本身，而在对象的原型上（prototype），每一个对象都有原型，在浏览器中它体现在一个隐藏的 __proto__ 属性上，在一些现代浏览器中你可以更改它们（不过不太建议这样操作） 它的原理是直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，如果没有找到，它会再次往下继续查找，这样逐级查找，一直找到了要找的方法，这些查找的原型构成了该对象的原型链条（最后指向 Object.prototype.__proto__ 也就是 null），类似于下面这样 1234567891011function Foo() {}var f1 = new Foo()// f1 的 __proto__ 是指向 Foo.prototype 的f1.__proto__ === Foo.prototype// 而 Foo.prototype.__proto__ 又是指向 Object.prototypeFoo.prototype.__proto__ === Object.prototype// 而 Object.prototype.__proto__ 则是指向 null 的Object.prototype.__proto__ === null 下面我们再来看看原型继承的例子，如下 1234567891011121314151617181920function Parent() { this.name = 'zhangsan'}Parent.prototype.getName = function () { return this.name}function Child() { }// 让子类的原型对象指向父类实例，这样一来在 Child 实例中找不到的属性和方法就会到原型对象（父类实例）上寻找Child.prototype = new Parent()// 根据原型链的规则，顺便绑定一下constructor，这一步不影响继承，只是在用到 constructor 时会需要Child.prototype.constructor = Child// 然后 Child 实例就能访问到父类及其原型上的 name 属性和 getName() 方法const child = new Child()child.name // 'zhangsan'child.getName() // 'zhangsan' 下面我们再来看看原型继承的缺点，它有下面两点 由于所有 Child 实例原型都指向同一个 Parent 实例，因此对某个 Child 实例的父类引用类型变量修改会影响所有的 Child 实例 在创建子类实例时无法向父类构造传参，即没有实现 super() 的功能 我们可以用代码来测试一下 12345678910111213141516171819function Parent() { this.name = ['zhangsan']}Parent.prototype.getName = function () { return this.name}function Child() { }Child.prototype = new Parent()Child.prototype.constructor = Childconst child1 = new Child()const child2 = new Child()child1.name[0] = 'foo'console.log(child1.name) // ['foo']console.log(child2.name) // ['foo']（预期是 ['zhangsan']，但是对 child1.name 的修改引起了所有 child 实例的变化） 组合式继承既然原型继承和类式继承各有互补的优缺点，那么我们为什么不组合起来使用呢，所以下面就有了综合二者的组合式继承 12345678910111213141516171819202122function Parent(name) { this.name = [name]}Parent.prototype.getName = function () { return this.name}function Child() { Parent.call(this, 'zhangsan')}Child.prototype = new Parent()Child.prototype.constructor = Childconst child1 = new Child()const child2 = new Child()child1.name[0] = 'foo'console.log(child1.name) // ['foo']console.log(child2.name) // ['zhangsan']child2.getName() // ['zhangsan'] 但是先别急着高兴，组合式继承也是存在着一定缺点的，那就是每次创建子类实例都会执行两次构造函数（call() 和 new 操作），虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅 寄生式组合继承所以，为了解决构造函数被执行两次的问题，我们将指向父类实例改为指向父类原型，减去一次构造函数的执行 123456789101112131415161718192021function Parent(name) { this.name = [name]}Parent.prototype.getName = function () { return this.name}function Child() { Parent.call(this, 'zhangsan')}// 这里我们将指向父类实例的方式调整为指向父类原型Child.prototype = Parent.prototypeChild.prototype.constructor = Childconst child1 = new Child()const child2 = new Child()child1.name[0] = 'foo'console.log(child1.name) // ['foo']console.log(child2.name) // ['zhangsan']child2.getName() // ['zhangsan'] 但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给 Child.prototype 增加一个 getName() 方法，那么会导致 Parent.prototype 也增加或被覆盖一个 getName() 方法，为了解决这个问题，我们在这里可以使用 Obeject.create() 这个方法来进行创建（关于 Object.create() 方法更为详细的用法可以参考 Object.create()） 12345678910111213141516171819function Parent(name) { this.name = [name]}Parent.prototype.getName = function () { return this.name}function Child() { Parent.call(this, 'zhangsan')}Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = Childconst child = new Child()const parent = new Parent()child.getName() // ['zhangsan']parent.getName() // 报错，找不到 getName() 以上便是我们最终完善后的继承方式，也称为寄生组合式继承，它是目前最为成熟的继承方式，在 Babel 对 ES6 中的继承的转化当中也是使用了寄生组合式继承，下面我们就来简单的了解一下 编译后的 extends我们都知道，ES6 的代码最后都是要在浏览器上能够跑起来的，这中间就利用了 Babel 这个编译工具，将 ES6 的代码编译成 ES5 让一些不支持新语法的浏览器也能运行，下面我们就来看看 extends 被编译成了什么样子，如下 1234567891011121314151617181920212223242526272829303132function _possibleConstructorReturn(self, call) { // ... return call &amp;&amp; (typeof call === 'object' || typeof call === 'function') ? call : self}function _inherits(subClass, superClass) { // ... subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }) if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass}var Parent = function Parent() { // 验证是否是 Parent 构造出来的 this _classCallCheck(this, Parent)}var Child = (function (_Parent) { _inherits(Child, _Parent) function Child() { _classCallCheck(this, Child) return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments)) } return Child}(Parent)) 核心是 _inherits 函数，我们可以发现它采用的是我们上面介绍到的『寄生组合继承』方式，同时证明了这种方式的成功，不过这里增加了一个额外的操作 Object.setPrototypeOf(subClass, superClass)，它的作用则是用来继承父类的静态方法，这也是我们原来的继承方式所疏忽掉的地方 继承本身的问题我们下面来从设计思想上简单的谈谈继承本身的问题，我们可能听闻过面向对象的设计的方式，那么面向对象的设计的方式一定就是好的设计吗？当然这个需要根据使用场景来进行区分，如果从继承的角度说，这一设计是存在巨大隐患的，假如我们现在有不同品牌的车，每辆车都有 drive、music、addOil 这三个方法 12345678910111213141516class Car { constructor(id) { this.id = id } drive() { console.log(`drive`) } music() { console.log(`music`) } addOil() { console.log(`addOil`) }}class otherCar extends Car { } 我们现在可以实现车的功能，并且以此去扩展不同的车，但是问题来了，新能源汽车也是车，但是它并不需要 addOil（加油），如果让新能源汽车的类继承 Car 的话，也是有问题的，而这也是俗称的『大猩猩和香蕉』的问题 大猩猩手里有香蕉，但是我们现在明明只需要香蕉，却拿到了一只大猩猩，也就是说加油这个方法，我们现在是不需要的，但是由于继承的原因，也给到子类了，所以我们可以发现 继承的最大问题在于『无法决定继承哪些属性，所有属性都得继承』 当然有人可能会说，我们可以再创建一个父类，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好，那我们该如何来解决继承的诸多问题呢？ 我们可以借住 React 当中的 HOC 的方式，利用『组合』来维护我们的继承，这也是当今编程语法发展的趋势，顾名思义，『组合』就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类 12345678910111213function drive() { console.log(`drive`)}function music() { console.log(`music`)}function addOil() { console.log(`addOil`)}let car = compose(drive, music, addOil)let otherCar = compose(drive, music) 可以发现，代码干净，复用性也很好，而这也就是面向组合的设计方式 总结我们回顾一下继承的实现过程 我们首先采用了类式继承，通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但类式继承存在着不能继承父类原型链上的属性和方法的缺陷 接着我们采用了原型继承，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型继承的缺陷在于对子类实例继承的引用类型的修改会影响到所有的实例对象以及无法向父类的构造方法传参 所以我们综合了两种继承的优点，提出了组合式继承，但组合式继承也引入了新的问题，它每次创建子类实例都执行了两次父类构造方法，所以我们通过采用 Obeject.create() 来替换掉使用 call() 方法会执行父类构造方法的缺点，也就是我们最终的寄生式组合继承的实现","link":"/2017/06/15/JavaScript/20/"},{"title":"浏览器存储机制","text":"我们在之前的章节当中梳理了 浏览器缓存机制 相关内容，乘热打铁，我们本章当中来看看浏览器存储机制的相关内容，主要涉及到 Cookie，localStorage，sessionStorage，Web SQL 和 IndexedDB 相关内容，下面我们就一个一个来进行介绍 CookieHTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上，通常它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态，Cookie 主要用于以下三个方面 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie 的特点Cookie 的特点有下面这些 Cookie 的大小受限，一般为 4 KB 同一个域名下存放 Cookie 的个数是有限制的，不同浏览器的个数不一样，一般为 20 个 Cookie 支持设置过期时间，当过期时自动销毁 每次发起同域下的 HTTP 请求时，都会携带当前域名下的 Cookie 支持设置为 HttpOnly，防止 Cookie 被客户端的 JavaScript 访问 Cookie 的原理Cookie 的原理可以如下图所示 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个 Set-Cookie 选项，将 Cookie 放入到响应请求中，在浏览器第二次发请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器，服务端会辨别用户身份，另外 Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定 Cookie 的设置与获取下面我们就看看如何使用代码来设置与获取 Cookie，先来看一个最为基本的简单用法 1234document.cookie = 'name=zhangsan'document.cookie = 'age=18'console.log(document.cookie) // name=zhangsan;age=18 下面的示例主要用于获取名为 test2 的 Cookie 123456document.cookie = 'test1=Hello'document.cookie = 'test2=World'var myCookie = document.cookie.replace(/(?:(?:^|.*;\\s*)test2\\s*\\=\\s*([^;]*).*$)|^.*$/, '$1')console.log(myCookie) Cookie 的缺陷虽然 Cookie 使用起来很方便，但是它还是存在着一些缺陷，如下 Cookie 不够大，Cookie 的大小限制在 4KB 左右 Cookie 是紧跟域名的，同一个域名下的所有请求，都会携带 Cookie，过多的 Cookie 会带来巨大的性能浪费 由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用 HTTPS Cookie 的安全性另外我们还需要注意 Cookie 的安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JavaScript 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 HttpOnly 不支持读写，浏览器不允许脚本操作去更改 Cookie，所以为避免跨域脚本（XSS）攻击，通过 JavaScript 的 document.cookie 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端，如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记，如下 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT; Secure; HttpOnly 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障 localStorage一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期，它是采用键值对的方式存储数据，按域名将数据分别保存到对应数据库文件里，相比 Cookie 来说，它能保存更大的数据，localStorage 的特点有以下这些 大小限制为 5MB ~ 10MB 在同源的所有标签页和窗口之间共享数据 数据仅保存在客户端，不与服务器进行通信 数据持久存在且不会过期，重启浏览器后仍然存在 对数据的操作是同步的 具体使用方式如下 1234567891011// 通过 setItem() 增加一个数据项localStorage.setItem('myName', 'zhangsan')// 通过 getItem() 获取某个数据项let me = localStorage.getItem('myName')// 通过 removeItem() 移除某个数据项localStorage.removeItem('myName')// 移除所有数据项localStorage.clear() sessionStorage与服务端的 Session 类似，sessionStorage 是一种会话级别的缓存，关闭浏览器时数据会被清除，需要注意的是 sessionStorage 的作用域是窗口级别的，也就是说不同窗口之间保存的 sessionStorage 数据是不能共享的，sessionStorage 的特点有以下这些 sessionStorage 的数据只存在于当前浏览器的标签页 数据在页面刷新后依然存在，但在关闭浏览器标签页之后数据就会被清除 与 localStorage 拥有统一的 API 接口 对数据的操作是同步的 具体使用方式如下 1234567891011// 通过 setItem() 增加一个数据项sessionStorage.setItem('myName', 'zhangsan')// 通过 getItem() 获取某个数据项let me = sessionStorage.getItem('myName')// 通过 removeItem() 移除某个数据项sessionStorage.removeItem('myName')// 移除所有数据项sessionStorage.clear() Web SQLWeb SQL 数据库 API 实际上不是 HTML5 规范的一部分，而是一个单独的规范，它引入了一组 API 来使用 SQL 来操作客户端数据库 不过需要注意的是，HTML5 已经放弃 Web SQL 数据库 Web SQL Database 规范中定义的三个核心方法，如下 openDatabase，这个方法使用现有数据库或新建数据库来创建数据库对象 transaction，这个方法允许我们根据情况控制事务的提交或回滚 executeSql，这个方法用于执行真实的 SQL 语句 Web SQL 的特点（相比 Cookie 与 WebStorage 而言） Web SQL 能方便进行对象存储 Web SQL 支持事务，能方便地进行数据查询和数据处理操作 具体使用方式如下 123456789var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024)db.transaction(function (tx) { // 执行查询操作 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)') // 执行插入操作 tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"foobar\")') tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"logmsg\")')}) IndexedDBIndexedDB 是一种底层 API，用于客户端存储大量结构化数据，包括文件、二进制大型对象，该 API 使用索引来实现对该数据的高性能搜索，虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太好用，IndexedDB 提供了一个解决方案，它的特点有以下这些 键值对存储，IndexedDB 内部采用对象仓库（Object Store）存放数据，所有类型的数据都可以直接存入，包括 JavaScript 对象，对象仓库中，数据以键值对的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误 数据操作是异步的，IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的，异步设计是为了防止大量数据的读写，拖慢网页的表现 存储空间大，IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限 支持二进制存储，IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象） 同源限制，IndexedDB 受到同源限制，每一个数据库对应创建它的域名，网页只能访问自身域名下的数据库，而不能访问跨域的数据库 支持事务型，IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况 下面我们来看看如何使用 1234567891011121314151617181920212223242526272829var dbName = 'my_db'var request = indexedDB.open(dbName, 2)request.onerror = function (event) { // 错误处理}request.onupgradeneeded = function (event) { var db = event.target.result // 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path），因为 ssn 可以保证是不重复的 var objectStore = db.createObjectStore('customers', { keyPath: 'ssn' }) // 建立一个索引来通过姓名来搜索客户，名字可能会重复，所以我们不能使用 unique 索引 objectStore.createIndex('name', 'name', { unique: false }) // 使用邮箱建立索引，我们确保客户的邮箱不会重复，所以我们使用 unique 索引 objectStore.createIndex('email', 'email', { unique: true }) // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕 objectStore.transaction.oncomplete = function (event) { // 将数据保存到新创建的对象仓库 var customerObjectStore = db.transaction('customers', 'readwrite').objectStore('customers') customerData.forEach(function (customer) { customerObjectStore.add(customer) }) }} WebStorage、Cookie 和 IndexedDB 之间的区别区别如下 特性 Cookie localStorage sessionStorage IndexedDB 数据生命周期 一般由服务器生成，可以以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 Header 中，对于请求性能影响 不参与 不参与 不参与 总结正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机，近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型，简单总结一下上文涉及到的几个核心观点 Cookie 的本职工作并非本地存储，而是维持状态 Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信 Web SQL 数据库已经被废弃 IndexedDB 用于客户端存储大量结构化数据 另外除了上文当中所介绍到的一些方式，网上还有一些比较优秀的第三方主流数据库，但是这里就不详细展开了，想了解更多的话可以参考对应链接，列表如下 localForage，通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL），进而改善你的 Web 应用程序的离线体验 PouchDB，一个浏览器内数据库，允许应用程序在本地保存数据，以便用户即使在离线时也可以享受应用程序的所有功能，另外数据在客户端之间是同步的，因此用户可以随时随地保持最新状态 Rxdb，一个 NoSQL 数据库，响应式的设计意味着你不仅可以查询当前状态，还可以订阅所有状态更改 NeDB，纯 JavaScript 实现，不依赖其它库，提供的 API 是 MongoDB API 的子集，重要的是它的速度非常快 Dexie.js，IndexedDB 的包装库，它提供了一套经过精心设计的 API，强大的错误处理，较强的可扩展性，此外它能够跟踪数据变化，支持 KeyRange（搜索不区分大小写，可设置匹方式和 OR 操作） 参考 Document.cookie Window.localStorage Window.sessionStorage IndexedDB","link":"/2019/11/15/JavaScript/23/"},{"title":"JavaScript 中的数据双向绑定","text":"关于数据双向绑定，绑定的基础就是监听属性的变化事件（propertyChange），在现在比较流行的一些框架当中的解决方法一般有以下几种 Knockout/Backbone（发布/订阅模式），简单来说就是另外开发一套 API，但使用起来却不得不使用这套 API 来操作 viewModel，导致上手复杂、代码繁琐 Angular（脏检查机制），特点是直接使用原生 JavaScript 来操作 viewModel，但脏检查机制随之带来的就是性能问题 Vue（数据劫持，也就是 Object.defineProperty），会把定义的 viewModel 对象（即 data 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 JavaScript 操作对象，又可以主动触发 propertyChange 事件，效率虽高，但也有一些限制，见后文 另外的几种方式 Object.observe，谷歌对于简化双向绑定机制的尝试，在 Chrome 49 中引入，然而由于性能等问题，并没有被其他各大浏览器及 ES 标准所接受，所以在后续版本当中移除了该方法的实现 Proxy，是 ES6 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程，它的其中一个作用就是用于（部分）替代 Object.observe 以实现双向绑定 基于数据劫持实现的双向绑定数据劫持比较好理解，通常我们利用 Object.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作 12345678910111213141516171819202122// 这是将要被劫持的对象const data = { name: '',}// 遍历对象,对其属性值进行劫持Object.keys(data).forEach(function (key) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { console.log(`get`) }, set: function (newValue) { // 当属性值发生变化时我们可以进行额外操作 console.log(`set`) console.log(newValue) }, })})data.name = 'new name' 数据劫持的优势以及实现思路目前业界分为两个大的流派，一个是以 React 为首的单向数据绑定，另一个是以 Angular、Vue 为主的双向数据绑定，两者主要有两点区别 无需显示调用，例如 Vue 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 Angular 的脏检测或是 React 需要显示调用 setState 可精确得知变化数据，例如上面的例子，我们劫持了属性的 setter，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 diff 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 diff 来找出变化值，这是额外性能损耗 本质上，基于数据劫持的双向绑定离不开 Proxy 与 Object.defineProperty 等方法对对象或者对象属性的劫持，我们要实现一个完整的双向绑定需要以下几个要点 利用 Proxy 或 Object.defineProperty 生成的 Observer 针对对象或者对象的属性进行劫持，在属性发生变化后通知订阅者 解析器 Compile 解析模板中的 Directive（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁，它将接收到的 Observer 产生的数据变化，并根据 Compile 提供的指令进行视图渲染，使得数据变化促使视图变化 基于 Object.defineProperty 双向绑定 这里引用了 剖析 Vue 原理 &amp;&amp; 实现双向绑定 MVVM 当中的部分内容，更为完整的实现可以见原文 我们仔细观察上面的示例，其实可以发现，里面是存在着一堆问题的，比如在上面的示例当中，我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等 我们可以参考 Vue 的实现方式，Vue 是采用数据劫持结合发布者订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter/getter，在数据变动时发布消息给订阅者，触发相应的监听回调，简单来说，主要有下面几个步骤 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter/getter，这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是 在自身实例化时往属性订阅器（dep）里面添加自己 自身必须有一个 update() 方法 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，所以最终便可以达到达到 数据变化 ==&gt; 视图更新 和 视图交互变化（input） ==&gt; 数据 model 变更 的双向绑定效果 下面是一个完成的例子 12345&lt;main&gt; &lt;p&gt;请输入:&lt;/p&gt; &lt;input type=\"text\" id=\"input\"&gt; &lt;p id=\"p\"&gt;&lt;/p&gt;&lt;/main&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它const Vue = (function() { let uid = 0 // 用于储存订阅者并发布消息 class Dep { constructor() { this.id = uid++ // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher this.subs = [] // 储存订阅者的数组 } // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身 depend() { Dep.target.addDep(this) } // 添加订阅者 addSub(sub) { this.subs.push(sub) } notify() { // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()) } } // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher Dep.target = null // 现在我们需要实现监听者（Observer），用于监听属性值的变化 // 监听者，监听对象属性值的变化 class Observer { constructor(value) { this.value = value this.walk(value) } // 遍历属性值并监听 walk(value) { Object.keys(value).forEach(key =&gt; this.convert(key, value[key])) } // 执行监听的具体方法 convert(key, val) { defineReactive(this.value, key, val) } } function defineReactive(obj, key, val) { const dep = new Dep() // 给当前属性的值添加监听 let chlidOb = observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: () =&gt; { // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中 // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者 // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法 if (Dep.target) { dep.depend() } return val }, set: newVal =&gt; { if (val === newVal) return val = newVal // 对新值进行监听 chlidOb = observe(newVal) // 通知所有订阅者，数值被改变了 dep.notify() }, }) } function observe(value) { // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== 'object') { return } return new Observer(value) } // 我们还需要实现一个订阅者（Watcher） class Watcher { constructor(vm, expOrFn, cb) { this.depIds = {} // hash 储存订阅者的 id，避免重复的订阅者 this.vm = vm // 被订阅的数据一定来自于当前 Vue 实例 this.cb = cb // 当数据更新时想要做的事情 this.expOrFn = expOrFn // 被订阅的数据 this.val = this.get() // 维护更新之前的数据 } // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用 update() { this.run() } addDep(dep) { // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存 // 此判断是避免同 id 的 Watcher 被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) { dep.addSub(this) this.depIds[dep.id] = dep } } run() { const val = this.get() console.log(val) if (val !== this.val) { this.val = val this.cb.call(this.vm, val) } } get() { // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this const val = this.vm._data[this.expOrFn] // 置空，用于下一个 Watcher 使用 Dep.target = null console.log(Dep.target, 2) return val } } // 将上述方法挂载在 Vue 上 class Vue { constructor(options = {}) { // 简化了 $options 的处理 this.$options = options // 简化了对 data 的处理 let data = (this._data = this.$options.data) // 将所有 data 最外层属性代理到 Vue 实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)) // 监听数据 observe(data) } // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) { new Watcher(this, expOrFn, cb) } _proxy(key) { Object.defineProperty(this, key, { configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; { this._data[key] = val }, }) } } return Vue})()// 使用let demo = new Vue({ data: { text: '', },})const p = document.getElementById('p')const input = document.getElementById('input')input.addEventListener('keyup', function(e) { demo.text = e.target.value});demo.$watch('text', str =&gt; p.innerHTML = str) Object.defineProperty 的缺陷其实我们升级版的双向绑定依然存在漏洞，比如我们将属性值改为数组 1234567891011121314151617181920212223242526272829303132let demo = new Vue({ data: { list: [1], },})const list = document.getElementById('list')const btn = document.getElementById('btn')btn.addEventListener('click', function () { demo.list.push(1)})const render = arr =&gt; { const fragment = document.createDocumentFragment() for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li') li.textContent = arr[i] fragment.appendChild(li) } list.appendChild(fragment)}// 监听数组，每次数组变化则触发渲染函数，然而却无法监听demo.$watch('list', list =&gt; render(list))setTimeout( function () { alert(demo.list) }, 5000,) 是的，Object.defineProperty 的第一个缺陷，无法监听数组变化，然而 Vue 的文档提到了 Vue 是可以检测到数组变化的，至于它是如何实现的，其实简单来说，这里就是重写了原来的方法 123456789101112131415161718192021// 首先获取 Array 原型const oldMethod = Object.create(Array.prototype)const newMethod = []['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method =&gt; { // 在 newMethod 上进行方法的重写 // 这里需要注意的是重写的方法是定义在 newMethod 的属性上而不是其原型属性（newMethod.__proto__ 没有改变） newMethod[method] = function () { console.log(`监听到数组的变化`) return oldMethod[method].apply(this, arguments) }})let list = [1, 2]// 将需要监听的数组的原型指针指向我们重新定义的新对象list.__proto__ = newMethodlist.push(3)// 如果不设定指向，则默认使用原生的方法let list2 = [1, 2]list2.push(3) 由于只针对了特定几种方法进行了 hack，所以其他数组的属性也是检测不到的，我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 Object.defineProperty 的第二个缺陷，只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是需要消耗不少性能的 1Object.keys(value).forEach(key =&gt; this.convert(key, value[key])) Proxy 实现的双向绑定Proxy 在 ES2015 规范中被正式发布，它在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写，我们可以这样认为 Proxy 是 Object.defineProperty 的全方位加强版，Proxy 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 Object.defineProperty Proxy 可以直接监听数组的变化当我们对数组进行操作（push、shift、splice 等）时，会触发对应的方法名称和 length 的变化，下面是一个实例 12345&lt;main&gt; &lt;ul id=\"list\"&gt; &lt;/ul&gt; &lt;button type=\"button\" name=\"button\" id=\"btn\"&gt;添加列表项&lt;/button&gt;&lt;/main&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const list = document.getElementById('list')const btn = document.getElementById('btn')// 渲染列表const Render = { // 初始化 init: function(arr) { const fragment = document.createDocumentFragment() for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li') li.textContent = arr[i] fragment.appendChild(li) } list.appendChild(fragment) }, // 我们只考虑了增加的情况，仅作为示例 change: function(val) { const li = document.createElement('li') li.textContent = val list.appendChild(li) },};// 初始数组const arr = [1, 2, 3, 4]// 监听数组const newArr = new Proxy(arr, { get: function(target, key, receiver) { console.log(key) return Reflect.get(target, key, receiver) }, set: function(target, key, value, receiver) { console.log(target, key, value, receiver) if (key !== 'length') { Render.change(value) } return Reflect.set(target, key, value, receiver) },})// 初始化window.onload = function() { Render.init(arr)}// push 数字btn.addEventListener('click', function() { newArr.push(6)}) Proxy的优势Proxy 有多种拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等，是 Object.defineProperty 不具备的，Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改","link":"/2018/07/10/JavaScript/29/"},{"title":"Zepto 架构设计","text":"最近看了 zepto 设计和源码分析 ，感觉有耳目一新的感觉，作者没有老套的去讲各个方法怎么实现的，能做些什么，而是讲了许多为什么源码要这样去设计，这样设计有什么好处，也分享了一些自己的看源码心得 一口气看完，收货良多，不光了解了 Zepto 的设计理念，同时也重温了 JavaScript 原型链的一些相关知识，在此记录一些笔记和涉及到的一些知识点，同时也感谢作者分享了加注版本的 zepto 源码，这样读起来也轻松不少，地址见 zepto-core-1.1.6 源码注视 大体结构看了以后会发现，这一类库的最外层的设计都是大同小异的 123456789101112131415161718192021222324252627282930313233343536var Zepto = (function () { var $, zepto = {} // ... // 一些判断方法，初始化操作 zepto.init = function (selector, context) { // ... return zepto.Z(dom, selector) } $ = function (selector, context) { return zepto.init(selector, context) } // ... // 一些挂载在 $ 上的方法，比如 $.each，$.map 等 // 这里是一些挂载在 $.fn 上的方法 $.fn = { ... } zepto.Z.prototype = $.fn // ... return $})()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 首先，Zepto 是一个自执行的匿名函数（IIFE），最后挂载在 window 对象身上，window.Zepto 和 window.$ 都赋值给了 Zepto 这个变量，当我们平时在使用的时候，比如 $('div')，依次会按照以下顺序来执行 123456789101112131415161718192021$ = function(selector, context){ return zepto.init(selector, context)}==&gt;zepto.init = function(selector, context) { // ... return zepto.Z(dom, selector)}==&gt;zepto.Z = function(dom, selector) { dom = dom || [] dom.__proto__ = $.fn dom.selector = selector || '' return dom} 接下来，我们分步来看 zepto.init查看源码可以发现，其实 $ 也是一个函数（同理也可得知 Zepto 也是一个函数） 123$ = function(selector, context){ return zepto.init(selector, context)} 它本身并没没有做什么具体的操作，而是直接返回了一个函数 zepto.init(selector, context)，查看源码可知，init 函数中添加了一系列判断来梳理 selector 参数的各种可能，然后根据不同条件下对 DOM 变量进行赋值，最终，它将通过 selector 一起传递给 zepto.Z 函数并返回值，我们一条一条的来看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768zepto.init = function (selector, context) { var dom // 如果 selector 为空（null，undefined...），即 $() 那么就直接返回一个空的 Zepto 对象 if (!selector) return zepto.Z() // 参数是 String 的情况（$('p')，$('&lt;div&gt;')） else if (typeof selector == 'string') { // 字符串的情况，一般有两种 // 第一，一段 html 代码，旨在通过 zepto 生成 dom 对象 // 第二，一段查询字符串，旨在通过 zepto 查找 dom 对象 // 将查询结果存储到 dom 变量中 // 先剔除掉两边的空格 selector = selector.trim() // fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/ // 取出 html 代码中第一个 html 标签（或注释），如取出 &lt;p&gt;123&lt;/p&gt;&lt;h1&gt;345&lt;/h1&gt; 中的 &lt;p&gt; if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) // 第一，RegExp.$1 取出来的就是第一个标签名称，即正则中 (\\w+|!) 对应的内容 // 第二，此时的 context 应该传入的是 css 属性对象（这里会产生歧义，老版的不会传入 context） dom = zepto.fragment(selector, RegExp.$1, context), selector = null // 如果 selector 不是 html 字符串标签，并且 context 有值，则从 context 中查找 else if (context !== undefined) return $(context).find(selector) // 除了以上情况，就从整个 document 执行 qsa 的查找 // qsa 就是 document.querySelectAll else dom = zepto.qsa(document, selector) } // 如果是函数，则放在 dom ready 时执行 // 即 $(document).ready(function(){ ... }) else if (isFunction(selector)) return $(document).ready(selector) // 如果传入的参数本身就已经是 zepto 对象，则直接返回 else if (zepto.isZ(selector)) return selector else { // compact 函数，剔除数组中 == null（undefined） 的元素 if (isArray(selector)) dom = compact(selector) // 如果传入的是 object，直接强制塞进一个数组 else if (isObject(selector)) dom = [selector], selector = null // 从此往下，和上文 selector 是字符串的情况处理相同 // fragmentRE.test 即判断字符串是否是 html 标签开头（即是否是 html fragement） else if (fragmentRE.test(selector)) // 此时，context 也是属性集合，不是容器（这里会产生歧义，老版的不会传入 context） // 然后清空 selector 不妨碍下面的判断 dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null else if (context !== undefined) return $(context).find(selector) else dom = zepto.qsa(document, selector) } // 最后通过 zepto.Z 创建了对象 // 这里的 dom 其实就是一个数组 return zepto.Z(dom, selector)} 最后 init 函数的结构梳理如下 1234567891011121314zepto.init = function (selector, context) { var dom // 分情况对 dom 赋值 // 1. selector 为空 // 2. selector 是字符串，其中又分好几种情况 // 3. selector 是函数 // 4. 其他情况，例如 selector 是数组、对象等 // 最后返回 return zepto.Z(dom, selector)} zepto.Z先来看看之前的 zepto.Z 的实现 12345678910111213zepto.Z = function (dom, selector) { // 首先，dom 是一个数组 dom = dom || [] // 然后把它的隐式原型（__proto__）赋值给 $.fn dom.__proto__ = $.fn dom.selector = selector || '' return dom} 首先需要明确，每一个函数，都有一个 prototype 的属性，同时又有一个 constructor 属性，指向该函数自身，如下图所示 所有通过函数 new 出来的对象，都有一个 __proto__（隐式原型）指向这个函数的 prototype（显式原型） 12var arr = [] // 相当于 new Array()arr.__proto__ === Array.prototype // true 所以当你想要使用一个对象（或者一个数组）的某个功能时 如果该对象本身具有这个功能，则直接使用 如果该对象本身没有这个功能，则去 __proto__ 中找（即构造函数的原型链上） 这就是为何数组会有 concat、push 等方法，因为这些方法都存在于 Array.prototype 中，这也就解释了为什么 Zepto 取得的元素数组（$('p') 返回的是一个元素数组）上会有类似 addClass 等方法了，原因就是 __proto__ 肯定是被修改过的，而不仅仅是 Array.prototype，这样再去看上面的 zepto.Z 函数就很明了了，新版的 zepto.Z 函数如下 12345678910111213141516function Z(dom, selector) { var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || ''}zepto.Z = function (dom, selector) { return new Z(dom, selector)}$.fn = { // ...}zepto.Z.prototype = Z.prototype = $.fn 相较于老版，新版的 zepto.Z 函数直接将构造函数的原型修改了，即 Z.prototype = $.fn，经过这样一改，构造函数再 new 出来的对象的隐式原型 __proto__ 自然就指向了 $.fn，而这时返回的是一个『对象数组』，相对于之前的单纯数组，本质上更灵活一些 区别如下之前的 zepto.Z 函数 现在的 zepto.Z 函数 Zepto 整体的设计就是以上这些了，明白了 __proto__（隐式原型）和 prototype（显式原型）再来看的话就会清晰不少，其他各个函数，方法的实现，就慢慢去读源码来摸索认识了","link":"/2019/05/28/JavaScript/34/"},{"title":"遍历对象的几种方法","text":"在 JavaScript 当中遍历对象方式有许多种，比如常见的 for-in 和 Object.keys(obj) 等等，但是对于它们之间的区别一直有些模糊，所以今天就抽些时间将 JavaScript 当中涉及到遍历对象的 API 整体的梳理了一遍，看看它们的使用方式和之间的区别，先来小小的总结一下，大致有以下几种 方法 return prototype Symbol 如果参数不是对象 Object.keys(obj) 返回所有可枚举属性 不包括 不含 ES6 之前报错，之后强制转换为对象 for-in 返回所有可枚举属性 包括 不含 ES6 之前报错，之后强制转换为对象 Object.getOwnPropertyNames(obj) 返回所有自身属性，也包括不可枚举属性，如果是数组，那么 length 属性也包含其中 不包括 不含 ES6 之前报错，之后强制转换为对象 Reflect.ownKeys(obj) 返回所有自身属性，不管是否可枚举，不管是不是 Symbol，一律返回 包括 包含 报错 for-of 返回当前对象上的每一个属性（迭代） 不包括 不含 普通的对象不能直接使用 for-of，否则会报错，必须部署了 iterator 接口才能使用，可以考虑使用 Object.entries(obj) 通过上表可以发现，Reflect.ownKeys(obj) 这个方法很强大，因为它可以返回所有自身属性，不管是否可枚举，不管是不是 Symbol，一律返回，下面我们就一个一个来看看它们之间的区别 Object.keys(obj)Object.keys(obj) 方法返回一个表示给定对象的所有可枚举属性的字符串数组，注意这里是可枚举属性，它包括对象自身的所有可枚举属性，但是不包含继承而来的属性，也不包含 Symbol 属性，使用如下 1234567var arr = ['a', 'b', 'c']console.log(Object.keys(arr)) // ['0', '1', '2']// -------------------------------var an_obj = { 100: 'a', 2: 'b', 7: 'c' }console.log(Object.keys(an_obj)) // ['2', '7', '100'] 它的参数如果不是一个对象，那么在 ES6 之前报错，之后会强制转换为对象，返回的是一个表示给定对象的所有可枚举属性的字符串数组（但不包括原型中的属性），这里有一个需要注意的地方，即使用 Object.keys(obj) 循环遍历对象时返回的顺序不一定正确，至于为什么会这样，可以参考 为什么 Object.keys 的返回值会自动排序 这篇文章 for-infor-in 语句以任意顺序遍历一个对象的可枚举属性，对于每个不同的属性，语句都会被执行 123456var c = Symbol('c')var obj = { a: 1, b: 2, [c]: 3 }for (var prop in obj) { console.log(prop) // a b} 它将返回所有可枚举属性，包括原型中的属性，但是不包含 Symbol 属性，如果参数不是一个对象，在 ES6 之前报错，之后会强制转换为对象，for-in 循环只遍历『可枚举』属性，循环将迭代对象的所有可枚举属性和从它的构造函数的 prototype 继承而来的（包括被覆盖的内建属性，即包括原型中的属性），但是因为其返回值的顺序问题，它不应该被用来迭代一个下标顺序很重要的 Array，同 Object.keys(obj) 一样，for-in 并不能够保证返回的是按一定顺序的索引，如果仅迭代自身的属性，而不是它的原型，可以使用 getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组 hasOwnProperty() 来确定某属性是否是对象本身的属性（一般使用这个来过滤） propertyIsEnumerable() 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性 Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames() 方法返回一个由指定对象的所有自身属性的属性名，『包括』不可枚举属性组成的数组，但不会获取原型链上的属性，如果参数不是一个对象，在 ES6 之前报错，之后会强制转换为对象 123var arr = ['a', 'b', 'c']console.log(Object.getOwnPropertyNames(arr).sort()) // ['0', '1', '2', 'length'] 它会返回所有的自身属性，不包括原型中属性，不含 Symbol 属性，但是它与前两种方式不同的是，它会包括不可枚举的属性 length，它枚举属性的顺序与通过 for-in 循环（或 Object.keys()）迭代该对象属性时是一致的，如果只获取到可枚举属性，使用 Object.keys() 或用 for-in 循环（配合 hasOwnProperty()） Reflect.ownKeys静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组，这个方法在之前也提到过了，十分强大，它会返回一个数组，里面包含了对象的所有自身属性，不管是否可枚举，不管是不是 Symbol，一律返回，参数不是一个对象的话，那么会抛出一个错误 123Reflect.ownKeys({ z: 3, y: 2, x: 1 }) // [ 'z', 'y', 'x' ]Reflect.ownKeys([]) // ['length'] 它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)) for-offor-of 语句在可迭代对象（包括 Array，Map，Set，string，TypedArray，arguments 对象等）上创建一个迭代循环，对每个不同属性的属性值，调用一个自定义的有执行语句的迭代挂钩 所谓的 TypedArray，它描述的是一个底层的二进制数据缓存区的一个类似数组（array-like）视图 12345678910111213141516171819let iterable = [10, 20, 30]for (let value of iterable) { console.log(value)}// 10// 20// 30//-----------------------------let iterable = 'foo'for (let value of iterable) { console.log(value)}// 'f'// 'o'// 'o' for-of 会返回当前对象上的每一个属性，遍历的是『当前对象』上的每一个属性值，不包括原型上的，但是并不适用于所有的 Object，只能迭代出拥有 iterator 的对象，通过观察上面的例子我们可以发现，我们在其中分别使用的是数组跟字符串，这两者都是默认部署了 Iterator 接口，所以可以使用 for-of 来进行遍历，那么对于普通的对象会是什么情况呢，我们来看下面这个例子 123456var c = Symbol('c')var obj = { a: 1, b: 2, [c]: 3 }for (let [key, value] of obj) { console.log(`${key}: ${value}`) // TypeError: obj is not iterable} 运行以后可以发现，对于普通的对象，for-of 不能直接使用，否则会报错，在这种情况下，我们可以使用 Object.entries() 来将我们的对象包裹一下即可（当然，你也可以手动的为对象添加 Iterator 接口），该方法返回一个给定对象『自身可枚举』属性的键值对数组，其排列与使用 for-in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性），因为返回的是数组，所以具有 Iterator 接口可以直接被 for-of 遍历 123456for (let [key, value] of Object.entries(obj)) { console.log(`${key}: ${value}`)}// a: 1// b: 2 Object.getOwnPropertySymbols()最后我们再来看一个比较特殊的方法，因为在上面列举的一些 API 当中我们可以发现，其中有很多方法的输出结果都是不包括 Symbol 属性的，所以 JavaScript 提供了一个 Object.getOwnPropertySymbols() 方法，专门用来返回一个给定对象自身的所有 Symbol 属性的数组 但是有一点需要注意，所有的对象在初始化的时候不会包含任何的 Symbol，除非你在对象上赋值了 Symbol，否则 Object.getOwnPropertySymbols() 只会返回一个空的数组，我们还是使用 Reflect.ownKeys(target) 当中的例子来进行对比说明，如下 123456789101112131415let a = Symbol.for('a')let b = Symbol.for('b')let obj = { [a]: 10, [b]: 20, key1: 30, key2: 40}Object.getOwnPropertyNames(obj) // [ 'key1', 'key2' ]Object.getOwnPropertySymbols(obj) // [ Symbol(a), Symbol(b) ]Reflect.ownKeys(obj) // [ 'key1', 'key2', Symbol(a), Symbol(b) ]","link":"/2019/06/28/JavaScript/35/"},{"title":"IntersectionObserver","text":"按照惯例，我们先来看看 IntersectionObserver 到底是个什么东西，MDN 上的介绍的是，IntersectionObserver 接口（从属于 Intersection Observer API），提供了一种异步观察目标元素与其祖先元素或顶级文档视窗（viewport）交叉状态的方法，祖先元素与视窗（viewport）被称为根（root） 当一个 IntersectionObserver 对象被创建时，其被配置为监听根中一段给定比例的可见区域，一旦 IntersectionObserver 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值，然而你可以在同一个观察者对象中配置监听多个目标元素 看上去云里雾里的，其实简单的总结一下，所谓的 IntersectionObserver 说的就是一种监听目标元素与其祖先或视窗交叉状态的手段，也就是观察一个元素是否在视窗可见 如上图，交叉了就是说明当前元素在视窗里，当前就是可见的了，但是有一点特别需要注意的就是，必须是子元素跟父（祖先）元素发生交叉，如果你想检查两个非父子关系的交叉，是不可以的 本文所有示例可见 IntersectionObserver 基本概念先来看看如何使用，使用方式很简单 1234const io = new IntersectionObserver(callback, options)io.observe(element) // 观察元素io.unobserve(element) // 停止观察io.disconnect() // 关闭观察器 下面我们就来详细介绍具体的配置参数 构造函数1new IntersectionObserver(callback, options) 其实就是一个简单的构造函数，它会返回一个 IntersectionObserver 实例，接收两个参数 callback，是当元素的可见性变化时候的回调函数 options，是一些配置项（可选的） callback当元素的可见性变化时，就会触发 callback 函数，callback 函数会触发两次，元素进入视窗（开始可见时）和元素离开视窗（开始不可见时）都会触发，它接受一个 entries 参数，返回当前已监听并且发生了交叉的目标集合 12345var io = new IntersectionObserver((entries) =&gt; { console.log(entries)})io.observe(document.body) 运行结果如下（$0 表示上一次审查元素的选择的节点） 我们可以看到 callback 函数有个 entries 参数，它是个 IntersectionObserverEntry 对象数组，各个属性如下 属性 解释 boundingClientRect 目标元素的矩形信息 intersectionRatio 相交区域和目标元素的比例值 intersectionRect/boundingClientRect，不可见时小于等于 0 intersectionRect 目标元素和视窗（根）相交的矩形信息，可以称为相交区域 isIntersecting 目标元素当前是否可见值，如果可见则为 true rootBounds 根元素的矩形信息，没有指定根元素就是当前视窗的矩形信息 target 观察的目标元素 time 返回一个记录从 IntersectionObserver 的时间到交叉被触发的时间的时间戳 如下图所示 options几个比较常用的参数如下 root 用于观察的根元素，默认是浏览器的视口，也可以指定具体元素，指定元素的时候用于观察的元素必须是指定元素的子元素 threshold 用来指定交叉比例，决定什么时候触发回调函数，是一个数组，默认是 [0] 1234567const options = { root: null, threshold: [0, 0.5, 1]}var io = new IntersectionObserver(callback, options)io.observe(document.querySelector('img')) 上面代码，我们指定了交叉比例为 [0, 0.5, 1]，当观察元素 img 处于 0%、50%、100% 时候就会触发回调函数 rootMargin 用来扩大或者缩小视窗的的大小，使用 CSS 的定义方法，10px 10px 30px 20px 表示 top、right、bottom 和 left 的值 12345const options = { root: document.querySelector('.box'), threshold: [0, 0.5, 1], rootMargin: '30px 100px 20px'} 为了方便理解，可以参考下图 首先我们先来看看上图当中的蓝线部分，它就是我们定义的 root 元素，我们添加了 rootMargin 属性，将视窗的增大了，虚线就是现在的视窗，所以元素现在也就在视窗里面了，简单来说就是自定义元素进入视窗的距离，由此可见，root 元素只有在 rootMargin 为空的时候才是绝对的视窗 实际应用在了解完 IntersectionObserver 的相关概念之后，我们来看几个具体的实例，本文所有示例可见 IntersectionObserver 监听元素先来看一个最简单的示例，主要代码如下 123456789let box = document.querySelector('.box')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { let tips = item.isIntersecting ? `进入` : `离开` console.log(tips) })})observe.observe(box) 结果如下图所示 打开控制台可以发现，每次当元素进入或者离开可视区的时候，控制台当中就会输出对应的字段，我们再来稍微的调整一下，将一个元素替换为多个元素，代码如下 1234let box02 = document.querySelectorAll('.box')let observe02 = new IntersectionObserver(entries =&gt; console.log(`发生交叉行为，目标元素个数为 ${entries.length} 个`))box02.forEach(item =&gt; observe02.observe(item)) 结果如下图所示 根据上图可以发现，虽然元素变成了三个，但是每次发生交叉的时候是一起发生的，再来调整一下，同样还是三个元素，但是排列方式不一样，结果如下图所示 可以发现，在这种情况之下每个目标轮流发生交叉，且当前只触发了一个，所以每次返回的集合长度只有一，如果想指定监听父元素，可以使用 root 参数 1234567891011let box = document.querySelector('.box')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { let tips = item.isIntersecting ? `进入` : `离开` console.log(tips) })}, { root: document.querySelector('.wrapper')})observe.observe(box) 现在我们已经基本了解了 IntersectionObserver 的一些基本用法，下面我们就来看一些实际场景当中的应用 图片懒加载以前的做法是监听浏览器滚动，然后遍历拿到每个图片的空间信息，然后判断一些位置信息从而进行图片加载，而现在只需要交给交叉观察者去做，页面布局如下 12345678&lt;!-- 多个 img 元素 --&gt;&lt;img src=\"https://via.placeholder.com/200x130\" data-origin=\"图片真实地址\"&gt;&lt;img src=\"https://via.placeholder.com/200x130\" data-origin=\"图片真实地址\"&gt;// ...&lt;img src=\"https://via.placeholder.com/200x130\" data-origin=\"图片真实地址\"&gt;&lt;img src=\"https://via.placeholder.com/200x130\" data-origin=\"图片真实地址\"&gt; 然后针对图片列表进行监听 123456789101112let images = document.querySelectorAll('img')let observe = new IntersectionObserver(entries =&gt; { entries.forEach(item =&gt; { // 如果目标元素当前可见，则加载图片资源 if (item.isIntersecting) { item.target.src = item.target.dataset.origin observe.unobserve(item.target) } })})images.forEach(item =&gt; observe.observe(item)) 效果如下，只有当对应图片进入可视区以后才会进行加载 也可以通过设置 rootMargin，来自定义图片进入视窗多少距离以后在进行加载，另外，使用该方法如果是横向滚动懒加载一样是可以使用的 传统的懒加载只是监听全局滚动条的滚动，因为它并不是判断目标是否出现在视窗，所以横向的图片会一起加载，即使你没有向左滑动，所以这也是交叉观察者的一大优点 触底使用交叉观察者可以让我们轻松实现滚动到底部自定加载的功能，我们首先在列表底部放一个参照元素，然后使用交叉观察者去监听，布局如下 1234567891011121314&lt;div class=\"box\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;!-- 参照元素 --&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; class 为 footer 的元素就作为我们的参照元素，下面就可以对其进行监听 123456new IntersectionObserver(entries =&gt; { // 这里使用 forEach 也可，但是我们的示例只有一个，直接使用也行 if (entries[0].isIntersecting) { console.log(`滚动到了底部！`) }}).observe(document.querySelector('.footer')) 结果如下 动画展示一个比较常见的效果，即当某个元素或者列表出现的时候就给该元素或者列表加个动画，比如渐变、偏移等，下面我们就来实现看看，首先是页面布局，跟上面的示例其实差不多，但是这里采用两列，主要 CSS 如下 1234567891011121314151617181920212223242526272829li.show { animation: left 1s ease;}li.show:nth-child(2n) { animation: right 1s ease;}@keyframes left { from { opacity: 0; transform: translate(-40px, 40px); } to { opacity: 1; }}@keyframes right { from { opacity: 0; transform: translate(40px, 40px); } to { opacity: 1; }} 最终效果如下 兼容性IntersectionObserver 的兼容性可见下图 从上图可以发现，IE 是不兼容的，但是官方提供了 polyfill，详细可见 IntersectionObserver 参考 Intersection Observer Intersection Observer API IntersectionObserver API 使用教程 Intersection Observer v2 IntersectionObserver","link":"/2019/09/22/JavaScript/46/"},{"title":"函数防抖和节流","text":"关于防抖和节流，是一个老生常提的话题了，随便在网上搜一搜，都可以找到现成可以使用的函数，但是现成的函数的功能实现的都是已经比较完善的了，我们并不清楚它如何或者为什么要这样设计，所以我们今天就从头开始的来深入的了解一下这两个方法，主要参考的是 Lodash 当中的 _.throttle 和 _.debounce 两个方法 什么是防抖和节流我们可以使用一个现实中常见的例子来进行举例，比如使用电梯运送策略来说明这两个方法，比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 throttle 和 debounce ，超时设定为 15 秒，不考虑容量限制 throttle 策略的电梯，保证如果电梯第一个人进来后，15 秒后准时运送一次，不等待，如果没有人，则待机 debounce 策略的电梯，如果电梯里有人进来，等待 15 秒，如果有人进来，15 秒等待重新计时，直到 15 秒超时，开始运送 但是有一点需要注意，当然你也可以采用箭头函数等一些 ES6 当中的方式来进行实现，但是本文大部分都是采用 ES5 的方式来进行介绍，主要是以介绍原理为主 我们先从防抖开始看起 debounce防抖即 debounce，根据我们之前的思路，我们可以迅速的实现我们的第一版代码 12345678// 第一版function debounce(fn, wait) { var timer return function () { clearTimeout(timer) timer = setTimeout(fn, wait) }} 运行以后可以发现，是存在问题的，函数当中的 this 是指向 window 对象的，所以我们需要将 this 指向正确的对象，所以针对于这种情况，我们可以使用一个变量来保存当前的 this 注意，这里如果使用了箭头函数则直接传递 this 即可，因为箭头函数会从自己的作用域链的上一层继承 this 1234567891011// 第二版function debounce(fn, wait) { var timer return function () { var that = this clearTimeout(timer) timer = setTimeout(function() { fn.apply(that) }, wait) }} 但是现在依然是存在一定问题的，因为我们传入的 fn 是有可能携带参数的，所以我们需要将其补上，也就有了下面的第三版 123456789101112// 第三版function debounce(fn, wait) { var timer return function () { // 注意保存 arguments，防止 setTimeout 当中获取不到参数 var that = this, args = arguments clearTimeout(timer) timer = setTimeout(function() { fn.apply(that, args) }, wait) }} 目前为止，我们已经完成了一个较为完善的方法，但是现在的需求有所变化，我们不希望非要等到事件停止触发后才执行我们的函数，而是希望可以在开始的时候立刻执行函数，然后等到停止触发 wait 秒后，才可以重新触发执行，所以针对这种情况，我们添加一个 immediate 参数判断是否是立刻执行，如果 immediate 参数传递为 true，则每隔 wait 秒后才会再次执行 1234567891011121314151617181920// 第四版function debounce(fn, wait, immediate) { var timer return function () { var that = this, args = arguments if (timer) clearTimeout(timer) if (immediate) { // 如果已经执行过，便不再执行 var callNow = !timer // ==&gt; 第一点 timer = setTimeout(function () { // ==&gt; 第二点 timer = null }, wait) if (callNow) fn.apply(that, args) } else { timer = setTimeout(function () { fn.apply(that, args) }, wait) } }} 关于文中标注的两点需要注意的地方，第一点 timer 是闭包变量，初始化时是 undefined，setTimeout 返回的是定时器的 id ，一个大于 0 的数字，而 clearTimeout 不会改变 timer 的值 若 timer 经历过赋值，即执行过 setTimeout，则 !timer 为假，所以也就不再执行 关于第二点，在官方源码当中有提到，主要作用就是防止重复点击用的 Pass true for the immediate argument to cause debounce to trigger the function on the leading instead of the trailing edge of the wait interval. Useful in circumstances like preventing accidental double-clicks on a “submit” button from firing a second time. 我们在之前考虑到了我们传入的函数 fn 是可能带有参数的，但是同样的，它也有可能会有返回值的，但是当 immediate 为 false 的时候，因为使用了 setTimeout，我们将 fn.apply(that, arguments) 的返回值 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果，所以直接定义一个 result 进行接收以后在返回即可 1234567891011121314151617181920// 第五版function debounce(fn, wait, immediate) { var timer, result return function () { var that = this, args = arguments if (timer) clearTimeout(timer) if (immediate) { var callNow = !timer timer = setTimeout(function () { timer = null }, wait) if (callNow) result = fn.apply(that, args) } else { timer = setTimeout(function () { fn.apply(that, args) }, wait) } return result }} 最后，我们再来考虑一点小需求，即我们希望可以取消 debounce 函数，比如我们设定了 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样一来，只有等待 10 秒后才能重新触发事件，所以我们希望有一个按钮，点击后可以取消防抖，这样再去触发，就可以又立刻执行，所以我们可以使用一个函数将 return 的部分包裹起来，然后给它添加一个取消的句柄即可 123456789101112131415161718192021222324252627// 第六版function debounce(fn, wait, immediate) { var timer, result var debounced = function () { var that = this, args = arguments if (timer) clearTimeout(timer) if (immediate) { var callNow = !timer timer = setTimeout(function () { timer = null }, wait) if (callNow) result = fn.apply(that, args) } else { timer = setTimeout(function () { fn.apply(that, args) }, wait) } return result } debounced.cancel = function () { clearTimeout(timer) timer = null } return debounced} 可以使用下面的代码来进行测试 1234567891011121314var mousemove = debounce(function (e) { console.log(e)}, 300)// 绑定监听document.addEventListener('mousemove', mousemove)// 关于取消按钮的用法，因为我们的 debounce 返回的是一个函数var hanle = debounce(log, 10000, true)// 如果想取消的话，直接调用 cancel() 方法即可btn.addEventListener('click', function () { hanle.cancel()}) 至此我们就已经完整实现了一个 debounce 函数，防抖看完之后，我们再来看看节流 throttle同样的逻辑，我们这次采用 throttle 策略来进行实现，基本逻辑如下，我们使用时间戳来进行记录，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于就不执行 123456789101112// 第一版function throttle(fn, wait) { var prev = 0 return function () { var that = this var now = +new Date() if (now - prev &gt;= wait) { fn.apply(that, arguments) prev = now } }} 上面是使用记录时间戳的方式来实现的，下面我们就来看看使用定时器的版本，当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器 12345678910111213// 第二版function throttle(fn, wait) { var timer return function () { var that = this if (!timer) { timer = setTimeout(function () { timer = null fn.apply(that, arguments) }, wait) } }} 可以发现，虽然在实现上很类似我们上面第三版的 debounce，但是它们的原理是有所不同的，先抛开这些，我们来对比一下上面两种实现方式 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 所以我们可以将两者进行结合，即在一开始的时候可以立刻执行，然后在停止触发的时候还能再执行一次 1234567891011121314151617function throttle(fn, wait) { var timer var prev = 0 return function () { var that = this, now = new Date(), args = arguments clearTimeout(timer) if (now - prev &gt;= wait) { fn.apply(that, args) prev = now } else { // 让方法在脱离事件后也能执行一次 timer = setTimeout(function () { fn.apply(that, args) }, wait) } }} 可以使用下面这段代码来进行测试 123456var mousemove = throttle(function (e) { console.log(e)}, 300)// 绑定监听document.addEventListener('mousemove', mousemove) 可以发现在鼠标刚移入的时候就会立即执行，并且在鼠标停止移动以后会在执行一次 总结总结一下大致的使用场景 debounce，特点是它在用户不触发事件的时候，才触发动作，并且抑制了本来在事件中要执行的动作 如果不添加 immediate 参数，一开始是不会立即运行的，一般用于比如 input 输入框的格式验或者提交按钮的点击事件等 throttle，类似于水坝，不能让水流动不了，只能让水流慢些，换言之就是不能让用户的方法都不执行，它会强制函数以固定的速率执行 一般用在比 input，keyup 更频繁触发的事件中，如 resize，touchmove，mousemove，scroll，另外还有动画相关的场景 如果不考虑额外功能，使用下面两种方式即可 123456789101112131415161718192021222324252627function debounce(fn, wait) { var timer return function () { var that = this, args = arguments clearTimeout(timer) timer = setTimeout(function() { fn.apply(that, args) }, wait) }}function throttle(fn, wait) { var timer var prev = 0 return function () { var that = this, now = new Date(), args = arguments clearTimeout(timer) if (now - prev &gt;= wait) { fn.apply(that, args) prev = now } else { timer = setTimeout(function () { fn.apply(that, args) }, wait) } }} 参考 跟着 underscore 学防抖 Lodash - debounce.js 彻底弄懂函数防抖和函数节流","link":"/2020/01/05/JavaScript/49/"},{"title":"Angular 中的依赖注入","text":"在前文（为什么要使用依赖注入）当中，我们简单的介绍了依赖注入的基本概念和 Angular 当中的一个简单的依赖注入实例，所以在本章，我们就来深入的了解一下 Angular 当中的依赖注入到底是什么东西 其实简单来说，依赖注入（DI）就是一种设计模式，它也是 Angular 的核心，在 Angular 当中我们一般使用 Provider 来描述与 Token 关联的依赖对象的创建方式，创建方式有四种，它们分别是 useClass，useValue，useExisting 和 useFactory（前两个也是使用较多的） 基本结构在 @NgModule 的 providers: [] 中，存放的是多个设定注入的元素，也可以称为 provider 的类型，每个 provider 的基本结构如下 1234{ provide: SomeClass, useXXXX: ...} 这里就涉及到两个比较重要的概念 provide: SomeClass，代表要提供的注入内容是什么，这时我们会把设定的类别当作是一个 Token，在之后则是选择要使用这个 Token，而这个 Token 的具体内容到到底是什么？则是由 useXXXX 来决定的 useXXXX: ...，useXXXX 其实是代表了多种设定，也就是上方我们提到的 useClass，useValue，useExisting 和 useFactory 下面我们就一个一个来进行介绍 useClass我们先来看看它的接口定义，ClassProvider 接口定义如下 12345678export interface ClassProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any useClass: Type&lt;any&gt; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean} 这里有一个需要注意的地方，就是 Type&lt;any&gt; 这个类型，在 Angular 当中分为 Type 类型和非 Type 类似，两者的区别主要在于注入方式的不同，即非 Type 类型的参数只能用 @Inject(Something) 的方式注入，接口的定义是下面这样的 12345export interface Type&lt;T&gt; extends Function { new (...args: any[]): T }export function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function'} 下面我们再说回 useClass，通常我们最常用的是 useClass 方法，代表的是使用某个类别，来当做产生 Token 的实体，如下 12345@NgModule({ providers: [ { provide: SomeClass, useClass: AnotherClass } ],}) 当程式内要注入 SomeClass 时，Angular 的核心程式就会改成以 AnotherClass 来建立新的实体，另外当 provide 和 useClass 相同时，可以直接简写，因此以下两段程式码是完全一样的 12345678910111213141516@NgModule({ providers: [ SomeClass ]})// ==&gt; 等同于@NgModule({ providers: [ { provide: SomeClass, useClass: SomeClass } ]}) useValue先来看看它的接口定义，ValueProvider 接口如下 123456789export interface ValueProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any // 设置注入的对象 useValue: any // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean} useValue 一般在设定 API 接口的时候使用较多，如下 123providers: [ { provide: 'SEARCH_URL', useValue: 'http://api.xxx.com'}] 如果需要使用的话，直接在当前组件的构造函数当中进行注入即可，需要注意使用 @Inject() 123constructor( @Inject('SEARCH_URL') private searchUrl) { } 还会遇到一种问题，如果在开发中引入第三方库以后，可能会引起比如上面的字符串 Token（SEARCH_URL）的冲突问题，这时可以使用 InjectionToken 来解决 useExistinguseExisting 的意思是使用已经注册的类型注入到这里（别名），比如下面示例意思是将 ApiService 起个叫 OtherApiService 的别名 123providers: [ { provide: 'OtherApiService', useExisting: ApiService }] useFactory还是先来看看接口定义，如下 1234567891011export interface FactoryProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any // 设置用于创建对象的工厂函数 useFactory: Function // 依赖对象列表 deps?: any[] // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean} useFactory 一般用于比较复杂的情况，简单来说就是告诉 Injector（注入器），通过调用 useFactory 对应的函数，返回 Token 对应的依赖对象，也就是下面这样 1234567891011121314@NgModule({ ... providers: [ { provide: APP_INITIALIZER, useFactory: (config: AppConfig) =&gt; { return () =&gt; config.load() }, deps: [AppConfig], // 关于这个属性，见下方 multi: true } ]}) 在上面的示例当中涉及到一个 multi 属性，关于 Multi providers，它的作用是可以让我们使用相同的 Token 去注册多个 Provider 123456789const SOME_TOKEN: OpaqueToken = new OpaqueToken('SomeToken')var injector = ReflectiveInjector.resolveAndCreate([ provide(SOME_TOKEN, { useValue: 'dependency one', multi: true }), provide(SOME_TOKEN, { useValue: 'dependency two', multi: true })])// dependencies == ['dependency one', 'dependency two']var dependencies = injector.get(SOME_TOKEN) 我们使用 multi: true 来告诉 Angular 的依赖注入系统，我们设置的 provider 是 multi provider，这样一来我们可以使用相同的 Token 值来注册不同的 provider，当我们使用对应的 Token 去获取依赖项的时候，我们获取的是已注册的依赖对象列表 至于为什么要使用 multi provider 的原因，这是因为如果使用同一个 Token 去注册 provider，后面注册的 provider 将会覆盖前面已经注册的 probider，此外，Angular 使用 multi provider 这种机制，为我们提供了可插拔的钩子（pluggable hooks） 另外需要注意的是 multi provider 是不能和普通的 provider 混用的 使用 Provider下面我们就来看看具体如何使用 provider，步骤如下所示 创建 Token 根据实际需求来选择依赖对象的创建方式，如 useClass，useValue，useExisting，useFactory 在 NgModule 或 Component 中注册 providers 使用构造注入的方式，注入与 Token 关联的依赖对象 下面是一个示例，封装 HTTP 服务，比如在每个 HTTP 的请求头中添加 Token（类似拦截器） 123456789101112131415161718192021222324252627282930// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...}// 然后在使用的 Module 当中进行注入@NgModule({ providers: [ { provide: ApiService, usdClass: ApiService } ],})// 然后在组件当中进行注入后使用export class HomePage { constructor( public apiService: ApiService ) {} ngOnInit(): void { this.apiService.get(url) .map(res =&gt; res.json()) .subscribe(v =&gt; { console.log(v) }) }} 下面是一些需要注意的地方 创建 Token 的时候为了避免命名冲突，尽量避免使用字符串作为 Token 若要创建模块内通用的依赖对象，需要在 NgModule 中注册相关的 provider 若在每个组件中都有唯一的依赖对象，就需要在 Component 中注册相关的 provider 当 DI 解析 Providers 时，都会对提供的每个 provider 进行规范化处理，即转换成标准的形式 12345678910111213141516function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] { providers.forEach(b =&gt; { // 支持简洁的语法，转换为标准格式 if (b instanceof Type) { res.push({ provide: b, useClass: b }) } else if (b &amp;&amp; typeof b == 'object' &amp;&amp; (b as any).provide !== undefined) { res.push(b as NormalizedProvider) } else if (b instanceof Array) { // 如果是数组，进行递归处理 _normalizeProviders(b, res) } else { throw invalidProviderError(b) } }) return res} Forward Reference在开发过程中我们可能会遇到类似下面这样的问题 1234567891011121314151617@Injectable()class Socket { constructor(private buffer: Buffer) { }}console.log(Buffer) // undefined@Injectable()class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }}console.log(Buffer) // [Function: Buffer]// 运行后报错// Error: Cannot resolve all parameters for Socket(undefined).// Make sure they all have valid type or annotations 这时因为我们编写的代码最终都会被转义为 ES5 来运行，所以在编译阶段『变量声明和函数声明会自动提升，而函数表达式不会自动提升』 如果要解决上面的问题，最简单的处理方式是交换类定义的顺序，或者还可以使用 Angular 提供的 forward reference 特性，Angular 通过引入 forwardRef 让我们可以在使用构造注入的时候，使用尚未定义的依赖对象类型，如果不使用 forwardRef 就会遇到上面那样的问题 12345678910111213import { forwardRef } from '@angular2/core'@Injectable()class Socket { constructor( @Inject(forwardRef(() =&gt; Buffer)) private buffer ) { }}class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }} forwardRef 原理分析下面我们来看看 forwardRef 到底做了些什么，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// @angular/core/src/di/forward_ref.ts/** * Allows to refer to references which are not yet defined. */export function forwardRef(forwardRefFn: ForwardRefFn): Type&lt;any&gt; { // forwardRefFn: () =&gt; Buffer // 当调用 forwardRef 方法时，我们只是在 forwardRefFn 函数对象上，增加了一个私有属性__forward_ref__ (&lt;any&gt;forwardRefFn).__forward_ref__ = forwardRef // 然后覆写了函数的 toString 方法 (&lt;any&gt;forwardRefFn).toString = function () { return stringify(this()) } return (&lt;Type&lt;any&gt;&gt;&lt;any&gt;forwardRefFn)}/** * Lazily retrieves the reference value from a forwardRef. */// 用来解析通过 forwardRef 包装过的引用值// 由依赖注入系统调用，当解析 Provider 和创建依赖对象的时候，会自动调用该函数// 如下export function resolveForwardRef(type: any): any { if (typeof type === 'function' &amp;&amp; type.hasOwnProperty('__forward_ref__') &amp;&amp; type.__forward_ref__ === forwardRef) { return (&lt;ForwardRefFn&gt;type)() // Call forwardRefFn get Buffer } else { return type }}/********************************************************************/// @angular/core/src/di/reflective_provider.ts/** * 解析Provider */function resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory { let factoryFn: Function let resolvedDeps: ReflectiveDependency[] ... if (provider.useClass) { const useClass = resolveForwardRef(provider.useClass) factoryFn = reflector.factory(useClass) resolvedDeps = _dependenciesFor(useClass) }}/********************************************************************//** * 构造依赖对象 */export function constructDependencies( typeOrFunc: any, dependencies: any[]): ReflectiveDependency[] { if (!dependencies) { return _dependenciesFor(typeOrFunc) } else { const params: any[][] = dependencies.map(t =&gt; [t]) return dependencies.map(t =&gt; _extractToken(typeOrFunc, t, params)) }}/** * 抽取Token */function _extractToken( typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency { token = resolveForwardRef(token) if (token != null) { return _createDependency(token, optional, visibility) } else { throw noAnnotationError(typeOrFunc, params) }} inject 装饰器在 Angular 中，Inject 是『参数装饰器』，主要用来在类的构造函数中描述非 Type 类型的参数对象，在 Angular 中的 Type 类型如下所示 12345678// Type类型 - @angular/core/src/type.tsexport const Type = Functionexport function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function'}export interface Type&lt;T&gt; extends Function { new (...args: any[]): T } Angular 中常用的非 Type 类型 Token 有字符串（常量）、OpaqueToken 对象、InjectionToken 对象等，后两者对象的构造如下 12345678910111213141516171819/** 用于创建 OpaqueToken 实例* export const CONFIG = new OpaqueToken('config')*/export class OpaqueToken { constructor(protected _desc: string) {} toString(): string { return `Token ${this._desc}` }}/** 用于创建 InjectionToken 实例，使用泛型描述该 Token 所关联的依赖对象的类型* const API_URL = new InjectionToken&lt;string&gt;('apiUrl')*/export class InjectionToken&lt;T&gt; extends OpaqueToken { private _differentiate_from_OpaqueToken_structurally: any constructor(desc: string) { super(desc) } toString(): string { return `InjectionToken ${this._desc}` }} 下面是一个 Inject 的简单示例 1234567891011121314151617181920// 公共模块，主要作用是导入 providers，比如我们定义一个常量，用来保存一个地址@NgModule({ providers: [ { provide: 'BASE_CONFIG', useValue: { uri: 'http://localhost:3002' } } ]})// 然后在需要使用的地方使用 @Inject 导入进来即可// 而对于 Http 这种 Type 类型则不需要使用 @Injectconstructor( @Inject('BASE_CONFIG') private config, private http: Http) { // ...} 那么这里就会涉及到几个问题 为什么在构造函数中，非 Type 类型的参数只能用 @Inject(Something) 的方式注入因为只有是 Type 类型的对象，才会被 TypeScript 编译器编译，即我们通过 class 关键字声明的服务，最终都会编译成 ES5 的函数对象 AppService（服务） 中的 @Injectable() 是必须的么如下，一个简单的示例 12345678// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...} 如果所创建的服务不依赖于其他对象，是可以不用使用 @Injectable() 类装饰器，但当该服务需要在构造函数中注入依赖对象，就需要使用 @Injectable() 装饰器，因为只有声明了 @Injectable() 这个装饰器的服务才可以注入其他服务 推荐的做法不管是否有依赖对象，在创建服务时都使用 @Injectable() 类装饰器，这样所有服务都遵循同样的规则，一致性 在构造函数中，Type 类型的参数是否可以使用 @Inject(Type) 的方式注入Type 类型的参数也能使用 @Inject(Type) 的方式注入，具体如下 12345// 虽然可以正常使用，但是编辑器会有提示 [ts] Parameter 'http' implicitly has an 'any' type.constructor(@Inject(Http) private http) { }// 也可以这样使用，但是有些冗余constructor(@Inject(Http) private http: Http) { } 如果是 Type 类型的参数，还是推荐使用下面这样的方式 1constructor(private http: Http) { } 注入器和提供器我们在使用的时候，一般会去定义一个变量用来接收对应的服务 ProductServicr 123constructor( private productServicr: ProductServicr) { } 而在定义的时候，需要在提供器的 providers 属性当中指明 123456789101112providers: [ProjectDirective]// 等价于下面这种写法，因为 provide 和 useClass 两者的属性皆为 ProductServicr，所以可以简写成上面那种形式providers: [{ // provide 属性指定了提供器的 token（key），就是根据这个属性来匹配注入的对象和提供器 // 然后才会根据提供器的 useClass 属性再去具体实例化某个类 provide: ProductServicr, // 指明实例化的方式为 new 操作（因为定义的为 useClass） // 比如上方在 constructor 当中注入的 ProductServicr 就是经过 new 操作之后的 // 如果这里定义为 useClass: AnotherProductServicr 的话就不能使用简写的方式，因为两者不一致 useClass: ProductServicr}] 还可以使用如下方式 12345providers: [{ provide: ProductServicr, // 在这种情况下就不再是直接去执行 new 一个类的操作了，而是通过一个工厂方法返回一个实例，再将这个实例注入到 providers 当中，比如做一些初始化的工作 useFactory: () =&gt; { ... }}] 提供器的作用域规则下面我们来看看提供器的作用域规则，它有以下这些规则 当一个提供器声明在模块当中时（Module），对于该模块下的所有组件是可见的，所有组件都是可以注入的，即在当前模块的 @NgModule 当中的 providers 当中进行注入之后，当前模块下所有组件可用 当一个提供器声明在组件当中时（Component），只对声明它的组件及其子组件可见，其他组件不可注入 当在模块（Module）和组件（Component）当中声明的提供器具有相同的 Token（key）的时候，那么组件当中的提供器会覆盖声明在模块当中的提供器（就近原则） 一般情况下优先将服务提供器声明在模块当中 只有在服务只针对某个组件使用，并且对其他组件不可见的时候，才会声明在组件当中 这种情况十分少见，所以一般推荐声明在模块当中 因为服务最终能不能注入到其他地方，是由它在没有在当前模块的 providers 当中声明来决定的 如果所依赖的服务是动态加载的我们从下面这个示例开始看起，一个随机生成的随机数动态加载对应服务 12345678910111213141516171819202122232425262728// app.module.ts@NgModule({ // ... providers: [{ provide: ProductService, useFactory: () =&gt; { let logger = new LoggerService() let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } } }, LoggerService]})// logger.service.ts，一个简单的打印日志的服务import { Injectable } from '@angular/core'@Injectable()export class LoggerService { constructor() { } log (messgae: string) { console.log(messgae) }} 这里有一点需要注意，如果多个组件共用这个服务，那么生成的实例都是相同的，因为工厂方法创建的对象是一个单例对象，工厂方法只会在创建第一个对象的时候被调用一次，然后在整个应用当中所有被注入的服务的实例都是同一个对象 上面的实例中存在两个问题 第一个问题在方法内部，我们手动实例化了一个 new LoggerService()，意味着工厂方法与这个类是一种强耦合的关系，而我们又声明了 LoggerService 的提供器，所以我们可以采用下面这种方式来解耦，即利用第三个参数 deps 来声明工厂方法所依赖的参数 12345678910111213141516@NgModule({ // ... providers: [{ provide: ProductService, useFactory: (logger： LoggerService) =&gt; { let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService] }, LoggerService]}) 这样一来就不需要我们手动的去实例化（new LoggerService()），这时的 Angular 将会使用 LoggerService 这个提供器来实例化一个 LoggerService 的实例，并将其注入到 ProductService 的工厂方法的参数当中 第二个问题我们是根据一个随机数来决定实例化哪个对象，这样测试是可以的，但是在发布的时候就不适用了，通常在这种情况下，我们可以使用一个变量来决定调用哪个方法，然后同样的在 deps 当中进行依赖声明，然后在当作参数的时候传递进去 12345678910111213141516171819202122@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, isDev) =&gt; { if (isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'IS_DEV_ENV'] }, LoggerService, { provide: 'IS_DEV_ENV', useValue: false } ]}) 同样的，可以不单一的注入一个固定的值，也是可以注入一个对象，方便维护 123456789101112131415161718192021222324@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, appConfig) =&gt; { if (appConfig.isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'APP_CONFIG'] }, LoggerService, { provide: 'APP_CONFIG', useValue: { isDev: false } } ]}) 注入器的层级关系前面的提供器只负责实例化所需的依赖对象，将实例化好的对象注入所需组件的工作则是由注入器来完成的，在程序启动的时候， Angular 首先会创建一个应用级注入器，然后将模块中声明的提供器，都注册到这个注入器当中，被注册的提供器除了应用的主模块声明的以外，还包括所有被引用的模块中声明的提供器，比如 123456789101112// app.module.ts@NgModule({ // ... imports: [ BrowserModule, FormsModule, HttpModule ], providers: [ // ... ]}) 在应用级的注入器里面，除了 AppModule 本身声明的一些提供器（providers）会被注册以外，它引入的部分（imports）所有其他的模块，这些模块当中声明的提供器都会被注册到应用级注入器当中，然后 Angular 会创建启动模块指定的主组件（bootstrap 指定的模块），同时应用级别的注入器会为这个主组件创建一个组件级的注入器，并将组件中声明的提供器注册到这个组件级的注入器上 当子组件被创建的时候，它的父组件的注入器会为这个子组件也创建一个注入器，然后将子组件声明的提供器注册上去，以此类推，应用中会形成一组注入器，这些注入器会形成一个与组件的上下级关系一样的层级关系，不过在一般情况下 Angular 可以通过构造函数的参数自动注入所需的依赖 1constructor(private http: Http) { } 同时也需要注意，Angular 的依赖注入点只有一个，就是它的构造函数，如果一个组件的构造函数为空，那么就可以断定，这个函数没有被注入任何东西，简单总结就是，Angular 当中的注入器层级关系分为 1应用级的注入器 ==&gt; 主组件注入器 ==&gt; 子组件注入器 手动添加注入器（避免此类操作）在前文当中我们介绍过了这种使用方式，但是需要注意的是，在实际的使用当中避免使用这种方式 12345678910import { Component, OnInit, Injector } from '@angular/core'import { ProductService } from './product.service'export class ProductComponent implements OnInit { private productService: ProductService constructor(private injector: Injector) { this.productService = injector.get(this.productService) }}","link":"/2018/12/26/Angular/03/"},{"title":"Angular 中的动态加载","text":"本篇主要介绍 Angular 当中的动态加载相关内容 基本原理Angular 当中的动态加载主要涉及到以下三个 API ViewChild 一个属性装饰器，用来从模版视图中获取对应的元素 可以通过模版变量获取，获取的时候可以通过 read 属性设置查询的条件 简单来说就是可以把视图转为不同的实例 ViewContainerRef 一个视图容器，可以在上面创建、插入、删除组件等 ComponentFactoryResolver 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上 所以总结起来简单来说就是 特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询 然后使用 ComponentFactoryResolver 将『已经声明但是未实例化』的组件解析成可以动态加载的 Component 再将此 Component 呈现到之前的视图容器当中 下面我们就来看看具体的实现 动态加载已经声明的组件引用的是 Angular 组件基础内容 当中的示例，模版文件十分简洁，就是通过创建一个 #dyncomp 句柄，以便获得引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 注意引入的内容，上文提到的所需的三个都要引入import { Component, OnInit, ViewChild, ViewContainerRef, ComponentFactoryResolver, ComponentRef } from '@angular/core'import { Child11Component } from './child11/child11.component'import { state } from '@angular/animations'@Component({ selector: 'dynamic-comp', templateUrl: './dynamic-comp.component.html', styleUrls: ['./dynamic-comp.component.scss']})export class DynamicCompComponent implements OnInit { // 这里引用模板里面定义的 dyncomp 容器标签 // 通过模版变量名来获取引用，然后可以通过 read 选项设置一个 ViewContainerRef // 最终在生命周期 ngAfterViewInit 之后便会获取此区域的一个 ViewContainerRef 实例 @ViewChild('dyncomp', { read: ViewContainerRef }) dyncomp: ViewContainerRef comp1: ComponentRef&lt;Child11Component&gt; comp2: ComponentRef&lt;Child11Component&gt; constructor( private resolver: ComponentFactoryResolver) { } ngOnInit() { } ngAfterContentInit() { console.log(`动态创建组件的实例`) // 这里是主要的加载组件函数 // 通过在 constructor 当中注入的 ComponentFactoryResolver 服务 // 调用其 resolveComponentFactory 来解析一个已经声明的组件并得到一个可动态加载的 componentFactory // 最后直接调用容器的 createComponent 函数将其解析出来的 componentFactory 动态的呈现到容器视图上 const childComp = this.resolver.resolveComponentFactory(Child11Component) this.comp1 = this.dyncomp.createComponent(childComp) // this.comp1.instance.title = `父层设置的新标题` // this.comp1.instance.btnClick.subscribe((param) =&gt; { // console.log('==&gt;' + param) // }) // 可以创建多个组件实例出来 // let temp1 = this.dyncomp.createComponent(childComp) // temp1.instance.title = '第2个动态子组件' // let temp2 = this.dyncomp.createComponent(childComp) // temp2.instance.title = '第3个动态子组件' // let temp3 = this.dyncomp.createComponent(childComp) // temp3.instance.title = '第4个动态子组件' // let temp4 = this.dyncomp.createComponent(childComp) // temp4.instance.title = '第5个动态子组件' // let temp5 = this.dyncomp.createComponent(childComp) // temp5.instance.title = '第6个动态子组件' // createComponent 方法可以调用很多次，会动态创建出多个组件实例，方法有第二个参数，表示组件渲染的顺序 this.comp2 = this.dyncomp.createComponent(childComp, 0) this.comp2.instance.title = `第二个子组件` } public destoryChild(): void { this.comp1.destroy() this.comp2.destroy() }} 上面特别需要注意的一点就是，对于动态加载的组件必须要声明在特性模块的 entryComponents 中，如下所示 1234567891011121314151617// ...@NgModule({ declarations: [ AppComponent, DynamicCompComponent, Child11Component ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent], entryComponents: [Child11Component]})export class AppModule { } 也就是说对于此处声明的组件，Angular 都会创建一个 ComponentFactory 并将其存储在 ComponentFactoryResolve 中，也就是动态加载必须的步骤 动态加载还未创建的组件在上面我们实现了对于已经创建好的组件的动态加载，那么如果是还未创建的组件呢？其实简单来说这种情况就是我们需要『动态创建』不存在的组件而不是已经声明的组件，不过这种情况一般很少遇见，但是如果遇到可以考虑使用 Compiler，它作用就是用于在运行的时候运行 Angular 编译器来创建 ComponentFactory 的服务，然后可以使用它来创建和呈现组件实例 我们知道，容器创建和呈现组件的函数需要一个 ComponentFactory，而 Compiler 能够在运行的时候动态创建一个 ComponentFactory，而有了 ComponentFactory 以后，我们就可以使用上面的方式来进行动态加载了，下面是一个简单的示例 12345678910111213141516171819202122232425262728293031323334353637// 首先引入 Compilerimport { Compiler } from '@angular/core'// ...// 然后在构造函数当中进行注入constructor( private cp: Compiler) {}// ...// 在创建的时候就不再是指定组件了而是模块，容器的呈现还是一样，直接 createComponentthis.comp1 = this.dyncomp.createComponent(this.createModule())// 新增一个 createModule 函数createModule() { // 通过 Component 和 NgModule 修饰器动态创建新的组件和模块 @Component({ template: '动态组件' }) class DynamicCom {} @NgModule({ declarations: [ DynamicCom ] }) class DynamicModule { } // 然后调用 Compiler 的 compileModuleAndAllComponentsSync 方法获取一个新的 ComponentFactory return this.cp.compileModuleAndAllComponentsSync(DynamicModule).componentFactories .find(comFac =&gt; comFac.componentType === DynamicCom)} 引申出来的问题在实际开发过程当中，通常的情况下我们不可能仅仅创建了一个动态组件就丢在那里不管它了，一般来说都会有数据的传递，比如要进行更新之类的操作，那么这里就可能会遇到在创建动态组件后，调用 componentRef.instance 后发现不能更新界面数据，下面就是我们尝试在动态组件创建了以后，使用动态组件的实例 componentRef.instance 去改变动态组件的属性，如下 1componentRef.instance.name = '123' 运行以后可以发现，界面上绑定的 name 属性并不会更新，但是控制台输出发现其中的 name 已经变更，并且如果是在动态组件当中使用函数，可以改变 name 属性的值，并且 name 属性也是可是实时更新，但是如果使用的是 componentRef，这样数据实时更新就不会起作用了，在这种情况下，有两种解决方法，一种是使用 setTimeout，可以解决问题，但是并不怎么优雅 12345678910111213141516171819202122232425262728293031323334@Component({ template: ` 我是测试模板 {{data}} `})export class CustomComponent implements OnInit { @Input() public data: string public ngOnInit() { console.log(this.data) setTimeout(() =&gt; { console.log(this.data) }, 3000) }}// ----------------------------export class HomeComponent implements OnInit { constructor( private viewContainerRef: ViewContainerRef, private cfr: ComponentFactoryResolver ) { } public ngOnInit() { let factory = this.cfr.resolveComponentFactory(CustomComponent) let componentRef = this.viewContainerRef.createComponent(factory) componentRef.instance.data = 'hello' setTimeout(() =&gt; { componentRef.instance.data = 'bye' }, 2000) }} 第二种解决方式可以采用官方提供的 changeDetectorRef.markForCheck() 来解决这个问题，即手动去触发检测更新，详细见 ChangeDetectorRef 宿主对象上面介绍了 Angular 中动态加载的一些相关内容，下面来看一些宿主对象相关的知识点，主要包括 Angular 中利用指令来指定宿主对象 Angular 中如何动态添加宿主 如何与动态添加后的组件进行通信 下面我们就一个一个来进行了解 使用指令来指定宿主对象在 Angular 中，我们通常需要一个宿主（Host）来给动态加载的组件提供一个容器，这个宿主在 Angular 中就是 ng-template，我们需要找到组件中的容器，并且将目标组件加载到这个宿主中，就需要通过创建一个指令（Directive）来对容器进行标记，先来看看模版文件 123456&lt;!-- app.component.html --&gt;&lt;h1&gt; {{title}}&lt;/h1&gt;&lt;ng-template dl-host&gt;&lt;ng-template&gt; 然后我们添加一个用于标记这个属性的指令 dl-host.directive 123456789101112// dl-host.directive.tsimport { Directive, ViewContainerRef } from '@angular/core'@Directive({ selector: '[dl-host]'})export class DlHostDirective { // 在这里注入了一个 ViewContainerRef 的服务 // 它的作用就是为组件提供容器，并且提供了一系列的管理这些组件的方法 constructor(public viewContainerRef: ViewContainerRef) { }} 这样一来，我们就可以在 app.component 中通过 @ViewChild 获取到 dl-host 的实例，因此进而获取到其中的 ViewContainerRef，另外，我们还需要为 ViewContainerRef 提供需要创建组件 A 的工厂，所以还需要在 app.component 中注入一个工厂生成器 ComponentFactoryResolver，并且在 app.module 中将需要生成的组件注册为一个 @NgModule.entryComponent 123456789101112131415161718192021222324// app.comonent.tsimport { Component, ViewChild, ComponentFactoryResolver } from '@angular/core'import { DlHostDirective } from './dl-host.directive'import { AComponent } from './a/a.component'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'app works!' @ViewChild(DlHostDirective) dlHost: DlHostDirective constructor(private componentFactoryResolver: ComponentFactoryResolver) { } ngAfterViewInit() { this.dlHost.viewContainerRef.createComponent( this.componentFactoryResolver.resolveComponentFactory(AComponent) ) }} 下面是模块内容 123456789101112131415161718// app.module.tsimport { BrowserModule } from '@angular/platform-browser'import { NgModule } from '@angular/core'import { AppComponent } from './app.component'import { AComponent } from './a/a.component'import { DlHostDirective } from './dl-host.directive'@NgModule({ declarations: [AppComponent, AComponent, DlHostDirective], imports: [BrowserModule, FormsModule, HttpModule], // 动态加载的组件需要在这里进行注册 entryComponents: [AComponent], providers: [], bootstrap: [AppComponent]})export class AppModule { } 如何动态添加宿主我们不可能在每一个需要动态添加组件的时候提供一个宿主组件，因为我们甚至都不会知道一个组件会在哪儿被创建出来并且被添加到页面中，就比如一个模态窗口，你希望在你需要使用的时候就能打开，而并非受限与宿主，在这种需求的前提下，我们就需要动态添加一个宿主到组件中，所以现在我们可以将 app.component 作为宿主的载体，但是并不提供宿主的显式声明，而是由我们动态去生成宿主，我们先将 app.component 还原 1234&lt;!-- app.component.html --&gt;&lt;h1&gt; {{title}}&lt;/h1&gt; 然后我们需要往 DOM 中注入一个节点，例如一个 div 节点作为页面上的宿主，再通过工厂生成一个 AComponent 并将这个组件的根节点添加到宿主上，在这种情况下我们需要通过工厂直接创建组件，而不是在使用 ComponentContanerRef 1234567891011121314151617181920212223242526272829303132333435363738// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, AfterViewInit, OnDestroy} from '@angular/core'import { AComponent } from './a/a.component'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!' component: ComponentRef&lt;AComponent&gt; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector) } ngAfterViewInit() { let host = document.createElement('div') host.appendChild((this.component.hostView as any).rootNodes[0]) this.elementRef.nativeElement.appendChild(host) } ngOnDestroy() { this.component.destroy() }} 这种手动添加 DOM 的方式会有一个问题，那就是无法对数据进行脏检查，如果修改了 a.component.ts 是不会触发更新的，所以我们需要手动的去通知应用处理这个组件的视图，对这个组件进行脏检查 1234567891011121314151617181920212223242526272829303132333435363738394041// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core'import { AComponent } from './a/a.component'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!' component: ComponentRef&lt;AComponent&gt; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector) appRef.attachView(this.component.hostView) } ngAfterViewInit() { let host = document.createElement(\"div\") host.appendChild((this.component.hostView as any).rootNodes[0]) this.elementRef.nativeElement.appendChild(host) } ngOnDestroy() { this.appRef.detachView(this.component.hostView) this.component.destroy() }} 如何与动态添加后的组件进行通信简单的方法是动态加载的组件通过 @Output() 向外 emit() 事件，外部组件通过监听事件（subscribe）得到通知 1234&lt;!-- 动态加载的组件 a.component.html，简单的绑定一个点击事件 --&gt;&lt;p (click)=\"onTitleClick()\"&gt; {{title}}&lt;/p&gt; 123456789101112131415161718// a.component.tsimport { Component, Output, Input, EventEmitter } from '@angular/core'@Component({ selector: 'app-a', templateUrl: './a.component.html', styleUrls: ['./a.component.css']})export class AComponent { @Input() title = 'a works!' @Output() onTitleChange = new EventEmitter&lt;any&gt;() onTitleClick() { this.onTitleChange.emit() }} 下面来看看外部组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 外部组件 app.component.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core'import { AComponent } from './a/a.component'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!' component: ComponentRef&lt;AComponent&gt; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector) appRef.attachView(this.component.hostView) (&lt;AComponent&gt;this.component.instance).onTitleChange .subscribe(() =&gt; { console.log('title clicked') }) (&lt;AComponent&gt;this.component.instance).title = 'a works again!' } ngAfterViewInit() { let host = document.createElement('div') host.appendChild((this.component.hostView as any).rootNodes[0]) this.elementRef.nativeElement.appendChild(host) } ngOnDestroy() { this.appRef.detachView(this.component.hostView) this.component.destroy() }} 查看页面可以看到界面就显示了 a works again! 的文字，点击这行文字，就可以看到在 console 中输入了 title clicked","link":"/2019/05/12/Angular/08/"},{"title":"什么是 rxjs","text":"因为最近在深入的学习 Angular 相关知识，所以 rxjs 这部分也就是必不可少的了，那么什么是 rxjs 呢？其实简单来说，rxjs 是一种针对异步数据流编程工具，或者叫响应式扩展程序，rxjs 的目标就是异步编程，Angular 引入 rxjs 为了就是让异步可控，更为简单 大部分 rxjs 操作符都不包括在 Angular 的 Observable 基本实现中，基本实现只包括 Angular 本身所需的功能，如果需要更多的 rxjs 功能，必须导入其所定义的库来扩展 Observable 对象，rxjs 是基于观察者模式和迭代器模式以函数式编程思维来实现的，含有两个基本概念 Observables，作为被观察者，是一个值或事件的流集合 Observer，则作为观察者，根据 Observables 进行处理 两者关系如下 订阅，Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable 发布，Observable 通过回调 next 方法向 Observer 发布事件 下面我们就分别来看看这两者 ObservableObservable 就是一个拥有以下特性的函数 它接收一个 observer 对象作为参数，该对象中包含 next、error 和 complete 方法 它返回一个函数，用于在销毁 Observable 时，执行清理操作，返回的是 Subcription 对象，该对象中包含一个 unsubscribe 方法 有几个特殊的状态，如下所示 永不结束，它没有 complete 状态，比如计时器 Never，完全不发射，流中没有任何元素，但是也不结束，就是一个空的，没有状态，一般用于测试 Empty，一般也是用于测试，与 Never 类似，也是空的，但是会直接进入 complete 状态，所以是有结束状态的 Throw，直接进入 error 状态，也是不会发射任何元素 nevernever 操作符会返回一个无穷的 Observable，当我们订阅它后，什么事情都不会发生，它是一个一直存在却什么都不做的 Observable 对象 123456Rx.Observable.never() .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) emptyempty 操作符返回一个空的 Observable 对象，如果我们订阅该对象，它会立即返回 Complete 信息 12345Rx.Observable.empty().subscribe( null, null, () =&gt; { console.log('Completed') }) throw只做一件事，抛出错误 123456Rx.Observable.throw('err') .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) Observer Observer (观察者) 是一个普通的对象，该对象会作为 subscribe() 方法的参数 当 Observable 对象产生新值的时候，我们可以通过调用 next() 方法来通知对应的观察者 若出现异常，则会调用观察者的 error() 方法，当我们订阅 Observable 对象后，只要有新的值，都会通知对应的观察者 在下面两种情况中，新的值不会再通知对应的观察者 已调用 observer 对象的 complete() 方法 执行取消订阅操作 1234567interface Observer&lt;T&gt; { closed?: boolean // 标识是否已经取消对 Observable 对象的订阅 next: (value: T) =&gt; void // 每当 Observable 发送新值的时候，next 方法会被调用 error: (err: any) =&gt; void // 当 Observable 内发生错误时，error 方法就会被调用 complete: () =&gt; void // 当 Observable 数据终止后，complete 方法会被调用 // 需要注意：在调用 complete 方法之后，next 方法不会再被调用} 下面是一些 rxjs 常用的操作符 创建类操作符 from，fromEvent，fromEventPattern，Interval，Timer 工具类操作符 do 变换类操作符 scan 数学类操作符 reduce 过滤类操作符 filter，take，first，last，skip 过滤类操作符 debounce，debounceTime 过滤类操作符 distinct，distinctUntilChanged 合并类操作符 merge，concat，startWith 合并类操作符 combineLatest，withLatestFrom，zip 下面我们就一个一个来看 fromfrom 可以支持从数组、类似数组的对象、Promise、iterable 对象或类似 Observable 的对象（ES5 当中的 Observable）来创建一个 Observable，它几乎可以把任何对象转换成 Observable 1234var array = [10, 20, 30]var result$ = Rx.Observable.from(array)result$.subscribe(x =&gt; console.log(x)) fromEvent这个操作符是专门为事件转换成 Observable 而制作的，用于处理各种 DOM 中的事件 12var click$ = Rx.Observable.fromEvent(document, 'click')click$.subscribe(x =&gt; console.log(x)) fromEventPattern我们经常会遇到一些已有的代码，这些代码和类库往往不受我们的控制，无法重构或代价太大，在 rxjs 中也提供了对应的方法可以转换 1234567891011121314function addClickHandler(handler) { document.addEventListener('click', handler)}function removeClickHandler(handler) { document.removeEventListener('click', handler)}var click$ = Rx.Observable.fromEventPattern( addClickHandler, removeClickHandler)click$.subscribe(x =&gt; console.log(x)) IntervalRx 提供内建的可以创建和计时器相关的 Observable 方法，第一个是 Interval，它可以在指定时间间隔发送整数的自增长序列 1234567891011121314151617181920212223242526// 没有条件的情况下 interval 会一直执行下去，所以触发不了剩余的两种情况（err 和 complete）Rx.Observable.interval(1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') })// 稍作修改，添加上条件，便可以看到 Completed，其中的 take() 表示取前几个Rx.Observable.interval(1000).take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) Timer一共有两种形式的 Timer，一种是指定时间后返回一个序列中只有一个元素（值为 0）的 Observable 1234567891011Rx.Observable.timer(1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') }) 另外一种很类似于 Interval，接收两个参数，第一个参数表示延迟多长时间，第二个参数表示之后要以什么样的频率来进行发送，也就是说，在一开始的延迟时间后，每隔一段时间就会返回一个整数序列 1234567891011Rx.Observable.timer(1000, 1000).subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') }) do一般用来调试，有时也会用来作为外部条件的设置，可以作为一个可以与外部交互的桥梁，因为当 subscribe() 之后，这个流中的东西就已经固定了，就没有办法在对流继续做一些链接的操作，简单来说，do 可以起到一个临时 subscribe() 的作用，但是并没有中断流 123456789101112131415161718192021// 即取得了这个值，也可以改变这个值let logLabel = '当前值为：'Rx.Observable.interval(1000) .map(val =&gt; val * 2) .do(v =&gt; { console.log(logLabel + v) logLabel = '修改后，当前值为：' }) .take(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) scan接收一个函数作为参数，而函数又接收两个参数 123scan((x, y) =&gt; { return x + y}) x 为累加器，将函数返回的值（比如上面的 x + y）作为下一次累加的 x 值传入进来，与递归很类似，y 为上一个序列过来所接收的值 12345678910111213141516171819202122Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .scan((x, y) =&gt; { return x + y }) .take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } )// 输出结果为// Value 0// Value 2// Value 6// Value 12// Completed 流程图如下所示 123456789101112原始序列： 0------1------2------3------4------5------6------ filter(val =&gt; val % 2 === 0)filter： 0-------------2-------------4-------------6------ scan((x, y) =&gt; { return x + y }) x = 0, y = 0 x = 0, y = 2 x = 2, y = 4 x = 6, y = 6 \\ \\ \\ \\ \\ \\ \\ \\scan： 0-------------2------------6-------------12----- 在有些情况下，需要记住之前的操作结果，这时候用 scan 就是很好的选择 reduce我们尝试将上面的例子改为 reduce 123456789101112131415Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .reduce((x, y) =&gt; { return x + y }) .take(4) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) 与 scan 有一点不同，每次做叠加之后都会发射出一个值，reduce 会把序列当中所有的东西做最后的一个累加值，只会发射出一个值，而又由于上面是一个无限的序列，所以会是一个 Never，所以调换一下 take() 的位置 123456789101112131415Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .take(4) .reduce((x, y) =&gt; { return x + y }) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) 可以看到结果为 12，其实本质上与 scan 的运算是一致的，只不过 reduce 要算出一个最终值，而且只发射最终值，reduce 不仅仅可以用于数学运算，还有一些高级的用法 12345678910111213141516Rx.Observable.interval(100) .filter(val =&gt; val % 2 === 0) .take(4) .reduce((x, y) =&gt; { return [...x, y] }, []) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } )// [0, 2, 4, 6] filter12345678910111213141516171819202122let logLabel = '当前值为：'// 利用 filter 过滤奇数，需要注意这里的 take(3)，原本应该是 0，1，2 就结束了// 但是之前使用了 filter() 使得偶数放行，所以这里表示需要等待三个偶数经过后才会结束Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .do(v =&gt; { console.log(logLabel + v) logLabel = '修改后，当前值为：' }) .take(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) first其实等同于 take(1)，如下对比 123456789101112131415161718192021222324252627282930Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .first() .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } )// ==&gt; 等同于 take(1)Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .take(1) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) last123456789101112131415// 如果替换成 last() 则会变为一个 Never 状态，因为序列永远无法到达Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .last() .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) skip123456789101112131415// 过滤，这里是过滤掉了前三个，即 0，2，4Rx.Observable.interval(1000) .filter(val =&gt; val % 2 === 0) .skip(3) .subscribe( v =&gt; { console.log('Value', v) }, e =&gt; { console.log('Error', e) }, () =&gt; { console.log('Completed') } ) debounce，debounceTime两个操作符的作用都是节流器，限制一定时间内的输出，但是在使用上会有一些不同，所以我们分别来进行介绍 debounceTime直接使用，后面传入指定的时间即可，即可达到在规定的时间内节流的作用 12345678Rx.Observable.fromEvent(number, 'keyup') .pluck('target', 'value') .debounceTime(300) .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) debounce与 debounceTime 时分类似，但是静默时间段由第二个 Observable 决定，所以可以操作的空间就比较广泛 123456789Rx.Observable.fromEvent(number, 'keyup') .pluck('target', 'value') // 需要注意，如果写成 debounce(() =&gt; { return Rx.Observable.interval(300) }) 这样带有 {} 的形式，需要加上 return .debounce(() =&gt; Rx.Observable.interval(300)) .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) distinct，distinctUntilChangeddistinct它的作用是将整个序列的流中不一样的保留下来，一样的重复的则过滤掉，比如下面这个示例，如果将输入框中的元素选定或者删除，然后从新输入相同的内容，是不会触发 keyup 事件的 12345678Rx.Observable.fromEvent(number, 'keyup') .pluck('target', 'value') .distinct() .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) 使用的时候需要小心，尤其是应用在无尽序列当中，因为会极大的消耗内存 distinctUntilChanged它的作用是只和前一个元素进行对比，前一个元素如果跟其一样，那就抛弃掉 12345678Rx.Observable.fromEvent(number, 'keyup') .pluck('target', 'value') .distinctUntilChanged() .subscribe( v =&gt; { console.log(v) }, e =&gt; { console.log(e) }, () =&gt; { console.log('complete') } ) merge，concat，startWith这几个操作符的作用都是类似的，都是针对多个流，两个或者两个以上的流进行合并，只是合并的方式不同 merge两个流，按各自的事件顺序进行合并，严格有时间交叉，一种简单的合并，不回去更改两条流的任何东西 123456789101112const a = document.querySelector('#a')const b = document.querySelector('#b')const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value')const b$ = Rx.Observable.fromEvent(b, 'keyup').pluck('target', 'value') Rx.Observable.merge(a$, b$) .subscribe( (v) =&gt; { console.log(v) } ) 在两个输入框内分别输入值，则会交替的输出每个输入框内的值 concat严格来说不属于合并，应该属于对接，等待前一个流完成了之后，才会进行下一个流，尽管后面的流的序列很快的执行，也会等待前一个流完成之后才会进行输出 123456Rx.Observable.concat(a$, b$) .subscribe( (v) =&gt; { console.log(v) } ) 从运行结果可以看出，第一个输入框可以正常的输出内容，但是触发第二个输入框的时候是没有反应的，原因是因为第一个输入框是一个无尽序列，理论上只有第一个序列完成后才会输出后面的值，稍作修改 123456789const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value')const c$ = Rx.Observable.from([1, 2, 3, 4]) Rx.Observable.concat(c$, a$) .subscribe( (v) =&gt; { console.log(v) } ) 这样就可以看到输入的值了，因为只有等待第一个序列完成后后续序列输入的值才会输出 startWith如果希望这个流在一开始的时候就有一个值可以发射出来的话，就可以使用 startWith 设置一个默认值，类似初始值，类似于在序列前 concat 一个值 12Rx.Observable.from([1, 2, 3, 4]).startWith(0).subscribe(v =&gt; console.log(v))// 输出 0 1 2 3 4 一般都是用来赋予初始值，避免在一开始的时候流是空的 combineLatest，withLatestFrom，zipcombineLatest组成它的任何一个流当中有新元素出现的话，那么它就会产生一个新流当中对应的一个数据，和 withLatestFrom 相比的话，无论哪个流有改变均会有输出 zip一对一的输出，和 combineLatest 类似，但是严格要求必须配对，即全都需要新的数据，combineLatest 和 zip 的示例可以参考文章开头部分 withLatestFrom以一个流为主，然后这个流产生的数据的时候会去获取另一个流的最新值，注意输出的结果为数组 123456789const a$ = Rx.Observable.fromEvent(a, 'keyup').pluck('target', 'value')const b$ = Rx.Observable.fromEvent(b, 'keyup').pluck('target', 'value') a$.withLatestFrom(b$) .subscribe( (v) =&gt; { console.log(v) } ) 简单来说，只有当第一个输入框内的值发生变化的时候，才会去取第二个输入框内的值组合成一个数组发送出来，所以改变第二个输入框内的值是不会引起变化的","link":"/2019/06/04/Angular/11/"},{"title":"Angular 中的表单","text":"在 Angular 当中存在两种表单处理的方式，模版式表单和响应式表单，它们两者对于表单的的处理方式是有所不同的，下面我们就慢慢来进行了解 它们两者的区别是 不管是哪种表单，都有一个对应的数据模型来存储表单的数据，在模版式表单中，数据模型是由 Angular 基于你组件模版中的指令隐式创建的，而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的 HTML 元素与底层的数据模型连接在一起 数据模型并不是一个任意的对象，它是一个由 angular/forms 模块中的一些特定的类，如 FormControl，FormGroup，FormArray 等组成的，在模版式表单中，你是不能直接访问到这些类的 响应式表单并不会替你生成 HTML，模版仍然需要你自己来编写，响应式表单不能在模版当中去操作数据模型，只能在代码中操作，模版式表单不能在代码中去操作，只能在模版当中操作 模版式表单（模版驱动表单）表单的数据模型是通过组件模版中的相关指令来定义的，因为使用这种方式定义表单的数据模型的时候，我们会受限于 HTML 的语法，所以模版驱动方式只适合用于一些简单的场景，它主要包括这样几个指令 NgForm，NgModel，NgModelGroup，下面我们就一个一个来看 NgForm使用 NgForm 用来代表整个表单，在 Angular 应用中会被『自动的』添加到 form 元素上，不过需要注意的是，不仅限于 form 元素，对于 div 元素如果手动指定 ngForm 效果也是一样的，NgForm 指令隐式的创建了一个 FormGroup 类的实例，这个类用来代表表单的数据模型并且存储表单的数据 123456789&lt;form #myForm=\"ngForm\" (ngSubmit)=\"onSubmit(myForm.value)\"&gt; &lt;div&gt;用户名：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;div&gt;密码：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;div&gt; {{myForm.value | json}}&lt;/div&gt; NgModelNgModel 代表表单中的一个字段，这个指令会隐式的创建一个 FormControl 的实例来代表字段模型，并用这个 FormControl 类型的对象来存储字段的值，比如上面的示例，在 input 当中输入的值并不会反应在下方，这是因为 input 标签并没有绑定 ngModel 指令，不过需要注意的是，绑定的时候直接使用 ngModel 即可，不需要添加任何括号，但是同时需要为绑定的元素添加一个 name 属性 1&lt;div&gt;用户名：&lt;input type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt; 也可以单独的绑定 ngModel 123&lt;div&gt;用户名：&lt;input #username=\"ngModel\" type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt;&lt;div&gt;{{username.value}}&lt;/div&gt; NgModelGroupNgModelGroup 代表的是表单的一部分，它允许你将一些表单字段组织在一起形成更清晰的层次关系，和上面一样，也会创建一个 FormGroup 类的一个实例，这个实例会在 NgForm 对象的 value 属性中表现为一个嵌套的对象 12345&lt;div ngModelGroup=\"userinfo\"&gt; &lt;div&gt;用户名：&lt;input #username=\"ngModel\" type=\"text\" ngModel name=\"username\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{{username.value}}&lt;/div&gt; 生成的数据为 12345{ 'userinfo': { 'username': '' }} 响应式表单其实在实际开发过程当中，模版式表单的使用是比较少的，大多都是响应式表单，因为使用响应式表单可以让我们更为随心所欲的控制每一个输入的值，所以在这里我们将会重点介绍响应式表单 在使用响应式表单时，是通过编写 TypeScript 代码而不是 HTML 代码来创建一个底层的数据模型，在这个模型定义好了以后，可以使用一些特定的指令，将模版上的 HTML 元素与底层的数据模型连接在一起，若使用模版式表单表单，则导入 FormsModule，若使用响应式表单，则导入 ReactiveFormsModule，与模版式表单不同，创建一个响应式表单需要两步 首先需要创建一个数据模型，用来保存表单数据的数据结构，简称模型，它由定义在 Angular 中的 forms 模块中的三个类组成 FormControl，FormGroup 和 FormArray 然后需要使用一些指令将模版中的 HTML 元素连接到这个数据模型上 响应式表单的指令响应式表单使用一组与模版式表单完全不同的指令（全部来源于 ReactiveFormModule 模块） 类名 指令（这一列的需要使用属性绑定语法） 指令（这一列不需要使用属性绑定语法） FormGroup formGroup formGroupName FormControl formControl formControlName FormArray formArrayName 响应式表单中所有的指令都是以 form 开头的，所以可以很容易的和模版式表单（比如 ngModel）区分开来，这些 form 开头的指令是不能进行引用的（比如 #myForm=&quot;ngForm&quot;），模版式表单当中拿不到 FormControl，FormGroup 和 FormArray 这三个类，而在响应式表单当中可以直接访问数据模型相关的类（由于它们是不可以引用的，所以不能在模版当中去操作数据模型，只能在代码当中操作） FormGroup既可以代表表单的一部分，也可以用于代表整个表单，它是多个 FormControl 的集合，FormGroup 将多个 FormControl 的值和状态聚合在一起，比如在表单验证中，如果其中一个 FormControl 是无效的，那么整个 FormGroup 就是无效的 FormArray与 FormGroup 类似，但是有一个额外的长度属性，一般来说，FormGroup 用来代表整个表单或者表单字段的一个固定子集，而 FormArray 通常用来代表一个可以增长的字段集合，但是它里面的字段是没有 key 属性的，只能通过序列去查询 FormControl它是构成表单的基本单位，通常情况下会用来代表一个 input 元素，但是也可以用来代表一个更为复杂的 UI 组件，比如日历，下拉选择块等，它保存着与其关联的 HTML 元素当前的值以及元素的校验状态，还有元素是否被修改过的相关信息 1234export class ReactiveFormComponent implements OnInit { // FormControl 这个构造函数可以接收一个参数，用来指定 FormControl 的初始值 username: FormControl = new FormControl('zhangsan')} 指令的具体作用formGroup一般我们会使用绑定到一个 form 标签的 formGroup 对象来代表整个表单，比如 1&lt;form [formGroup]=\"formModel\"&gt;&lt;/form&gt; 这样一来，表单的处理方式就会变成一个响应式表单的处理方式 formGroupName在模版当中使用 formGroupName 来连接一个 formGroup，比如 formGroupName='dataRange'，在组件中使用 FormGroup 来构造对应的指定名称 formControlName必须声明在一个 formGroup 之内来连接 formGroup 之内的 formControl 和页面上的 DOM 元素 formArrayName同 formControlName 类似，同样必须用在 formGroup 之内，因为在 formArrayName 当中没有序列号，所以一般和 *ngFor 指令配合使用 formControl不能使用在模版当中的 formGroup 的内部，只能用在外部与某个单独的元素（input）绑定起来 再次强调 在响应式表单当中，所有的指令都是以 form 开头的（模版式表单才是以 ngxxx 开头） 如果指令以 Name 结尾，不需要使用属性绑定的语法，直接等于一个属性的名称即可（字符串），同时，这些属性只能用在 formGroup 覆盖的范围之内 如果指令不是以 Name 结尾，则需要使用属性绑定的语法（[]=&quot;&quot;） 使用 FormBuild 简化写法使用 FormBuild 简化了定义表单结构的语法，相对于直接使用 FormGroup，FormControl 和 FormArray，它可以让我们使用更少的代码定义出同样的数据结构，来重构上面的示例 12345678910111213formModel: FormGroupconstructor(private fb: FormBuilder) { this.formModel = fb.group({ username: ['zhangsan'], phone: [''], dateRange: fb.group({ from: [''], to: [''] }), emails: fb.array(['123@126.com', '456@126.com']) })} 使用 FormBuilder 可以简化我们的代码，同时提供了更多了配置，比如 fb.group({}) 方法，调用其就相当于 new FormGroup({})，但是其还可以接收一个额外的参数用来校验这个 formGroup，而对于其中的 formControl 则采用了一个数组（['']）的形式来进行初始化，同时还可以额外接收两个参数 12// 如果多于三个参数，其他的元素会被忽略username: ['初始值', 校验方法, 异步的校验方法], 完整示例前提需要在当前模块下导入 ReactiveFormsModule 并且在 imports 当中进行添加 12345678import { ReactiveFormsModule } from '@angular/forms'@NgModule({ // ... imports: [ ReactiveFormsModule ]}) 模版如下 1234567891011121314151617181920212223242526&lt;form [formGroup]=\"formModel\" (submit)=\"onSubmit()\"&gt; &lt;!-- 使用 formControl 来进行绑定，但是这样 username 属性进入不到表单内部，所以可以将其放入到 formGroup 内部，同时改变绑定写法（否则会报错） 在外部 &lt;input type=\"text\" [formControl]=\"username\"&gt; 在内部 &lt;input type=\"text\" formControlName=\"username\"&gt; 然后在组件中将 username 移动至 formModel 当中即可 --&gt; &lt;input formControlName=\"username\"&gt; &lt;input formControlName=\"phone\"&gt; &lt;!-- 使用 formGroupName 来指定组件当中的 formGroup 名称 --&gt; &lt;div formGroupName=\"dateRange\"&gt; 起始日期：&lt;input type=\"date\" formControlName=\"from\"&gt; 结束日期：&lt;input type=\"date\" formControlName=\"to\"&gt; &lt;/div&gt; &lt;div&gt; &lt;ul formArrayName=\"emails\"&gt; &lt;!-- 获得 formModel 当中 emails，然后使用 controls 来获取当中的集合（即数组） --&gt; &lt;li *ngFor=\"let email of this.formModel.get('emails').controls; let i = index;\"&gt; &lt;!-- 使用 formControlName 将其和循环下标绑定在一起，注意需要使用属性绑定语法 --&gt; &lt;input type=\"text\" [formControlName]=\"i\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=\"button\" (click)=\"addEmail()\"&gt;新增 Email&lt;/button&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;保存&lt;/button&gt;&lt;/form&gt; 组件如下 123456789101112131415161718192021222324252627282930313233import { FormGroup, FormControl, FormArray } from '@angular/forms'export class ReactiveFormComponent implements OnInit { // FormControl 这个构造函数可以接收一个参数，用来指定 FormControl 的初始值 username: FormControl = new FormControl('zhangsan') formModel: FormGroup = new FormGroup({ username: new FormControl('zhangsan'), dateRange: new FormGroup({ from: new FormControl(), to: new FormControl() }), emails: new FormArray([ new FormControl('123@126.com'), new FormControl('456@126.com') ]) }) constructor() { } ngOnInit() { } onSubmit() { console.log(this.formModel.value) } addEmail() { // 拿到了是一个 FormArray 类型的对象，所以强制转换一下类型 const emails = this.formModel.get('emails') as FormArray // 点击新增的时候添加一个 input emails.push(new FormControl()) }} 自定义表单控件我们来尝试着将一个普通的模版封装为自定义表单控件，需要首先引入 ControlValueAccessor，然后将接口定义为 ControlValueAccessor，其内部有三个方法，需要我们自己去手动实现 123456789101112131415161718192021222324252627import { ControlValueAccessor } from '@angular/forms'export class ImageListSelectComponent implements ControlValueAccessor { public propagateChange = (_: any) =&gt; {} // 这个方法用来写入值，就像之前的设置初始值，或者在方法内部写入值，比如 this.form.patchValue 或者 this.form.setValue writeValue(obj: any): void { this.selected = obj } // 如果表单的 value 或者值发生了变化，需要通知表单，定义一个空函数接收系统传递的一个函数在表单发生变化的时候 emit 这个事件通知表单需要进行更新 registerOnChange(fn: any): void { } // 指明表单控件什么情况下算是 Touch 状态，需要告诉给表单定义一个空函数来进行接收 registerOnTouched(fn: any): void { this.propagateChange = fn } // 然后在发生变化的时候，emit 通知表单发生了变化 onChange(i) { this.propagateChange(this.selected) }} 然后需要指定依赖池 123456789101112131415161718192021222324import { forwardRef } from '@angular/core'// 引入 NG_VALUE_ACCESSOR 令牌import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms'@Component({ providers: [ { // 将自身注册到这个令牌上 provide: NG_VALUE_ACCESSOR, // useExisting 使用已有的，也就是自身 // 然后这里存在一个问题，在元数据当中，自身可能没有被创建，所以注册不到令牌上面，所以这里使用 forwardRef() 方法，就可以引用自身了 // 会等待实例化之后才会进行引用，这样写不影响使用 useExisting 注册到依赖池当中 useExisting: forwardRef(() =&gt; ImageListSelectComponent), // 类似 NG_VALUE_ACCESSOR 这种令牌，本身都是多对一的，比如多个控件使用同一个令牌 multi: true }, // 验证同理，也需要是可以验证的 { provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; ImageListSelectComponent), multi: true } ]}) 添加自定义认证 1234567validate(c: FormControl): {[key: string]: any} { return this.selected ? null : { imageListInvalid: { valid: false } }} 完整代码如下 12345678910111213141516171819&lt;!-- 模版 --&gt;&lt;div&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;img [src]=\"selected\" class=\"avatar\"&gt;&lt;/div&gt;&lt;div class=\"scroll-container\"&gt; &lt;md-grid-list [cols]=\"cols\" [rowHeight]=\"rowHeight\"&gt; &lt;md-grid-tile *ngFor=\"let item of items; let i = index\"&gt; &lt;div class=\"image-container\" (click)=\"onChange(i)\"&gt; &lt;img class=\"avatar\" [src]=\"item\"&gt; &lt;div class=\"after\"&gt; &lt;div class=\"zoom\"&gt; &lt;md-icon&gt;checked&lt;/md-icon&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/md-grid-tile&gt; &lt;/md-grid-list&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { Component, Input, forwardRef } from '@angular/core'import { ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, FormControl } from '@angular/forms'@Component({ selector: 'app-image-list-select', templateUrl: './image-list-select.component.html', styleUrls: ['./image-list-select.component.scss'], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ImageListSelectComponent), multi: true }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; ImageListSelectComponent), multi: true } ]})export class ImageListSelectComponent implements ControlValueAccessor { @Input() title = '选择' @Input() cols = '6' @Input() rowHeight = '64px' @Input() items: string[] = [] public selected: string public propagateChange = (_: any) =&gt; { } constructor() { } onChange(i) { this.selected = this.items[i] this.propagateChange(this.selected) } writeValue(obj: any): void { this.selected = obj } registerOnChange(fn: any): void { this.propagateChange = fn } registerOnTouched(fn: any): void { } validate(c: FormControl): { [key: string]: any } { return this.selected ? null : { imageListInvalid: { valid: false } } }} 使用 123456&lt;!-- 选择头像 --&gt;&lt;app-image-list-select [cols]=\"6\" [items]=\"items\" formControlName=\"avatar\"&gt;&lt;/app-image-list-select&gt; 这样一来就可以进行初始化操作了 123456789101112131415161718192021222324import { FormBuilder, FormGroup } from '@angular/forms'export class RegisterComponent implements OnInit { public items: string[] = [ 'assets/avatar/01.jpg', 'assets/avatar/02.jpg', 'assets/avatar/03.jpg', 'assets/avatar/04.jpg' ] form: FormGroup constructor(private fb: FormBuilder) { } ngOnInit() { this.form = this.fb.group({ email: [], name: [], password: [], repeat: [], avatar: ['assets/1.jpg'] }) }}","link":"/2019/05/27/Angular/10/"},{"title":"CSS 中一些小技巧汇总","text":"之前整理过 JavaScript 中一些常用方法的实现，这次就来整理一下 CSS 当中一些小技巧，部分内容参考自 30 seconds of CSS 清除浮动更好的方式无需借助辅助元素进行浮动的清除，一般在 float 布局当中才会使用，在实际场景中还是推荐使用 flexbox 布局或者网格布局 12345&lt;div class=\"clearfix\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789.clearfix::after { content: ''; display: block; clear: both;}.item { float: left;} 相邻兄弟选择器通常我们在实现一个列表的时候，一般需要给列表当中的 li 元素添加边框，比较常见的做法是给所有的 li 都添加某个方向的边框，然后使用 :last-child 或者 :first-child 过滤掉首部或者尾部的元素，如下 1234567li { border-bottom: 1px solid lightblue;}li:last-child { border-bottom: none;} 但是使用相邻兄弟选择器来实现的话就简单许多 123ul &gt; li + li { border-top: 1px solid lightblue;} 居中的一种简单实现方式通常我们在实现居中布局的时候经常会去使用 flex 来实现，比如针对容器 &lt;div class=&quot;wrap&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; 当中的子元素实现居中，我们采用的方式一般是下面这样的 1234567891011.wrap { display: flex; align-items: center; justify-content: center;}div { width: 200px; height: 200px; background: lightblue;} 除了以上方式以外，还有一种更为简便的方式也可以达到我们想要的效果 12345678910.wrap { display: flex;}div { width: 200px; height: 200px; background: lightblue; margin: auto;} 不变宽高比（等比）示例可见 不变宽高比（等比），给定宽度可变的元素，它将确保其高度以响应方式保持成比例（即其宽高比保持不变） 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516.box { width: 50%; background: rgb(66, 201, 201);}.box::before { content: ''; padding-top: 100%; float: left;}.box::after { content: ''; display: block; clear: both;} ::before，为元素定义一个伪元素 padding-top: 100%，设置伪元素的内上边距，百分比的值是按照宽度计算的，所以元素是响应式的 此方法还允许将内容正常放置在元素内 图片在容器中自适应示例可见 图片在容器中自适应，设置图像在其容器内的适合度和位置，同时保留其宽高比，等同于 background-size 的效果，但是其可以直接作用于 img 标签上 1&lt;img src=\"https://gitee.com/heptaluan/backups/raw/master/cdn/cover/81.webp\"&gt; 123456789img { object-fit: contain; object-position: center;}img { object-fit: cover; object-position: right top;} object-fit: contain，容器内显示整个图像，并且保持宽高比 object-fit: cover，用图像填充容器，并保持宽高比 object-position: [x] [y]，对图像的显示部位进行调整 将元素垂直居中于另一个元素示例可见 将元素垂直居中于另一个元素 123&lt;div class=\"center\"&gt; &lt;p&gt;这是一段测试文本（深色区域是由我撑开的）&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718.center { height: 150px; background: rgb(11, 121, 121);}.center::before { content: ''; display: inline-block; height: 100%; vertical-align: middle;}.center p { display: inline-block; vertical-align: middle; font-size: 14px; color: #fff;} 使两个元素在水平方向上垂直对齐，不设置前者的宽度，而是设置高度为 100% 使其保持与容器一致的高度 尝试给 .center::before 添加一点宽度并且设置一个背景色就很明了了 使用 :before 伪元素的样式垂直对齐内联元素而不更改其 position 属性 最后一项占满剩余高度示例可见 最后一项占满剩余高度，通过为最后一个元素提供当前视口中剩余的可用空间，即使在调整窗口大小时，也可以利用可用的视口空间 12345&lt;div class=\"wrapper\"&gt; &lt;div class=\"header\"&gt;Header&lt;/div&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"footer\"&gt;Footer&lt;/div&gt;&lt;/div&gt; 123456789.wrapper { height: 100%; display: flex; flex-direction: column;}.wrapper &gt; div:last-child { flex: 1;} display: flex，启用 flex flex-direction: column，将项目的顺序设置成从上到下 flex-grow: 1，flexbox 会将容器的剩余可用空间应用于最后一个子元素，父级必须具有视口高度 flex-grow：1 可以应用于第一个或第二个元素，它将具有所有可用空间 列表计数器示例可见 列表计数器，计数器本质上是由 CSS 维护的变量，其值可以通过 CSS 规则递增以跟踪它们被使用的次数 123456789101112&lt;ul&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt; List item &lt;ul&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;li&gt;List item&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 12345678ul { counter-reset: counter;}li::before { counter-increment: counter; content: counters(counter, '.') ' ';} 可以使用任何类型的 HTML 标签创建有序列表 counter-reset，初始化计数器，该值是计数器的名称，默认情况下计数器从 0 开始，此属性还可用于将其值更改为任何特定数字 counter-increment，用于可数的元素，一旦计数器重置初始化，计数器的值可以增加或减少 counter(name, style)，显示节计数器的值，通常用于内容属性，此函数可以接收两个参数，第一个作为计数器的名称，第二个参数表示占位内容 CSS 计数器对于制作轮廓列表特别有用，因为计数器的新实例是在子元素中自动创建的，使用 counters() 函数，可以在不同级别的嵌套计数器之间插入分隔文本 创建动态阴影示例可见 创建动态阴影，创建类似于 box-shadow 的阴影，但基于元素本身的颜色 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516171819.box { width: 200px; height: 200px; position: relative; z-index: 1; background: linear-gradient(75deg, #6d78ff, #00ffb8);}.box::after { content: ''; width: 100%; height: 100%; position: absolute; background: inherit; top: 10px filter: blur(8px); opacity: .7; z-index: -1;} ::after，定义一个伪元素 position: absolute，使伪元素脱离文档流并相对于父级定位 width/height: 100%，对伪元素进行大小调整以填充其父元素的大小，使其大小相等 background: inherit，使伪元素继承父级的线性渐变 top: 10px，将伪元素相对于其父元素略微偏移 filter: blur(8px)，设置伪元素模糊效果，以创建下方阴影效果 opacity: 0.7，设置伪元素透明度 z-index: -1，将伪元素定位在父元素后面但在背景前面 鼠标悬停渐变效果示例可见 鼠标悬停渐变效果，一种鼠标悬停效果，其中渐变跟随鼠标光标 123&lt;button&gt; &lt;span&gt;Hover me&lt;/span&gt;&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334button { position: relative; background: #6d78ff; padding: 20px 70px; border: none; color: white; font-size: 22px; cursor: pointer; outline: none; overflow: hidden; border-radius: 10px;}span { position: relative; pointer-events: none;}button::before { --size: 0; content: ''; position: absolute; left: var(--x); top: var(--y); width: var(--size); height: var(--size); background: radial-gradient(circle closest-side, #00ffb8, transparent); transform: translate(-50%, -50%); transition: width .2s ease, height .2s ease;}button:hover::before { --size: 300px;} 123456document.querySelector('button').onmousemove = (e) =&gt; { const x = e.pageX - e.target.offsetLeft const y = e.pageY - e.target.offsetTop e.target.style.setProperty('--x', `${x}px`) e.target.style.setProperty('--y', `${y}px`)} 利用伪元素来达到渐变效果，使其显示位置与鼠标悬停位置一致 var() 函数可以代替元素中任何属性中的值的任何部分 重置所有样式示例可见 重置所有样式，使用一个属性将所有样式重置为默认值，这不会影响 direction 和 unicode-bidi 属性 1234&lt;div class=\"box\"&gt; &lt;p&gt;这是一段测试文本（这一段文本属性没有被重置，默认使用的继承过来的属性）&lt;/p&gt; &lt;p&gt;这是一段测试文本（这一段文本属性已被重置，使用控制台可以发现继承过来的属性均已重置）&lt;/p&gt;&lt;/div&gt; 123.box p:last-child { all: initial;} all 属性允许您将所有样式（继承或不继承）重置为默认值 形状分隔符示例可见 形状分隔符，使用 SVG 形状分割两个不同的块以创建更有趣的视觉外观 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213.box { position: relative; height: 50px;}.box::after { content: ''; background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 12'%3E%3Cpath d='m12 0l12 12h-24z' fill='%23fff'/%3E%3C/svg%3E\"); position: absolute; width: 100%; height: 12px; bottom: 0;} background-image: url()，添加 SVG 形状作为伪元素的背景图像，默认情况下重复，它必须与要分割的块颜色相同 如果想使用其他图形，可以使用 URL-encoder for SVG 滑动开关示例可见 滑动开关，可以依靠纯 CSS 来实现一个 Switch 滑动开关效果 1&lt;input type=\"checkbox\" id=\"checkbox\" /&gt; &lt;label for=\"checkbox\" class=\"switch\"&gt;&lt;/label&gt; 123456789101112131415161718192021222324252627282930313233343536.switch { position: relative; display: inline-block; width: 60px; height: 30px; background-color: rgba(0, 0, 0, 0.25); border-radius: 20px; cursor: pointer; transition: all 0.3s;}.switch::after { content: ''; position: absolute; width: 28px; height: 28px; border-radius: 18px; background-color: white; top: 1px; left: 1px; transition: all 0.3s;}input[type=\"checkbox\"]:checked + .switch::after { transform: translateX(30px);}input[type=\"checkbox\"]:checked + .switch { background-color: #499AFF;}input[type=\"checkbox\"] { border: 0; width: 0; height: 0;} 利用 input 的 checkbox 的特性来实现整个效果 使用 switch::after 来实现开关外形 在 input:checked 状态下动态调整 switch::after 的位置 最后将 input 隐藏掉，只使用 label 来进行关联 画一个三角形示例可见 画一个三角形 1&lt;div class=\"box\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.box01 { width: 0; height: 0; border-top: 30px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box02 { width: 0; height: 0; border-right: 30px solid #499AFF; border-top: 30px solid transparent; border-bottom: 30px solid transparent;}.box03 { width: 0; height: 0; border-bottom: 30px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box04 { width: 0; height: 0; border-left: 30px solid #499AFF; border-top: 30px solid transparent; border-bottom: 30px solid transparent;}.box05 { width: 0; height: 0; border-bottom: 50px solid #499AFF; border-left: 30px solid transparent; border-right: 30px solid transparent;}.box06 { width: 30px; height: 30px; border-top: 2px solid #499AFF; border-right: 2px solid #499AFF;}.box07 { width: 30px; height: 30px; border-top: 2px solid #499AFF; border-right: 2px solid #499AFF; transform: rotate(45deg);} 将高度和宽度设为 0，剩下四个边框，再将某一方向边框去掉，除开对应的一边，将另外两边设置为透明即可 如果需要调整角度，在上面基础之上调整对应宽度即可 如果需要空心箭头，设置夹角两边边框即可，方向可以根据需要进行调整 斑马线效果示例可见 斑马线效果 1&lt;div class=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526.box01 { width: 100%; height: 20px; background-color: #499AFF; background-image: linear-gradient(45deg, hsla(0, 0%, 100%, .15) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, .15) 0, hsla(0, 0%, 100%, .15) 75%, transparent 0, transparent); background-size: 36px 36px;}.box02 { width: 100%; height: 20px; background-color: #499AFF; background-image: linear-gradient(45deg, hsla(0, 0%, 100%, .15) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, .15) 0, hsla(0, 0%, 100%, .15) 75%, transparent 0, transparent); background-size: 36px 36px; animation: progress-bar-stripes 2s linear infinite;}@keyframes progress-bar-stripes { from { background-position: 36px 0; } to { background-position: 0 0; }} 利用 background-image 的 linear-gradient() 函数创建斑马线 如果想让其运动起来，添加动画效果改变其 background-position 位置即可 加载动画示例可见 加载动画，下面是一种实现方式 12345&lt;div class=\"box\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.box { height: 80px; display: flex; justify-content: center; align-items: center;}.box &gt; div { width: 12px; height: 12px; margin: 15px 8px; background: #fff; border-radius: 50%; animation: loading .6s infinite alternate}.box &gt; div:nth-child(2) { animation-delay: .2s;}.box &gt; div:nth-child(3) { animation-delay: .4s;}@keyframes loading { to { opacity: 0.1; transform: translate3d(0, -10px, 0); }} 另外一种方式 123&lt;div class=\"box\"&gt; &lt;div class=\"loading\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526@keyframes loading { from { transform: rotate(0deg); } to { transform: rotate(360deg); }}.box { height: 80px; background: #499AFF; display: flex; justify-content: center; align-items: center;}.box .loading { width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #00ffb8; border-radius: 50%; animation: loading 3s infinite linear;} 两者原理一致，使用 @keyframes 来定义动画效果，使元素在竖直方向上运动 使用 animation-delay 延迟执行来达到交替的效果 如果设定了元素的 border-radius，则 border-top 会显示为弧形 按钮边框动画示例可见 按钮边框动画，例一如下 123&lt;div class=\"box\"&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142button { padding: 15px 50px; outline: none; border: none; position: relative; background: #499AFF; cursor: pointer; color: #fff; transition: all .3s;}button::before,button::after { border: 0 solid transparent; transition: all .3s; position: absolute; content: ''; height: 24px; width: 24px;}button::before { border-top: 2px solid rgb(41, 137, 255); left: 0; top: -8px;}button::after { border-bottom: 2px solid rgb(41, 137, 255); right: 0; bottom: -8px;}button:hover { background: rgb(41, 137, 255);} button:hover::before,button:hover::after { width: 100%; height: 100%;} 例二 12345&lt;div class=\"box\"&gt; &lt;button&gt;提交&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.box { position: relative; overflow: hidden;}.box div { transition: all .35s; cursor: pointer;}.box div:nth-of-type(1) { width: 126px; height: 50px; border: solid #499AFF; border-width: 0 2px; position: absolute; left: 0; top: 0; transform: translate(0, -200px);}.box div:nth-of-type(2) { width: 130px; height: 46px; border: solid #499AFF; border-width: 2px 0; position: absolute; left: 0px; top: 0; transform: translate(-200px, 0);}.box button { width: 130px; height: 50px; outline: none; border: none; position: relative; background: #ccc; cursor: pointer; transition: all .3s;}.box:hover button { background: rgb(187, 187, 187);}.box:hover div:nth-of-type(1),.box:hover div:nth-of-type(2) { transform: translate(0, 0);} 两个示例的原理是一致的，均是使用 :before 和 :after 伪元素作为在悬停时设置动画的边框 悬停下滑线动画示例可见 悬停下滑线动画，当文本悬停时，创建文本下划线动画效果 1&lt;p&gt;这是一段测试文本&lt;/p&gt; 123456789101112131415161718192021222324p { display: inline-block; color: #fff; position: relative; font-size: 16px;}p:after { content: ''; position: absolute; width: 100%; transform: scaleX(0); height: 2px; bottom: -2px; left: 0; background: #fff; transform-origin: bottom right; transition: transform .3s ease-out;}p:hover::after { transform: scaleX(1); transform-origin: bottom left;} display: inline-block，使 p 成为内联块，以防止下划线跨越整行宽度而不仅仅是文本内容 transform: scaleX(0)，最初将伪元素缩放为 0，因此是看不见的 bottom: 0 and left: 0，将伪元素放在父元素的左下角 transition: transform 0.25s ease-out，设置动画效果为 ease-out，并且在 0.25 秒内完成 transform-origin: bottom right，变换中心点到父元素的右下角 :hover::after，然后使用 scaleX(1) 将宽度转换为 100％，然后将中心点更改为左下角，允许它在悬停时从另一个方向转换出来 兄弟元素淡化示例可见 兄弟元素淡化，悬停时兄弟节点淡化显示 1234567&lt;ul class=\"box\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526.box { width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; flex-direction: row;}li { list-style: none; width: 50px; height: 50px; line-height: 50px; text-align: center; font-size: 16px; margin: 0 20px; background: #499AFF; color: #fff; transition: opacity .3s; cursor: pointer;}.box:hover li:not(:hover) { opacity: 0.5;} transition: opacity 0.2s，设置 0.2 秒的淡化动画 .box:hover li:not(:hover)，当父级悬停时，选择当前未悬停的 li 子项并将其透明度更改为 0.5 target 选择器示例可见 target 选择器，点击切换的时候 div 会同步变化 12345678&lt;a href=\"#1\"&gt;1&lt;/a&gt;&lt;a href=\"#2\"&gt;2&lt;/a&gt;&lt;a href=\"#3\"&gt;3&lt;/a&gt;&lt;div class=\"box\"&gt; &lt;div id=\"1\"&gt;&lt;/div&gt; &lt;div id=\"2\"&gt;&lt;/div&gt; &lt;div id=\"3\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box { display: flex; align-items: center;}.box div { width: 100px; height: 100px; margin: 5px; background: #499AFF; transition: flex 1s;}.box div:target { flex: 1; background: lightcoral;} 立体感按钮示例可见 立体感按钮，页面布局就是一个单纯的 &lt;button&gt;&lt;/button&gt; 按钮，样式如下 12345678910111213141516button { padding: 1em 3em; border-radius: .2em; outline: none; border: none; color: #fff; cursor: pointer; background: linear-gradient(#3de5fb, #26acbd); text-shadow: 0 1px 1px grey; box-shadow: 0 0.3em 0 #068494, 0 0.3em 0.3em grey;}button:active { box-shadow: 0 0.1em 0 #068494, 0 0.1em 0.1em grey; transition: translate(0, 0.05em);}","link":"/2019/09/27/CSS/12/"},{"title":"CSS 当中的 position","text":"我们在之前的章节当中介绍过了 CSS 当中的 float 和 display 属性，今天我们接着上回继续来看 CSS 当中另一个比较重要的属性，那就是 position，关于 position 的简单用法可以参考下面这个示例（转自 MDN） 基本语法在 CSS 中，每一个元素都由一个矩形盒子所包含，每一个盒子都会具有一个内容区，内容区被一个内边距所包裹，内边距外是盒子的边框，并且在边框之外会有一个外边距用于与其他盒子分隔开来，这些你可以从下面这张图片看到 定位模式规定了一个盒子在总体的布局上应该处于什么位置以及对周围的盒子会有什么影响，定位模式包括了常规文档流，浮动，和几种类型的 position 定位的元素，它的属性可以取 absolute/relative/fixed/static/sticky 其中的一种，它们之间的区别如下 static，该关键字指定元素使用正常的布局行为，如果没有设置 postion，所以元素的 position 都是默认的 static，即元素在文档常规流中当前的布局位置，此时 top/right/bottom/left/z-index 属性均无效 relative，该关键字下，此时元素仍然处于正常流，且不改变 display 属性，元素会先放置在未添加定位时的位置，在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白），对 table-*-group/table-row/table-column/table-cell/table-caption 元素无效，可以理解为仍然占据原来空间，所以不影响其他元素布局，但是可能会覆盖别的元素 absolute，元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置，绝对定位的元素可以设置外边距（margins），且不会与其他边距合并 fixed，元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置，元素的位置在屏幕滚动时不会改变，fixed 属性会创建新的层叠上下文，当元素祖先的 transform/perspective/filter 属性非 none 时，容器由视口改为该祖先 sticky，元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 Containing Block（最近块级祖先，nearest block-level ancestor），包括 table-related 元素，基于 top/right/bottom/left 的值进行偏移，偏移值不会影响任何其他元素的位置，该值总是创建一个新的层叠上下文（stacking context） 需要注意的是，一个 sticky 元素会固定在离它最近的一个拥有滚动机制的祖先上（当该祖先的 overflow 是 hidden/scroll/auto/overlay 时），即便这个祖先不是最近的真实可滚动祖先，这有效地抑制了任何 sticky 大多数情况下，height 和 width 被设定为 auto 的绝对定位元素，按其内容大小调整尺寸，但是被绝对定位的元素可以通过指定 top 和 bottom ，保留 height 未指定（即 auto），来填充可用的垂直空间，它们同样可以通过指定 left 和 right 并将 width 指定为 auto 来填充可用的水平空间，不过这里有一个需要注意的地方，就是如果 top 和 bottom 都被指定（严格来说，这里指定的值不能为 auto ）的时候 top 优先 在深入展开之前，我们先来看看包含块（Containing Block）的和偏移属性的概念 包含块包含块简单理解就是一个定位参考块，就是大盒子里套小盒子中那个大盒子，元素有 positon 属性就必然涉及到包含块，包含块简单来说分为两部分，即根元素与非根元素，根元素 HTML 的包含块（也称为初始包含块，Initial containing block，即根元素的包含框）是一个视窗大小的矩形，即 HTML 的父级 Document，而非根元素分为两种情况（positon: fixed 元素的包含块是由 viewport 决定的，和根元素无关） 如果 position 值是 relative 或 static，包含块由最近的块级框、表单元格或行内祖先框的内容边界构成，也就是元素包含块为最近的块级（block/list-item/table）父元素的内容框 content-box 如果 position 值是 absolute，包含块设置为最近的 position 值不是 static 的祖先元素（可以是任何类型），过程如下 如果这个祖先是块级元素，包含块则设置为该元素的内边距边界，换句话说就是由边框界定的区域 如果这个祖先是行内元素，包含块则设置为该祖先元素的内容边界 如果没有祖先，元素的包含块定义为初始包含块，即 Document 需要注意的是，由于元素可以定位到其包含块的外面，这与浮动元素使用负外边距浮动到其父元素内容区外面很类似，所以这里包含块实际上应该是定位上下文，或者定位父级 偏移属性CSS 有三种基本的布局机制，普通流、浮动和绝对定位，利用定位可以准确地定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置，但元素究竟如何定位，定位到什么位置，主要依靠偏移属性来决定 三种定位机制使用了四个属性来描述定位元素各边相对于其包含块的偏移，这四个属性被称为偏移属性，它们是 top/right/bottom/left，并且初始值都为 auto，可以应用于 position 值不是 static 的定位元素，如果使用的是百分数，则对于 top 和 bottom 而言它相对于包含块的 clientHeight，而对于 right 和 left 来说则相对于包含块的 clientWidth 这些属性描述了距离包含块最近边的偏移，top 描述了定位元素上外边界离其包含块的顶端有多远，如果 top 为正值，会把定位元素的上外边距边界下移，若为负值，则会把定位元素的上外边距移到其包含块的顶端之上，类似地，left 描述了定位元素的左外边距边界在其包含块左边界右边（正值）或左边（负值）有多远 如果是正值，会把定位元素的外边距边界移到包含块左边界右边，而负值则将其移到包含块左边界左边，所以，正值会导致向内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移，偏移定位元素的外边距边界时，带来的影响是元素的所有一切（包含外边距、边框、内边距和内容）都会在定位的过程中移动 定位元素的边界是指定位元素 margin 外侧的边界，包含块的包含区域是指包含块的 border 内侧的 padding + content 区域 在了解了包含块的和偏移属性的概念以后，我们就来看看各种不同的取值之间的差别，不过在本章当中，我们主要介绍 position 和 sticky 这两个属性，其他几个属性就简单带过 绝对定位元素绝对定位时，会从文档流中完全删除，然后相对于其包含块定位，其边界根据偏移属性（top、left 等）放置，定位元素不会流入其他元素的内容，反之亦然，元素绝对定位时，会为其后代元素建立一个包含块，如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位 一个绝对定位的元素的起点位置是相对于它的第一个 position 值不为 static 的父元素而言的，如果在它的父元素链上没有满足条件的父元素，那么绝对定位元素则会相对于文档窗口来进行定位，也就是说，当你在一个元素的样式上设置 position: absolute 则意味着需要考虑它的父元素，如果父元素的 position 值不为 static ，那么绝对定位元素的起点为父元素的左上角位置 如果父元素没有应用除了 static 以外的 position 定位，那么它会检查父元素的父元素是否有应用非 static 定位，如果该元素应用了定位，那么它的左上角便会成为绝对元素的起点位置，如果没有则会继续向上遍历 DOM 直到找到一个定位元素或者寻找失败以到达最外层的浏览器窗口，当元素绝对定位时，它的偏移属性表现如下 left: 0，元素的左边界（margin-left 外侧）位于包含块的左边界内侧（border-left 内侧） top: 0，元素的上边界（margin-rop 外侧）位于包含块的上边界内侧（border-top 内侧） right: 0，元素的右边界（margin-right 外侧）位于包含块的右边界内侧（border-right 内侧） bottom: 0，元素的下边界（margin-bottom 外侧）位于包含块的下边界内侧（border-bottom 内侧） 当 top/right/bottom/left 四个值都为 auto 时（即都处于默认状态时） left: auto，元素的左边界位于元素处于静态位置时的左边界 top: auto，元素的上边界位于元素处于静态位置时的上边界 right: auto，元素的右边界位于正好能包裹住元素的横向区域的右边界（margin-right 外侧） bottom: auto，元素的下边界位于正好能包裹住元素的纵向区域的下边界（margin-bottom 外侧） 元素的静态位置是指元素在正常流中原本的位置，更确切的讲，顶端的静态位置是从包含块的上边界到假想框的上外边距边界之间的距离，假想框是假设元素 position 属性为 static 时元素的第一个框，如果这个假想框在包含块的上面，则这个值为负 格式化对于普通流的元素来说，水平格式化的七大属性是 margin-left/border-left/padding-left/width/padding-right/border-right/margin-right，这些属性的值加在一起就是元素包含块的宽度，这往往也是块元素的父元素的 width 值（因为块级元素的父级元素几乎都是块级元素）垂直方向也类似，但是对于绝对定位元素则不相同，它的水平格式化等式为 1left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = Containing Block clientWidth 类似的，垂直格式化等式为 1top + margin-top + border-top-width + padding-top + height + padding-bottom + border-bottom-width + margin-bottom + bottom = Containing Block clientHeight 也就是下图这样 auto在之前偏移属性表现的时候，我们提到了 auto，其实 auto 值是用来弥补实际值与所需总和的差距，水平方向上，可以为 auto 的属性有 left/margin-left/width/margin-right/right，同样的，在垂直方向上，可以为 auto 的属性有 top/margin-top/height/margin-bottom/bottom margin-left: auto; margin-right: auto; left: 0; right: 0;，块元素可以横向居中显示 margin-top: auto; margin-bottom: auto; top: 0; right: 0;，块元素可以纵向居中显示 所以我们可以结合上面两点来实现水平垂直居中显示 相对定位相对定位的元素也是根据 top/right/bottom/left 四个属性来决定自己的位置的，但只是相对于它们原来所处于的位置进行移动，在某种意义上来说，为元素设置相对定位和为元素添加 margin 有点相似，但也有一个重要的区别，区别就是在围绕在相对定位元素附近的元素会忽略相对定位元素的移动 我们可以把它看做是一张图片的重像从真实的图片的位置开始进行了一点移动，它原始图片所占据的位置仍然保留，但我们已经没法再看到它，只能看到它的重像，这样就让元素之间可以进行位置的重叠，因为相对定位元素能够移动到其他元素所占据的空间中，如果相对定位元素离开了正常文档流，但仍然影响着围绕着它的元素，那些元素表现地就好像这个相对定位元素仍然在正常文档流当中 固定定位固定定位的行为类似于绝对定位，但也有一些不同的地方，首先，固定定位总是相对于浏览器窗口来进行定位的，并且通过 top/right/bottom/left 属性来决定其位置，它抛弃了它的父元素，第二个不同点是固定定位的元素是固定的，它们并不随着页面的滚动而移动，你可以告诉元素它所处的位置并永远不再移动 在某种意义上说固定定位元素有点儿类似固定的背景图片，只不过它的外层容器块总是浏览器窗口罢了，如果你在 body 中设置一个背景图片那么它与一个固定定位的元素的行为时非常像的，只不过在位置上的精度会略少一些 这里提到固定定位和绝对定位的话，那就不得不提另外一个属性，那也就是 z-index 了，不过关于 z-index 的相关内容较多，所以我们会另起篇幅来进行介绍，这里可以先简单了解一下，参考下图 由上图可知，高的 z-index 位于低的 z-index 的上面并朝页面的上方运动，相反地，一个低的 z-index 在高的 z-index 的下面并朝页面下方运动，现在我们只需要记住这个维度的基本概念以及它的堆叠顺序，另外还要记住只有定位元素才能应用 z-index 属性 粘性定位sticky 是 CSS 属性 position 中的一个可选值，跟我们用得比较多的 static/fixed/relative/absolute 一样，都是用来描述元素的定位方式，它是计算后位置属性为 sticky 的元素，简单的理解就是，在目标区域以内，它的行为就像 position: relative 一样，但是在滑动过程中，某个元素距离其父元素的距离达到 sticky 粘性定位的要求时（比如 top：100px），这时 position: sticky 的效果就相当于 fixed 定位，固定到适当位置 其实可以说是相对定位 relative 和固定定位 fixed 的结合，元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么就会相对于 viewport 来计算元素的偏移量，比如下面这个示例 用代码实现的话，大概是下面这样的 12345678910111213&lt;div class=\"container\"&gt; &lt;nav&gt;我是导航栏&lt;/nav&gt; &lt;div class=\"content\"&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;p&gt;我是内容栏&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.container { background: #eee; width: 600px; height: 1000px; margin: 0 auto;}nav { position: -webkit-sticky; position: sticky; top:0;}nav { height: 50px; background: #999; color: #fff; font-size: 30px; line-height: 50px;}.content { margin-top: 30px; background: #ddd;}p { line-height: 40px; font-size: 20px;} 其实 position:sticky 在使用上很简单，就两句核心代码 1234div { position: sticky; top: 0;} 但是它的生效是有一定的限制的，总结如下 须指定 top/right/bottom/left 四个阈值其中之一，才可使粘性定位生效，否则其行为与相对定位相同 上面的 top: 0 的意思是当元素滑动到距离视口 0px 时再继续滑动，元素吸顶 并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时 left 的优先级高 设定为 position: sticky 元素的任意父节点的 overflow 属性必须是 visible，否则 position: sticky 不会生效，这里需要解释一下： 如果 position: sticky 元素的任意父节点定位设置为 overflow: hidden，则父容器无法进行滚动，所以 position: sticky 元素也不会有滚动然后固定的情况 如果 position: sticky 元素的任意父节点定位设置为 position: relative/absolute/fixed，则元素相对父元素进行定位，而不会相对 viewprot 定位 达到设定的阀值，也就是设定了 position: sticky 的元素表现为 relative 还是 fixed 是根据元素是否达到设定了的阈值决定的 下面再来看一个示例 123456&lt;div class=\"container\"&gt; &lt;div class=\"sticky-box\"&gt;内容1&lt;/div&gt; &lt;div class=\"sticky-box\"&gt;内容2&lt;/div&gt; &lt;div class=\"sticky-box\"&gt;内容3&lt;/div&gt; &lt;div class=\"sticky-box\"&gt;内容4&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.container { background: #eee; width: 600px; height: 1000px; margin: 0 auto;}.sticky-box { position: -webkit-sticky; position: sticky; height: 60px; margin-bottom: 30px; background: #ff7300; top: 0px;}div { font-size: 30px; text-align: center; color: #fff; line-height: 60px;} 我们在之前的部分曾经提到过，sticky 效果只在 Containing Block 内有效，当 Containing Block 滑出屏幕时，Stickey Element 也跟着滑走，但是针对于上面这个示例，多个 Sticky Element 放在一块就有了前一个被后一个顶出去的效果，实际上并不是真的被顶出去，而是 Containing Block 把它拖走了 其实使用 sticky 比较优势的地方是移动端，在没有 CSS Sticky 之前，类似的效果都是使用 JavaScript 来进行实现的，它一般的流程是下面这样 监听滚动事件，计算目标元素距离视口的距离 距离不满足条件时，按兵不动 距离满足条件时，创建占位元素，修改目标元素定位方式为 fixed 1234window.addEventListener('scroll', () =&gt; { const rect = elem.getBoundingClientRect() // 计算目标元素和视口的距离}) 但是使用 CSS Sticky 以后，工作都交给 GPU 了，不再占用 JavaScript 主线程的资源，所以在移动端上的表现异常流畅 参考 Why does overflow:hidden prevent position:sticky from working? position","link":"/2018/11/30/CSS/14/"},{"title":"CSS 当中的 vertical-align","text":"我们在之前的章节当中介绍过了 CSS 当中的 float，display，position 和 line-height 属性，今天我们接着上回继续来看与 line-height 联系十分紧密的 vertical-align，可以参考下面这个例子来看看 vertical-align 的基本用法（转自 MDN） 还是老规矩，我们从一个示例开始进行介绍，如下 12&lt;div&gt;&lt;/div&gt;&lt;div&gt;为什么？&lt;/div&gt; 我们页面当中有有两个 div 元素，第一个为空，第二个中间我们添加了一些文本，应用的样式如下 123456div{ width: 100px; height: 100px; border: 1px solid red; display: inline-block;} 那么请问，此时页面当中的显示是什么样子的？运行以后你可能会很惊讶，因为结果是下面这样的 至于解决办法，很简单，只需要给第二个 div 加上 vertical-align: top 即可，那么为什么会这样呢？这也是我们今天将要探讨的问题 vertical-alignvertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式，也就是说，对于块级元素，vertical-align 是不起作用的，vertical-align 的属性值可以归为以下四类 线类，如 baseline、top、middle、bottom 文本类，如 text-top、text-bottom 上标下标类，如 sub、super 数值百分比类，如 10px、1em、5% 线类线类当中用的较多的是 middle，但是我们还是一个一个来进行了解，先从 baseline 开始看起 baselinebaseline 为 vertical-align 的默认值，其意思是指基线对齐，所谓基线，指的是字母 x 的下边缘（关于基线的概念可以参考之前的 line-height 章节）我们来看个例子，代码如下 12345.box { width: 100px; line-height: 100px; border: 1px solid #ccc;} 123&lt;div class=\"box\"&gt; &lt;span class=\"text\"&gt;文本&lt;/span&gt;&lt;/div&gt; 由于 baseline 是默认值，所以可以不用写，父元素的 line-height 为 100px，这其实是给默认空白节点设置的，我们在之前介绍过，每一个行框盒子都有一个看不见的节点，该节点继承了 line-height，因此子元素对齐于该节点的基线（可以想象成这个看不见的节点有一个字母 x，而子元素就是跟这个字母 x 的下边缘对齐），效果如下 关于 baseline 有一个需要注意的地方就是 inline-block 元素，如果一个 inline-block 元素，里面没有内联元素，或者 overflow 不是 visible，则该元素的基线是其 margin 底边缘，否则其基线就是元素里面最后一行内联元素的基线，其实就是我们开头时候看到的问题，例子如下 123456.text { display: inline-block; width: 100px; height: 100px; border: 1px solid #ccc;} 1234&lt;div class=\"container\"&gt; &lt;span class=\"text\"&gt;文本&lt;/span&gt; &lt;span class=\"text\"&gt;&lt;/span&gt;&lt;/div&gt; 效果如下 top对于内联元素，指的是元素的顶部和当前行框盒子的顶部对齐，对于 table-cell 元素，指的是元素的顶 padding 边缘和表格行的顶部对齐，例子如下 12345678910.box { width: 100px; line-height: 100px; border: 1px solid #ccc;}.top { line-height: normal; vertical-align: top;} 123&lt;div class=\"box\"&gt; &lt;span class=\"top\"&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下 其中 bottom，跟 top 类似，将顶部换成底部即可，所以我们就不展开了，下面来看看 middle middle这个属性值用得比较多，对于内联元素是将元素盒子的垂直中点与父盒子的 baseline 加上父盒子的 x-height 的一半位置对齐，简单点说就是字母 x 的中心位置对齐，对于 table-cell 元素，指的是单元格填充盒子相对于外面的表格行居中对齐 基本上所有字体中，字母 x 的位置都是偏下一点的，font-size 越大偏移越明显，因此字母 x 中心的位置不是行框盒子的中心，也就是说 vertical-align 只能实现近似垂直居中对齐 文本类文本类分为以下两种 text-top，指的是盒子的顶部和父级内容区域的顶部对齐 text-bottom，指的是盒子的底部和父级内容区域的底部对齐 看下面这个例子 123456789101112131415161718192021222324.box { width: 300px; line-height: 100px; border: 1px solid #ccc; font-size: 20px;}.f12 { font-size: 12px;}.f16 { font-size: 16px;}.f20 { font-size: 20px;}.text-top { line-height: normal; vertical-align: text-top; width: 100px;} 123456&lt;div class=\"box\"&gt; &lt;span class=\"f12\"&gt;12px&lt;/span&gt; &lt;span class=\"f16\"&gt;16px&lt;/span&gt; &lt;span class=\"f20\"&gt;20px&lt;/span&gt; &lt;img class=\"text-top\" src=\"./card.jpg\"/&gt;&lt;/div&gt; 效果如下 所谓内容区域，可以看成是鼠标选中文字后高亮的背景色区域，上面的例子中，由于父元素设置的是 20px，所以图片的 vertical-align 设置 text-top 的时候，就可以看成是跟子元素为 20px 元素的内容区域顶部对齐 上标下标类上标和下标对应着两个标签 super 和 sub，super 在上面，sub 在下面，这两个属性值在数学公式和化学表达式中用得比较多，平时我们开发几乎用不到，所以这里就不在展开了 数值百分比类vertical-align 是支持数值的，并且兼容性也非常好，但大部分开发人员却不知道 vertical-align支持数值，对于数值，正值表示由基线往上偏移，负值表示由基线往下偏移，而百分比则是基于 line-height来计算的，百分比用得比较少，因为 line-height 一般都是开发人员给出的，这时候数值就可以精确定位元素，不需要再使用百分比再去计算一遍，使用数值的代码如下 1234567891011.box { width: 300px; line-height: 100px; border: 1px solid #ccc; font-size: 20px;}.num { line-height: normal; vertical-align: 20px;} 123&lt;div class=\"box\"&gt; &lt;span class=\"num\"&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下 vertical-align 起作用的前提vertical-align 起作用是有前提条件的，这个前提条件就是，只能应用于内联元素以及 display 值为 table-cell 的元素，在 CSS 中，有些 CSS 属性是会改变元素的 display 值的，例如 float 和 position: absolute，一旦设置了这两个属性之一，元素的 display 值就是变为 block，因此 vertical-align 也就失去了作用，下面这段代码这样写就是错的 1234span { float: left; vertical-align: middle; /* 这一句是无效的 */} 另外，更多人遇到的是以下这种无效的情况 12345678.box { height: 200px;}.box &gt; img { height: 100px; vertical-align: middle;} 123&lt;div class=\"box\"&gt; &lt;img src=\"1.jpg\" /&gt;&lt;/div&gt; 其实，不是 vertical-align 无效，而是前面所提到的行框盒子当中的空白节点引起的原因，由于父元素没有设置 line-height，所以当前空白节点的 line-height 就非常小，比图片的高度小很多，vertical-align: middle 没法发挥作用，这时给父元素一个比较高的 line-height，就会看到 vertical-align 起作用了 1234.box { height: 200px; line-height: 200px;} vertical-align 与 line-height 的关系前面我们提到，vertical-align 的百分比值是根据 line-height 来计算的，但实质上只要是内联元素，这两个元素都会同时在起作用，如下例子 1234567.box { line-height: 32px;}.box &gt; span { font-size: 24px;} 123&lt;div class=\"box\"&gt; &lt;span&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下 从代码上看，好像父元素的高度会是 32px，但实质上父元素的高度会比 32px 还要高，原因是空白节点继承了 line-height: 32px，span 也继承了 line-height: 32px，但两者的 font-size 不一样，这就导致了空白节点的 font-size 比较小，而 span 的 font-size 比较大，也就是说它们的基线不在同一位置上，空白节点偏上一点，而 span 默认又是基线对齐，为此，span 总体会往上移以便跟空白节点的基线对齐，父元素元素就是这样被撑高了，而解决方案可以有以下几种 span 元素不使用基线对齐，可以改为 top 对齐 span 元素块状化 line-height 设置为 0 font-size 设置为 0 关于边界和 baseline对于垂直对齐这个知识点来说最重要的就是涉及元素的 baseline，有时候元素的盒模型的上下边界也会变的很重要，在上面我们曾提到过 vertical-align 起作用的前提，也就是 display 值为 inline 和 inline-block 的元素（inline-table 的元素不在本文的讨论范围内），下面我们就来看看它们之间的区别 inline 如图所示有三行文字，行高的上下边界是红线，文字的上下边界是绿色的线，蓝色的线就是 baseline 了，左边文字的高度与行高是一致的，因此绿线和红线重合了，中间的行高是文字大小的两倍，而在右边，行高是文字大小的二分之一 行内元素的外边缘在行高的上边缘和下边缘这个范围内对齐，如果行高小于文字的高度也无所谓，关于 baseline 的定义可以参考 leading inline-block 从左到右的三张图都是 inline-block 元素，不同的是，左面包含着没有脱离正常流的内容 C，中间的除了没有脱离正常流的内容以外还加了 overflow: hidden，右面的没有内容但是内容区还有高度，红线代表了 margin-box 的边界，黄色代表的是 border，绿色的是 padding，蓝色的是 content，蓝色的线代表的还是 baseline 我们可以发现 inline-block 元素的外边缘就是 margin-box 的边缘，inline-block 元素的 baseline 的位置要看该元素有没有处于正常流之内的内容，所以这里可以分为三种情况 在有处于正常流内容的情况下，inline-block 元素的 baseline 就是最后一个作为内容存在的元素的 baseline，这个元素的 baseline 的确定就要根据它自身来确定了 在 overflow 属性不为 visible 的情况下，baseline 就是 margin-box 的下边界了 第三种情况下 baseline 还是 margin-box 的下边界 line-box 这一次我们将文字部分高亮显示，可以发现 line-box 的上边界与最高元素的上边界对齐，下边界与最低元素的下边界对齐 line-box 的 baseline 是不可见的，但是可以很轻松的将它可视化出来，在行的开头添加一个字母，比如 x，这个字母的下边界默认就是 baseline 的位置，围绕着 baseline 在 line-box 中形成了文字盒，文字盒可以被认为是没有和任何元素对齐的 line-box 中的 inline 元素，因此文字盒仅仅包含非格式化的 line-box 的文本，文字盒的边界由绿线来表示，因为文字盒是紧挨着 baseline 的，所以 baseline 的位置发生变化的话，文字盒的位置也会跟着改变（这里所提到的文字盒其实就是我们之前介绍到的空白节点） 总结起来的话有以下两点 有一个区域叫做 line-box，垂直方向上的对齐都是发生在这个区域里面，它有 baseline，有文字盒，有上下边界 inline 元素也有 baseline 和上下边界，inline 元素是需要对齐的对象 line-box 的 baseline 的移动问题这是一个 vertical-align 的坑，line-box 中的所有元素都会影响到 baseline 的位置，假设，一个元素按某种方式垂直对齐了，但是这种对齐方式会引起 baseline 的移动，又因为大部分的垂直对齐方式（除了 top 和 bottom）和 baseline 有关，因此这个元素的垂直方向对齐的行为会引起该 line-box 内其他元素位置的调整，我们来看下面这个例子 一个很高的元素，其高度占满了整个 line-box，那么 vertical-align 对其实没有影响的，在它的 top 和 bottom 之外没有空间让其移动，但是为了满足它的 vertical-align 的值，line-box 的 baseline 会发生移动，左面的高元素的取值为 text-bottom，矮元素的取值为 baseline，如果右面的高元素的取值为 text-top，你会看到 baseline 跳上去了 1234567&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt; 12345.tall-box,.short-box { display: inline-block }.text-bottom { vertical-align: text-bottom }.text-top { vertical-align: text-top } 如果把高元素的 vertical-align 设置为其他值，也能看到类似的行为，甚至将 vertical-align 设置为 bottom 或者是 top 也会让 baseline 发生移动，这很奇怪，因为这时候应该就没 baseline 什么事儿了，如下图所示 1234567&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt; 12345.tall-box,.short-box { display: inline-block }.bottom { vertical-align: bottom }.top { vertical-align: top } 将两个更大的元素放在一个 line 里面，并且设置 vertical-align 的值让 line-box 的 baseline 移动，在满足 vertical-align 数值对齐的条件下，line-box 的高度会自我调整，如左面的图，再增加第三个元素，第三个元素如果因为其 vertical-align 的设置不会超过 line-box 的边缘的话，它是不会影响到 line-box 的高度和 baseline 的位置的，如果它会超过 line-box 的边缘，那么 line-box 的高度和 baseline 的位置也会进行调整，在第二种情况下，另外两个元素的位置发生了下移 12345678910111213&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;!-- mark-up in the middle --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box middle\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-100up\"&gt;&lt;/span&gt; 123456.tall-box { display: inline-block }.middle { vertical-align: middle }.text-top { vertical-align: text-top }.text-bottom { vertical-align: text-bottom }.text-100up { vertical-align: 100% } 使用场景其实我们可以发现，在大部分的情况之下，使用 line-height 就可以解决 vertical-align 所遇到的问题，这么说的话是不是 vertical-align 就派不上用场了呢？ 在这样的场景下可以尝试使用 vertical-align，即当一个文本后面跟着个 inline-block 的元素时，后者是对其文本的基线的，这就导致文本看上去被挤下来了一样，使用 vertical-align: top/text-top 就可以解决这个问题，这是 line-height 所解决不了的 参考 Vertical-Align: All You Need leading vertical-align Leading and half-leading","link":"/2019/01/08/CSS/16/"},{"title":"前端字体优化","text":"最近在工作当中遇到了关于前端字体优化的问题，主要是公司有一款产品是一个在线的编辑工具，其中可以提供给用户各种不同的字体来进行编辑操作，所以在载入编辑区的过程当中会变得十分缓慢，所以特意抽了些时间研究了一下，在这里顺便记录一下 在正式展开之前，可以先了解一下 各平台的默认字体情况，下面我们就从如何加载自定义字体开始介绍 如何加载自定义字体在 CSS3 当中，使用 @font-face 即可加载自定义字体了，使用 @font-face 可以定义某个特定字体资源的位置，其样式特征用于网页 12345678910@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 600; src: local('Some Font Italic'), url('/fonts/someFont.woff2') format('woff2'), url('/fonts/someFont.woff') format('woff'), url('/fonts/someFont.ttf') format('ttf'), url('/fonts/someFont.eot') format('eot');} 使用 local() 指令，我们可以引用、加载和使用本地安装的字体 使用 url() 指令，我们可以加载外部字体，并且该指令可以包含一个可选的 format() 提示，指示由提供的网址所引用的字体的格式 对大型 unicode 字体进行子集内嵌以提高性能，比如使用 unicode-range 子集内嵌，并为较旧的浏览器提供手动子集内嵌回退 减少风格字体变体的数量以改进网页和文本呈现性能 为了兼容不同的浏览器，我们一般会使用多个格式，也许你会遇到类似下面这样的写法 123456@font-face { font-family: 'SomeFont'; src: url('someFont.eot'); /* IE9 Compat Modes */ src: url('someFont.eot?#iefix') format('embedded-opentype'), /* IE6 - IE8 */ url('someFont.woff') format('woff'), /* Modern Browsers */} 可以注意到，上面例子当中有两个 src 属性，并且还有一个 ?#iefix 的后缀，它是有何作用的呢？绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式，这是因为在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效，由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题 IE9 之前的版本没有按照标准解析字体声明，当 src 属性包含多个 url 时，它无法正确的解析而返回 404 错误，而其他浏览器会自动采用自己适用的 url，因此把仅 IE9 之前支持的 EOT 格式放在第一位，然后在 url 后加上 ?，这样 IE9之前的版本会把问号之后的内容当作 url 的参数，至于 #iefix 的作用，一是起到了注释的作用，二是可以将 url 参数变为锚点，减少发送给服务器的字符 字体格式现在网络上使用的字体容器格式有四种 EOT、TTF、WOFF 和 WOFF2，遗憾的是，无论选择的范围有多宽，都不会有在所有旧浏览器和新浏览器上都可以使用的单一通用格式 EOT 仅 IE 支持 TTF 具有 部分 IE 支持 WOFF 的支持最广泛，但它在许多较旧的浏览器中不可用 WOFF 2.0 支持 对于许多浏览器来说还未实现， 所以一般采用以下方式，采用多个样式，让浏览器自动采用自己所适用的 将 WOFF 2.0 变体提供给支持它的浏览器 将 WOFF 变体提供给大多数浏览器 将 TTF 变体提供给旧 Android（4.4 版以下）浏览器 将 EOT 变体提供给旧 IE（IE9 之下）浏览器 还有一种 SVG 字体，因为兼容性和用途有限，可以忽略不提 但是在使用过程当中也会遇到问题，通常来说，字体文件一般加载都是非常缓慢的，因为中文字体文字数量庞大，字体文件也变得非常之大，页面加载之后，还需要很长的时间来下载字体，下载完成之后，才会正确显示 在用户看来，就是打开页面很久之后字体又变了，体验非常不好，所以为了解决这个问题，看了很多文档，也尝试了许多种方法，每种方法又可有优劣，所以在这里大致的总结一下，一般比较常见的有以下几种方案 压缩字体大小并且使用缓存这个应该是比较常用的方法了，但是效果的提升不是很明显，一般的做法是在服务器开启 http/2，并对静态资源设置 E-TAG 和 Cache-Control 来进行缓存，也可以在服务器端配置 GZIP 压缩，可以有效的减小字体文件大小 还可以考虑使用 Zopfli 压缩处理 EOT、TTF 和 WOFF 格式，Zopfli 是一个 zlib 兼容压缩工具，该工具通过 gzip 大概可以减小越 5% 的文件大小，这种方法只是在一定层度上减小了字体文件的体积，却没用从根本上解决如果字体文件过大，加载缓慢的问题 font-spider其实一开始也是准备使用 字蛛（font-spider） 这个库的，但是在目前这个项目当中，我们并不能知道用户添加的文本有哪些，输入的标题有哪些，所以也就不能使用这个方法了，但是还是抽空了解了一下使用方式 那么什么是 font-spider 呢？引用官方的话就是，字蛛是通过分析本地 CSS 与 HTML 文件获取 WebFont 中没有使用的字符，并将这些字符数据从字体中删除以实现压缩，同时生成跨浏览器使用的格式，使用起来感觉很简单，首先进行安装 1$ npm install font-spider -g 安装完成以后就可以在 CSS 中使用 WebFont 12345678910111213141516/* 声明 WebFont */@font-face { font-family: 'myfont'; src: url('../font/myfont.eot'); src:url('../font/myfont.eot?#font-spider') format('embedded-opentype'), url('../font/myfont.woff') format('woff'), url('../font/myfont.ttf') format('truetype'), url('../font/myfont.svg') format('svg'); font-weight: normal; font-style: normal;}/* 使用选择器指定字体 */.test &gt; p { font-family: 'myfont';} 注意需要指定 ?#font-spider 后缀，关于这个属性，上面已经介绍过了 配置完成了以后，就可以在当前路径下，或者要压缩字体的 HTML 文件下执行以下操作 1font-spider ./demo/*.html 这时，font-spider 就会帮助我们将页面依赖的字体将会自动压缩好，并且原 .ttf 字体是会备份的，下面是尝试过程当中遇到的一些坑 格式相关问题，font-spider 主要依据 ttf 格式的文件来进行分析压缩的，所以 font-face 的路径必须存在 ttf 格式的，其他格式不行 路径，引入路径要使用相对路径，否则会报 Web Font was not found 局限性，font-spider 仅适用于固定文本，如果文字内容为动态可变的，新增的文字将无法显示为特殊字体 解决办法是将备份还原，重新压缩 font-spider xxx.html 如果不添加 options，会默认备份原文件 如果是 base64 形式的字体，可能会报不存在引入文件的错误，所以如果不想压缩某个字体包的话，就先注释其 font-face 一旦压缩一次后，再次压缩别的是没用的 比如说在一个文件夹里压缩了字体，生成了字体包，又在另一个文件夹里压缩字体，这两个文件夹的字体共用一个字体包和 font-face 所以再次压缩的就是上一个压缩字体包进行压缩的，所以导致页面中有的字体没有转化过来 解决办法，使用 font-spider file1/*.html file2/*.html file3/*.html 命令，压缩所有指定文件即可 fontmin另外一个方法和 font-spider 差不多，但是感觉用起来更为方便一些，那就是 fontmin，简答来说，fontmin 的作用就是提取 ttf 字体文件中需要用到的文字，然后转换为 woff 文件输出，更为方便的就是我们可以手动指定输出内容 123456789101112131415161718const Fontmin = require('fontmin');const fontmin = new Fontmin() .src('assets/fonts/SourceHanSerifCN-Light.ttf') .dest('build/fonts/') .use(Fontmin.glyph({ text: '天地玄黄宇宙洪荒', hinting: false })) .use(Fontmin.ttf2woff({ deflate: true }))fontmin.run((err) =&gt; { if (err) { throw err }}) 下面是一些注意事项 src 制定了输入字体文件路径（必须是 ttf 文件） dest 是输出路径 use(Fontmin.glyph({text, hinting})) 会生成一个只包含 text 字符的字体文件子集 hinting 指定所生成的 ttf 文件是否包含控制值表、字体程序区之类的信息（用于保留完整的 TrueType 轮廓描述信息） use(Fontmin.ttf2woff({deflate: true})) 用来将上一步生成的 ttf 文件转化为 woff，进一步压缩大小 同样的，这个方法也只能用来处理固定的文本内容，由于在项目当中我们无法得知用户输入的具体内容，所以这个方案也被 pass 掉了 使用 Unicode-range 子集内嵌在查找解决方法的过程中，发现了一个很少见的方法，即使用 Unicode-range 子集内嵌，原理是使用 unicode-range 描述符，我们可以指定一个范围值的逗号分隔列表，其中每个可以采用以下三种不同的形式之一 单一代码点（例如 U+416) 间隔范围（例如 U+400-4ff），指示范围的开始代码点和结束代码点 通配符范围（例如 U+4??），字符指示任何十六进制数字 1234567891011121314151617181920212223@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 400; src: local('SomeFont Font'), url('/fonts/someFont-l.woff2') format('woff2'), url('/fonts/someFont-l.woff') format('woff'), url('/fonts/someFont-l.ttf') format('ttf'), url('/fonts/someFont-l.eot') format('eot'); unicode-range: U+000-5FF; /* Latin glyphs */}@font-face { font-family: 'SomeFont'; font-style: normal; font-weight: 400; src: local('SomeFont Font'), url('/fonts/someFont-jp.woff2') format('woff2'), url('/fonts/someFont-jp.woff') format('woff'), url('/fonts/someFont-jp.ttf') format('ttf'), url('/fonts/someFont-jp.eot') format('eot'); unicode-range: U+3000-9FFF, U+ff??; /* Japanese glyphs */} 通过使用 unicode range 子集以及为字体的每种样式变体使用单独的文件，我们可以定义一个复合字体系列，访问者将仅下载变体及变体需要的子集，而不会强制他们下载他们可能从未在网页上看到或使用过的子集，在浏览器不支持 unicode range 的情况下，浏览器会下载所有字体 preload最终敲定的方案是使用 &lt;link rel=preload&gt; 来提前加载字体文件，因为刚好在项目当中，用户在进入编辑区之前会有一个预览页面，所以在这个页面进行字体的预加载，然后利用浏览器的缓存功能，这样一来就可以保证用户在进入编辑区的时候不会经历漫长的等待，在此之前，我们先来看看网页加载中的字体加载过程，如下图所示 字体的延迟加载可能会延迟文本呈现，主要原因是由于浏览器必须构造呈现树，这依赖于 DOM 和 CSSOM 树，在此之后，它将知道它将需要哪些字体资源来呈现文本，因此，会将字体请求很好地延迟到其他关键资源之后，并且在取回资源之前可能会阻止浏览器呈现文本，下面是一个简化版本的浏览器渲染过程 浏览器请求 HTML 文档 浏览器开始解析 HTML 响应并构造 DOM 浏览器发现 CSS、JavaScript 和其他资源并分派请求 收到所有 CSS 内容之后，浏览器会立即构造 CSSOM，并将其与 DOM 树组合到一起来构造呈现树 在呈现树指明需要哪些字体变体来呈现网页上的指定文本之后，会立即分派字体请求 浏览器执行布局，并将内容绘制到屏幕上 如果字体还不可用，浏览器可能不会呈现任何文本像素 字体可用之后，浏览器会立即绘制文本像素 网页内容的首次绘制（在构建呈现树之后可以很快完成）和字体资源请求之间的先后顺序就会产生了 FOIT（Flash of Invisible Text），这种情况下浏览器可能会呈现网页布局而忽略任何文本，在不同浏览器之间实际的行为会有所不同 Safari 在字体下载完成之前会暂停文本呈现 Chrome 和 Firefox 会暂停字体呈现最多 3 秒钟，3 秒钟之后它们会使用一种备用字体，并且字体下载完成之后，它们会立即使用下载的字体重新呈现一次文本 如果请求字体还不可用，IE 会立即使用备用字体呈现，并在字体下载完成之后马上重新呈现 可以发现，这里有一个微观的过程就是字体显示时间线，简单的理解就是分为 1字体阻止期 ==&gt; 字体交换期 ==&gt; 字体失败期 如果我们希望能够让浏览器更早一些的显示出正确字体的文字，那么就需要优化字体载入的时间 所以在这种情况下，我们就可以利用 &lt;link rel=preload&gt; 来提前加载字体文件，我们就可以把 &lt;link rel=preload&gt; 放到 HTML 的 &lt;head&gt;&lt;/head&gt; 中，让浏览器提前下载字体文件，而不用等 DOM 树完成后等 CSS 下载后才去请求，由于下载字体使用了额外的 HTTP 请求，因此 http/2 可以大幅提高性能，它不需要受六个并发 HTTP 请求的限制 当然也可以采用动态加载的方式，也就是下面这样 123456789function preLoad(href) { const preloadLink = document.createElement('link') preloadLink.href = href preloadLink.rel = 'preload' preloadLink.as = 'font' preloadLink.type = 'font/woff' preloadLink.crossorigin = 'anonymous' document.head.appendChild(preloadLink)} 当你在服务器上设置好 E-TAG（告诉客户端你的资源有没有变化）和 Cache-control（告诉客户端缓存时间长度）后，这些字体资源就不需要多次下载，以节省时间 使用 font-display 来控制字体阻止期font-display 是 CSS 中新添加的属性，主要用来控制加载字体显示方式，有以下取值 auto 默认值，典型的浏览器字体加载的行为会发生，也就是使用自定义字体的文本会先被隐藏，直到字体加载结束才会显示 swap 后备文本立即显示直到自定义字体加载完成后再使用自定义字体渲染文本 在大多数情况下，这就是我们所追求的效果 fallback 这个可以理解为 auto 和 swap 的一种折中方式 需要使用自定义字体渲染的文本会在较短的时间（Google 浏览器大概在 100ms）不可见 如果自定义字体还没有加载结束，那么就先加载无样式的文本，一旦自定义字体加载结束，那么文本就会被正确赋予样式 optional 效果和 fallback 几乎一样，都是先在极短的时间内文本不可见，然后再加载无样式的文本 不过 optional 选项可以让浏览器自由决定是否使用自定义字体，而这个决定很大程度上取决于浏览器的连接速度，如果速度很慢，那你的自定义字体可能就不会被使用 将 font-display 设置为 swap 后，意味着阻止期为 0，而交换期为无限长，这样一来你便可以避免网页出现空白文本，而立即用替换字体显示内容，一旦需要的字体下载完成后就可以替换原来的字体正确显示 如果你不知道选择那个作为 font-display 的属性值，可以选择 swap，它不仅提供了自定义字体和内容的可访问性之间的最佳平衡，它还提供了和使用 JavaScript 脚本相同的字体加载行为，如果你在页面上有想要加载的字体，但是最终也可以不加载，这时你就可以考虑使用 fallback 或者 optional 作为 font-display 的值 参考 如何优雅的选择字体 @font-face The Web Open Font Format (WOFF) Web 字体简介: TTF, OTF, WOFF, EOT &amp; SVG 通过 rel=”preload” 进行内容预加载 css-font-loading Font Face Observer","link":"/2019/08/18/Essay/03/"},{"title":"线性表（单链表）","text":"在之前的章节当中我们介绍了 线性表（顺序存储结构），它最大的缺点就是插入和删除的时候需要移动大量元素，这显然就需要耗费时间，如果我们想要解决这个问题，就需要考虑一下是如何导致这个问题出现的原因，即为什么当插入和删除的时候，需要移动大量元素？ 其实简单来说，原因就是在于相邻两元素的存储位置也具有邻居关系，它们在内存中的位置是紧挨着的，所以无法快速的插入和删除，如果想要解决这个问题，就可以使用今天我们将要介绍的『链式存储结构』 链式存储结构线性表的链式存储结构的特点就是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置，比起顺序存储结构每个数据元素只需要存储一个位置就可以了，而在链式存储结构中，除了要存储元素信息外，还要存储它的后继元素的存储地址（指针），也就是说出了存储其本身的信息外，还需要存储一个指示其直接后继的存储位置的信息 我们把存粗数据元素信息的域称为『数据域』，把存储直接后继位置的域称为『指针域』，指针域中存储的信息称为『指针域链』，这两部分信息组成数据元素称为存储映像，也称之为『结点』（Node），这里有一个需要注意的地方，就是注意区分『节点』和『结点』，具体区别如下 节点通常被认为是一个实体，有处理能力，比如网络上的一台计算机 而结点则只是一个交叉点，打个结，做个标记，仅此而已 要记住，一般算法中点的都是『结点』 我们在数据结构的图形表示中，对于数据集合中的每一个数据元素用中间标有元素值的方框表示，一般称它为数据结点，简称结点，而在链表数据结构中，链表中每一个元素称为『结点』，每个结点都应包括两个部分 一个是需要用的实际数据 data 另一个就是存储下一个结点地址的指针，即数据域和指针域 数据结构中的每一个数据结点对应于一个存储单元，这种储存单元称为储存结点，也可简称结点 单链表比如 n 个结点链接成一个链表，即为线性表（a1，a2，a3 … an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表，如下图所示 对于线性表来说，存在头部和尾部，链表也不例外，我们把链表中的第一个结点的存储位置称为『头指针』，最后一个结点称为『空』（null） 头指针域头结点通过之前的内容我们可以知道，头结点的数据域一般是不存储任何信息的，那么又与头指针有什么区别呢 头指针 是指链表指向第一个结点的指针，如果链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字） 无论链表是否为空，头指针『均不为空』 头指针是链表的『必要元素』 头结点 头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度） 有了头结点，对在第一元素结点前插入和删除的操作就可以与其他结点的操作相统一 头结点不一定是链表的必须要素（非必要元素） 单链表的示例如下 空链表的示例如下 单链表存储结构我们在 C 语言中可以使用结构指针来描述单链表 123456typedef struct Node { ElemType data; // 数据域 struct Node* Next; // 指针域} Node;typedef struct Node* LinkList; 再次强调，我们一般看到的结点是由『存放数据元素的数据域』和『存放后继结点地址的指针域』组成，比如我们假设 p 是指向线性表第 i 个元素的指针，则该结点 ai 的『数据域』我们可以用 p -&gt; data 的值来进行表示（它是一个数据元素），而结点 ai 的指针域可以用 p -&gt; next 来进行表示（它的值是一个指针），所以我们可以推断出 p -&gt; next 是指向第 i + 1 个元素的，也就是指向 ai + 1 的指针 同理，如果 p -&gt; data = ai，那么 p -&gt; next -&gt; data = ai + 1 的，而在 JavaScript 当中，我们设计链表包含两个类，一个是 Node 类用来表示结点，另一个是 LinkedList 类提供插入结点、删除结点等一些操作，Node 类包含两个属性 element 用来保结点点上的数据 next 用来保存指向下一个结点的链接 具体实现如下 12345// 结点function Node(element) { this.element = element // 当前结点的元素 this.next = null // 下一个结点链接} 而 LinkedList 类提供了对链表进行操作的方法，包括插入删除结点，查找给定的值等，值得注意的是，它只有一个属性，那就是使用一个 Node 对象来保存该链表的头结点，实现如下 123456789// 链表类function LList() { this.head = new Node('head') // 头结点 this.find = find // 查找结点 this.insert = insert // 插入结点 this.remove = remove // 删除结点 this.findPrev = findPrev // 查找前一个结点 this.display = display // 显示链表} 单链表的读取在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的，直接获取元素的下标即可，但是在单链表中，由于第 i 个元素的位置我们是不知道的，所以必须要从第一个结点开始挨个查找，代码如下 12345678// 查找结点function find(item) { var currNode = this.head while (currNode.element !== item) { currNode = currNode.next } return currNode} find 方法同时展示了如何在链表上移动，首先创建一个新结点，将链表的头结点赋给这个新创建的结点，然后在链表上循环，如果当前结点的 element 属性和我们要找的信息不符，就将当前结点移动到下一个结点，如果查找成功，该方法返回包含该数据的结点，否则就会返回 null 单链表的插入我们先来看下单链表但插入，假设存储元素 e 但结点为 s，要实现结点 p，p -&gt; next 和结点 s 之间逻辑关系但变化，可以参考下图 其实简单来说，并没有那么复杂，我们只需要按照如下简单操作即可 先 s -&gt; next = p -&gt; next 再 p -&gt; next = s 但是这里有个需要注意的地方，即上面两者的操作顺序是不可颠倒的，即 先 p -&gt; next = s 再 s -&gt; next = p -&gt; next 但是这样一来，如果先执行 p -&gt; next 的话会先被覆盖为 s 的地址，那么在执行 s -&gt; next = p -&gt; next 就相当于执行 s -&gt; next = s 了，可以发现，这是一个死循环，所以这两者的顺序一定不要弄反了 在上面我们实现了 find() 方法，有了 find() 方法以后，我们就可以十分简便的来实现插入操作了，只需要将新结点的 next 属性设置为后面结点的 next 属性对应的值，然后设置后面结点的 next 属性指向新的结点 1234567// 插入结点function insert(newElement, item) { var newNode = new Node(newElement) var currNode = this.find(item) newNode.next = currNode.next currNode.next = newNode} 单链表的删除流程可以如下所示 假设元素 a2 的结点为 q，要实现结点 q 删除单链表的操作，其实就是将它的前继结点的指针绕过，指向后继结点即可，所以我们所要做的操作实际上就是一步 可以 p -&gt; next = p -&gt; next -&gt; next 也可以先让 q = p -&gt; next 然后 p -&gt; next = q -&gt; next 从链表中删除结点时，我们先要找到待删除结点的前一个结点，找到后，我们修改它的 next 属性，使其不在指向待删除的结点，而是待删除结点的下一个结点 那么，我们就得需要定义一个 findPrev 方法遍历链表，检查每一个结点的下一个结点是否存储待删除的数据，如果找到，返回该结点，这样就可以修改它的 next 属性了 12345678// 查找前一个结点function findPrev(item) { var currNode = this.head while (currNode.next !== null &amp;&amp; currNode.next.element !== item) { currNode = currNode.next } return currNode} 这样一来，remove 方法的实现也就迎刃而解了 123456789// 删除结点function remove(item) { var prevNode = this.findPrev(item) var currNode = this.find(item) if (prevNode.next !== null) { prevNode.next = prevNode.next.next currNode.next = null }} 效率对比通过上面的操作我们可以发现，无论是单链表插入还是删除算法，它们其实都是由两个部分组成 第一部分就是遍历查找第 i 个元素 第二部分就是实现插入和删除操作 从整个算法来说，我们很容易可以推出它们的时间复杂度都是 O(n)，如果在我们不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上与线性表的顺序存储结构是没有太大优势的，但是如果我们希望从第 i 个位置开始，插入连续 10 个元素 对于顺序存储结构意味着，每一次插入都需要移动 n - i 个位置，所以每次都是 O(n) 而对于单链表，我们只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，但是接下来只是简单地通过赋值移动指针而已，时间复杂度都是 O(1) 显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显 测试最后我们将代码综合起来，在测试一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 一个简单的单向链表 * @param element */// 结点function Node(element) { this.element = element // 当前结点的元素 this.next = null // 下一个结点链接}// 链表类function LList() { this.head = new Node('head') // 头结点 this.find = find // 查找结点 this.insert = insert // 插入结点 this.remove = remove // 删除结点 this.findPrev = findPrev // 查找前一个结点 this.display = display // 显示链表}// 查找结点function find(item) { var currNode = this.head while (currNode.element !== item) { currNode = currNode.next } return currNode}// 插入结点function insert(newElement, item) { var newNode = new Node(newElement) var currNode = this.find(item) newNode.next = currNode.next currNode.next = newNode}// 删除结点function remove(item) { var prevNode = this.findPrev(item) var currNode = this.find(item) if (prevNode.next !== null) { prevNode.next = prevNode.next.next currNode.next = null }}// 查找前一个结点function findPrev(item) { var currNode = this.head while (currNode.next !== null &amp;&amp; currNode.next.element !== item) { currNode = currNode.next } return currNode}// 显示链表function display() { var currNode = this.head while (currNode.next !== null) { currNode = currNode.next console.log(currNode.element) }}var llist = new LList()llist.insert('111', 'head')llist.insert('222', '111')llist.insert('333', '222')llist.insert('444', '333')llist.display()llist.remove('222')llist.display() 单链表整表创建对于顺序存储结构的线性表的『整表创建』，我们可以用数组的初始化来直观理解，而单链表和顺序存储结构就不一样了，它不像顺序存储结构数据这么集中，它的数据可以是分散在内存各个角落的，它的增长也是动态的，对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成 创建单链表的过程是一个动态生成链表的过程，从『空表』的初始状态起，依次建立各元素结点并逐个插入链表，所以单链表整表创建的算法思路如下 声明一个结点 p 和计数器变量 i 初始化一空链表 L 让 L 的头结点的指针指向 null，即建立一个带头结点的单链表 循环实现后继结点的赋值和插入 而创建的方式通常又有两种，即『头插法』和『尾插法』，下面我就一个一个来看 头插法头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束为止，简单来说就是把新加进的元素放在表头后的第一个位置，然后 先让新节点的 next 指向头节点之后 然后让表头的 next 指向新节点 12345678910111213141516171819/* 头插法建立单链表示例 */void CreateListHead(LinkList *L, int n) { LinkList p; int i; // 初始化随机数种子 srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L) -&gt; next = NULL; for(i = 0; i &lt; n; i++) { // 生成新结点 p = (LinkList)malloc(sizeof(Node)); p -&gt; data = rand() % 100 + 1; p -&gt; next = (*L) -&gt; next; (*L) -&gt; next = p; }} 尾插法头插法建立链表虽然算法简单，但是生成的链表中结点的次序和输入的顺序相反（即是从右向左的），所以在某些场景下就不太适合，所以我们可以采用把新结点都插入到最后，也就是所谓的尾插法（正常方向，从右向左） 123456789101112131415161718192021222324/* 尾插法建立单链表演示 */void CreateListTail(LinkList *L, int n) { LinkList p, r; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); // 多了这一步，r 是指向尾部的结点 r = *L; for(i = 0; i &lt; n; i++) { p = (Node *)malloc(sizeof(Node)); p -&gt; data = rand() % 100 + 1; r -&gt; next = p; // 这一句需要说明一下 // 即我们每次新建一个新的结点 p，然后把 p 赋值给 r // 这时新的结点就成了 r，然后再次创建一个结点 p，依次循环 r = p; } r -&gt; next = NULL;} 单链表整表删除当我们不打算使用这个单链表当时候，我们需要把它销毁，其实也就是在内存中将它释放掉，以便留出空间给其他程序或软件来进行使用，单链表整表删除的思路如下 声明结点 p 和 q 将第一个结点赋值给 p，下一个结点赋值给 q 循环执行释放 p，然后将 q 赋值给 p 1234567891011121314Status ClearList(LinkList *L) { LinkList p, q; p = (*L) -&gt; next; while (p) { q = p -&gt; next; free(p); p = q; } (*L) -&gt; next = NULL; return OK;} 这里会存在一个问题，可不可以直接剔除掉 q，直接写成 free(p) 和 p = p -&gt; next 呢，答案是不可以的，原因是我们知道，p 是一个结点，它除了有数据域，还有指针域，当我们进行 free(p) 的时候，其实是对它整个结点进行删除和内存释放的工作，而我们的整表删除是需要一个一个结点来进行删除的，所以我们就需要使用一个临时变量 q 来记载 p 的下一个结点 单链表结构与顺序存储结构优缺点我们分别从存储分配方式、时间性能、空间性能三方面来进行对比 存储分配方式 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找 顺序存储结构 O(1) 单链表 O(n) 插入和删除 顺序存储结构需要平均移动表长一半的元素，时间复杂度为 O(n) 单链表在计算出某位置的指针后（这时的复杂度为 O(n)），但是插入和删除时间仅为 O(1) 空间性能 顺序存储结构需要预分配存储空间，分大了，容易造成空间浪费，分小了，容易发生溢出 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制 综上所述对比，我们得出一些比较实用的结论 若线性表需要频繁查找，很少进行插入和删除操作时，可以采用顺序存储结构 若需要频繁插入和删除时，可以采用单链表结构 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题 而如果事先知道线性表的大致长度，比如一年十二个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多 总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能 如何快速找到未知长度单链表的中间结点最后的最后，我们再来看一个网上比较流行的单链表面试题，关于这个题目的解法有两种，我们一个一个来看，比较常规的解法就是，首先遍历一遍单链表用来确定单链表的长度 L，然后再次从头结点出发循环 L/2 次来找到单链表的中间结点，由此可知，其算法的复杂度为 O(L + L/2) = O(3L/2)，这里我们之所以没有简化，是为来与后面的方法来进行对比 我们主要来看一下下面这个很巧妙的方法，即利用『快慢指针』的方法，主要原理如下（这也是标尺的思想） 设置两个指针 *search、*mid 都指向单链表的头节点 其中 *search 的移动速度是 *mid 的 2 倍 当 *search 指向末尾节点的时候，*mid 正好就在中间了 123456789101112131415161718Status GetMidNode(LinkList L, ElemType *e) { LinkList search, mid; mid = search = L; while (search -&gt; next != NULL) { // search 的移动速度是 mid 的两倍 if (search -&gt; next -&gt; next != NULL) { search = search -&gt; next -&gt; next; mid = mid -&gt; next; } else { search = search -&gt; next; } } *e = mid -&gt; data; return OK;}","link":"/2020/01/12/Essay/07/"},{"title":"递归","text":"递归（Recursion algorithm）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法，递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念，绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归，在平常可以说是经常可以听到的概念，今天我们就来深入的了解一下，什么是递归，以及递归的一些相关应用 什么是递归简单来说，在编程语言中，函数直接或间接调用函数本身，则该函数称为『递归函数』，我们可以用数学代入法来理解，假设我们用递归来算阶乘 f(n)，常用的方式是这样的 123456function factorial(n) { return n === 1 ? 1 : n * factorial(n - 1)}// 也可以使用箭头函数来进行简化const factorial = (x) =&gt; (x == 0 ? 1 : x * factorial(x - 1)) 我们可以发现，在 f 的里面再次用到了 f，我们把它展开了来看看 123456789101112f(6)=&gt; 6 * f(5)=&gt; 6 * (5 * f(4))=&gt; 6 * (5 * (4 * f(3)))=&gt; 6 * (5 * (4 * (3 * f(2))))=&gt; 6 * (5 * (4 * (3 * (2 * f(1)))))=&gt; 6 * (5 * (4 * (3 * (2 * 1))))=&gt; 6 * (5 * (4 * (3 * 2)))=&gt; 6 * (5 * (4 * 6))=&gt; 6 * (5 * 24)=&gt; 6 * 120=&gt; 720 也就是下图这样 通过上面的拆解，我们可以发现，其实就是先递进，再回归，而这就是『递归』，比如下面这个多级对象遍历的示例，就是递归的实际应用，也是我们平常开发当中经常会遇到的问题 12345678910111213141516171819202122232425262728293031323334var treeNodes = [{ id: 1, name: '1', children: [{ id: 11, name: '11', children: [{ id: 111, name: '111', children: [] }, { id: 112, name: '112' }] }, { id: 12, name: '12', children: [] }], users: []}]function parseTreeJson(treeNodes) { if (!treeNodes || !treeNodes.length) return for (var i = 0, len = treeNodes.length; i &lt; len; i++) { var childs = treeNodes[i].children console.log(treeNodes[i].id) if (childs &amp;&amp; childs.length &gt; 0) { parseTreeJson(childs) } }}parseTreeJson(treeNodes) 斐波那契数列我们下面来看一个实际的应用场景，也算是递归的经典应用场景，那就是斐波那契数列，我们先来看看不使用递归如何来实现斐波那契（Fibonacci）数列，如下 1234567891011121314151617#include &lt;stdio.h&gt;int main() { int i; int a[40]; a[0] = 0; a[1] = 1; printf(\"%d %d \", a[0], a[1]); for (i = 2; i &lt; 40; i++) { a[i] = a[i - 1] + a[i - 2]; printf(\"%d \", a[i]); } return 0;} 在上面代码中，我们使用循环从 i = 2 开始进行迭代，然后输出每一步对应的值，不过看上去就很麻烦的样子，下面我们在用递归的方式改写一下 123456789101112131415161718#include &lt;stdio.h&gt;int Fib(int i) { if (i &lt; 2) { return i == 0 ? 0 : 1; } return Fib(i - 1) + Fib(i - 2);}int main() { int i; for (i = 0; i &lt; 40; i++) { printf(\"%d \", Fib(i)); } return 0;} 这样可以发现代码就很清晰了，拆解后如下图所示 JavaScript 当中的实现方式如下 1234567function fibonacci(n) { return n &lt;= 1 ? 1 : fibonacci(n - 1) + fibonacci(n - 2)}for (let i = 0; i &lt;= 10; i++) { console.log(fibonacci(i))} 上面是最为基本的实现方式，但是我们可以利用记忆函数来对其进行优化，也就是将之前运算过的结果保存下来，对于频繁依赖之前结果的计算能够节省大量的时间，但是也存在一定的缺点，那就是闭包中的 obj 对象会额外占用内存，如下 123456789const memory = function (fn) { let obj = {} return function (n) { if (obj[n] === undefined) obj[n] = fn(n) return obj[n] }}fibonacci = memory(fibonacci) 另外使用『动态规划』会比之前实现的空间复杂度更低，也是更推荐的解法 12345678910111213function fibonacci_DP(n) { let res = 1 if (n === 1 &amp;&amp; n === 2) return res n = n - 2 let cur = 1, pre = 1 while (n) { res = cur + pre pre = cur cur = res n-- } return res} 尾调用在上面我们介绍了斐波那契数列的实现，在这里我们多提一点，那就是 尾调用 的使用，它的作用是利用在某个函数的最后一步是调用另一个函数的方式来进行优化，我们需要做的就是把所有用到的内部变量改写成函数的参数，比如我们使用尾调用来优化我们上面提到的斐波那契数列和阶乘 阶乘优化 12345function factorial(n, total) { return n === 1 ? total : factorial(n - 1, n * total)}factorial(5, 1) // 120 斐波纳契数列优化 1234567function fibonacci(n, n1 = 1, n2 = 1) { return n &lt;= 1 ? n2 : fibonacci(n - 1, n2, n1 + n2)}for (let i = 0; i &lt;= 10; i++) { console.log(fibonacci(i))} 递归定义之前我们通过了斐波那契数列的示例简单的了解了一下什么是递归，下面我们就来看看递归的具体含义 在高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作『递归函数』，不过，递归程序最怕的就是陷入永不结束的无穷递归中，所以需要注意，每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值，比如之前我们的 Fbi 函数结束条件就是 i &lt; 2 之前我们对比了两种实现斐波那契的代码，迭代和递归的区别是 迭代使用的是循环结构 递归使用的是选择结构 使用递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间，但大量的递归调用会建立函数的副本，会消耗大量的时间和内存，而迭代则不需要此种付出，所以需要根据当前环境进行考虑使用，递归函数分为调用和回退阶段，递归的回退顺序是它调用顺序的逆序 分治思想分而治之的思想古已有之，秦灭六国，统一天下正是采取各个击破、分而治之的原则，而分治思想在算法设计中也是非常常见的，当一个问题规模较大且不易求解的时候，就可以考虑将问题分成几个小的模块，逐一解决，因为采用分治思想处理问题，其各个小模块通常具有与大问题相同的结构，这种特性也使递归技术有了用武之地，下面我们就通过一个实例来了解一下 汉诺塔汉诺塔问题，它是用递归方法求解的一个典型问题，题目是这样的 塔上有三根柱子和一套直径各不相同的空心圆盘，开始时源柱子上的所有圆盘都按从大到小的顺序排列，目标是通过每一次移动一个圆盘到另一根柱子上，最终把一堆圆盘移动到目标柱子上，过程中不允许把较大的圆盘放置在较小的圆盘上 如下图所示 把一堆圆盘从一个柱子移动另一根柱子，必要时需要使用辅助的柱子，这样一来我们可以把它分为三个子问题 首先，移动一对圆盘中较小的圆盘到辅助柱子上，从而露出下面较大的圆盘 其次，移动下面的圆盘到目标柱子上 最后，将刚才较小的圆盘从辅助柱子上在移动到目标柱子上 再把三个步骤转化为简单数学问题 把 n - 1 个盘子由 A 移到 B 把第 n 个盘子由 A 移到 C 把 n - 1 个盘子由 B 移到 C 这样问题解决了，但实际操作中，只有第二步可直接完成，而第一、三步又成为移动的新问题，以上操作的实质是把移动 n 个盘子的问题转化为移动 n - 1 个盘，那一、三步如何解决？ 事实上上述方法设盘子数为 n，n 可为任意数，该法同样适用于移动 n - 1 个盘，因此依据上法，可解决 n - 1 个盘子从 A 杆移到 B 杆（第一步）或从 B 杆移到 C 杆（第三步）问题，所以现在的问题就是由移动 n 个盘子的操作转化为移动 n - 2 个盘子的操作，依据该原理层层递推，即可将原问题转化为解决移动 n - 2，n - 3 … 3、2，直到移动 1 个盘的操作，而移动一个盘的操作是可以直接完成的 至此，我们的任务算作是真正完成了，而这种由繁化简，用简单的问题和已知的操作运算来解决复杂问题的方法，就是递归法，我们先来看看如何使用 C 语言来实现 1234567891011121314151617181920212223#include &lt;stdio.h&gt;// 将 n 个盘子从 x 借助 y 移动到 zvoid move(int n, char x, char y, char z) { if (1 == n) { printf(\"%c --&gt; %c\\n\", x, z); } else { move(n - 1, x, z, y); // 将 n-1 个盘子从 x 借助 z 移到 y 上 printf(\"%c --&gt; %c\\n\", x, z); // 将 第 n 个盘子从 x 移到 z 上 move(n - 1, y, x, z); // 将 n-1 个盘子从 y 借助 x 移到 z 上 }}int main() { int n; printf(\"请输入汉诺塔的层数: \"); scanf(\"%d\", &amp;n); printf(\"移动的步骤如下: \\n\"); move(n, 'X', 'Y', 'Z'); return 0;} 下面再来看看使用 JavaScript 如何实现，其实本质上原理是一致的 123456789var hanoi = function (num, x, y, z) { if (num &gt; 0) { hanoi(num - 1, x, z, y) console.log(' 移动 ' + num + ' 号圆盘' + ' 从 ' + x + ' 移动到 ' + z) hanoi(num - 1, y, x, z) }}hanoi(3, 'A', 'B', 'C') 运行结果如下 1234567移动 1 号圆盘 从 A 移动到 C移动 2 号圆盘 从 A 移动到 B移动 1 号圆盘 从 C 移动到 B移动 3 号圆盘 从 A 移动到 C移动 1 号圆盘 从 B 移动到 A移动 2 号圆盘 从 B 移动到 C移动 1 号圆盘 从 A 移动到 C 其实简单总结就是 目标是 x ==&gt; z 第一步 x ==&gt; y（借助 z） 第二步 y ==&gt; z（借助 x） 最终，我们的操作结果可以由下图所示 八皇后问题最后我们再来看一下八皇后问题，八皇后问题是一个古老而著名的问题，是回溯算法的典型例题，问题是这样的，在 8 x 8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？如下图，便是其中一种实现方式 那么到底什么是『回溯法』呢？我们慢慢来看，我们首先将棋盘调整的小一些，这样比较方便描述，结果如下 那么现在问题变成了 4 皇后问题了，现在我们把第一个皇后放在第一个格子，被涂黑的地方是不能放皇后的，便成为了下面这样的方式 这时我们可以发现，第二行的皇后只能放在第三格或第四格，比方我们放第三格 这时可以发现，前两位皇后已经把第三行全部锁死了，即第三位皇后无论放在第三行任何位置都会被吃掉，所以我们可以得出，在第一个皇后位于 1 号，第二个皇后位于 3 号的情况下问题无解，显然此时我们只能返回上一步，来给 2 号皇后换个位置，如下 这时可以发现，第三个皇后只有一个位置可选，但是当第三个皇后占据第三行蓝色空位时，第四行皇后无路可走，于是也会发生错误，所以这是我们就需要再次返回上层调整三号皇后的位置，但是三号皇后没有别的地方可以安排，所以继续返回到第二层来进行调整，但是二号皇后也是同样的情况，那么我们只能调整一号皇后的位置了，于是我们将一号皇后的位置稍微调整一下以便我们继续搜索，也就是下图这样的情况 说到这里，应该就已经对『回溯法』已经有了基本概念，下面我们就来看看如何使用代码来进行实现 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int n = 8;int total = 0;int *c = new int(n);bool is_ok(int row) { for (int j = 0; j != row; j++) { if (c[row] == c[j] || row - c[row] == j - c[j] || row + c[row] == j + c[j]) return false; } return true;}void queen(int row) { if (row == n) total++; else for (int col = 0; col != n; col++) { c[row] = col; if (is_ok(row)) queen(row + 1); }}int main() { queen(0); cout &lt;&lt; total; return 1;} 其实代码主要的逻辑就是下面的十行代码 12345678910void queen(int row) { if (row == n) total++; else for (int col = 0; col != n; col++) { c[row] = col; if (is_ok(row)) queen(row + 1); }} 算法是逐行安排皇后的，其参数 row 为现在正执行到第几行，n 表示的是皇后数，代码第二行比较好理解，如果程序当前能正常执行到第八行，那自然是找到了一种解法，于是八皇后问题解法数加 1 如果当前还没排到第八行，则进入 else 语句，遍历所有列 col，将当前 col 存储在数组 c 里，然后使用 is_ok() 检查 row 行 col 列能不能摆皇后，若能摆皇后，则递归调用 queen 去安排下一列摆皇后的问题，下面我们一步一步来逐步拆解了解 刚开始的时候 row = 0，意思是要对第 0 行摆皇后操作，if 判断失败，进入 else，进入 for 循环，col 初始化为 0，显然，0 行 0 列的位置一定可以摆皇后的，因为这是第一个皇后，于是 is_ok(0) 测试成功，递归调用 queen(1) 安排第一行的皇后 在第一行时 row = 1，进来 if 依然测试失败，进入 for 循环，col 初始化为 0，第 1 行第 0 列显然是不能摆皇后的，因为 0 行 0 列已经有了一个皇后，于是 is_ok() 测试失败，循环什么也不做空转一圈，col 变为 1，1 行 1 列依然 is_ok() 测试失败，一直到 1 行 2 列，发现可以摆皇后，于是继续递归 queen(2) 去安排第二个皇后位置 如果在某种情况下问题无解呢？例如前面在 4 皇后问题中，0 行 0 列摆皇后是无解的，假设前面递归到 queen(2) 时候，发现第 2 行没有地方可以摆皇后，那怎么办呢？但是这时要注意 queen(2) 的调用是在 queen(1) 的 for 循环框架内的，queen(2) 若无解，则自然而然 queen(1) 的 for 循环 col 自加 1，即将第 1 行的皇后从 1 行 2 列改为 1 行 3 列的位置，检查可否放皇后后继续安排下一行的皇后 如此递归，当 queen(0) 的 col 自加到 7，说明第一列的皇后已经遍历了从 0 行 1 列到 0 行 7 列，此时 for 循环结束，程序退出，所以此时我们就可以在主函数中调用 queen(0)，得到正确结果（八皇后问题一共有 92 种解法） 看完了 C 语言的版本，我们再来看看如何使用 JavaScript 来进行实现，首先尝试使用嵌套 for 循环实现，发现只能找出第一种解法，没办法统计到所有的解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var n = 8var arr = []var total = 0function b() { for (var row = 0; row &lt;= n;) { if (row == n) { total++ break } else { var col = 0 if (arr[row] != undefined) { // 说明是回溯回来重新选择位置的，要从上次的位置开始往后选 var col = arr[row] + 1 } for (; col &lt;= n; col++) { if (col == n) { // 当前行的所有列都走完了，都没有位置可以放棋子，则从上一行开始从新选择位置 arr[row] = undefined row-- if (row) break } if (isOk(row, col)) { arr[row] = col row++ break } } } }}function isOk(row, col) { for (var i = 0; i &lt; row; i++) { if (row == 0) { // 第一行随便放哪个位置都行 return true } if (arr[i] == col || Math.abs(arr[i] - col) == Math.abs(i - row)) { // 同一行，同一列或者斜对角线都不能放 return false } } // 成功比较完了之前的所有行，说明这个位置可以放置 return true}b()console.info(total) 可以发现，for 循环的实现太过复杂，当找到一个解法后，希望移动第一行的棋子，寻找其他解法时，这个时候，当回溯到第一行时，无法控制棋子的位置（比如已经从第 0 个位置移到 2 的位置才寻找到了第一种解法，当寻找其他解法时，回溯到第一行时，就不应该在返回 0 和 1 这个两个位置），而 for 循环是无法记录的 所以这里我们采用递归来进行实现，此时每一行的 for 循环都能被记住当前是第几列（也就是上面所说的 queen(2) 的调用是在 queen(1) 的 for 循环框架内的） 12345678910111213141516171819202122232425262728293031323334353637var arr = []var arr2 = []var total = 0function ab(row) { if (row == n) { // 当 row 已经成功走到最后一行，说明已经找到了一种解法，找到一种解法，就把当前的位置记录下来 arr2.push([].slice.call(arr)) total++ } for (var col = 0; col &lt; n; col++) { if (isOk(row, col)) { // 当前行的这一列不与前几行的位置冲突，则把这个位置记录下来，位置记录下来，是为了每次循环比较是否有冲突 arr[row] = col // 进入下一行选位置，因为递归，所以当里层的循环全部结束以后，会返回上一层继续循环，实现了回溯 ab(row + 1) } }}// 这个方法同上function isOk(row, col) { for (var i = 0; i &lt; row; i++) { if (row == 0) { return true } if (arr[i] == col || Math.abs(arr[i] - col) == Math.abs(i - row)) { return false } } return true}ab(0)console.info(total)console.info(arr2)","link":"/2020/03/05/Essay/13/"},{"title":"关键路径","text":"在上一章当中我们研究了 最短路径 的相关算法，它们是迪杰斯特拉算法（Dijkstra）和弗洛伊德算法（Floyd），本章我们就来了解一下关键路径的一些相关算法，这也是图结构相关内容的最后一部分，但是在展开之前，我们需要先来了解一些前置知识，它们就是『拓扑序列』和『拓扑排序』 拓扑序列那么什么是拓扑序列呢？在前面的章节当中，我们已经知道，一个无环的有向图可以称之为无环图（Directed Acyclic Graph），我们可以将其简称为 DAG 图，而在一个表示工程的有向图中，如果用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图就称为顶点表示活动的网，我们称之为 AOV 网（Active On Vertex Network），而 AOV 网中的弧表示活动之间存在的某种制约关系，简单来说就说 AOV 网不能存在回路 这里涉及到几个新的概念，比如工程和活动，我们可以这样来进行理解 比如你想要开一家店铺，那么开店铺这整个流程，我们就可以将其称之为一个工程，而开店铺过程当中涉及到的比如选址，装修，进货等行为，我们就可以将其称之为一个一个的活动，所有的工程或者某种流程都可以分为若干个小的工程或者阶段，我们称这些小的工程或阶段为活动，而至于不能存在回路，可以理解为你不能先进行装修和进货，而是必须要在店铺的选址工作完成了以后才能进行接下来的流程，这样一来是不是就比较容易理解了，下面我们在来看看拓扑排序 拓扑排序之前我们介绍的拓扑序列，如果使用概念来进行定义的话，是这样的 设 G = (V, E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 V1, V2, ... Vn 满足若从顶点 Vi 到 Vj 有一条路径，则在顶点序列中顶点 Vi 必在顶点 Vj 之前，则我们称这样的顶点序列为一个拓扑序列 而所谓的拓扑排序，其实就是对一个『有向图构造拓扑序列』的过程，我们可以以一个具体的例子来进行理解，如下图 上图是某校计算机专业所修课程，比如代号 C1 的课程，它就不需要前置课程，而比如对于课程 C3 它就需要 C1 和 C14 这两门前置课程，我们将上图转换为 AOV 网是下面这样的 针对于上图其中的一种拓扑序列为 1, 13, 4, 8, 14, 15, 5, 2, 3, 10, 11, 12, 7, 6, 9（在下面我们会通过代码来进行求解），在用代码实现之前，我们先来看看针对 AOV 网进行拓扑排序的方法和步骤，主要流程如下，主要利用了栈的特点 从 AOV 网中选择一个没有前趋的顶点（该顶点的入度为 0）并且输出它 从网中删去该顶点，并且删去从该顶点发出的全部有向边 重复上述两步，直到剩余网中不再存在没有前趋的顶点为止 有了实现步骤，下面我们就来看看如何使用代码来进行实现，由于需要删除顶点，所以在这里我们选择『邻接表』的数据结构来表示会更加方便（相较于邻边矩阵），形式如下 针对于该算法时间复杂度而言 对一个具有 n 个顶点，e 条边的网来说，初始建立入度为零的顶点栈，要检查所有顶点一次，执行时间为 O(n) 排序中，若 AOV 网无回路，则每个顶点入、出栈各一次，每个表结点被检查一次，因而执行时间是 O(n + e) 所以，整个算法的时间复杂度是 O(n + e) 首先我们需要先来生成图 123456789101112131415161718192021222324252627282930313233343536373839404142434445class vex { constructor(value) { this.data = value this.firstEdge = null // 用于存放顶点的入度 this.in = 0 }}class adjvex { constructor(node, weight) { this.node = node this.weight = weight this.next = null }}class Graph { constructor(v, vr) { let len = v.length let vexs = new Array(len) let v1 = 0, v2 = 0 let newvex = null for (let i = 0; i &lt; len; i++) { vexs[i] = new vex(v[i]) } for (let arc of vr) { v1 = v.indexOf(arc[0]) v2 = v.indexOf(arc[1]) newvex = new adjvex(v2, arc[2]) newvex.next = vexs[v1].firstEdge vexs[v1].firstEdge = newvex vexs[v2].in++ } this.adjList = vexs }}let a = new Graph(['v0', 'v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7', 'v8', 'v9', 'v10', 'v11', 'v12', 'v13'], [['v0', 'v11', 1], ['v0', 'v4', 1], ['v0', 'v5', 1], ['v1', 'v4', 1], ['v1', 'v8', 1], ['v1', 'v2', 1], ['v2', 'v5', 1], ['v2', 'v6', 1], ['v3', 'v2', 1], ['v3', 'v13', 1], ['v4', 'v7', 1], ['v5', 'v8', 1], ['v5', 'v12', 1], ['v6', 'v5', 1], ['v8', 'v7', 1], ['v9', 'v11', 1], ['v9', 'v10', 1], ['v10', 'v13', 1], ['v12', 'v9', 1]])console.log(a) 当有了图以后，我们就可以来实现我们的排序操作 12345678910111213141516171819202122232425262728293031323334353637383940function topoSort(G) { // 辅助栈 let stack = [] // 寻找入度为 0 的顶点推入栈 for (let i = 0; i &lt; G.adjList.length; i++) { if (G.adjList[i].in === 0) { stack.push(i) } } let currentVex = null // 用于计数已经输出的顶点 let count = 0 while (stack.length &gt; 0) { currentVex = G.adjList[stack.pop()] // 输出栈顶顶点 console.log(currentVex.data) count++ currentVex = currentVex.firstEdge // 删除当前顶点，遍历其邻接顶点，使它们入度减 1 while (currentVex) { // 当邻接顶点入度为 0 时 if ((--G.adjList[currentVex.node].in) === 0) { // 将邻接顶点压入栈中 stack.push(currentVex.node) } currentVex = currentVex.next } } // 若输出的顶点数少于图中顶点数，则存在环 if (count &lt; G.adjList.length) { console.log(`存在环路`) return false } else { return true }} 关键路径的作用在了解完拓扑排序以后，我们就可以正式的来看看关键路径，不过对于一个新东西，在了解它之前我们一般都会先了解它是做什么的，它解决了什么样的问题，同样的，我们也使用一个示例来进行说明 比如某汽车公司生产一辆汽车，其中生产轮子需要 0.5 天，发动机需要 3 天，底盘需要 2 天，外壳需要 2 天，其他零部件需要 2 天，全部零部件集中到一处需要 0.5 天，组装成车并测试需要 2 天，那么请问生成一辆汽车最短需要多少时间呢？ 针对于上面这个例子，通过简单的计算就可以得出结果，但是如果是在实际当中，往往会涉及到其他更多的部门分工合作，所以也就会变得更为复杂，那么针对于这种情况，我们该如何处理这样的问题呢？所以这就有了我们的关键路径算法，它的定义是下面这样的 在一个表示工程的带权有向图（注意这里是带权的）中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 AOE 网（Activity On Edge Network） 我们把 AOE 网中没有『入边』的顶点称为始点或源点，没有『出边』的顶点称为终点或汇点，如下图所示 AOV 网与 AOE 网的比较下面我们来看看两者之间的区别，有一个比较好的记忆方式就是，注意它们是否带权，不带权的就是 AOV，而带权的就是 AOE，如下 而像上图 AOE 网当中标注的红色路线就是我们的关键路径，下面我们就来看看关键路径是如何建立在拓扑序列之上的 关键路径简单来说，关键路径的算法就是我们先求得顶点事件的最早和最晚发生时间，再求得弧活动的最早和最晚开工时间，最后比较弧活动的两者时间是否相等，然后判断其是否为关键活动，在这里涉及到了四个新的概念，我们先来了解一下 名词 定义 etv 事件的最早发生时间，就是顶点的最早发生时间，简单来说就是 源点 ==&gt; 汇点 ltv 事件的最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此时间将会延误整个工期，简单来说就是 汇点 ==&gt; 源点 ete 活动的最早开工时间，就是弧的最早发生时间 lte 活动的最晚开工时间，不推迟工期的最晚开工时间 其实简单来说，关键路径就是『源点到汇点之间权值最大的一条路径』，这条路径决定了整个工期，关键路径上的关键活动的最早开始的时间和最晚开始的时间应该是相同的（也就是 etv == ltv），否则说明还有其他工程会影响工期，这条路径就不是关键路径了，而引入 ete 和 lte 是为了通过循环边来找出关键活动，同时可以得到边上的权，还是以下图为例 根据图中的信息，我们可以得到如下信息 下面来简单介绍一下上图中的信息 顶点我们就使用 C1，C2 ... C9 来进行表示，左边是源点，右边是汇点 etv，事件的最早发生时间，也就是从左往右，比如 C2 这个点，它需要经过 a1 这个活动结束以后才能到达 C2，所以 C2 的值为 6，这里我们主要看一下 C5 这种情况，它需要等两条线路都结束以后才能开始，所以它的值为 7，其他的点都是同理 ltv，事件的最晚发生时间，我们这里是从右往左，整个工程所需要的时间是 16 个单位，因为 a11 执行需要四个单位，所以 C8 所需要的最迟时间也就是 12，这里我们主要看一下 C6 的情况，因为 a9 需要 4 个单位，所以 C6 的值是 8（这里需要注意的就是 ltv 的 C1 是取的较小的值，也就是这里的 0），所以在 C6 这个点上我们可以发现，它最早发生的时间是 7，而最晚发生的时间是 8，它们之间是相差一个单位的 ete，活动的最早开工时间，我们可以发现，我们有 9 个顶点，但是却产生了 11 条弧，比如 a1，a2，a3 它们的事件都是从 C1 开始的，所以它们都是 0，我们来看 a4 这条弧，它对应着 C2 最早的发生时间，通过观察可知，C2 的 etv 的值为 6，所以它的 ete 的值也为 6，同理，a5 就相当于 C3 的最早发生时间，是不是有点眉目了，后面都是以此类推 lte，活动的最晚开工时间，又是最晚，所以我们需要从右往左来看，简单来说比如 a9 这条弧，对应着 C8 这个点的 ltv，它的 ltv 的值为 12，所以 a9 为 12 - 4 = 8 所以简单的总结一下就是，如果得出了 etv 和 ltv 的值以后，就可以很简单的推算出 ete 和 lte 的值了 etv 可以直接推断出 ete 而 lte 可以简单的换算得到 ltv 这里有一个需要注意的地方，就是如果细心观察可以发现，图上的 C1，C2，C5 ... 等点，也就是下图这些点 它们的 etv 是等于 ltv 的，通过图我们可以发现，其实它们之间的连线也就是我们所要的关键路径，但是这里存在一个问题，既然知道连接弧就是关键路径，那么为什么还有必要要求得 ete 和 lte 呢 首先，关键路径是活动的集合，也就是弧的集合而不是事件的集合，虽然我们可以求出 etv == ltv 的情况，也可以一眼就看出结果，但是对于计算机而言，我们还是需要让它通过弧将其表现出来的，况且有了 etv 和 ltv，通过我们上面的介绍，得出 ete 和 lte 也是十分简单的 代码实现其实通过上面的内容，我们可以将整个求解关键路径的过程划分为三部分 求解各顶点事件的最早发生时间 求解各顶点事件的最晚发生时间 求解各弧上活动的最早和最晚发生时间，并做关键活动的判断 邻边表如下，右侧加粗的部分表示权值 我们还是在我们之前的拓扑排序的基础之上来进行调整，首先求得各顶点事件的最早发生时间，可以与拓扑排序相对比，可以发现它们是很相似的 123456789101112131415161718192021222324252627282930313233343536373839404142434445function getEtvs(G) { let etvs = [] // 用于存储各顶点的最早发生时间 let stack = [], T = [] // stack 为辅助栈，T 为存储拓扑序列的数组 let count = 0 // 用于统计顶点个数 // 初始化数组，并将入度为 0 的顶点推入栈 for (let i = 0; i &lt; G.adjList.length; i++) { etvs[i] = 0 if (G.adjList[i].in === 0) { stack.push(i) } } let currentAdjVex = null let currentIndex = 0 while (stack.length &gt; 0) { // 弹出栈顶入度为 0 的顶点 currentIndex = stack.pop() count++ T.push(currentIndex) currentAdjVex = G.adjList[currentIndex].firstEdge // 遍历当前顶点的所有邻接顶点 while (currentAdjVex) { // 关键代码，求各顶点事件最早发生时间 if (etvs[currentIndex] + currentAdjVex.weight &gt; etvs[currentAdjVex.node]) { etvs[currentAdjVex.node] = etvs[currentIndex] + currentAdjVex.weight } // 将当前邻接顶点入度减 1，若等于 0，则推入栈中 if (--G.adjList[currentAdjVex.node].in === 0) { stack.push(currentAdjVex.node) } currentAdjVex = currentAdjVex.next } } if (count &lt; G.adjList.length) { return false } else { return [etvs, T] }} 接着根据各顶点事件的最早发生时间，反向求各顶点的最晚发生时间，相当于把拓扑排序倒过来 1234567891011121314151617181920212223242526function getLtvs(G, etvs, T) { let ltvs = [] // 初始化每个顶点的最晚发生时间 for (let i = 0; i &lt; G.adjList.length; i++) { ltvs[i] = etvs[G.adjList.length - 1] } let currentAdjVex = null let currentIndex = 0 while (T.length &gt; 0) { // 反向拓扑序列计算 currentIndex = T.pop() currentAdjVex = G.adjList[currentIndex].firstEdge while (currentAdjVex) { // 关键代码，求各顶点事件的最晚发生时间，注意与 etv 的判断条件不一样 if (ltvs[currentIndex] &gt; ltvs[currentAdjVex.node] - currentAdjVex.weight) { ltvs[currentIndex] = ltvs[currentAdjVex.node] - currentAdjVex.weight } currentAdjVex = currentAdjVex.next } } return ltvs} 最后即可根据各顶点事件的最早和最晚发生时间，计算弧上活动的最早和最晚时间，并作比较判断是否为关键活动，需要注意的是，弧上活动 &lt;Vi, Vj&gt; 的最早开工时间不可能早于顶点 Vi 事件最早发生时间，而最晚开工时间则不可能晚于顶点 Vj 事件最晚发生时间减去弧上活动持续时间 1234567891011121314151617181920212223242526function criticalPath(G) { let etvs = null, ltvs = null let T = null // 调用函数获取图各顶点事件的最早和最晚发生时间 [etvs, T] = getEtvs(G) ltvs = getLtvs(G, etvs, T) let ete = 0, lte = 0 let currentAdjVex = null // 遍历每一条弧 for (let i = 0; i &lt; G.adjList.length; i++) { currentAdjVex = G.adjList[i].firstEdge while (currentAdjVex) { // 弧上活动的最早开工时间 ete = etvs[i] // 弧上活动的最晚开工时间 lte = ltvs[currentAdjVex.node] - currentAdjVex.weight if (ete === lte) { console.log('v' + i, 'v' + currentAdjVex.node, currentAdjVex.weight) } currentAdjVex = currentAdjVex.next } }}","link":"/2020/05/08/Essay/25/"},{"title":"查找算法","text":"在本章当中，我们将会介绍一类在平常开发过程当中经常会使用的算法，那就是查找算法，关于查找算法肯定不需要多说，都是耳熟能详的，什么顺序、二分之类的就算是没有用过应该也听闻过，那么今天我们就来简单的总结整理一下查找算法的分类和一些比较常用的算法 查找算法的分类其实简单来说，查找算法可以分为静态查找和动态查找两类 静态查找表示数据集合稳定，不需要添加，删除元素的查找操作 对于静态查找来说，我们可以用线性表结构组织数据，这样可以使用顺序查找算法，如果我们再对关键字进行排序，则可以使用折半查找算法或斐波那契查找算法等来提高查找的效率 动态查找表示数据集合在查找的过程中需要同时添加或删除元素的查找操作 对于动态查找来说，我们则可以考虑使用二叉排序树的查找技术，另外我们还可以使用散列表结构来解决一些查找问题 而在此基础上又可以分为无序查找和有序查找 无序查找，被查找数列有序无序均可 有序查找，被查找数列必须为有序数列 这里会涉及到一个概念，平均查找长度（Average Search Length，ASL），表示需和指定 key 进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度，对于含有 n 个数据元素的查找表，查找成功的平均查找长度为 ASL = Pi * Ci 的和 Pi，查找表中第 i 个数据元素的概率 Ci，找到第 i 个数据元素时已经比较过的次数 下面我们就从最简单的顺序查找开始看起 顺序查找顺序查找又叫线性查找，是最基本的查找技术，它的查找过程是从第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功 顺序查找适合于存储结构为顺序存储或链接存储的线性表 我们来稍微分析一下它的复杂度 查找成功时的平均查找长度为（假设每个数据元素的概率相等），则 ASL = 1 / n(1 + 2 + 3 + ... + n) = (n + 1) / 2 当查找不成功时，需要 n + 1 次比较，时间复杂度为 O(n) 所以，顺序查找的时间复杂度为 O(n)，下面来看代码如何实现 12345678910// 顺序查找，a 为要查找的数组，n 为要查找的数组的长度，key 为要查找的关键字int Sq_Search(int *a, int n, int key) { int i; for (i = 1; i &lt;= n; i++) { if (a[i] == key) { return i; } } return 0;} 针对于上面这个实现，我们可以考虑稍微将其优化一下，所以就有了下面这样的方式 123456789// 顺序查找优化方案，a 为要查找的数组，n 为要查找的数组的长度，key 为要查找的关键字int Sq_Search(int *a, int n, int key) { int i = n; a[0] = key; while (a[i] != key) { i--; } return i;} 如果我们设立一个比对对象，只需要依次检查数组当中的元素与我们的比对对象是否相等，下面再来看看 JavaScript 当中的实现 12345678function Sq_Search(arr, value) { for (let i = 0; i &lt; arr.length; i++) { if (arr[i] == value) { return i } } return - 1} 原理是类似的，都是依次对比查找，如果找到就返回该元素，否则返回 -1 二分查找首先需要注意，二分查找是有一个前提条件的，那就是『元素必须是有序的，如果是无序的则要先进行排序操作』，二分查找也称为折半查找，首先要找到一个中间值，通过与中间值比较，大的放右边，小的放在左边，再在两边中寻找中间值，持续以上操作，直到找到所在位置为止，如果找不到返回 false，最坏情况下，关键词比较次数为 log2(n + 1)，且期望时间复杂度为 O(log2n) 折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率，但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用 下面我们来看看如何用代码进行实现，大致思路是，任意输入一个用数字 n，用折半查找法找到 n 位于数组中的位置，如果 n 不属于数组 A，则显示错误提示，下面是 C++ 的实现方式 123456789101112131415161718192021222324252627// 非递归版本int bin_search(int a[], int value, int n) { int low, high, mid; low = 0; high = n - 1; while (low &lt;= high) { mid = (low + high) / 2; if (a[mid] == value) return mid; if (a[mid] &gt; value) high = mid - 1; if (a[mid] &lt; value) low = mid + 1; } return -1;}// 递归版本int bin_search(int a[], int value, int low, int high) { int mid = low + (high - low) / 2; if (a[mid] == value) return mid; if (a[mid] &gt; value) return bin_search(a, value, low, mid - 1); if (a[mid] &lt; value) return bin_search(a, value, mid + 1, high);} JavaScrip 版本如下，也有两种方式，递归和非递归，对于非递归的版本，可以使用 while 123456789101112131415161718192021222324252627282930313233343536// 非递归版本function bin_search(data, dest) { var end = data.length - 1 var start = 0 // 这里需要注意判断条件是 &lt;= while (start &lt;= end) { var m = Math.floor((end + 1) / 2) if (data[m] == dest) { return m } if (data[m] &gt; dest) { end = m - 1 } else { start = m + 1 } } return false}// 递归版本function bin_search(arr, val, start, end) { var end = end || arr.length - 1 var start = start || 0 // 这里是条件 var mid = Math.floor((start + end) / 2) if (arr[mid] == val) { return mid } else if (arr[mid] &gt; val) { return bin_search(arr, val, start, mid - 1) } else { return bin_search(arr, val, mid + 1, end) }} 插值查找插值查找简单来说就是针对于二分查找的改进，在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，在英文字典里面查 apple，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查 zoo，很显然这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻，同样的，比如要在取值范围 1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找 5，我们自然会考虑从数组下标较小的开始查找 经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的），二分查找中查找点计算如下 mid = (start + end) / 2，即 mid = start + 1 / 2 * (end - start)，通过类比，我们可以将查找的点改进为 mid = start + (key - a[start]) / (a[end] - a[start]) * (end - start)，也就是将上述的比例参数 1 / 2 改进为自适应的，根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，这样也就间接地减少了比较次数 简单来说，就是将查找点的选择改进为自适应选择，可以提高查找效率，当然它也属于有序查找，有以下两点需要注意的 一般对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多 反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择 插值查找如果查找成功或者失败的时间复杂度均为 O(log2(log2n))，与二分查找可以分情况来进行使用，下面来看看代码的实现方式，下面是 C++ 的实现方式 123456789int bin_search(int a[], int value, int low, int high) { int mid = low + (value - a[low]) / (a[high] - a[low]) * (high - low); if (a[mid] == value) return mid; if (a[mid] &gt; value) return bin_search(a, value, low, mid - 1); if (a[mid] &lt; value) return bin_search(a, value, mid + 1, high);} 下面再来看看 JavaScript 当中的实现，其实原理都是一样的，都是针对基准点的调整 123456789101112131415function bin_search(arr, val, start, end) { var end = end || arr.length - 1 var start = start || 0 // 这里是改进的地方 var mid = start + (val - arr[start]) / (arr[end] - arr[start]) * (end - start) if (arr[mid] == val) { return mid } else if (arr[mid] &gt; val) { return bin_search(arr, val, start, mid - 1) } else { return bin_search(arr, val, mid + 1, end) }} 斐波那契查找在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念，黄金分割 黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为 1 : 0.618 或 1.618 : 1，0.618 被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用，因此被称为黄金分割，我们可以发现，在斐波那契数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ... 当中，随着斐波那契数列的递增，前后两个数的比值会越来越接近 0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中 下面我们来看看斐波那契查找的基本思想，它其实也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率，同样地，斐波那契查找也属于一种有序查找算法，该方法的主要思路为 先在斐波那契数列 F 中找到第 k 项，使其满足 F[k] - 1 &gt; 有序数组的最大索引号 &gt; F[k - 1] - 1，然后将数组扩充到长度为 F[K] - 1，并使扩充项的值都等于有序数组的最后一项，分割点的索引为 mid = low + F[K - 1] - 1，此时有序数组被 mid 划分为两段，左段长度为 F[K - 1] - 1，右段长度为 F[k - 2] - 1，若查找值大于 mid 值，则 low 等于 mid + 1，而 k = k - 2，若查找值小于 mid，则 high = mid - 1, k = k - 1 也就是如下图所示 最坏情况下，时间复杂度为 O(log2n)，且其期望复杂度也为 O(log2n) 12345678910111213141516171819202122232425262728293031323334353637383940414243function search(array, value) { let low = 0, high = array.length - 1, n = array.length - 1 let mid, k = 0 // 构建一个长度大于 array 数组的斐波那契数组 var F = [] F[0] = 0 F[1] = 1 for (var i = 2; i &lt; high + 5; i++) { F[i] = F[i - 1] + F[i - 2] } // 寻找第 k 项 while (high &gt; F[k] - 1) { k++ } // 补全有序数组 for (let i = high; i &lt; F[k] - 1; i++) { array[i] = array[high] } while (low &lt;= high) { mid = low + F[k - 1] - 1 if (array[mid] &gt; value) { high = mid - 1 // 长度缩减为 F[k - 1] - 1 k = k - 1 } else if (array[mid] &lt; value) { low = mid + 1 // 长度缩减为 F[k - 2] - 1 k = k - 2 } else { // 相等则找到位置 if (mid &lt;= n) return mid else // 大于原始长度，则说明等于数组最后一项 return n } } return -1} 线性索引查找前面介绍的几种查找的算法都是基于数据『有序』的基础上进行的，但是在实际的应用中，很多数据集可能有惊人的数据量，面对这些海量的数据，要保证记录全部按照当中的某个关键字有序，其时间代价是非常昂贵的，所以这种数据通常都是按先后顺序存储的，那么如何能够快速的查找到需要的数据呢？办法就是『索引』 索引就是把一个关键字与它对应的记录相关联的过程，一个索引有若干个索引项构成，每个索引项至少应包括『关键字』和『对应的记录在存储器中的位置』等信息，在索引表中的每个索引项对应多条记录，则称为『稀疏索引』，若每个索引项唯一对应一条记录，则称为『稠密索引』，索引按照结构可以分为『线性索引』、『树形索引』和『多级索引』，所谓的线性索引就是将索引项集合组织为线性结构，也称为索引表 稠密索引稠密索引是指在线性索引表中，将数据集中的每个记录对应一个索引项，并且索引项一定是按照关键码有序的排列，索引项有序也就意味着，在查找关键字时，可以用到折半、插值、斐波那契等有序的查找算法，如下图所示 稠密索引的改进的地方在于它简化了庞大的原数据集，使原本不能装入内存的庞大的数据集，能一次性的装入内存，并且能够在内存中实现关键字码的排序，并且每一个索引项能够指向磁盘中它代表的原数据记录，能利用高级的查找算法，这显然是稠密索引的优点，但是如果数据集非常的大，那么索引表也是非常的大，对于内存有限的计算机来说，不得不把索引表也放到磁盘中，这样就大大的降低了效率 分块索引稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项（类似于图书馆的分块），分块有序是把数据集的记录分成了若干块，并且这些块需要满足两个条件 块内无序，每一块内的记录不要求有序 块间有序，比如要求第二块所以记录的关键字均要大于第一块中所有记录的关键字，第三块要大于第二块，因为只有块间有序才有可能在查找时带来效率 对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做『分块索引』 上图中定义的索引项的结构分为三个数据项 最大关键码，它存储了每一块中的最大关键字，这样的好处是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大，当然这个索引关键字码可以是任何能够唯一标识一个块的任何数据 存储了块中记录的个数，以便于循环时使用 用于指向块首数据元素的指针，便于开始对这一块中记录遍历 在分块索引表中查找，可以分为两步 在分块索引表中查找要查的关键字所在块，由于分块索引表是块间有序的，因此很容易利用折半插值等算法得到结果 根据块首指针找到相应的块，并在块中顺序查找关键码，因为块中可以是无序的，因此只能顺序查找 假设有 m 块，每块中共有 t 条记录，显然 n = m * t，故而 ASL = (m + 1) / 2 + (t + 1) / 2 = (n / t + t) / 2 + 1，上式的最小值即 n / t = t， n = t ^ 2，则最小的 ASL = n ^ (1 / 2) + 1，分块索引的效率比顺序查找 O(n) 高了很多，总的来说分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库查找等技术的应用当中 倒排索引倒排索引（Inverted Index），是一种索引方法，常被用于全文检索系统中的一种单词文档映射结构，现代搜索引擎绝大多数的索引都是基于倒排索引来进行构建的，这源于在实际应用当中，用户在使用搜索引擎查找信息时往往只输入信息中的某个属性关键字，如一些用户不记得歌名，会输入歌词来查找歌名，输入某个节目内容片段来查找该节目等等 面对海量的信息数据，为满足用户需求，顺应信息时代快速获取信息的趋势，聪明的开发者们在进行搜索引擎开发时对这些信息数据进行逆向运算，研发了『关键词 —— 文档』形式的一种映射结构，实现了通过物品属性信息对物品进行映射时，可以帮助用户快速定位到目标信息，从而极大降低了信息获取难度，倒排索引又叫反向索引，它是一种逆向思维运算，是现代信息检索领域里面最有效的一种索引结构 索引项的结构是次关键字码和记录号表，其中记录号表存储具有相同关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引，如下图所示 倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录，这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址，由于不是由记录来确定属性值，而是由属性来确定记录的位置，因而称为『倒排索引』 倒排索引的优点显然是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，即可以得到结果。但是它的缺点是这个记录号不定长，可多可少","link":"/2020/05/25/Essay/26/"},{"title":"HTTPS 是如何进行加密的","text":"最近在梳理计算机网络相关知识，刚好梳理到 HTTPS 这一块，关于 HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是 HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念，所以打算抽些时间，通过参考一些文章，来梳理一下 HTTPS 整套机制的实现，本文主要通过以下三个方面来进行梳理 HTTP 通信存在什么问题 HTTPS 如何改进 HTTP 存在那些问题 HTTPS 工作原理是什么 HTTPHTTP 是属于应用层的协议，它是基于 TCP/IP 的，所以它只是规定一些要传输的内容，以及头部信息，然后通过 TCP 协议进行传输，依靠 IP 协议进行寻址 客户端发出请求，服务端进行响应，就是这么简单，在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露 什么是 HTTPSHTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版，现在它被广泛用于万维网上安全敏感的通讯，HTTPS 主要作用是 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全 对网站服务器进行真实身份认证 我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信，使用 HTTPS 通信时，不再用 http://，而是改用 https://，另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记，对 HTTPS 的显示方式会因浏览器的不同而有所改变 HTTP 与 HTTPS 的区别HTTP 是明文传输协议，HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全 主要的区别有以下这些 HTTP 是明文传输协议，HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全 HTTPS 比HTTP更加安全，对搜索引擎更友好，利于 SEO，像谷歌、百度都会优先索引 HTTPS 网页 HTTPS 标准端口 443，HTTP 标准端口 80 HTTPS 需要用到 SSL 证书，而 HTTP 不用 其实简单来说，就两点 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全 对网站服务器进行真实身份认证， 为什么需要 HTTPS在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题，接下来我们先来了解下 HTTP 协议存在哪些问题 通信使用明文（不加密），内容可能被窃听由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密，即 HTTP 报文使用明文（指未经过加密的报文）方式发送 HTTP 明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因，HTTP 协议无法加密数据，所有通信数据都在网络中明文裸奔，通过网络的嗅探设备及一些技术手段，就可还原 HTTP 报文内容 无法证明报文的完整性，所以可能遭篡改所谓完整性是指信息的准确度，若无法证明其完整性，通常也就意味着无法判断信息是否准确，由于 HTTP 协议无法证明通信的报文完整性，因此在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉 换句话说，没有任何办法确认，发出的 请求/响应 和接收到的 请求/响应 是前后相同的 不验证通信方的身份，因此有可能遭遇伪装HTTP 协议中的请求和响应不会对通信方进行确认，在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求，另外服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下） HTTP 协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现钓鱼欺诈，用户无法察觉，反观 HTTPS 协议，它比 HTTP 协议相比多了以下优势 数据隐私性，内容经过对称加密，每个连接生成一个唯一的加密密钥 数据完整性，内容传输经过完整性校验 身份认证，第三方无法伪造服务端（客户端）身份 HTTPS 如何解决 HTTP 上述问题HTTPS 并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已，通常 HTTP 直接和 TCP 通信，当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了，简言之所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP 在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能，也就是说 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法，『散列函数』、『对称加密』和『非对称加密』，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性 下面我们就来看看 HTTPS 是如何解决我们上面提到过的几个问题 解决内容可能被窃听的问题（加密）主要有三种方式 对称加密这种方式加密和解密同用一个密钥，加密和解密都会用到密钥，没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了，但是此时我们虽然对数据进行加密了，但是随之会产生一些问题 以对称加密方式加密时必须将密钥也发给对方，可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义，另外还得设法安全地保管接收到的密钥 非对称加密在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫『非对称加密』，采用非对称加密时，客户端和服务端均拥有一个公钥和私钥顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走 非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但是这种方式也是存在一定缺点的 公钥是公开的，所以针对私钥加密的信息，中间人截获后可以使用公钥进行解密，获取其中的内容 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率 对称加密 + 非对称加密这种方式也是 HTTPS 采用的方式，使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的，所以我们可以将对称加密与非对称加密结合起来，充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式 具体做法是，发送密文的一方使用对方的公钥进行加密处理『对称的密钥』，然后对方用自己的私钥解密拿到『对称的密钥』，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信，所以 HTTPS 采用对称加密和非对称加密两者并用的混合加密机制 解决报文可能遭篡改问题（数字签名）网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？在这种情况下我们就可以考虑使用校验数字签名，通常数字签名有两种功效 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名 数字签名能确定消息的完整性,证明数据是否未被篡改过 下面我们再来看看数字签名如何生成，如下所示 12345678910111213+---------------------+| A digital signature ||(not to be confused ||with a digital ||certificate) | | is a mathematical |---- 哈希 --&gt; [消息摘要] --- 私钥加密 --&gt; [数字签名]|technique used | |to validate the ||authenticity and ||integrity of a ||message, software ||or digital document. |+---------------------+ 将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者，接下来就是接收者校验数字签名的流程了，如下 12345678910111213141516+---------------------+| A digital signature ||(not to be confused ||with a digital ||certificate) | | is a mathematical |---- 哈希 ----&gt; [消息摘要]|technique used | ||to validate the | ||authenticity and | ||integrity of a | ||message, software | 对比|or digital document. | |+---------------------+ | | | [数字签名] --- 公钥解密 --&gt; [消息摘要] 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 Hash 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比，如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性 解决通信方身份可能被伪装的问题（数字证书）上面我们提到了数字签名，很美好，你可以使用公钥来进行解密，说明确实是私钥方发送的，但是有没有想过，万一这把公钥本身，就被人做了手脚呢？所以为了保证公钥是可信的，这里就引出了证书颁发机构（Certificate Authority，简称 CA，也就是所谓的第三方认证中心） 这里唯一不同的是，假设对网站信息加密的算法是 MD5，通过 MD5 加密后，然后通过第三方机构的私钥再次对其加密，这样的话，数字证书包含有两个特别重要的信息，即某网站公钥 + 数字签名，假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题 下面我们来看一下客户端是如何去对比两者数字签名的 浏览器会去安装一些比较权威的第三方认证机构的公钥，比如 VeriSign、Symantec 以及 GlobalSign 等等 验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名 然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败 这里存在一个问题，那就是既然有第三方认证，为什么我们不直接使用第三方认证的方式来进行加密呢？ 这是因为第三方认证机构是一个公开的平台，中间人可以去获取，如果只是对网站信息进行第三方机构私钥加密的话，还是会受到欺骗 因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露，这其实也就是数字签名作用 HTTPS 工作流程 Client 发起一个 HTTPS 的请求，连接 443 端口，这个过程可以理解成是请求公钥的过程 Server 端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给 Client Client 验证公钥证书，比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书），如果验证通过则继续，不通过则显示警告信息 Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server Server 使用自己的私钥（private key）解密这个消息，得到对称密钥，至此，Client 和 Server 双方都持有了相同的对称密钥 Server 使用对称密钥加密明文内容 A，发送给 Client Client 使用对称密钥解密响应的密文，得到明文内容 A Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的明文内容 B，然后 Server 使用对称密钥解密密文，得到明文内容 B 为何不所有的网站都使用 HTTPS既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS 呢？ 首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书，从证书的选择、购买到部署，传统的模式下都会比较耗时耗力 其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源，如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少，但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题 除此之外，想要节约购买证书的开销也是原因之一，要进行 HTTPS 通信，证书是必不可少的，而使用的证书必须向认证机构（CA）购买 总结 HTTPS 就是使用 SSL/TLS 协议进行加密 传输大致流程是客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个对称加密的秘钥，使用该公钥加密，传输给服务端，服务端再通过解密拿到该对称秘钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程 第三方认证，最重要的是数字签名，避免了获取的公钥是中间人的 参考 图解 HTTP HTTPS 工作原理 HTTPS 原理详解 为什么 HTTPS 比 HTTP 更安全 什么是 HTTPS HTTPS 原理通俗了解 SSL 握手过程详解 大型网站的 HTTPS 实践","link":"/2020/08/09/HTTP/09/"},{"title":"HTTP/3","text":"既然有 HTTP/3 的诞生，那么就说明在 HTTP/1.1 和 HTTP/2 当中是存在一些问题的，下面我们就先从这个根本上的问题开始看起 本文主要参考的是 HTTP/3 原理与实践，内容有所调整，主要是方便自己理解，更为详细的内容可以参考原文 RTTRTT 是 Round Trip Time 的缩写，通俗地说就是通信一来一回的时间，下面我们就先来看看在连接过程当中需要哪些 RTT TCP 建立连接时间最早大家使用 TCP 来运输 HTTP，TCP 需要三次握手，建立了 TCP 虚拟通道，那么这三次握手需要几个 RTT 时间呢？ 一去（SYN） 二回（SYN + ACK） 三去（ACK） 相当于一个半来回，故 TCP 连接的时间 = 1.5 RTT HTTP 通信时间这意味着，用户在浏览器里输入的网址 URL，直到时间流逝了 1.5 RTT 之后，TCP 才开始运输 HTTP Request，浏览器收到服务器的 HTTP Response，又要等待的时间为 一去（HTTP Request） 二回（HTTP Responses） 故 HTTP 的通信时间 = 1 RTT，那么我们可以大致得出，基于 TCP 传输的 HTTP 通信，一共花费的时间总和 1HTTP 通信时间总和 = TCP 连接时间 + HTTP 通信时间 = 1.5 RTT + 1 RTT = 2.5 RTT HTTPS随着互联网的爆发式增长，人类发现完全明文传输的 HTTP 通信很不安全，做为 OSI 七层参考模型的现实实现的 TCP/IP 协议，在设计之初没有考虑安全加密的环节，互联网先驱 Netscape 公司，创造性发明了 SSL（Secure Socket Layer），SSL 位于 TCP 与 HTTP 之间，做为 HTTP 的安全供应商，全权负责 HTTP 的安全加密工作，也就像下面这样 1IP / TCP / SSL / [HTTP] 随着 SSL 的名气攀升，互联网标准化组织 IETF 在 SSL 3.0 版本的基础上，重新设计并命名了这个协议，其全新的名字为 TLS（Transport Layer Security），最初的版本为 1.0 版本，从其名字就可以看出，其核心使命就是保证传输层的安全，各个通信部门成员的占位与 SSL 占位一致 1IP / TCP / TLS / [HTTP] 我们通常将 TLS 安全保护的 HTTP 通信，称之为 HTTPS，以区别于没有 TLS 安全防护的 HTTP 明文通信，那么下面我们就以 1.2 版本为例，看看 HTTPS 通信一共要消耗几个 RTT 时间？ 浏览器给服务器发送的 Client Hello 消息（一去） 服务器给浏览器发送的 Server Hello 消息（二回） 浏览器给服务器发送的 Key Exchange 消息（三去） 所以我们可以得出 1HTTPS 通信时间总和 = TCP 连接时间 + TLS 连接时间 + HTTP 通信时间 = 1.5 RTT + 1.5 RTT + 1 RTT = 4 RTT 如果浏览器与服务器物理距离很近，RTT &lt; 10 ms，即使 4 RTT 最大也不过 40 ms 的时间，用户压根感觉不到慢，但是如果浏览器与服务器相隔上万公里，一个 RTT 时间通常在 200ms 以上，4RTT 时间通常在 1 秒以上，用户会明显感觉到网速慢了 HTTP/1.x浏览器从服务器获取的一个页面，通常由很多资源链接所组成，服务器给浏览器推送的第一个页面，页面里通常嵌入了图片资源文本链接、以及动态页面资源链接、或第三方网站的链接资源，还需要浏览器根据这些文本链接内容，去链接所对应的服务器，继续下载链接所对应的内容 浏览器通常采用的流程是，重新建立一个 TCP 连接、TLS 连接、HTTP 通信，这又是一个漫长的 4RTT 等待过程，用户看到浏览器完整页面的时间为 1完整页面加载时间 = 4 RTT * 2 = 8 RTT HTTP/2既然第一次页面与第二次页面都是同一个网站服务器，为何第二次页面要重新建立一个 TCP 连接，一个 TLS 连接？如果重用第一个 TCP 连接，那么就少了 1.5 RTT + 1.5 RTT = 3 RTT 的时间 的确，用户的多个 HTTP Request 请求，使用同一个逻辑通道进行运输，这样会大大减少重新建立连接所花费的时间，但是，这样会带来一个副作用，多个 HTTP 流使用同一个 TCP 连接，遵守同一个流量状态控制，只要第一个 HTTP 流遭遇到拥塞，剩下的 HTTP 流压根没法发出去，这就是头部阻塞（Head of line Blocking） 至此，我们可以发现问题的根源所在，那就是 TCP 连接，那么有人就会问了，我们不使用 TCP 不就可以了吗？所以这也就引出了我们今天的主角，HTTP/3 和 QUIC HTTP/3在介绍 HTTP/3 之前，我们先简单看下 HTTP 的历史，了解下 HTTP/3 出现的背景 随着网络技术的发展，1999 年设计的 HTTP/1.1 已经不能满足需求，所以 Google 在 2009 年设计了基于 TCP 的 SPDY，后来 SPDY 的开发组推动 SPDY 成为正式标准，不过最终没能通过，不过 SPDY 的开发组全程参与了 HTTP/2 的制定过程，参考了 SPDY 的很多设计，所以我们一般认为 SPDY 就是 HTTP/2 的前身 无论 SPDY 还是 HTTP/2，都是基于 TCP 的，TCP 与 UDP 相比效率上存在天然的劣势，所以 2013 年 Google 开发了基于 UDP 的名为 QUIC 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能替代 TCP，使得网页传输更加高效，后经提议，互联网工程任务组正式将基于 QUIC 协议的 HTTP（HTTP over QUIC）重命名为 HTTP/3 关于 UDP 与 TCP 的区别可见之前整理过的 TCP 和 UDP 的比较 QUIC 协议TCP 一直是传输层中举足轻重的协议，而 UDP 则默默无闻，长期以来 UDP 给人的印象就是一个很快但不可靠的传输层协议，正是看中了 UDP 的速度与效率，同时 QUIC 也整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化，用一张图可以清晰地表示他们之间的关系 那 QUIC 和 HTTP/3 什么关系呢？QUIC 是用来替代 TCP、SSL/TLS 的传输层协议，在传输层之上还有应用层，我们熟知的应用层协议有 HTTP、FTP、IMAP 等，这些协议理论上都可以运行在 QUIC 之上，其中运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3，这就是 HTTP over QUIC 即 HTTP/3 的含义 因此想要了解 HTTP/3，QUIC 是绕不过去的，下面我们就通过几个比较重要的特性来简单的了解一下 QUIC 相关内容 零 RTT 建立连接用一张图可以形象地看出 HTTP/2 和 HTTP/3 建立连接的差别 HTTP/2 的连接需要 3 RTT，如果考虑会话复用，即把第一次握手算出来的对称密钥缓存起来，那么也需要 2 RTT，更进一步的，如果 TLS 升级到 1.3，那么 HTTP/2 连接需要 2 RTT，考虑会话复用则需要 1 RTT，有人会说 HTTP/2 不一定需要 HTTPS，握手过程还可以简化，这没毛病，HTTP/2 的标准的确不需要基于 HTTPS，但实际上所有浏览器的实现都要求 HTTP/2 必须基于 HTTPS，所以 HTTP/2 的加密连接必不可少，而 HTTP/3 首次连接只需要 1 RTT，后面的连接更是只需 0 RTT，意味着客户端发给服务端的第一个包就带有请求数据，这一点在 HTTP/2 当中是难以实现的，那这背后又是什么原理呢？我们可以具体看下 QUIC 的连接过程 首次连接时，客户端发送 Inchoate Client Hello 给服务端，用于请求连接 服务端生成 g、p、a，根据 g、p 和 a 算出 A，然后将 g、p、A 放到 Server Config 中再发送 Rejection 消息给客户端 客户端接收到 g、p、A 后，自己再生成 b，根据 g、p、b 算出 B，根据 A、p、b 算出初始密钥 K，B 和 K 算好后，客户端会用 K 加密 HTTP 数据，连同 B 一起发送给服务端 服务端接收到 B 后，根据 a、p、B 生成与客户端同样的密钥，再用这密钥解密收到的 HTTP 数据，为了进一步的安全（前向安全性），服务端会更新自己的随机数 a 和公钥，再生成新的密钥 S，然后把公钥通过 Server Hello 发送给客户端，连同 Server Hello 消息，还有 HTTP 返回数据 客户端收到 Server Hello 后，生成与服务端一致的新密钥 S，后面的传输都使用 S 加密 这样，QUIC 从请求连接到正式接发 HTTP 数据一共花了 1 RTT，这 1 个 RTT 主要是为了获取 Server Config，后面的连接如果客户端缓存了 Server Config，那么就可以直接发送 HTTP 数据，实现 0 RTT 建立连接 这里使用的是 DH 密钥交换算法，DH 算法的核心就是服务端生成 a、g、p 三个随机数，a 自己持有，g 和 p 要传输给客户端，而客户端会生成 b 这 1 个随机数，通过 DH 算法客户端和服务端可以算出同样的密钥，在这过程中 a 和 b 并不参与网络传输，安全性大大提高，因为 p 和 g 是大数，所以即使在网络中传输的 p、g、A、B 都被劫持，那么靠现在的计算机算力也没法破解密钥 连接迁移TCP 连接基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化，当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久，如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间 QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持，那这是怎么做到的呢？道理很简单，QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持 队头阻塞/多路复用HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking），那什么是队头阻塞呢？ TCP 是个面向连接的协议，即发送请求后需要收到 ACK 消息，以确认对方已接收到数据，如果每次请求都要在收到上次请求的 ACK 消息后再请求，那么效率无疑很低，后来 HTTP/1.1 提出了 Pipelining 技术，允许一个 TCP 连接同时发送多个请求，这样就大大提升了传输效率 在这个背景下，下面就来谈 HTTP/1.1 的队头阻塞，下图中，一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽资源 因此 HTTP 一般又允许每个主机建立 6 个 TCP 连接，这样可以更加充分地利用带宽资源，但每个连接中队头阻塞的问题还是存在 HTTP/2 的多路复用解决了上述的队头阻塞问题，不像 HTTP/1.1 中只有上一个请求的所有数据包被传输完毕下一个请求的数据包才可以被传输，HTTP/2 中每个请求都被拆分成多个 Frame 通过一条 TCP 连接同时被传输，这样即使一个请求被阻塞，也不会影响其他的请求，如下图所示，不同颜色代表不同的请求，相同颜色的色块代表请求被切分的 Frame HTTP/2 虽然可以解决请求这个粒度的阻塞，但 HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题，HTTP/2 的每个请求都会被拆分成多个 Frame，不同请求的 Frame 组合成 Stream，Stream 是 TCP 上的逻辑传输单元，这样 HTTP/2 就达到了一条连接同时发送多条请求的目标，这就是多路复用的原理 我们看一个例子，在一条 TCP 连接上同时发送 4 个 Stream，其中 Stream1 已正确送达，Stream2 中的第 3 个 Frame 丢失，TCP 处理数据时有严格的前后顺序，先发送的 Frame 要先被处理，这样就会要求发送方重新发送第 3 个 Frame，Stream3 和 Stream4 虽然已到达但却不能被处理，那么这时整条连接都被阻塞 不仅如此，由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题，TLS 基于 Record 组织数据，将一堆数据放在一起（即一个 Record）加密，加密完后又拆分成多个 TCP 包传输，一般每个 Record 有 16K 左右，包含 12 个 TCP 包，这样如果 12 个 TCP 包中有任何一个包丢失，那么整个 Record 都无法解密 队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢，那 QUIC 是如何解决队头阻塞问题的呢？主要有两点 QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题 QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理 拥塞控制拥塞控制的目的是避免过多的数据一下子涌入网络，导致网络超出最大负荷，QUIC 的拥塞控制与 TCP 类似，并在此基础上做了改进，所以我们先简单介绍下 TCP 的拥塞控制，关于 TCP 当中的拥塞控制更为详细的内容可以参考 TCP 的流量控制和拥塞控制 这篇博文，这里我们只简单介绍一二 TCP 拥塞控制由 4 个核心算法组成，即 『慢启动』、『拥塞避免』、『快速重传』和『快速恢复』，理解了这 4 个算法，对 TCP 的拥塞控制也就有了大概了解 慢启动，发送方向接收方发送 1 个单位的数据，收到对方确认后会发送 2 个单位的数据，然后依次是 4 个、8 个呈指数级增长，这个过程就是在不断试探网络的拥塞程度，超出阈值则会导致网络拥塞 拥塞避免，指数增』长变为线性增长 快速重传，发送方每一次发送时都会设置一个超时计时器，超时后即认为丢失，需要重发 快速恢复，在上面快速重传的基础上，发送方重新发送数据时，也会启动一个超时定时器，如果收到确认消息则进入拥塞避免阶段，如果仍然超时，则回到慢启动阶段 QUIC 重新实现了 TCP 协议的 Cubic 算法进行拥塞控制，并在此基础上做了不少改进，下面介绍一些 QUIC 改进的拥塞控制的特性 热插拔TCP 中如果要修改拥塞控制策略，需要在系统层面进行操作，QUIC 修改拥塞控制策略只需要在应用层操作，并且 QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法 前向纠错 FECQUIC 使用前向纠错（FEC，Forward Error Correction）技术增加协议的容错性，一段数据被切分为 10 个包后，依次对每个包进行异或运算，运算结果会作为 FEC 包与数据包一起被传输，如果不幸在传输过程中有一个数据包丢失，那么就可以根据剩余 9 个包以及 FEC 包推算出丢失的那个包的数据，这样就大大增加了协议的容错性 这是符合现阶段网络技术的一种方案，现阶段带宽已经不是网络传输的瓶颈，往返时间才是，所以新的网络传输协议可以适当增加数据冗余，减少重传操作 单调递增的 Packet NumberTCP 为了保证可靠性，使用 Sequence Number 和 ACK 来确认消息是否有序到达，但这样的设计存在缺陷 超时发生后客户端发起重传，后来接收到了 ACK 确认消息，但因为原始请求和重传请求接收到的 ACK 消息一样，所以客户端就郁闷了，不知道这个 ACK 对应的是原始请求还是重传请求，如果客户端认为是原始请求的 ACK，但实际上是左图的情形，则计算的采样 RTT 偏大，如果客户端认为是重传请求的 ACK，但实际上是右图的情形，又会导致采样 RTT 偏小，图中有几个术语，RTO 是指超时重传时间（Retransmission TimeOut），跟我们熟悉的 RTT 长得很像，采样 RTT 会影响 RTO 计算，超时时间的准确把握很重要，长了短了都不合适 QUIC 解决了上面的歧义问题，与 Sequence Number 不同的是，Packet Number 严格单调递增，如果 Packet N 丢失了，那么重传时 Packet 的标识不会是 N，而是比 N 大的数字，比如 N + M，这样发送方接收到确认消息时就能方便地知道 ACK 对应的是原始请求还是重传请求 ACK DelayTCP 计算 RTT 时没有考虑接收方接收到数据到发送确认消息之间的延迟，如下图所示，这段延迟即 ACK Delay，QUIC 考虑了这段延迟，使得 RTT 的计算更加准确 更多的 ACK 块一般来说，接收方收到发送方的消息后都应该发送一个 ACK 回复，表示收到了数据，但每收到一个数据就返回一个 ACK 回复太麻烦，所以一般不会立即回复，而是接收到多个数据后再回复，TCP SACK 最多提供 3 个 ACK block，但有些场景下，比如下载，只需要服务器返回数据就好，但按照 TCP 的设计，每收到 3 个数据包就要返回一个 ACK，而 QUIC 最多可以捎带 256 个 ACK block，在丢包率比较严重的网络下，更多的 ACK block 可以减少重传量，提升网络效率 流量控制TCP 会对每个 TCP 连接进行流量控制，流量控制的意思是让发送方不要发送太快，要让接收方来得及接收，不然会导致数据溢出而丢失，TCP 的流量控制主要通过滑动窗口来实现的，可以看出，拥塞控制主要是控制发送方的发送策略，但没有考虑到接收方的接收能力，流量控制是对这部分能力的补齐 QUIC 只需要建立一条连接，在这条连接上同时传输多条 Stream，好比有一条道路，两头分别有一个仓库，道路中有很多车辆运送物资，QUIC 的流量控制有两个级别 连接级别（Connection Level） Stream 级别（Stream Level） 好比既要控制这条路的总流量，不要一下子很多车辆涌进来，货物来不及处理，也不能一个车辆一下子运送很多货物，这样货物也来不及处理 那 QUIC 是怎么实现流量控制的呢？我们先看单条 Stream 的流量控制，Stream 还没传输数据时，接收窗口（flow control receive window）就是最大接收窗口（flow control receive window），随着接收方接收到数据后，接收窗口不断缩小，在接收到的数据中，有的数据已被处理，而有的数据还没来得及被处理，如下图所示，蓝色块表示已处理数据，黄色块表示未处理数据，这部分数据的到来，使得 Stream 的接收窗口缩小 随着数据不断被处理，接收方就有能力处理更多数据，当满足下列条件时 1(flow control receive offset - consumed bytes) &lt; (max receive window / 2) 接收方会发送 WINDOW_UPDATE frame 告诉发送方你可以再多发送些数据过来，这时 flow control receive offset 就会偏移，接收窗口增大，发送方可以发送更多数据到接收方 Stream 级别对防止接收端接收过多数据作用有限，更需要借助 Connection 级别的流量控制，理解了 Stream 流量那么也很好理解 Connection 流控，Stream 中，接收窗口为 1(flow control receive window) = 最大接收窗口(max receive window) - 已接收数据(highest received byte offset) 而对 Connection 来说 1接收窗口 = Stream1 接收窗口 + Stream2 接收窗口 + ... + StreamN 接收窗口 参考 HTTP/3 原理与实践 A QUIC update on Google’s experimental transport http-over-Quic What Is HTTP/3 HTTP/3 如何看待 HTTP/3","link":"/2020/09/12/HTTP/12/"},{"title":"Node.js 中的事件轮询机制","text":"本文主要借助 libuv 来简单的了解一下 Node.js 中的事件轮询机制相关概念，注意与浏览器中的 EventLoop 区分开来，下面我们就先来看看什么是 libuv 关于浏览器中的 EventLoop 详细可见 JavaScript 并发模型 libuvlibuv 是一个高性能的，事件驱动的 I/O 库，并且提供了跨平台（如 windows, linux）的 API，如果想要参考更为详细的内容可以参考 An Introduction to libuv，中文教程可以参考 libuv 的中文教程 和 libuv，下面我们就正式的来看看 libuv，libuv 的 官方文档 在阐述其架构的时候有这么一张图，如下 仅仅凭着这么一张图并不能让我们对其内部机制理解得透彻，简单来说，在 Node.js 里面 V8 充当的角色更多的是语法解析层面，另外它还充当了 JavaScript 和 C/C++ 的桥梁，但是我们都知道 Node.js 中一切皆可异步，但这并不是通过 V8 来实现的，充当这个角色的其实就是 libuv，比如一个简单的 JavaScript 异步代码，使用 setTimeout 就可以实现 1234567setTimeout(function () { console.log('timeout 0') }, 0)console.log('outter')// outter// timeout 0 想要深挖为什么会出现这样的结果，要首先来研究一下 libuv 的事件轮询机制 事件轮询机制事件轮询机制是一个执行模型，在不同的地方有不同的实现，浏览器和 Node.js 基于不同的技术实现了各自的 EventLoop，但是不要混淆 Node.js 和浏览器中的 EventLoop 简单来讲，Node.js 的 event 是基于 libuv，而浏览器的 EventLoop 则在 HTML 5 的规范中明确定义，libuv 已经对 EventLoop 作出了实现，而 HTML 5 规范中只是定义了浏览器中 EventLoop 的模型，具体实现留给了浏览器厂商 在 libuv 中，有一个句柄（handle）的概念，每个句柄中存储数据和回调函数之类的信息，句柄在使用前要添加到对应的队列（Queue）或者堆（Heap）中，其实只有定时器句柄使用了 最小堆 的数据结构，其他句柄使用队列的数据结构进行存储，libuv 在进行每一次事件轮询的时候都会从每个类型的句柄中，取出关联的队列或者堆结构进行处理，流程图如下所示 Node.js 的 EventLoop 分为六个阶段，每个阶段的作用如下 timers，执行 setTimeout() 和 setInterval() 中到期的 callback I/O callbacks，上一轮循环中有少数的 I/O callback 会被延迟到这一轮的这一阶段执行 idle, prepare，仅内部使用 poll，最为重要的阶段，执行 I/O callback，在适当的条件下会阻塞在这个阶段 check，执行 setImmediate 的 callback close callbacks，执行 close 事件的 callback，例如 socket.on('close',func) 如果想要具体了解其内部执行流程，可以参考这篇文章中的 源码解析部分，我们这里只是简单介绍一下其执行的流程，上面的图片可以简化成下面的流程 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌────────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └────────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ EventLoop 的每一次循环都需要依次经过上述的阶段，每个阶段都有自己的 callback 队列，每当进入某个阶段，都会从所属的队列中取出 callback 来执行，当队列为空或者被执行 callback 的数量达到系统的最大数量时，进入下一阶段，这六个阶段都执行完毕称为一轮循环，下面我们来分类查看 timer 阶段 在 timer 阶段其实使用一个最小堆而不是队列来保存所有元素（其实也可以理解，因为 timeout 的 callback 是按照超时时间的顺序来调用的，并不是先进先出的队列逻辑），然后循环取出所有到期的 callback 执行 其实简单来说就是，检查定时器，如果到了时间，就执行回调，其中这些定时器就是 setTimeout、setInterval I/O callbacks 阶段 根据 libuv 的文档，一些应该在上轮循环 poll 阶段执行的 callback，因为某些原因不能执行，就会被延迟到这一轮的循环的 I/O callbacks 阶段执行，换句话说这个阶段执行的 callbacks 是上轮残留的 idle 和 prepare 阶段 idle 和 prepare 回调，仅仅在内部使用 poll 阶段 轮询阶段，因为代码中难免会有异步操作，比如文件 I/O，网络 I/O 等，当这些异步操作完成就会通知 JavaScript 主线程，怎么通知呢？就是通过 'data'、'connect' 等事件使得事件循环到达 poll 阶段，而到达了这个阶段后 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，EventLoop 将回到 timer 阶段 如果没有定时器, 会去看回调函数队列 如果队列不为空，拿出队列中的方法依次执行 如果队列为空，检查是否有 setImmdiate 的回调 有则前往 check 阶段 没有则继续等待，相当于阻塞了一段时间（阻塞时间是有上限的），等待 callback 函数加入队列，加入后会立刻执行，一段时间后自动进入 check 阶段 check 阶段 这是一个比较简单的阶段，直接执行 setImmdiate 的回调 close 阶段 循环关闭所有的 closing handles 其实简单的总结一下就是，浏览器和 Node.js 两者最主要的区别在于浏览器中的微任务是在『每个相应的宏任务中』执行的，而 Node.js 中的微任务是在『不同阶段之间』执行的 另外需要注意的是，process.nextTick 是一个独立于 EventLoop 的任务队列，在每一个 EventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行 实例演示下面我们通过一个实例来加深一下印象，如下 12345678910111213setTimeout(() =&gt; { console.log(`timer1`) Promise.resolve().then(function () { console.log(`promise1`) })}, 0)setTimeout(() =&gt; { console.log(`timer2`) Promise.resolve().then(function () { console.log(`promise2`) })}, 0) 但是需要注意的是，Node.js 版本在 &gt;= 11 和在 11 以下的会有不同的表现，我们先来看 &gt;= 11 的情况，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务，输出结果如下 1234timer1promise1time2promise2 而在版本小于 11 的情况下，对于定时器的处理是: 若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，『直接去执行』新的定时器任务 当新的定时器任务执行完后，再『一一执行』中途产生的微任务 因此会打印出这样的结果 1234timer1timer2promise1promise2 线程模型最后的部分，我们再来简单的了解一下 libuv 的线程模型，因为要想实现一个无堵塞的事件轮询必须依靠线程，libuv 中大体上可以把线程分为两类，一类是事件轮询线程，一类是文件 I/O 处理线程 第一类事件轮询线程是单线程，另外一类称其为文件 I/O 处理线程多少有些不准确，因为它不仅能处理文件 I/O，还能处理 DNS 解析，也能处理用户自己编写的 Node.js 扩展中的逻辑，它是一个线程池，如果你想自己编写一个 C++ 扩展来处理耗时业务的话，也会用上它 其实我们平时在听到 Node.js 相关的特性时，经常会对异步 I/O、非阻塞 I/O 有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 Node.js 来说，这两种技术底层是如何实现的 什么是 I/O首先，我们有必要先把 I/O 的概念解释一下，I/O 即 Input/Output，也就是输入和输出的意思，在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于网络 I/O，回到 Node.js 中，其实这种的 I/O 的场景就更加广泛了，我们在上面也提到过，主要分为两种 文件 I/O，比如用 fs 模块对文件进行读写操作 网络 I/O，比如 HTTP 模块发起网络请求 阻塞和非阻塞 I/O阻塞和非阻塞 I/O 其实是针对操作系统内核而言的，而不是 Node.js 本身，阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作 对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了，那如果换成非阻塞 I/O，调用返回后我们的 Node.js 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O，这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，那就是 Node.js 应用程序怎么知道操作系统已经完成了 I/O 操作呢？ 为了让 Node.js 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是轮询，对于轮询而言，有以下这么几种方案 一直轮询检查 I/O 状态，直到 I/O 完成，这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面，其实跟阻塞 I/O 的效果是一样的 遍历文件描述符（即文件 I/O 时操作系统和 Node.js 之间的文件凭证）的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变，但 CPU 轮询消耗还是很大 epoll 模式，即在进入轮询的时候如果 I/O 未完成 CPU 就休眠，完成之后唤醒 CPU 总之，CPU 要么重复检查 I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，所以我们希望的是，Node.js 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 Node.js 发一个完成信号，Node.js 执行回调操作就行，这也是最理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？ 其实在 linux 原生存在这样的一种方式，即（AIO），但两个致命的缺陷 只有 linux 下存在，在其他系统中没有异步 I/O 支持 无法利用系统缓存 是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了，下面我们来看看 Node.js 中的异步 I/O 方案 Node.js 中的异步 I/O 方案其实我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，异步 I/O 就是使用这样的『线程池』来实现的，只不过在不同的系统下面表现会有所差异，在 linux 下可以直接使用线程池来完成，在 windows 系统下则采用 IOCP 这个系统 API（其内部还是用线程池完成的） 有了操作系统的支持，那 Node.js 如何来对接这些操作系统从而实现异步 I/O 呢？这里我们就以文件 IO 处理来作为示例，来看看这两类线程之前是怎么通信的 12345let fs = require('fs')fs.readFile('/test.txt', function (err, data) { console.log(data)}) 执行代码的过程中大概发生了以下这些事情 首先，fs.readFile 调用 Node.js 的核心模块 fs.js 接下来，Node.js 的核心模块调用内建模块 node_file.cc，创建对应的文件 I/O 观察者对象 最后，根据不同平台（linux 或者 windows），内建模块通过 libuv 中间层进行系统调用 流程也就如下图所示 libuv 调用过程拆解下面我们再来看看 libuv 中是如何来进行进行系统调用的，也就是 uv_fs_open() 中做了些什么？ 创建请求对象以 windows 系统为例来说，在这个函数的调用过程中，我们创建了一个文件 I/O 的请求对象，并往里面注入了回调函数 1req_wrap -&gt; object_ -&gt; Set(oncomplete_sym, callback) req_wrap 便是这个请求对象，req_wrap 中 object_ 的 oncomplete_sym 属性对应的值便是我们 Node.js 应用程序代码中传入的回调函数 推入线程池，调用返回在这个对象包装完成后，QueueUserWorkItem() 方法将这个对象推进线程池中等待执行，至此现在 JavaScript 的调用就直接返回了，我们的 JavaScript 应用程序代码可以继续往下执行，当然，当前的 I/O 操作同时也在线程池中将被执行，这不就完成了异步么，但是别高兴太早，因为回调还没有执行，所以接下来便是执行回调通知的环节 回调通知事实上现在线程池中的 I/O 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成，重要的是 I/O 完成后会发生什么，不过在此之前，我们先来看两个比较重要的方法 GetQueuedCompletionStatus 和 PostQueuedCompletionStatus 还记得之前提到过的 EventLoop 吗？在每一个 Tick 当中会调用 GetQueuedCompletionStatus 检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了 而 PostQueuedCompletionStatus 方法则是向 IOCP 提交状态，告诉它当前 I/O 完成了 所以现在我们可以言归正传，把后面的流程全部串联起来了，当对应线程中的 I/O 完成后，会将获得的结果存储起来，保存到相应的请求对象中，然后调用 PostQueuedCompletionStatus() 向 IOCP 提交执行完成的状态，并且将线程还给操作系统，一旦 EventLoop 的轮询操作中，调用 GetQueuedCompletionStatus 检测到了完成的状态，就会把请求对象塞给 I/O 观察者 I/O 观察者现在的行为就是取出请求对象的存储结果，同时也取出它的 oncomplete_sym 属性，即回调函数，将前者作为函数参数传入后者，并执行后者，至此，回调函数就成功执行了 总结 阻塞和非阻塞 I/O 其实是针对操作系统内核而言的，阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作 Node.js 中的异步 I/O 采用多线程的方式，由 EventLoop、I/O 观察者，请求对象、线程池四大要素相互配合，共同实现 参考 官方文档 Linux IO 概览 Libuv 源码阅读 The Node.js EventLoop, Timers, and process.nextTick() 不要混淆 Node.js 和浏览器中的 eventloop An Introduction to libuv libuv Libuv 的中文教程","link":"/2019/07/05/Node/04/"},{"title":"Node.js 中的模块机制","text":"为了让 Node.js 的文件可以相互调用，Node.js 提供了一个简单的模块系统，模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的，换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展 CommonJS 规范Node.js 遵循 CommonJS 规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口，CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行，下面是一个简单的示例 123456// a.jsmodule.exports = (a, b) =&gt; a + b// b.jsconst add = require('./a')console.log(add(2, 3)) CommonJS 也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 源码 经常与 CommonJS 规范一起出现的还有 AMD 规范和 CMD 规范，在这里就不详细展开，感兴趣的可以参考 JavaSript 模块规范 - AMD 规范与 CMD 规范介绍，总结的很棒 模块分类在 Node.js 中，模块主要可以分为以下几种类型 核心模块，包含在 Node.js 源码中，被编译进 Node.js 可执行二进制文件 JavaScript 模块，也叫 Native 模块，比如常用的 HTTP，fs 等等 C/C++ 模块，也叫 built-in 模块，一般我们不直接调用，而是在 native module 中调用，然后我们再 require Native 模块，比如我们在 Node.js 中常用的 Buffer，fs，os 等 Native 模块，其底层都有调用 built-in 模块 如对于 Native 模块 Buffer，还是需要借助 builtin node_buffer.cc 中提供的功能来实现大容量内存申请和管理，目的是能够脱离 V8 内存大小使用限制 第三方模块，非 Node.js 源码自带的模块都可以统称第三方模块，比如 express，Webpack 等等 JavaScript 模块，这是最常见的，我们开发的时候一般都写的是 JavaScript 模块 JSON 模块，就是一个 JSON 文件 C/C++ 扩展模块，使用 C/C++ 编写，编译之后后缀名为 .node 源码的目录结构如下 1234567891011├── benchmark // 一些 Node.js 性能测试代码├── deps // Node.js 依赖├── doc // 文档├── lib // Node.js 对外暴露的 js 模块源码├── src // Node.js 的 C/C++ 源码文件，内建模块├── test // 单元测试├── tools // 编译时用到的工具├── doc // api 文档├── vcbuild.bat // win 平台 makefile 文件├── node.gyp // node-gyp 构建编译任务的配置文件... 模块对象每个模块内部，都有一个 module 对象，代表当前模块，它有以下属性 module.id，模块的识别符，通常是带有绝对路径的模块文件名 module.filename，模块的文件名，带有绝对路径 module.loaded，返回一个布尔值，表示模块是否已经完成加载 module.parent，返回一个对象，表示调用该模块的模块 module.children，返回一个数组，表示该模块要用到的其他模块 module.exports，表示模块对外输出的值 模块加载机制简单来说，模块加载机制也就是 require 函数执行的主要流程，在 Node.js 中模块加载一般会经历三个步骤，『路径分析』、『文件定位』、『编译执行』，按照模块的分类，按照以下顺序进行优先加载 系统缓存，模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值 系统模块，也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了『路径分析』、『文件定位』，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下 文件模块，优先加载以 .、..、/ 开头的，如果文件没有加上扩展名，会依次按照 .js、.json、.node 进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在 从性能优化的角度来看待，.json、.node 最好还是加上文件的扩展名 目录做为模块，这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个『包』来处理 Node.js 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 (&quot;main&quot;: &quot;lib/hello.js&quot;) 描述的入口文件进行加载 如果也没加载到，则会抛出默认错误: Error: Cannot find module 'lib/hello.js' node_modules 目录加载，对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录 我们在上面介绍了 Node.js 模块机制的一些基本内容，下面我们就来看一些 Node.js 模块当中可能涉及到的一些问题，主要有下面这些 模块中的 module、exports、__dirname、__filename 和 require 来自何方？ module.exports 与 exports 有什么区别？ 模块之间循环依赖是否会陷入死循环？ require 函数支持导入哪几类文件？ require 函数执行的主要流程是什么？ Node.js 模块与前端模块的异同 Node.js 中的 VM 模块是做什么用的？ 模块中的 module、exports、dirname、filename 和 require 来自何方？针对于这个问题，我们手动的试一下就知道了，新建一个 index.js 文件，输入以下内容 12345console.log(module)console.log(exports)console.log(__dirname)console.log(__filename)console.log(require) 执行完以上代码，控制台的输出如下，我们忽略掉输出对象中的大部分属性，只保留一些比较重要的，如下 12345678910111213141516171819202122232425Module { ========================================================&gt; module id: '.', exports: {}, parent: null, filename: 'index.js', loaded: false, children: [], // 模块查找路径 paths: []}{} ==============================================================&gt; exports/Users/Desktop/test =============================================&gt; __dirname/Users/Desktop/test/index.js ====================================&gt; __filename{ [Function: require] ===========================================&gt; require resolve: { [Function: resolve] paths: [Function: paths] }, // Module对象 main: Module { ... }, extensions: { '.js': [Function], '.json': [Function], '.node': [Function] }, cache: { ... } } 通过控制台的输出值，我们可以清楚地看出每个变量的值，在执行代码之前，Node.js 会对要执行的代码进行封装，至于到底是如何封装的，可以见下方 require 函数支持导入哪几类文件？，如下所示 123(function(exports, require, module, __filename, __dirname) { // 模块的代码}) 这里我们就清楚了，模块中的 module、exports、__dirname、__filename 和 require 这些对象都是函数的输入参数，在调用包装后的函数时传入 module.exports 与 exports 的区别我们先来看一行代码 1console.log(module.exports === exports) // true 可以发现，输出为 true，再看下面这样 123exports.id = 1 // 方式一，可以正常导出exports = { id: 1 } // 方式二，无法正常导出module.exports = { id: 1 } // 方式三，可以正常导出 为什么方式二无法正常导出呢？这里可以参考上面的 module 和 exports 输出的对应值来理解，如果 module.exports === exports 执行的结果为 true，那么表示模块中的 exports 变量与 module.exports 属性是指向同一个对象，当使用方式二 exports = { id: 1 } 的方式会改变 exports 变量的指向，这时与 module.exports 属性指向不同的变量，而当我们导入某个模块时，是导入 module.exports 属性指向的对象 如果想要深入了解，可以参考之前整理过的一篇文章内容 exports、module.exports 和 export、export default，分析的很详细 模块之间循环依赖是否会陷入死循环？我们先来看看什么是循环依赖，所谓循环依赖就是，当模块 a 执行时需要依赖模块 b 中定义的属性或方法，而在导入模块 b 中，发现模块 b 同时也依赖模块 a 中的属性或方法，即两个模块之间互相依赖，这种现象我们称之为循环依赖，我们来验证一下 123456789// a.jsexports.a = 1exports.b = 2require('./b')exports.c = 3// b.jsconst a = require('./a')console.log(a) 当在控制台运行 a.js 之后可以发现程序正常运行，并不会出现死循环，但『只会输出相应模块已加载的部分数据』，如下 1{ a: 1, b: 2 } 所以我们可以得出结论，在启动 a.js 的时候，会加载 b.js，那么在 b.js 中又加载了 a.js，但是此时 a.js 模块还没有执行完，返回的是一个 a.js 模块的 exports 对象『未完成的副本』给到 b.js 模块（因此是不会陷入死循环的），然后 b.js 完成加载之后将 exports 对象提供给了 a.js 模块 require 函数支持导入哪几类文件？在 require 函数对象中，有一个 extensions 属性，顾名思义表示它支持的扩展名，支持的文件类型主要有 .js、.json 和 .node，在上面输出的 require 函数对象中我们已经可以了解到了 12345678{ [Function: require] ===========================================&gt; require resolve: { [Function: resolve] paths: [Function: paths] }, // Module对象 main: Module { ... }, extensions: { '.js': [Function], '.json': [Function], '.node': [Function] }, cache: { ... } } 我们再来深入一下，其实模块内的 require 函数对象是通过 lib/internal/module.js 文件中的 makeRequireFunction 函数创建的 1234567891011121314151617function makeRequireFunction(mod) { const Module = mod.constructor function require(path) { try { exports.requireDepth += 1 return mod.require(path) } finally { exports.requireDepth -= 1 } } // Enable support to add extra extension types. require.extensions = Module._extensions require.cache = Module._cache return require} 可以发现，在导入模块时，最终还是通过调用 Module 对象的 require() 方法来实现模块导入，在上面代码中，我们可以发现这一行 require.extensions = Module._extensions，在 lib/module.js 文件当中我们可以发现以下的定义 123456789101112131415161718192021// Native extension for .jsModule._extensions['.js'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8') module._compile(internalModule.stripBOM(content), filename)}// Native extension for .jsonModule._extensions['.json'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8') try { module.exports = JSON.parse(internalModule.stripBOM(content)) } catch (err) { err.message = filename + ': ' + err.message throw err }}//Native extension for .nodeModule._extensions['.node'] = function (module, filename) { return process.dlopen(module, path.toNamespacedPath(filename))} 这是 Node.js 针对处理的几种文件类型，这里我们主要看处理 .js 类型文件 12345// Native extension for .jsModule._extensions['.js'] = function (module, filename) { var content = fs.readFileSync(filename, 'utf8') module._compile(internalModule.stripBOM(content), filename)} 可以发现，首先我们会以同步的方式读取对应的文件内容，然后在使用 module._compile() 方法对文件的内容进行编译 123456789Module.prototype._compile = function (content, filename) { // ... // create wrapper function var wrapper = Module.wrap(content) // ...} 在这里，我们主要关注 var wrapper = Module.wrap(content) 这一行，调用 Module 内部的封装函数对模块的原始内容进行封装 12345678Module.wrap = function (script) { return Module.wrapper[0] + script + Module.wrapper[1]}Module.wrapper = [ '(function (exports, require, module, __filename, __dirname) { ', '\\n});'] 看到这里我们就可以明白，原来模块中的原始内容是在这个阶段进行包装的，包装后的格式为 123(function (exports, require, module, __filename, __dirname) { // 模块原始内容}) 这也就解释了之前的模块中的 exports，require，module，__filename 和 __dirname 来自何方 require 函数执行的主要流程是什么？在之前的章节中我们已经了解到了 require 函数执行的主要流程，其实就是模块加载机制，在加载对应模块前，我们首先需要定位文件的路径，文件的定位是通过 Module 内部的 _resolveFilename() 方法来实现，简化版的相关的伪代码描述如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647从 Y 路径的模块 require(X)1. 如果 X 是一个核心模块， a. 返回核心模块 b. 结束2. 如果 X 是以 '/' 开头 a. 设 Y 为文件系统根目录3. 如果 X 是以 './' 或 '/' 或 '../' 开头 a. 加载文件(Y + X) b. 加载目录(Y + X)4. 加载Node模块(X, dirname(Y))5. 抛出 \"未找到\"加载文件(X)1. 如果 X 是一个文件，加载 X 作为 JavaScript 文本，结束2. 如果 X.js 是一个文件，加载 X.js 作为 JavaScript 文本，结束3. 如果 X.json 是一个文件，解析 X.json 成一个 JavaScript 对象，结束4. 如果 X.node 是一个文件，加载 X.node 作为二进制插件，结束加载索引(X)1. 如果 X/index.js 是一个文件，加载 X/index.js 作为 JavaScript 文本，结束3. 如果 X/index.json 是一个文件，解析 X/index.json 成一个 JavaScript 对象，结束4. 如果 X/index.node 是一个文件，加载 X/index.node 作为二进制插件，结束加载目录(X)1. 如果 X/package.json 是一个文件， a. 解析 X/package.json，查找 \"main\" 字段 b. let M = X + (json main 字段) c. 加载文件(M) d. 加载索引(M)2. 加载索引(X)加载Node模块(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. 加载文件(DIR/X) b. 加载目录(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS 下面就简单的看一下内部的 Module 对象的 require() 方法 123456789101112// Loads a module at the given file path. Returns that module's// `exports` property.Module.prototype.require = function (id) { if (typeof id !== 'string') { throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'id', 'string', id) } if (id === '') { throw new errors.Error('ERR_INVALID_ARG_VALUE', 'id', id, 'must be a non-empty string') } return Module._load(id, this, /* isMain */ false)} 通过源码可以发现，其本质上是调用了 Module._load() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243// Check the cache for the requested file.// 1. If a module already exists in the cache: return its exports object.// 2. If the module is native: call `NativeModule.require()` with the// filename and return the result.// 3. Otherwise, create a new module for the file and save it to the cache.// Then have it load the file contents before returning its exports// object.Module._load = function (request, parent, isMain) { // 解析文件的具体路径 var filename = Module._resolveFilename(request, parent, isMain) // 优先从缓存中获取 var cachedModule = Module._cache[filename] if (cachedModule) { updateChildren(parent, cachedModule, true) // 导出模块的 exports 属性 return cachedModule.exports } // 判断是否为 native module，如 fs、http 等 if (NativeModule.nonInternalExists(filename)) { debug('load native module %s', request) return NativeModule.require(filename) } // Don't call updateChildren(), Module constructor already does. // 创建新的模块对象 var module = new Module(filename, parent) if (isMain) { process.mainModule = module module.id = '.' } // 缓存新建的模块 Module._cache[filename] = module // 尝试进行模块加载 tryModuleLoad(module, filename) return module.exports} 可以发现，与我们之前的模块加载机制是完全类似的，这里存在一个小问题，模块首次被加载后，会被缓存在 Module._cache 属性中，但有些时候，我们修改了已被缓存的模块，希望其它模块导入时，获取到更新后的内容的话该怎么处理呢？针对这种情况，我们可以使用以下方法清除指定缓存的模块，或清理所有已缓存的模块 1234567// 删除指定模块的缓存delete require.cache[require.resolve('/* 被缓存的模块名称 */')]// 删除所有模块的缓存Object.keys(require.cache).forEach(function (key) { delete require.cache[key]}) Node.js 模块与前端模块的异同通常有一些模块可以同时适用于前后端，但是在浏览器端通过 script 标签的载入 JavaScript 文件的方式与 Node.js 不同，Node.js 在载入到最终的执行中，进行了包装，使得每个文件中的变量天然的形成在一个闭包之中，不会污染全局变量，而浏览器端则通常是裸露的 JavaScript 代码片段，所以为了解决前后端一致性的问题，类库开发者需要将类库代码包装在一个闭包内，比如 underscore 的定义方式 1234567891011121314151617181920(function () { // Establish the root object, `window` in the browser, or `global` on the server. var root = this var _ = function (obj) { return new wrapper(obj) } if (typeof exports !== 'undefined') { if (typeof module !== 'undefined' &amp;&amp; module.exports) { exports = module.exports = _ } exports._ = _ } else if (typeof define === 'function' &amp;&amp; define.amd) { // Register as a named module with AMD. define('underscore', function () { return _ }) } else { root['_'] = _ }}).call(this) 首先，它通过 function 定义构建了一个闭包，将 this 作为上下文对象直接 call 调用，以避免内部变量污染到全局作用域，续而通过判断 exports 是否存在来决定将局部变量 _ 绑定给 exports，并且根据 define 变量是否存在，作为处理在实现了 AMD 规范环境 下的使用案例 仅只当处于浏览器的环境中的时候，this 指向的是全局对象（window 对象），才将 _ 变量赋在全局对象上，作为一个全局对象的方法导出，以供外部调用，所以在设计前后端通用的 JavaScript 类库时，都有着以下类似的判断 12345if (typeof exports !== 'undefined') { exports.EventProxy = EventProxy} else { this.EventProxy = EventProxy} 即，如果 exports 对象存在，则将局部变量挂载在 exports 对象上，如果不存在，则挂载在全局对象上 Node.js 中的 VM 模块是做什么用的？VM 模块提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码，JavaScript 代码可以被编译并立即运行，或编译、保存然后再运行 vm.runInThisContext(code[, options])vm.runInThisContext() 在当前的 global 对象的上下文中编译并执行 code，最后返回结果，运行中的代码无法获取本地作用域，但可以获取当前的 global 对象 12345678910111213const vm = require('vm')let localVar = 'initial value'const vmResult = vm.runInThisContext('localVar = \"vm\";')console.log('vmResult:', vmResult)console.log('localVar:', localVar)const evalResult = eval('localVar = \"eval\";')console.log('evalResult:', evalResult)console.log('localVar:', localVar)// vmResult: 'vm', localVar: 'initial value'// evalResult: 'eval', localVar: 'eval' 正因 vm.runInThisContext() 无法获取本地作用域，故 localVar 的值不变，相反 eval() 确实能获取本地作用域，所以 localVar 的值被改变了 参考 CommonJS JavaSript 模块规范 - AMD 规范与 CMD 规范介绍 结合源码分析 Node.js 模块加载与运行原理 modules node模块化之require学习 Node.js介绍 - 模块化 exports、module.exports 和 export、export default 到底是咋回事 Node.js 的 VM 模块","link":"/2019/09/28/Node/08/"},{"title":"Node.js 中的 HTTP 模块","text":"HTTP 模块是 Node.js 中非常重要的一个核心模块，通过 HTTP 模块，可以使用其 http.createServer() 方法创建一个 HTTP 服务器，也可以使用其 http.request() 方法创建一个 HTTP 客户端，Node.js 对 HTTP 协议及相关 API 的封装比较底层，其仅能处理流和消息，对于消息的处理，也仅解析成『报文头』和『报文体』，但是不解析实际的报文头和报文体内容，这样不仅解决了 HTTP 原本比较难用的特性，也可以支持更多的 HTTP 应用 本文内容主要分为两部分『客户端』与『服务端』，我们下面就一个一个来进行了解 服务端实现 HTTP 服务端功能，要通过 http.createServer() 方法创建一个服务端对象 http.Server，这个方法接收一个可选传入参数 requestListener，该参数是一个函数，传入后将做为 http.Server 的 request 事件监听，不传入时，则需要通过在 http.Server 对象的 request 事件中单独添加，下面是两种创建 http.Server 对象及添加 request 事件监听器的示例 1234567891011121314var http = require('http')// 创建 server 对象，并添加 request 事件监听器var server = http.createServer(function (req, res) { res.writeHeader(200, { 'Content-Type': 'text/plain' }) res.end('baidu.com')})// 创建 server 对象，通过 server 对象的 request 事件添加事件事件监听器var server = new http.Server()server.on('request', function (req, res) { res.writeHeader(200, { 'Content-Type': 'text/plain' }) res.end('baidu.com')}) http.serverhttp.server 是一个基于事件的 HTTP 服务器，所有的请求都被封装到独立的事件当中，我们只需要对事件编写相应的函数就可以实现 HTTP 服务器的所有功能，它继承自 EventEmitter，提供了以下的事件 request，当客户端请求到来的时候触发该事件，提供两个参数 request 和 response，分别是 http.ServerRequest 和 http.ServerResponse，表示请求和响应的信息 connection，当 TCP 建立连接的时候触发该事件，提供了一个参数 socket，为 net.socket 的实例（底层协议对象） close，当服务器关闭的时候会被触发 除此之外还有 checkContinue、upgrade、clientError 等事件，一般比较常见的还是 request 事件，所以官方也提供了一个更为简便的创建方式 http.createServer([requestListener])，就如上面示例当中的一样 request &amp;&amp; responserequest 代表着请求信息，比如我们请求的 url 地址为 http://localhost:8080/index.html?name=123，则服务器接收到的信息如下 1234567let server = http.createServer((req, res) =&gt; { let { pathname, query } = url.parse(req.url, true) console.log(pathname) // index.html console.log(query) // { name: 123 } console.log(req.url) // /index.html?name=123 console.log(req.headers) // 获取请求头}) response 代表着响应信息 123456789let server = http.createServer((req, res) =&gt; { res.setHeader('Content-Type', 'text/html;charset=utf8') // 一旦调用会立刻向客户端发送 res.writeHead(200, { 'Content-Type': 'text/html;charset=utf8' }) res.statusCode = 400 res.end()}) 客户端HTTP 模块不仅可以做为 HTTP 服务器使用，也适用于客户端，HTTP 模块提供了创建 HTTP 客户端对象的方法，使用客户端对象可以创建对 HTTP 服务的访问，http.request() 方法用于创建 HTTP 请求，该方法会返回一个 http.ClientRequest 对象， 是 http.createClient() 方法的替代方法 请求创建后并不会立即发送请求，我们还可以继续访问和设置请求头，比如使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) 等 API 进行修改，实际的请求头会与第一个数据块一起发送或当调用 request.end() 时发送 http.ClientRequesthttp.ClientRequest 对象由 http.request() 创建并返回，它是一个正在处理的 HTTP 请求，其头部已经在队列中，Header 将会随着第一个数据块发送，或在连接关闭时发送 http.ClientRequest 实现了 Writable Stream 接口，其对于向服务器发送数据，本质上是对这个可写流的操作，它还是一个 EventEmitter，包含 response、socket、upgrade、continue 等事件 http.Agenthttp.Agent 是会把套接字做成资源池，用于 HTTP 客户端请求，当需要自定义一些自定义的代理参数（如主机的套接字并发数、套接字发送 TCP KeepAlive 包的频率等）时可以设置此对象，该对象由构造函数 new Agent([options]) 创建返回 更多详细内容可以参考官方文档 new Agent([options]) http.globalAgentAgent 的全局实例，是 HTTP 客户端的默认请求代理对象，其结构类似如下 123456789101112131415{ domain: null, _events: { free: [Function] }, _maxListeners: undefined, defaultPort: 80, protocol: 'http:', options: { path: null }, requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256 } GET 请求123456789101112131415161718192021222324const http = require('http')const options = { host: 'localhost', port: 8080, method: 'get', path: '/post'}let req = http.request(options)// 当服务器把请求体发回来的时候，或者说客户端接受到响应的时候req.on('response', (res) =&gt; { let result = [] res.on('data', (data) =&gt; { result.push(data) }) res.on('end', () =&gt; { let str = Buffer.concat(result) console.log(str.toString()) })})// 只有调用 end() 才会真正向服务器发请求req.end() 对应服务端代码如下 1234567891011121314const express = require('express')const app = express()const bodyParser = require('body-parser')// 处理 JSON 的请求体app.use(bodyParser.json())// GET 请求的内容是存储在 req.body 当中app.get('/post', (req, res, next) =&gt; { // console.log(req.body) res.send('123')})app.listen(8080) POST 请求12345678910111213141516171819202122232425262728293031let http = require('http')let options = { host: 'localhost', port: 8080, method: 'POST', path: '/post', headers: { 'Content-Type': 'application/json' }}// 需要注意，此时请求并没发出let req = http.request(options)// 当服务器把请求体发回来的时候，或者说客户端接受到响应的时候req.on('response', (res) =&gt; { let result = [] res.on('data', (data) =&gt; { result.push(data) }) res.on('end', (data) =&gt; { let str = Buffer.concat(result) console.log(str.toString()) })})// 向请求体写数据req.write('{\"name\": \"zhangsan\"}')// 是结束写入请求体，只有调用 end() 才会真正向服务器发请求req.end() 对应服务端代码如下 12345678910111213const express = require('express')const app = express()const bodyParser = require('body-parser')// 针对 POST 请求，因为内容是一个 chunk 数据流累计的结果，所以采用 bodyParser 来进行处理app.use(bodyParser.json())app.post('/post', (req, res, next) =&gt; { // console.log(req.body) res.send('123')})app.listen(8080) 请求与响应过程先来回顾一下之前的示例，创建一个基本的服务器 12345const http = require('http')http.createServer((req, res) =&gt; { res.end('hello world')}).listen(8080) 使用起来就是这么简单，因为 Node.js 已经把具体实现细节给封装起来了，我们只需要调用 HTTP 模块提供的方法即可，那么，一个请求是如何处理，然后响应的呢？我们先来简单的梳理一下 1234567 _______ | | &lt;== resrequest ==&gt; | ? | |_______| ==&gt; req /\\ || http.createServer() 先调用 http.createServer() 生成一个 http.Server 对象来处理请求 每次收到请求，都先解析生成 req（http.IncomingMessage）和 res（http.ServerResponse），然后交由用户函数处理 用户函数调用 res.end() 来结束处理，响应请求 我们先来看看 http.IncomingMessage 和 http.ServerResponse IncomingMessage在 Node.js 服务器接收到请求时，会利用 http-parser 对象来解析请求报文，为了便于开发者使用，Node.js 会基于解析后的请求报文创建 IncomingMessage 对象，IncomingMessage 构造函数（代码片段）如下 1234567891011121314151617function IncomingMessage(socket) { Stream.Readable.call(this) this.socket = socket this.connection = socket this.httpVersion = null this.complete = false this.headers = {} // 解析后的请求头 this.rawHeaders = [] // 原始的头部信息 // request (server) only this.url = '' // 请求 url 地址 this.method = null // 请求地址}util.inherits(IncomingMessage, Stream.Readable) HTTP 协议是基于请求和响应，请求对象我们已经介绍了，那么接下来就是响应对象，在 Node.js 中，响应对象是 ServerResponse 类的实例 ServerResponse12345678910111213141516function ServerResponse(req) { OutgoingMessage.call(this) if (req.method === 'HEAD') this._hasBody = false this.sendDate = true this._sent100 = false this._expect_continue = false if (req.httpVersionMajor &lt; 1 || req.httpVersionMinor &lt; 1) { this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te) this.shouldKeepAlive = false }}util.inherits(ServerResponse, OutgoingMessage) 通过以上代码，我们可以发现 ServerResponse 继承于 OutgoingMessage，在 OutgoingMessage 对象中会包含用于生成响应报文的相关信息，下面就让我们正式开始探寻 http.createServer() 方法的内部原理 http.createServerhttp.createServer 的实现如下 123456789101112131415161718// lib/http.jsfunction createServer(requestListener) { return new Server(requestListener)}// lib/_http_server.jsfunction Server(requestListener) { if (!(this instanceof Server)) return new Server(requestListener) net.Server.call(this, { allowHalfOpen: true }) if (requestListener) { this.on('request', requestListener) } this.on('connection', connectionListener) // ...} http.createServer() 函数返回一个 http.Server 实例，该实例监听了 request 和 connection 两个事件 request 事件绑定 requestListener() 函数，req 和 res 准备好时触发 connection 事件绑定 connectionListener() 函数，连接时触发 用户函数是 requestListener()，也就是说，在触发 request 事件后，就会调用我们设置的 requestListener 函数，如下 123(req, res) =&gt; { res.end('hello world')} connectionListenerInternalconnection 事件，顾名思义用来跟踪网络连接，因此我们需要知道 request 事件何时触发 12345678910111213141516171819202122232425262728293031function connectionListener(socket) { defaultTriggerAsyncIdScope( getOrSetAsyncId(socket), connectionListenerInternal, this, socket )}function connectionListenerInternal(server, socket) { httpSocketSetup(socket) if (socket.server === null) socket.server = server if (server.timeout &amp;&amp; typeof socket.setTimeout === 'function') socket.setTimeout(server.timeout) // 处理超时情况 socket.on('timeout', socketOnTimeout) // 获取 parser 对象（见下方） var parser = parsers.alloc() parser.reinitialize(HTTPParser.REQUEST) parser.socket = socket socket.parser = parser parser.incoming = null var state = { outgoing: [], incoming: [], //... } parser.onIncoming = parserOnIncoming.bind(undefined, server, socket, state)} 在 connectionListenerInternal 函数内部可以发现有一个 parser 对象，parser 对象是由一个叫做 FreeList 的数据结构实现，其主要目的是复用 parser，通过调用 parsers.alloc() 和 parsers.free(parser) 来获取释放 parser，下面就先来看看 FreeList 这个对象 FreeList在 Node.js 中为了避免频繁创建和销毁对象，有一个通用的 FreeList 机制，在 HTTP 模块中，就利用到了 FreeList 机制，即用来动态管理 http-parser 对象 1234var parsers = new FreeList('parsers', 1000, function () { var parser = new HTTPParser(HTTPParser.REQUEST) //...} 具体实现如下 12345678910111213141516171819202122class FreeList { constructor(name, max, ctor) { this.name = name // 管理的对象名称 this.ctor = ctor // 管理对象的构造函数 this.max = max // 存储对象的最大值 this.list = [] // 存储对象的数组 } alloc() { return this.list.length ? this.list.pop() : this.ctor.apply(this, arguments) } free(obj) { if (this.list.length &lt; this.max) { this.list.push(obj) return true } return false }} 在处理 HTTP 请求的场景下，当新的请求到来时，我们通过调用 parsers.alloc() 方法来获取 http-parser 对象，从而解析 HTTP 请求，当完成 HTTP 解析任务后，我们可以通过调用 parsers.free() 方法来归还 http-parser 对象 parserOnIncoming既然，HTTP 报文是由 parser 来解析的，那么就让我们来看看 parser 是如何创建的吧 1234567891011121314151617var parsers = new FreeList('parsers', 1000, function () { var parser = new HTTPParser(HTTPParser.REQUEST) parser._headers = [] parser._url = '' parser._consumed = false parser.socket = null parser.incoming = null parser.outgoing = null parser[kOnHeaders] = parserOnHeaders parser[kOnHeadersComplete] = parserOnHeadersComplete parser[kOnBody] = parserOnBody return parser}) 在上面以 parser 开头的这些对象，都是定义在 _http_common.js 文件中的函数对象，让我们来简单的梳理一下 parserOnHeaders，当请求头跨多个 TCP 数据包或者过大无法再一个运行周期内处理完才会调用该方法 kOnHeadersComplete，请求头解析完成后，会调用该方法，方法内部会创建 IncomingMessage 对象，填充相关的属性，比如 url、httpVersion、method和 headers 等 parserOnBody，不断解析已接收的请求体数据 这里需要注意的是，请求报文的解析工作是由 C++ 来完成，内部通过 binding 来实现，具体可以参考 deps/http_parser 目录 1const { methods, HTTPParser } = process.binding('http_parser') 在 connectionListenerInternal 函数中，在最后一行设置了 parser 对象的 onIncoming 属性为绑定后的 parserOnIncoming 函数 1234567891011121314151617181920212223242526272829303132333435363738394041function parserOnIncoming(server, socket, state, req, keepAlive) { // 缓冲 IncomingMessage 实例 state.incoming.push(req) var res = new server[kServerResponse](req) if (socket._httpMessage) { // 缓冲 ServerResponse 实例 state.outgoing.push(res) } else { res.assignSocket(socket) } // 判断请求头是否包含 expect 字段且 http 协议的版本为 1.1 if (req.headers.expect !== undefined &amp;&amp; (req.httpVersionMajor === 1 &amp;&amp; req.httpVersionMinor === 1)) { // continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i // Expect: 100-continue if (continueExpression.test(req.headers.expect)) { res._expect_continue = true if (server.listenerCount('checkContinue') &gt; 0) { server.emit('checkContinue', req, res) } else { res.writeContinue() server.emit('request', req, res) } } else if (server.listenerCount('checkExpectation') &gt; 0) { server.emit('checkExpectation', req, res) } else { // http 协议中的 417 Expectation Failed 状态码表示客户端错误 // 意味着服务器无法满足 Expect 请求消息头中的期望条件 res.writeHead(417) res.end() } } else { server.emit('request', req, res) } return 0} 通过观察上面的代码，我们终于发现了 request 事件的踪迹，在 parserOnIncoming 函数内，我们会基于 req 请求对象创建 ServerResponse 响应对象，在创建响应对象后，会判断请求头是否包含 expect 字段，然后针对不同的条件做出不同的处理，对于之前最早的示例来说，程序会直接走 else 分支，即触发 request 事件，并传递当前的请求对象和响应对象 最后我们来回顾一下整个流程 调用 http.createServer() 方法创建 server 对象，该对象创建完后，我们调用 listen() 方法执行监听操作 当 server 接收到客户端的连接请求，在成功创建 socket 对象后，会触发 connection 事件 当 connection 事件触发后，会执行对应的 connectionListener 回调函数，在函数内部会利用 http-parser 对象，对请求报文进行解析 在完成请求头的解析后，会创建 IncomingMessage 对象，并填充相关的属性，比如 url、httpVersion、method 和 headers 等 在配置完 IncomingMessage 对象后，会调用 parserOnIncoming 函数，在该函数内会构建 ServerResponse 响应对象，如果请求头不包含 expect 字段，则 server 就会触发 request 事件，并传递当前的请求对象和响应对象 request 事件触发后，就会执行我们设定的 requestListener 函数 参考 http http 模块 http.ClientRequest Node.js 源码 http server http 请求响应过程","link":"/2019/10/02/Node/09/"},{"title":"常用中间件的实现","text":"在 上一章 当中，我们简单的介绍了中间件的基本概念，以及洋葱模型，在最后我们也手动实现了一个简单的 compose() 方法，所以本章当中我们就主要手动的来实现一个最基本的 Koa.js 框架以及 Koa.js 当中一些比较常用的中间件的简单实现，比如 koa-logger 和 koa-static 等 文中所有的示例源码均可见 koa2-example ctx在实现基本的框架之前，我们先来看看 Koa.js 当中的 ctx 这个对象，一般我们使用的话是这么用的 123app.use(async (ctx, next) =&gt; { ctx.body = 'hello world'}) 上面示例当中的 ctx，其实就是 Context，大多数人称之为上下文对象，这个对象下有四个主要的属性，它们分别是 ctx.req，原生的 req 对象 ctx.res，原生的 res 对象 ctx.request，Koa.js 自己封装的 request 对象 ctx.response，Koa.js 自己封装的 response 对象 其中 Koa.js 自己封装的和原生的最大的区别在于 Koa.js 自己封装的请求和响应对象的内容不仅囊括原生的还添加了一些额外的东西，除此之外，ctx 本身还代理了 ctx.request 和 ctx.response 身上的属性，比如下面的示例 12345// 如果是在原生当中，则是需要经过 url.parse(p, true).query 才能得到的 query 对象console.log(ctx.query)// 如果是在原生当中，则是需要经过 url.parse(p).pathname 才能得到的路径（url 去除 query 部分）console.log(ctx.path) 框架的实现我们先来简单的总结一下 Koa.js 的一些基本特点 有一个可以注册使用中间件的 use() 方法 还有一个服务事件监听事件 listen() 方法，并且可以接收回调函数 我们先来使用最简单的回调方法来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const http = require('http')const Emitter = require('events')class WebServer extends Emitter { constructor() { super() this.middleware = [] this.context = Object.create(null) } // 服务事件监听 listen(...args) { const server = http.createServer(this.callback()) return server.listen(...args) } // 注册使用中间件 use(fn) { if (typeof fn === 'function') { this.middleware.push(fn) } } // 回调方法 callback() { let that = this if (this.listeners('error').length === 0) { this.on('error', this.onerror) } const henadleRequest = (req, res) =&gt; { let context = that.createContext(req, res) this.middleware.forEach((cb, idx) =&gt; { try { cb(context) } catch (err) { that.onerror(err) } if (idx + 1 &gt;= this.middleware.length) { if (res &amp;&amp; typeof res.end === 'function') { res.end() } } }) } return henadleRequest } // 异常监听处理 onerror(err) { console.log(err) } // 创建通用上下文 createContext(req, res) { let content = Object.create(this.context) content.req = req content.res = res return content }}module.exports = WebServer 然后来稍微的测试一下我们上面定义的服务 123456789101112131415161718const WebServer = require('./index')const app = new WebServer()app.use(ctx =&gt; { ctx.res.write('hello world 1 \\n')})app.use(ctx =&gt; { ctx.res.write('hello world 2 \\n')})app.use(ctx =&gt; { ctx.res.write('hello world 3 \\n')})app.listen(3000, _ =&gt; { console.log(`app is running at port 3000`)}) 发现是可以正常使用的，但是这里面有一个问题，就是我们在处理中间件队列的时候，底层使用的是回调嵌套去处理的，但是中间件越多，回调嵌套越深，代码的可读性和可扩展性就很差，所以我们就可以考虑将我们的 handleRequest 方法调整为 async/await 方式，所以在这种情况下，我们就可以使用我们之前已经定义过的 compose() 方法，如下 12345678const handleRequest = (req, res) =&gt; { let context = this.createContext(req, res) let middleware = this.middleware // 执行中间件 compose(middleware)(context).catch(err =&gt; this.onerror(err))}return handleRequest 下面是整合后的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const http = require('http')const Emitter = require('events')const compose = require('./compose')// 通用上下文const context = { _body: null, get body() { return this._body }, set body(val) { this._body = val this.res.end(this._body) }}class SimpleKoa extends Emitter { constructor() { super() this.middleware = [] this.context = Object.create(context) } // 服务事件监听 listen(...args) { const server = http.createServer(this.callback()) return server.listen(...args) } // 注册使用中间件 use(fn) { if (typeof fn === 'function') { this.middleware.push(fn) } } // 中间件总回调方法 callback() { if (this.listeners('error').length === 0) { this.on('error', this.onerror) } const handleRequest = (req, res) =&gt; { let context = this.createContext(req, res) let middleware = this.middleware // 执行中间件 compose(middleware)(context).catch(err =&gt; this.onerror(err)) } return handleRequest } // 异常处理监听 onerror(err) { console.log(err) } // 创建通用上下文 createContext(req, res) { let context = Object.create(this.context) context.req = req context.res = res return context }}module.exports = SimpleKoa 测试一下 1234567891011const SimpleKoa = require('./index')const app = new SimpleKoa()app.use(async ctx =&gt; { ctx.body = '&lt;p&gt;SimpleKoa&lt;/p&gt;'})app.listen(3000, () =&gt; { console.log(`app is running at port 3000`)}) 发现是可以正常使用的，下面我们再来看看 Koa.js 当中的一些比较常用的中间件的实现 koa-logger我们先来看一个比较简单的 koa-logger 的实现，我们这里只实现简单的拦截请求，打印请求的 url，以及操作响应并且打印出响应的 url，通过实现可以发现，这里就用到了我们之前提到过的洋葱模型 123456789101112131415const logger = async (ctx, next) =&gt; { let res = ctx.res // 拦截操作请求 request console.log(`&lt;== 请求的方式和地址为 ${ctx.method} ${ctx.url}`) await next() // 拦截操作响应 request res.on('finish', _ =&gt; { console.log(`==&gt; 响应的方式和地址为 ${ctx.method} ${ctx.url}`) })}module.exports = logger 直接引入使用即可 1234567891011const Koa = require('koa')const logger = require('./log')const app = new Koa()app.use(logger)app.use(async (ctx, next) =&gt; { ctx.body = `hello world`})app.listen(3000) koa-send主要参考的是官方的 koajs/send，主要流程如下 拦截请求，判断该请求是否请求本地静态资源文件 操作响应，返回对应的静态文件文本内容或出错提示 简单的梳理一下，可以分为以下几个步骤 配置静态资源绝对目录地址 判断是否支持隐藏文件 获取文件或者目录信息 判断是否需要压缩 设置 HTTP 头信息 静态文件读取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const fs = require('fs')const path = require('path')const { basename, extname} = pathconst defaultOpts = { root: '', maxage: 0, immutable: false, extensions: false, hidden: false, brotli: false, gzip: false, setHeaders: () =&gt; { }}async function send(ctx, urlPath, opts = defaultOpts) { const { root, hidden, immutable, maxage, brotli, gzip, setHeaders } = opts let filePath = urlPath // 配置静态资源绝对目录地址 try { filePath = decodeURIComponent(filePath) if (/[\\.]{2,}/ig.test(filePath)) { ctx.throw(403, 'Forbidden') } } catch (err) { ctx.throw(400, 'failed to decode') } filePath = path.join(root, urlPath) const fileBasename = basename(filePath) // 判断是否支持隐藏文件 if (hidden !== true &amp;&amp; fileBasename.startsWith('.')) { ctx.throw(404, '404 Not Found') return } // 获取文件或者目录信息 let stats try { stats = fs.statSync(filePath) if (stats.isDirectory()) { ctx.throw(404, '404 Not Found') } } catch (err) { const notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'] if (notfound.includes(err.code)) { ctx.throw(404, '404 Not Found') return } err.status = 500 throw err } let encodingExt = '' // 判断是否需要压缩 if (ctx.acceptsEncodings('br', 'identity') === 'br' &amp;&amp; brotli &amp;&amp; (fs.existsSync(filePath + '.br'))) { filePath = filePath + '.br' ctx.set('Content-Encoding', 'br') ctx.res.removeHeader('Content-Length') encodingExt = '.br' } else if (ctx.acceptsEncodings('gzip', 'identity') === 'gzip' &amp;&amp; gzip &amp;&amp; (fs.existsSync(filePath + '.gz'))) { filePath = filePath + '.gz' ctx.set('Content-Encoding', 'gzip') ctx.res.removeHeader('Content-Length') encodingExt = '.gz' } // 设置 http 头信息 if (typeof setHeaders === 'function') { setHeaders(ctx.res, filePath, stats) } ctx.set('Content-Length', stats.size) if (!ctx.response.get('Last-Modified')) { ctx.set('Last-Modified', stats.mtime.toUTCString()) } if (!ctx.response.get('Cache-Control')) { const directives = ['max-age=' + (maxage / 1000 | 0)] if (immutable) { directives.push('immutable') } ctx.set('Cache-Control', directives.join(',')) } const ctxType = encodingExt !== '' ? extname(basename(filePath, encodingExt)) : extname(filePath) ctx.type = ctxType // 静态文件读取 ctx.body = fs.createReadStream(filePath)}module.exports = send 使用如下 123456789const send = require('./send')const Koa = require('koa')const app = new Koa()app.use(async ctx =&gt; { await send(ctx, ctx.path, { root: `${__dirname}/public` })})app.listen(3000) koa-static之前我们简单的介绍了 koa-send 这个中间件，但是这个中间件平常使用的较少，因为 Koa.js 官方对 koa-send 进行了二次封装，推出了我们所熟知的 koa-static 中间件，目标是用于做静态服务器或者项目静态资源管理，当然，还是主要依赖我们之前已经实现的 koa-send 这个中间件，因为需要它的静态文件读取过程，我们先来简单的梳理一下实现流程 配置静态资源绝对目录地址 判断是否支持等待其他请求 判断是否为 GET 和 HEAD 类型的请求 通过 koa-send 中间件读取和返回静态文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// static.jsconst { resolve } = require('path')const send = require('./send')function statics(opts = { root: '' }) { opts.root = resolve(opts.root) // 是否需要等待其他请求 if (opts.defer !== true) { // 如果需要等待其他请求 return async function statics(ctx, next) { let done = false if (ctx.method === 'HEAD' || ctx.method === 'GET') { try { await send(ctx, ctx.path, opts) done = true } catch (err) { if (err.status !== 404) { throw err } } } if (!done) await next() } } else { // 如果不需要等待其他请求 return async function statics(ctx, next) { await next() if (ctx.method !== 'HEAD' &amp;&amp; ctx.method !== 'GET') { return } if (ctx.body != null || ctx.status !== 404) { return } try { await send(ctx, ctx.path, opts) } catch (err) { if (err.status !== 404) { throw err } } } }}module.exports = statics 使用如下 12345678910const path = require('path')const Koa = require('koa')const statics = require('./static')const app = new Koa()const root = path.join(__dirname, './public')app.use(statics({ root }))app.listen(3000) koa-view这一个中间件，在官方当中比较有代表性的是 koa-ejs 中间件，它实现了代理上下文（Context），即把渲染的方法挂载在 Koa 实例 App 的 app.context 属性中，所以这里我们就简单的实现一个模版渲染中间件来模仿 koa-ejs 的基本能力，老规矩，简单的梳理一下实现流程 初始化一个 Koa 实例（let app = new Koa()） 将需要的属性或者方法 view 挂载在 app.context 上（app.context.view） 在 app.use() 中间件直接使用 ctx.view 方法或属性渲染模板 123456789101112131415161718192021// view.jsconst path = require('path')const fs = require('fs')function view(app, opts = {}) { const { baseDir = '' } = opts // 将需要的属性或者方法挂载在 app.context 上 app.context.view = function (page = '', obj = {}) { let ctx = this let filePath = path.join(baseDir, page) if (fs.existsSync(filePath)) { let tpl = fs.readFileSync(filePath, 'binary') ctx.body = tpl } else { ctx.throw(404) } }}module.exports = view 然后我们来使用一下，目录结构如下 123456.├── view.js├── index.js└── views ├── hello.html └── index.html index.js 如下 12345678910111213141516171819202122232425const Koa = require('koa')const path = require('path')const view = require('./view')// 初始化一个 Koa 实例const app = new Koa()// 将需要的属性或者方法挂载在 app.context 上view(app, { baseDir: path.join(__dirname, 'views')})app.use(async ctx =&gt; { await ctx.view(`${ctx.path}.html`, { title: 'index page' })})app.use(async ctx =&gt; { await ctx.view(`${ctx.path}.html`, { title: 'index page' })})app.listen(3000) 直接运行，然后在浏览器当中访问对应的路由即可（/hello 和 /index） koa-jsonp下面来看一个跟我们之前实现的 koa-view 非常类似的一个示例，本质上原理是一致的，就是首先初始化一个 Koa 实例，将需要的属性或者方法 jsonp 挂载在 app.context 上，当前请求响应要返回 jsonp 数据时候设置 ctx.body = ctx.jsonp(result) 123456789101112131415161718192021// jsonp.jsfunction jsonp(app, opts = {}) { let callback = opts.callback || 'callback' app.context.jsonp = function (obj = {}) { let ctx = this if (Object.prototype.toString.call(obj).toLowerCase() === '[object object]') { let jsonpStr = `;${callback}(${JSON.stringify(obj)})` // 用 text/javascript 让请求支持跨域获取 ctx.type = 'text/javascript' // 输出 jsonp 字符串 ctx.body = jsonpStr } else { ctx.throw(500, 'result most be a json') } }}module.exports = jsonp 然后我们来测试一下 1234567891011121314const Koa = require('koa')const jsonp = require('./jsonp')const app = new Koa()jsonp(app, {})app.use(async ctx =&gt; { await ctx.jsonp({ data: 'this is jsonp test', success: true })})app.listen(3000) 可以发现，访问 3000 端口的时候可以看到我们返回的 callback koa-bodyparser本节主要参考的是官方 koajs/bodyparser，如果有使用过 bodyparser 这个中间件，就会了解到 bodyparser 中间件的主要作用就是 拦截 POST 请求，然后等待解析表单信息，最后把表单信息代理到 ctx.request.body 上 这样一来，在后面的中间件当中都可以使用 ctx.request.body 来获取表单当中的数据，下面我们就来看看是如何实现的，我们先来看看如何来解析请求体当中的数据流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function readStream(req) { return new Promise((resolve, reject) =&gt; { try { streamEventListen(req, (data, err) =&gt; { if (data &amp;&amp; !isError(err)) { resolve(data) } else { reject(err) } }) } catch (err) { reject(err) } })}function isError(err) { return Object.prototype.toString.call(err).toLowerCase() === '[object error]'}function streamEventListen(req, callback) { let stream = req.req || req let chunk = [] let complete = false // attach listeners stream.on('aborted', onAborted) stream.on('close', cleanup) stream.on('data', onData) stream.on('end', onEnd) stream.on('error', onEnd) function onAborted() { if (complete) { return } callback(null, new Error('request body parse aborted')) } function cleanup() { stream.removeListener('aborted', onAborted) stream.removeListener('data', onData) stream.removeListener('end', onEnd) stream.removeListener('error', onEnd) stream.removeListener('close', cleanup) } function onData(data) { if (complete) { return } if (data) { chunk.push(data.toString()) } } function onEnd(err) { if (complete) { return } if (isError(err)) { callback(null, err) return } complete = true let result = chunk.join('') chunk = [] callback(result, null) }}module.exports = readStream 然后再来实现我们的 bodyparser 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const readStream = require('./readStream')let strictJSONReg = /^[\\x20\\x09\\x0a\\x0d]*(\\[|\\{)/let jsonTypes = [ 'application/json']let formTypes = [ 'application/x-www-form-urlencoded']let textTypes = [ 'text/plain']function parseQueryStr(queryStr) { let queryData = {} let queryStrList = queryStr.split('&amp;') for (let [index, queryStr] of queryStrList.entries()) { let itemList = queryStr.split('=') queryData[itemList[0]] = decodeURIComponent(itemList[1]) } return queryData}function bodyParser(opts = {}) { return async function (ctx, next) { // 拦截 POST 请求 if (!ctx.request.body &amp;&amp; ctx.method === 'POST') { // 解析请求体中的表单信息 let body = await readStream(ctx.request.req) let result = body if (ctx.request.is(formTypes)) { result = parseQueryStr(body) } else if (ctx.request.is(jsonTypes)) { if (strictJSONReg.test(body)) { try { result = JSON.parse(body) } catch (err) { ctx.throw(500, err) } } } else if (ctx.request.is(textTypes)) { result = body } // 将请求体中的信息挂载到上下文的 request 属性中 ctx.request.body = result } await next() }}module.exports = bodyParser 下面我们建立个表单来测试一下，如下 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;form post demo&lt;/p&gt; &lt;form method=\"POST\" action=\"/post\"&gt; &lt;span&gt;data&lt;/span&gt; &lt;input name=\"userName\" type=\"text\"&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324const Koa = require('koa')const fs = require('fs')const path = require('path')const body = require('./bodyparser')const app = new Koa()app.use(body())app.use(async (ctx, next) =&gt; { if (ctx.url === '/') { // 当 GET 请求时候返回表单页面 let html = fs.readFileSync(path.join(__dirname, './index.html'), 'binary') ctx.body = html } else if (ctx.url === '/post' &amp;&amp; ctx.method === 'POST') { // 当 POST 请求的时候，解析 POST 表单里的数据，并显示出来 ctx.body = ctx.request.body } else { ctx.body = '404' } await next()})app.listen(3000) 可以发现，页面可以正常输出 koa-router最后我们来看一个不直接提供中间件，而是通过间接方式提供了中间件，最具代表性的莫过于 koa-router 了，我们先来看下实现步骤 初始化路由实例 注册路由请求信息缓存到实例中 请求类型 请求 path 对应的请求后操作 注册的路由操作就是子中间件 路由实例输出父中间件 返回一个父中间件 中间件里对每次请求进行遍历匹配缓存中注册的路由操作 匹配上请求类型，路径就执行对应路由子中间件 app.use() 路由实例返回的父中间件 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const methods = [ 'GET', 'PUT', 'PATCH', 'POST', 'DELETE']class Layer { constructor(path, methods, middleware, opts) { this.path = path this.methods = methods this.middleware = middleware this.opts = opts }}class Router { constructor(opts = {}) { this.stack = [] } register(path, methods, middleware, opts) { let route = new Layer(path, methods, middleware, opts) this.stack.push(route) return this } routes() { let stock = this.stack return async function (ctx, next) { let currentPath = ctx.path let route for (let i = 0; i &lt; stock.length; i++) { let item = stock[i] if (currentPath === item.path &amp;&amp; item.methods.indexOf(ctx.method) &gt;= 0) { route = item.middleware break } } if (typeof route === 'function') { route(ctx, next) return } await next() } }}methods.forEach(method =&gt; { Router.prototype[method.toLowerCase()] = Router.prototype[method] = function (path, middleware) { this.register(path, [method], middleware) }})module.exports = Router 测试一下 1234567891011121314151617181920const Koa = require('koa')const Router = require('./router')const app = new Koa()// 初始化路由实例const router = new Router()// 注册路由请求信息缓存到实例中router.get('/index', async ctx =&gt; { ctx.body = 'index page' })router.get('/post', async ctx =&gt; { ctx.body = 'post page' })router.get('/list', async ctx =&gt; { ctx.body = 'list page' })router.get('/item', async ctx =&gt; { ctx.body = 'item page' })app.use(router.routes())app.use(async ctx =&gt; { ctx.body = '404'})app.listen(3000) 参考 koajs/send koajs/bodyparser Koa：核心探秘与入坑指北","link":"/2019/10/25/Node/13/"},{"title":"Koa.js 源码解析","text":"在 中间件 和 常用中间件的实现 章节当中，我们简单的介绍了一下中间件和洋葱模型的概念，然后我们手动实现了一个最基本的 Koa.js 框架，最后又看了一些比较常用的中间件，所以在本章当中，我们就来深入的了解一下 Koa.js 的源码，看看它与我们手动实现的版本有什么区别 使用在分析源码之前，我们先来看看如何使用 Koa.js 来创建一个 server 的大体流程 12345678const Koa = require('koa')const app = new Koa()app.use(async ctx =&gt; { ctx.body = 'hello world'})app.listen(3000) 下面是一张来源于网络关于 Koa.js 架构的示意图，我们可以对比着进行了解 入口文件一般我们都是从入口文件开始找起，如果你看了 Koa.js 的源码，会发现 Koa.js 源码其实很简单，一共就四个文件 123456// https://github.com/koajs/koa/tree/master/lib── lib ├── application.js ├── context.js ├── request.js └── response.js 其实这四个文件分别对应着 Koa.js 当中的四个对象 12345── lib ├── application.js ==&gt; new Koa() || ctx.app ├── context.js ==&gt; ctx ├── request.js ==&gt; ctx.req || ctx.request └── response.js ==&gt; ctx.res || ctx.response 对比使用可以发现，其实总的来说就三个步骤 实例化一个对象（new Koa()） 注册一个或多个中间件（app.use(async ctx =&gt; { ... })） 调用 listen() 方法启动一个服务器 下面我们就按照步骤一个一个来了解 构造函数通过查看 package.json 的 main 字段中可以发现 application.js 是入口文件，下面是入口文件的部分源码，只罗列了一些比较核心的内容，详细见 lib/application.js 1234567891011121314151617181920212223242526// 依赖模块，我们主要看下面这几个const response = require('./response')const compose = require('koa-compose')const context = require('./context')const request = require('./request')const Emitter = require('events')const convert = require('koa-convert')// 可以发现 Application 类是继承于 EventEmitter 的// 所以我们在 koa 实例对象上可以使用 on，emit 等方法进行事件监听module.exports = class Application extends Emitter { constructor() { super() // 因为继承于 EventEmitter，这里需要调用 super this.middleware = [] // 该数组存放所有通过 use 函数的引入的中间件函数 // 这两个见下方 this.proxy = false // 代理设置 this.subdomainOffset = 2 // 下面这三个是我们重点需要关注的 // 分别通过 context.js、request.js、response.js 来创建对应的 context、request、response this.context = Object.create(context) this.request = Object.create(request) this.response = Object.create(response) }} 相关内容都已经写在注释当中了，这里我们主要要提及两个属性 subdomainOffsetsubdomainOffset 属性会改变获取 subdomain 时返回数组的值，比如 test.page.example.com 域名，如果设置 subdomainOffset 为 2，那么返回的数组值为 ['page', 'test']，如果设置为 3，那么返回数组值为 ['test'] proxy顾名思义，指的是代理，属性值是 true 或者 false，它的作用在于是否获取真正的客户端 IP 地址，在我们实际运用当中，可能会使用很多的代理服务器，包括我们常见的正向代理与反向代理，虽然代理的用处很大，但是无法避免地我们有时需要知晓真正的客户端的请求 IP 而其实实际上，服务器并不知道真正的客户端请求 IP，即使你使用 socket.remoteAddrss 属性来查看，因为这个请求是代理服务器转发给服务器的，幸好代理服务器例如 nginx 提供了一个 HTTP 头部来记录每次代理服务器的源 IP 地址，也就是 X-Forwarded-For 头部，形式如下 1X-Forwarded-For: client, proxy1, proxy2 如果一个请求跳转了很多代理服务器，那么 X-Forwarded-For 头部的 IP 地址就会越多，第一个就是原始的客户端请求 IP，第二个就是第一个代理服务器 IP，以此类推，当然，X-Forwarded-For 并不完全可信，因为中间的代理服务器可能会更改某些 IP（也有可能直接手动设定），所以 Koa.js 中 proxy 属性的设置就是如果使用 true，那么就是使用 X-Forwarded-For 头部的第一个 IP 地址 如果使用 false，则使用 server 中的 socket.remoteAddress 属性值 除了 X-Forwarded-For 之外，proxy 还会影响 X-Forwarded-proto 的使用，和 X-Forwarded-For 一样，X-Forwarded-proto 记录最开始的请求连接使用的协议类型（http/https），因为客户端与服务端之间可能会存在很多层代理服务器，而代理服务器与服务端之间可能只是使用 HTTP 协议，并没有使用 HTTPS，所以 proxy 属性为 true 的话，Koa.js 的 protocol 属性会去取 X-Forwarded-proto 头部的值 Koa.js 中 protocol 属性会先使用 tlsSocket.encrypted 属性来判断是否是 HTTPS 协议，如果是则直接返回 HTTPS 关于此部分内容想了解更多的可以参考下面两个链接 科普文：如何伪造和获取用户真实 IP ？ egg.js 提供的 前置代理模式 接下来我们再来看注册中间件使用的 use() 方法 注册中间件在实例化一个对象以后，接下来使用 use() 方法来注册一个中间件，其实就是简单的 push 到自身的 mideware 这个数组中 12345678use(fn) { if (isGeneratorFunction(fn)) { // 兼容 koa v1 的 generator 写法 fn = convert(fn) } this.middleware.push(fn) return this} 这其中有一个 convert() 的方法，简单来说就是将 koa v1 当中使用的 generator 函数转换成 koa v2 中的 async 函数，更准确的说是将 generator 函数转换成使用 co 包装成的 Promise 对象，然后执行对应的代码，这里就不详细展开了，详细可以参考这篇博文 koa-convert 源码分析 启动服务最后调用 listen() 方法来启动服务 1234listen(...args) { const server = http.createServer(this.callback()) return server.listen(...args)} 使用了 Node.js 原生的 http.createServer() 来创建服务器，并把 this.callback() 作为参数传递进去，下面我们就来看一下这个核心的 callback() 函数 12345678910111213141516callback() { // 使用 koa-compose 来组合 middleware 的运行方式（可以参考之前我们手动实现的 compose 方法） const fn = compose(this.middleware) if (!this.listenerCount('error')) this.on('error', this.onerror) // 这里的 req, res 两个参数，代表原生的 request, response 对象 const handleRequest = (req, res) =&gt; { // 每次接受一个新的请求就是生成一次全新的 context const ctx = this.createContext(req, res) return this.handleRequest(ctx, fn) } return handleRequest} 这里主要涉及到三个方法 compose(this.middleware)洋葱模型实现的核心 123456789101112131415161718192021222324252627282930313233343536/** * Compose `middleware` returning a fully valid middleware comprised of all those which are passed. * * @param {Array} middleware * @return {Function} */function compose(middleware) { // 参数校验 if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') } /** * @param {Object} context * @return {Promise} */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) function dispatch(i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try { // 执行下一个中间件逻辑，并将 next 参数设置为 dispatch(i + 1) return Promise.resolve(fn(context, dispatch.bind(null, i + 1))) } catch (err) { return Promise.reject(err) } } }} 之前我们已经手动的实现了一个简化版本的了，这里就不详细展开了，可以参考之前的洋葱模型的实现章节，这里主要介绍其中两行代码 12if (i === middleware.length) fn = nextif (!fn) return Promise.resolve() 在我们调用 fnMiddleware 是可以传入两个参数的，第二个可选参数表示最终的回调函数，比如 123fnMiddleware(ctx, () =&gt; { console.log(`done`, ctx)}) 当 i === middleware.length 成立时，实际上所有传入的 middleware 已经执行完，这个时候我们的 fn = next 表示 fn 被赋值给了这个传入的最终回调，接下来判断如果没有传入最终回调，那么整个中间件执行流程就到此结束 createContext(req, res)1234567891011121314createContext(req, res) { const context = Object.create(this.context) const request = context.request = Object.create(this.request) const response = context.response = Object.create(this.response) context.app = request.app = response.app = this context.req = request.req = response.req = req context.res = request.res = response.res = res request.ctx = response.ctx = context request.response = response response.request = request context.originalUrl = request.originalUrl = req.url context.state = {} return context} 根据 req 和 res 封装中间件所需要的 ctx，简单来说就是将变量挂到 Context 上面，然后最后返回，但是这里需要注意区分 request.req、response.req 指向的是 HTTP 模块原生的 IncomingMessage 对象 而 request.response、response.request 指向的都是 Koa.js 封装后的对象 即 ctx.req 和 ctx.res 是原生的 req 和 res 对象 而 ctx.request 和 ctx.response 则是 Koa.js 自己封装的 request 和 response 对象 这里有一个小问题，这里明明只是将原生的 req 和 res 赋值给相应的属性，但是 ctx 上不是暴露出来很多属性吗？它们在哪里？其实这些东西我们可以通过 request.js 和 response.js 的源码来了解，通过源码可以发现，经过原型链的形式，我们 ctx.request 所能访问属性和方法绝大部分都在其对应的 request 这个简单的对象上面 1234567891011121314151617181920212223242526// https://github.com/koajs/koa/blob/master/lib/request.jsmodule.exports = { /** * Return request header. * * @return {Object} * @api public */ get header() { return this.req.headers }, /** * Set request header. * * @api public */ set header(val) { this.req.headers = val }, // ...} 所以当你操作 ctx.request.xx 的时候，其实访问的都是 resquest 这个对象上的属性的赋值器（setter）和取值器（getter） handleRequest(ctx, fnMiddleware)123456789// fnMiddleware 是经过 compose 包装后的函数handleRequest(ctx, fnMiddleware) { const res = ctx.res res.statusCode = 404 const onerror = err =&gt; ctx.onerror(err) const handleResponse = () =&gt; respond(ctx) onFinished(res, onerror) return fnMiddleware(ctx).then(handleResponse).catch(onerror)} 这个函数简单来说只是负责执行中间件所有的函数, 并在中间件函数执行结束的时候调用 respond(ctx)，本质上，在执行 fnMiddleware(ctx) 的时候其实就会调用 compose() 方法当中的那个 dispatch(0)，然后开始不断递归，直到中间件流程执行结束，触发 handleResponse，也就是我们这里的 respond(ctx) 对请求的响应处理 respond对于 respond() 函数, 其核心就是根据不同类型的数据对 HTTP 的响应头部与响应体 body 做对应的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function respond(ctx) { // allow bypassing koa // 用于设置自定义的 response 策略 if (false === ctx.respond) return // writable 是原生的 response 对象的 writeable 属性，检查是否是可写流 if (!ctx.writable) return const res = ctx.res let body = ctx.body const code = ctx.status // ignore body // 如果响应的 statusCode 是属于 body 为空的类型，例如 204，205，304，将 body 置为 null if (statuses.empty[code]) { // strip headers ctx.body = null return res.end() } // 如果是 HEAD 方法 // 需要注意，HEAD 请求不返回 body if ('HEAD' == ctx.method) { // headersSent 属性 Node 原生的 response 对象上的，用于检查 http 响应头部是否已经被发送 // 如果头部未被发送，那么添加 length 头部 if (!res.headersSent &amp;&amp; isJSON(body)) { ctx.length = Buffer.byteLength(JSON.stringify(body)) } return res.end() } // status body // 如果 body 值为空 if (null == body) { // body 值为 context 中的 message 属性或 code body = ctx.message || String(code) // 修改头部的 type 与 length 属性 if (!res.headersSent) { ctx.type = 'text' ctx.length = Buffer.byteLength(body) } return res.end(body) } // responses if (Buffer.isBuffer(body)) return res.end(body) // 对 body 为 buffer 类型的进行处理 if ('string' == typeof body) return res.end(body) // 对 body 为字符串类型的进行处理 if (body instanceof Stream) return body.pipe(res) // 对 body 为流形式的进行处理，流式响应使用 pipe，更好的利用缓存 // body: json // 对 body 为 json 格式的数据进行处理，（转化为 json 字符串，添加 length 头部信息） body = JSON.stringify(body) if (!res.headersSent) { ctx.length = Buffer.byteLength(body) } res.end(body)} 可以发现，respond() 函数主要用于将中间件处理后的结果通过 res.end 返回给客户端 错误处理在 Koa.js 中, 错误处理分为在 application.js 中的 onerror 处理函数与在 context.js 中的 onerror 处理函数 Context 的 onerror 函数是绑定在中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的（为了处理请求或响应中出现的 error 事件） application.js 中的 onerror 函数是绑定在 Koa.js 实例对象上的, 它监听的是整个对象的 error 事件 这里，我们主要看 Context 中的的 onerror() 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162onerror(err) { // don't do anything if there is no error. // this allows you to pass `this.onerror` // to node-style callbacks. // 没有错误则忽略, 不执行下面的逻辑 if (null == err) return // 将错误转化为 Error 实例 if (!(err instanceof Error)) err = new Error(util.format('non-error thrown: %j', err)) let headerSent = false if (this.headerSent || !this.writable) { headerSent = err.headerSent = true } // delegate // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行 this.app.emit('error', err, this) // nothing we can do here other // than delegate to the app-level // handler and log. // 如果响应头部已经发送（或者 socket 不可写）, 那么退出函数 if (headerSent) { return } // 获取 http 原生 res 对象 const { res } = this // first unset all headers // 根据文档 res.getHeaderNames 函数是 7.7.0 版本后添加的, 这里为了兼容做了一个判断 // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置 if (typeof res.getHeaderNames === 'function') { res.getHeaderNames().forEach(name =&gt; res.removeHeader(name)) } else { res._headers = {} // Node &lt; 7.7 } // then set those specified this.set(err.headers) // force text/plain // 出错后响应类型为 text/plain this.type = 'text' // ENOENT support // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404 if ('ENOENT' == err.code) err.status = 404 // default to 500 // 默认设置状态码为 500 if ('number' != typeof err.status || !statuses[err.status]) err.status = 500 // respond const code = statuses[err.status] const msg = err.expose ? err.message : code // 设置响应状态码 this.status = err.status // 设置响应 body 长度 this.length = Buffer.byteLength(msg) // 返回 message this.res.end(msg)} 在之前的 callback() 中的源码我们可以看到，App 会默认注册一个错误处理函数 1if (!this.listenerCount('error')) this.on('error', this.onerror) 但是我们每次 HTTP 请求的错误其实是交给 ctx.onerror 处理的 1234const onerror = err =&gt; ctx.onerror(err)const handleResponse = () =&gt; respond(ctx)onFinished(res, onerror)return fnMiddleware(ctx).then(handleResponse).catch(onerror) onFinished 是确保一个流在关闭、完成和报错时都会执行相应的回调函数 ctx.onerror 这个函数在参数为空或者 null 的时候，直接返回，不会做任何操作，就是上面源码当中的 1234// don't do anything if there is no error.// this allows you to pass `this.onerror`// to node-style callbacks.if (null == err) return 否则，则会触发 App 产生一个错误事件，如下 123// delegate// 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行this.app.emit('error', err, this) 然后如果判断该请求处理依旧没有结束，也就是 App 注册的 onerror 事件没有结束该请求，则会尝试向客户端产生一个 500 的错误 1234567891011121314151617181920let headerSent = falseif (this.headerSent || !this.writable) { headerSent = err.headerSent = true}// nothing we can do here other// than delegate to the app-level// handler and log.if (headerSent) { return}// ...// default to 500if ('number' != typeof err.status || !statuses[err.status]) err.status = 500// ...this.res.end(msg) 总结起来，我们可以在不同的抽象层次上处理错误，比如我们可以在顶层的中间件将所有中间件产生的错误捕获并处理了，这样错误就不会被上层捕获，我们也可以覆盖 ctx.onerror 的方式来捕获所有的异常，而且可以不触发 App 的 error 事件，最后我们也可以直接监听 App 的 error 事件的方式来处理错误 参考 koajs/koa context.js 十分钟带你看完 KOA 源码","link":"/2019/10/30/Node/14/"},{"title":"Redux 源码初探","text":"在之前的章节当中我们介绍了 Flux 与 Redux 和 Redux、Flux 和 React-Redux 三者之间的区别，这一章我们就深入的来了解一下 Redux 的源码结构，先来看看 Redux 的源码目录，如下所示 12345678├── utils/│ ├── warning.js // 控制台显示警告信息├── applyMiddleware.js├── bindActionCreators.js├── combineReducers.js├── compose.js├── createStore.js├── index.js // 入口文件 可以发现，除开 index 和 warning 以外，剩余的五个就是 Redux 的 API，下面我们就一个一个来看 compose(…functions)compose() 方法没有任何依赖，是一个纯函数，它的使用方式是 1compose(f, g, h)(...arg) =&gt; f(g(h(...args))) 不过值得注意的是，它用到了 reduceRight，因此执行顺序是『从右到左』，reduceRight() 方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加，具体实现方式如下 1234567891011121314151617/** * @param {多个函数，用逗号隔开} * @return {函数} */export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } if (funcs.length === 1) { return funcs[0] } const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))} 这里的关键点在于『可传入初始值』，因为 reduce/reduceRight 仅仅是方向的不同 123456789101112131415var arr = [1, 2, 3, 4, 5]var re1 = arr.reduce(function (total, i) { return total + i})console.log(re1) // 15// ==================================var re2 = arr.reduce(function (total, i) { return total + i}, 100)console.log(re2) // 115 一个比较完整的示例 123456789101112131415161718192021222324252627282930313233343536function func1(num) { console.log('func1 获得参数 ' + num) return num + 1}function func2(num) { console.log('func2 获得参数 ' + num) return num + 2}function func3(num) { console.log('func3 获得参数 ' + num) return num + 3}var re1 = func3(func2(func1(0)))console.log('re1：' + re1)console.log('===============')// 使用 redux 提供的 compose() 方法var re2 = Redux.compose(func3, func2, func1)(0)console.log('re2：' + re2)// ===============================================// 执行结果如下// func1 获得参数 0// func2 获得参数 1// func3 获得参数 3// re1：6// ===============// func1 获得参数 0// func2 获得参数 1// func3 获得参数 3// re2：6 combineReducers(reducers)简单来说，这个函数的作用就是通过逐层下分管理对应部分的 state（拆分 state，各个模块管理自己的 state，最后合并），因为在 Flux 中是根据不同的功能拆分出多个 store 分而治之，而 Redux 只允许应用中有唯一的 store，通过拆分出多个 reducer 分别管理对应的 state，无论是 dispatch 哪个 action，都会流通所有的 reducer，这也是为何 reducer 必须返回其对应的 state 的原因（否则整合状态树时，该 reducer 对应的键值就是 undefined） 12345678910111213141516171819202122232425262728function combineReducers(reducers) { var reducerKeys = Object.keys(reducers) var finalReducers = {} for (var i = 0; i &lt; reducerKeys.length; i++) { var key = reducerKeys[i] if (typeof reducers[key] === 'function') { finalReducers[key] = reducers[key] } } var finalReducerKeys = Object.keys(finalReducers) // 返回合成后的 reducer return function combination(state = {}, action) { var hasChanged = false var nextState = {} for (var i = 0; i &lt; finalReducerKeys.length; i++) { var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] // 获取当前子 state var nextStateForKey = reducer(previousStateForKey, action) // 执行各子 reducer 中获取子 nextState nextState[key] = nextStateForKey // 将子 nextState 挂载到对应的键名 hasChanged = hasChanged || nextStateForKey !== previousStateForKey } return hasChanged ? nextState : state }} bindActionCreators(actionCreators, dispatch)这个函数主要用于分发 action（比如使用 dispatch(actionCreator())），实现自动 dispatch 123456789101112131415161718192021// 为 Action Creator 加装上自动 dispatch 功能function bindActionCreator(actionCreator, dispatch) { return (...args) =&gt; dispatch(actionCreator(...args))}export default function bindActionCreators(actionCreators, dispatch) { // 类型判断... var keys = Object.keys(actionCreators) var boundActionCreators = {} for (var i = 0; i &lt; keys.length; i++) { var key = keys[i] var actionCreator = actionCreators[key] if (typeof actionCreator === 'function') { // 逐个装上自动 dispatch 技能 boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) } } return boundActionCreators} createStore()源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import isPlainObject from 'lodash/isPlainObject'import $$observable from 'symbol-observable'// Redux 的私有 action 常量export var ActionTypes = { INIT: '@@redux/INIT'}/** * @param {函数} reducer 不多解释了 * @param {对象} preloadedState 主要用于前后端同构时的数据同步 * @param {函数} enhancer 可以实现中间件、时间旅行，持久化等 * @return {Store} * * ==&gt; Redux 仅提供 applyMiddleware 这个 Store Enhancer */export default function createStore(reducer, preloadedState, enhancer) { // 省略部分代码，后续会用到 // 这里的代码用于中间件（判断），见后面的 applyMiddleware(...middlewares) var currentReducer = reducer var currentState = preloadedState // 这就是整个应用的 state var currentListeners = [] // 用于存储订阅的回调函数，dispatch 后逐个执行 var nextListeners = currentListeners // 至于为什么使用两个存放回调函数的变量，见下方 var isDispatching = false /** * 之所以使用两个存放回调函数的变量 * * 有这样一种情况，试想在 dispatch 后，回调函数正在被逐个执行（for 循环进行时），假设回调函数队列原本是这样的 [a, b, c, d] * 现在 for 循环执行到第 3 步，亦即 a、b 已经被执行，准备执行 c，但是此时 a 被取消订阅，那么此时回调函数队列就变成了 [b, c, d]，那么第 3 步就对应换成了 d * * 为了避免这个问题，本函数会在上述场景中把 currentListeners 复制给 nextListeners，这样的话，dispatch 后，在逐个执行回调函数的过程中 * 如果有新增订阅或取消订阅，都在 nextListeners 中操作，让 currentListeners 中的回调函数得以完整地执行 * * 既然新增是在 nextListeners 中 push，因此毫无疑问，新的回调函数不会在本次 currentListeners 的循环体中被触发 * * =================================================================== * * 简单总结就是 currentListeners 中的回调函数依次完整地执行，而如果有新增订阅或取消订阅，都在 nextListeners 中操作 * */ // 这个函数的作用就是避免发生上述情况 ============ (1) function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice() } } /** * 返回 state */ function getState() { return currentState } /** * 这里需要注意的就是，回调函数中如果需要获取 state，请每次都使用 getState() 来获取（而不是开头用一个变量缓存住它） * 因为回调函数执行期间，有可能有连续几个 dispatch 让 state 改得物是人非，而且别忘了，dispatch 之后，整个 state 是被完全替换掉的 * * @param {函数} 想要订阅的回调函数 * @return {函数} 取消订阅的函数 */ function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected listener to be a function.') } var isSubscribed = true // 避免 (1) 的情况 ensureCanMutateNextListeners() // 新增订阅在 nextListeners 中操作 nextListeners.push(listener) // 返回一个取消订阅的函数 return function unsubscribe() { if (!isSubscribed) { return } isSubscribed = false // 避免 (1) 的情况 ensureCanMutateNextListeners() var index = nextListeners.indexOf(listener) // 取消订阅还是在 nextListeners 中操作 nextListeners.splice(index, 1) } } /** * 用于改变应用状态（不要直接修改 state，而是 dispatch 一个 action） * * 内部的实现是，往 reducer 中传入 currentState 以及 action，用其返回值替换 currentState，最后逐个触发回调函数 * 如果 dispatch 的不是一个对象类型的 action（同步的），而是 Promise/thunk（异步的），则需引入 redux-thunk 等中间件来反转控制权（见下方） * * @param &amp; @return {对象} action */ function dispatch(action) { if (!isPlainObject(action)) { throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) } if (typeof action.type === 'undefined') { throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) } if (isDispatching) { throw new Error('Reducers may not dispatch actions.') } try { isDispatching = true // 关键点，currentState 与 action 会流通到所有的 reducer，所有 reducer 的返回值整合后，替换掉当前的 currentState // 简单来说，往 reducer 中传入 currentState 以及 action currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 令 currentListeners 等于 nextListeners，表示正在逐个执行回调函数（这就是上面 (1) 中的判定条件） var listeners = currentListeners = nextListeners // 逐个触发回调函数 for (var i = 0; i &lt; listeners.length; i++) { listeners[i]() } // 为了方便链式调用，dispatch 执行完毕后，返回 action return action } /** * 主要用于代码分离按需加载、热替换等情况（这个用的较少） * * @param {函数} nextReducer */ function replaceReducer(nextReducer) { if (typeof nextReducer !== 'function') { throw new Error('Expected the nextReducer to be a function.') } // 就直接把传入的 nextReducer 赋给 currentReducer currentReducer = nextReducer // 触发生成新的 state 树 dispatch({ type: ActionTypes.INIT }) } /** * 这是留给 可观察/响应式库 的接口（详情 https://github.com/zenparsing/es-observable） * 扩展可见 rxjs * @return {observable} */ function observable() { 略 } // 这里 dispatch 只是为了生成 应用初始状态 dispatch({ type: ActionTypes.INIT }) return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable }} 反转控制权所谓的反转控制权即 在同步场景下，dispatch(action) 的这个 action 中的数据是同步获取的，并没有控制权的切换问题 但异步场景下，则需要将 dispatch 传入到回调函数，待异步操作完成后，回调函数自行调用 dispatch(action) 简单来说就是，在异步 Action Creator 中自行调用 dispatch 就相当于反转控制权 它们的作用也仅仅就是把 dispatch 等传入异步 Action Creator 罢了 applyMiddleware(…middlewares)我们先来简单的看一眼源码，内容不是很多，我们下面会慢慢来进行介绍 1234567891011121314151617function applyMiddleware(...middlewares) { return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; { const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] const middlewareAPI = { getState: store.getState, dispatch: (action) =&gt; dispatch(action) } chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch } }} 我们注意到 applyMiddleware 作为 enhancer 又把 createStore 这个函数作为参数传入并在内部返回函数中调用了，这其实也是依赖注入的理念，然后我们可以发现内部其实将 applyMiddleware 的入参传入的中间件都执行了一次，传参为 getState 和 dispatch，这里先打住，我们先来看一个中间件的示例，就是一个打印动作前后 state 的中间件 12345678910111213141516171819// 一般的写法function printStateMiddleware(middlewareAPI) { // (1) &lt;== 中间件内可用的 API return function (dispatch) { // (2) &lt;== 传入上级中间件处理逻辑（若无则为原 store.dispatch） return function (action) { // (3) &lt;== 整个函数将会被传到下级中间件（如果有的话）作为它的 dispatch 参数 console.log('state before dispatch', middlewareAPI.getState()) var returnValue = dispatch(action) // dispatch 的返回值其实还是 action console.log('state after dispatch', middlewareAPI.getState()) return returnValue // 将 action 返回给上一个中间件（实际上可以返回任意值，或不返回） } }}// 比较优雅的写法const printStateMiddleware = ({ getState }) =&gt; next =&gt; action =&gt; { console.log('state before dispatch', getState()) let returnValue = next(action) console.log('state after dispatch', getState()) return returnValue} 通过上面代码我们可以发现，一般 middleWare 的内部构造都遵从一个 ({ getState, dispatch }) =&gt; next =&gt; action =&gt; {...} 的范式，并且导出的时候已经被调用了一次，即返回了一个需要接收 getState 和 dispatch 的函数 了解了这一点以后，我们再往后看，接着通过 compose 将中间件高阶组合并增强传入原 store.dispatch 的功能，最后再在返回值内解构覆盖原始 store 的 dispatch，所以这个时候，我们应该已经可以了解 applyMiddleware 到底做了什么，那就是『增强了原始 createStore 返回的 dispatch 的功能』 下面我们就来详细的梳理一下 applyMiddleware 的实现，如下 12345678910111213141516171819export default function applyMiddleware(...middlewares) { // 传入中间件 return function (createStore) { // 传入 createStore return function (reducer, preloadedState, enhancer) { // 返回一个函数签名跟 createStore 一模一样的函数，即返回的是一个增强版的 createStore var store = createStore(reducer, preloadedState, enhancer) // 用原 createStore 先生成一个 store，其包含 getState/dispatch/subscribe/replaceReducer 四个 API var dispatch = store.dispatch // 指向原 dispatch var chain = [] // 存储中间件的数组 var middlewareAPI = { // 提供给中间件的 API（其实都是 store 的 API） getState: store.getState, dispatch: (action) =&gt; dispatch(action) } chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 给中间件 \"组装上\" API，见上面的 (1) dispatch = compose(...chain)(store.dispatch) // 串联所有中间件 return { ...store, // store 的 API 中保留 getState/subsribe/replaceReducer dispatch // 新 dispatch 覆盖原 dispatch，往后调用 dispatch 就会触发 chain 内的中间件链式串联执行 } } }} 关于上面代码当中的 chain 这里我们多提及一点，例如 chain 为 [M3, M2, M1]，而 compose 是从右到左进行包裹的，所以 M1 的 dispatch 参数为 store.dispatch M2 的 dispatch 参数为 M1 的 (2) M3 的 dispatch 参数为 M2 的 (2) 最后，我们得到串联后的中间件链 M3(M2(M1(store.dispatch)))，这也就是所谓的『中间件的洋葱模型』 以上，经过我们的梳理以后也可以大致了解到，其实最终返回的虽然还是 store 当中的那四个 API，但是其中的 dispatch 函数的功能是已经被增强了的，也就是下图当中所示『中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点』 一个综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function inc() { return { type: 'INCREMENT' }}function dec() { return { type: 'DECREMENT' }}function reducer(state, action) { state = state || { counter: 0 } switch (action.type) { case 'INCREMENT': return { counter: state.counter + 1 } case 'DECREMENT': return { counter: state.counter - 1 } default: return state }}// 见上方function printStateMiddleware(middlewareAPI) { return function (dispatch) { return function (action) { console.log('dispatch 前：', middlewareAPI.getState()) var returnValue = dispatch(action) console.log('dispatch 后：', middlewareAPI.getState(), '\\n') return returnValue } }}var enhancedCreateStore = Redux.applyMiddleware(printStateMiddleware)(Redux.createStore)var store = enhancedCreateStore(reducer)store.dispatch(inc())store.dispatch(inc())store.dispatch(dec())// ============================================// 输出结果为// dispatch 前：{ counter: 0 }// dispatch 后：{ counter: 1 }// dispatch 前：{ counter: 1 }// dispatch 后：{ counter: 2 }// dispatch 前：{ counter: 2 }// dispatch 后：{ counter: 1 } 上述的案例中，生成 store 的代码中其实可以将中间件放到 createStore 中 1234var store = Redux.createStore( reducer, Redux.applyMiddleware(printStateMiddleware)) 如果有多个中间件以及多个增强器，还可以这样写 12345678910111213141516import { createStore, applyMiddleware, compose } from 'redux'const store = createStore( reducer, preloadedState, // 可选参数，前后端同构的数据同步 compose( // 顺序是从右到左 applyMiddleware( // 关乎中间件的增强器，必须置于 compose 执行链的最后 middleware1, middleware2, middleware3 ), enhancer3, enhancer2, enhancer1 )) 之所以可以这样使用，是因为在 createStore 的源码的开头部分 123456789101112131415161718192021222324export default function createStore(reducer, preloadedState, enhancer) { // ... if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') { // 只传入 reducer 和 Store Enhancer 这两个参数的情况 enhancer = preloadedState preloadedState = undefined } if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } // 存在 enhancer 就立即执行，返回增强版的 createStore &lt;== 注 (1) return enhancer(createStore)(reducer, preloadedState) } if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.') } // ...} 如果有多个中间件以及多个增强器（有多个 enhancer），则注 (1) 中的代码会执行多次，生成最终的超级增强版 store，比如上例中 compose 内部的执行顺序示意图 1234567891011121314151617原 createStore ———————— ↓return enhancer1(createStore)(reducer, preloadedState, enhancer2) | ├———————— ——&gt; createStore 增强版 1 ↓return enhancer2(createStore1)(reducer, preloadedState, enhancer3) | ├———————————&gt; createStore 增强版 1 + 2 ↓return enhancer3(createStore1 + 2)(reducer, preloadedState, applyMiddleware(m1, m2, m3)) | ├————————————————————————————&gt; createStore 增强版 1 + 2 + 3 ↓return appleMiddleware(m1, m2, m3)(createStore1 + 2 + 3)(reducer, preloadedState) | ├——————————————————————————————————&gt; 生成最终增强版 store","link":"/2019/06/05/React/03/"},{"title":"Flux 与 Redux","text":"最近在学习 Redux 的相关知识，然后在学习的过程中又发现了一个与它关系十分密切的 Flux，而且除了这两个之外，还有一个 React-Redux，为了弄清它们三者之间的差异，所以就打算抽点时间来整理整理 Redux、Flux 和 React-Redux 这三者的关系与区别，我们就先从一切的起源 Flux 开始看起 什么是 FluxFlux 是 Facebook 用于构建客户端 Web 应用程序的基本架构，我们可以将 Flux 看做一种应用程序中的数据流的设计模式，而 Redux 正是基于 Flux 的核心思想实现的一套解决方案，Flux 应用中的数据以『单一方向流动』的，它有以下几个特点 视图产生动作消息，将动作传递给调度器 调度器将动作消息发送给每一个数据中心 数据中心再将数据传递给视图 也就是下图当中所示的流程 我们可以将上图简化为以下流程 1View（视图层） ==&gt; Action（请求层） ==&gt; Dispatcher（传输层） ==&gt; Store（处理层） ==&gt; 最后再次回到 View 比如用户在视图上（view）点击了一个按钮，即发送了一个 action，然后 action 发送到 dispatcher 中（调度器），dispatcher 来分配这个 action（比如要指派给谁去做任务）给 store（在一个 Flux 结构中，store 可以有多个，注意和 React-Redux 区分），在 store 中的作用就是存储并修改数据，然后传递给 view 进行渲染（渲染到虚拟 DOM 当中），单一方向数据流还具有以下特点 集中化管理数据，常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在 Flux 架构中，所有数据都只放在 store 中进行储存与管理 可预测性，在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新，对于 Flux 架构来讲，一次 action 触发，只能引起一次数据流循环，这使得数据更加可预测 方便追踪变化，所有引起数据变化的原因都可由 action 进行描述，而 action 只是一个纯对象，因此十分易于序列化或查看 Flux 的工作流当我们在使用 MVC 或者 MVVM 架构设计模式的时候，有一个缺点，就是当项目越来越大，逻辑越来越复杂的时候，数据间的流动就会显得十分混乱，而 Flux 就是致力于解决数据有序传输问题的架构设计模式，其中最大的哲学就是『数据是单向流动的』 下面我们就来了解一下 Flux 当中的工作流，可以如下图所示 在 Flux 中我们可以看到会有以下几个角色的出现 dispatcher，调度器，接收到 action 并将它们发送给 store action，动作消息，包含动作类型与动作描述 store，数据中心，持有应用程序的数据，并会响应 action 消息 view，应用视图，可展示 store 数据，并实时响应 store 的更新 下面我们就来分别看看它们各自的作用 Dispatcher dispatcher 接收 action，并且要把这些 action 分派给已经注册到 dispatcher 的 store 上 所有的 store 都将接收所有的 action 在每个 App 中，应该确保只有一个 dispatcher 的实例 Store store 是在 App 中持有数据的东西，stores 将要在 App 的 dispatcher 身上注册，以确保它们可以接收 actions 存在 store 中的数据只能够因为响应 action 才能有所改变 在 store 中不能够有公共的 setter 函数，仅能够有 getter 函数 stores 决定了它们愿意响应哪些 actions 无论什么时候，store 中的数据改变了，就会触发一个 change 事件 在一个 App 中可能有很多 store Action action 定义了我们 App 中内部的 API 它们捕获所有可能改变 App 的任何途径、方法 它们是简单的 JSON 对象，并且要有 type 属性，和其他一些数据属性，也就是下面这样 1234{ type: 'delete-todo', todoId: '123'} action 应该具有一个语义化的命名，比如上面我们定义的这个删除操作的 action，我们一眼就可以看出需要执行的是删除操作，它对应的 id 为 123 所有的 store 都将接收同一个 action，并且通过这同一个 action，store 会知道它们要清除和更新哪些数据 Views 从 store 中来的数据将被展示在 view 上 view 层可以使用任何框架 当一个视图想要使用从某一个 store 中来的数据，它必须订阅 subscribe（订阅）一下该 store 的 change 事件 当 store 发射（emit）了 change 事件，此时 view 就能够得到新的数据并且重新渲染 如果一个组件要使用 store，但是没有订阅这个 store，就会出现问题（bug） action 最常见的产生原因实在 App 的某一个部分因用户的交互行为，而被此 view dispatch（派发） 出来了 什么是 Redux在知道了什么是 Flux 以后，我们再来看看 Redux 的相关内容，简单来说，Redux 就是 Flux 思想在 React 当中的实现，所谓的 Redux 可以简单的理解为一个可以预测状态的 JavaScript 的 App 容器，而 App 中的全部 state 都被存储在一个单独的 store 中，形式是 object-tree（JSON），唯一更改 state 的途径就是 emit 一个 action，这个 action 描述了发生了什么 为了指定这些 actions 如何改变 state tree，必须书写简单的、纯净的 reducers，所谓的纯净的 reducers 就是类似下面这样伪代码，它不继承任何东西，并且无论何时返回的值都是固定的 1234function reducers(state, action) { // 返回一个新的 state return newState} 上面就是一个 reducer，是一个纯函数，接收 state 和 action 两个参数，返回新的 state 表达式，如果有使用过 Flux，在这里我们可以发现有一个重要的区别 即在 Redux 当中没有 dispatcher 的概念（store 自己负责 dispatch 某个 action 到自己身上），也不允许有多个 store，所以一般来说，Redux 比较适合用于有强的全局数据概念的 Web 应用（比如商城，购物车等） Redux 中只有一个唯一的 store，使用唯一的 reducing function，随着项目增长的时候也不要去增加 store，而是应该切割当前的 store 为一个个小的 store，即 store 应该只有一个，类似于 React 当中只允许使用一个根节点，但是根节点是由众多的节点组成，我们下面将会分别进行讨论 为什么要用 Redux这个需要视当前的使用场景来决定的，当然除了 Redux 还有 Flux、Reflux、Mobx 等状态管理库可供选择，下面就是一个实际场景，比如在控制台上记录用户的每个动作 12345678910111213141516171819// 后端，比如使用 Express 中实现一个简单的 Logger var loggerMiddleware = function (req, res, next) { console.log('[Logger]', req.method, req.originalUrl) next()}...app.use(loggerMiddleware)// 前端，jQuery$('#loginBtn').on('click', function (e) { console.log('[Logger] 用户登录') ...})$('#logoutBtn').on('click', function () { console.log('[Logger] 用户退出登录') ...}) 然后现在又需要在上述需求的基础上，记录用户的操作时间 12345678910111213141516171819// 后端，只需要稍微修改一下原来的中间件即可var loggerMiddleware = function (req, res, next) { console.log('[Logger]', new Date(), req.method, req.originalUrl) next()}...app.use(loggerMiddleware)// 前端，需要一个一个去改$('#loginBtn').on('click', function (e) { console.log('[Logger] 用户登录', new Date()) ...})$('#logoutBtn').on('click', function () { console.log('[Logger] 用户退出登录', new Date()) ...}) 又比如说，在正式上线的时候，把控制台中有关 Logger 的输出全部去掉，亦或是自动收集 bug，很明显的可以看出前后端对于这类需求的处理竟然大相径庭，原因在于，后端具有统一的入口与统一的状态管理（数据库），因此可以引入中间件机制来统一实现某些功能，而前端也可以使用 MVC 的开发思维，将应用中所有的动作与状态都统一管理，让一切有据可循 Store我们首先要区分 store 和 state 之间的区别，state 是应用的状态，一般本质上是一个普通对象，例如我们有一个 Web App，包含计数器和待办事项两大功能，那么我们可以为该应用设计出对应的存储数据结构（应用初始状态） 12345/』应用初始 state『/{ counter: 0, todos: []} 而 store 则是应用状态 state 的管理者，包含下列四个函数 getState()，获取整个 state dispatch(action)，触发 state 改变的【唯一途径】 subscribe(listener)，可以理解成是 DOM 中的 addEventListener replaceReducer(nextReducer)，一般在 Webpack Code-Splitting 按需加载的时候用（使用较少） 二者的关系是 state = store.getState() Redux，规定，一个应用只应有一个单一的 store，其管理着唯一的应用状态 state Redux，还规定，不能直接修改应用的状态 state，也就是说，下面的行为是不允许的 1234var state = store.getState()// 禁止在业务逻辑中直接修改 statestate.counter = state.counter + 1 若要改变 state，必须 dispatch 一个 action，这是修改应用状态的不二法门 针对 action，暂时只需要记住，action 就是一个包含 type 属性的普通对象，例如 { type: 'INCREMENT' } 而 store，我们需要调用 Redux 提供的的 createstore() 方法，如下 123456import { createStore } from 'redux'// ...// 只需记住 store 是靠传入 reducer 来生成的const store = createStore(reducer, initialState) 针对 reducer，暂时只需要记住，reducer 是一个 函数，负责更新并返回一个新的 state 即可 而第二个参数 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）（可暂时不用管） Actionaction（动作）实质上是包含 type 属性的普通对象，这个 type 是我们实现用户行为追踪的关键，例如增加一个待办事项的 action 可能是像下面一样 12345678{ type: 'ADD_TODO', payload: { id: 1, content: '待办事项1', completed: false }} action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性 12345678910111213141516// 下面这些 action 都是合法的，但就是不够规范{ type: 'ADD_TODO', id: 1, content: '待办事项1', completed: false}{ type: 'ADD_TODO', abc: { id: 1, content: '待办事项1', completed: false }} 具体规范可见 flux-standard-action Action CreatorAction Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）（可以是同步的，也可以是异步的），例如下面就是一个新增一个待办事项的 Action Creator 1234567891011var id = 1function addTodo(content) { return { type: 'ADD_TODO', payload: { id: id++, content: content, // 待办事项内容 completed: false // 是否完成的标识 } }} 简单来说，Action Creator 就是用于绑定到用户的操作（比如点击按钮等），其返回值 action 用于之后的 dispatch(action) Reducer需要注意的是，reducer 必须是同步的『纯函数』，简单来说分为以下三步 用户每次 dispatch(action) 后，都会触发 reducer 的执行 reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState 最后会用 reducer 的返回值 nextState 完全替换掉原来的 state 几个需要注意的地方 所谓的更新并不是指 reducer 可以直接对 state 进行修改 Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作 例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign/map/filter ... 等返回副本的函数 例如下面这个示例 123456789101112131415161718192021var initState = { counter: 0, todos: []}function reducer(state, action) { // 应用的初始状态是在第一次执行 reducer 时设置的 if (!state) state = initState switch (action.type) { case 'ADD_TODO': var nextState = _.cloneDeep(state) nextState.todos.push(action.payload) return nextState default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state }} 简单的理解就是，reducer 返回什么，state 就被替换成什么 Redux 的整体流程 store 由 Redux 的 createstore(reducer) 生成 state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象 action 本质上是一个包含 type 属性的普通对象，由 action Creator（函数） 产生 改变 state 必须 dispatch 一个 action reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数 reducer 必须返回值，否则 nextState 即为 undefined 实际上，state 就是所有 reducer 返回值的汇总 大致流程如下所示 123456789101112131415161718192021Action Creator ==&gt; Action ==&gt; store.dispatch(action) ==&gt; reducer(state, action) ==&gt; state(`原`) ==&gt; nextState(`新`) Redux 官方示例剖析下面我们就通过一个例子来深入的了解一下 Redux 的工作流程，示例参考的是官方提供的 counter-vanilla（见 redux/examples/counter-vanilla/index.html） 1234567891011// reducerfunction counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 case 'DECREMENT': return state - 1 default: return state }} action 所对应的字段一般都是约定成俗的使用大写字母来进行表示，它描述了一个 action 如何使当前 state 改变为下一个 state，state 的形式取决于你，它可以是一个基本类型值，可以是一个数组，也可以是一个对象等等，唯一需要注意的就是，永远不要去更改当前的 state，而是应该返回一个新的 state 对象 1var store = redux.createstore(counter) 首先创建一个 Redux 的 store，用它来持有 App 的 store，store 的 API 及其简单，就三个，subscribe，dispatch 和 getState subscribe，让 store 去注册一个视图 dispatch，分发一个命令 getState，返回一个状态 1store.subscribe(render) 使用 store 的 subscribe() 方法，将 store 订阅了视图，render 是一个函数，其实简单来说就是，每次当 state 变化的时候就会执行该函数，通常情况下是与 React 来配合使用，调整上面的示例，添加一个每次点击增加 2 的按钮 12345678910111213141516171819202122232425262728// reducerfunction counter(state = 0, action) { switch (action.type) { case 'ADDTWO': return state + 2 default: return state }}// 创建一个 store，有三个方法，subscribe，dispatch 和 getStatevar store = Redux.createStore(counter)// 得到 span 元素var valueEl = document.getElementById('value')// 渲染函数并且调用function render() { valueEl.innerHTML = store.getState().toString()}render()store.subscribe(render)// 加 2document.getElementById('addTwo').onclick = function () { store.dispatch({ type: 'ADDTWO' })} 调整示例，添加一个输入框，然后点击的时候加上输入框内的值 12345678910111213141516function counter(state = 0, action) { switch (action.type) { case 'ADDNUMBER': return state + action.number default: return state }}// ...// 增加输入框内的值document.getElementById('addNumber').onclick = function () { var number = Number(document.getElementById('textNumber').value) store.dispatch({ type: 'ADDNUMBER', number: number })} 综合以上示例，点击按钮的时候，使 store 去 disptch 一个命令，这时需要注意了，数据存储在 store 中，然后 store 给自己 dispatch 了一条命令，然后自己再去识别给自己发送的命令（case），然后改变存储在自己 store 中的 state（return） 之所以这样设计，就是因为在 reducer 中可以看见整个程序的 state 会发生怎样的变化，虽然不知道什么时候会变化，但是知道其可以做出什么样的变化，知道其不能够做出什么样的变化，这就是 Redux 的哲学，让 state 可以被预期，这也就是下面的 reducer 存在的意义 12345678910111213141516171819202122232425// reducer 清单function counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 case 'ADDNUMBER': return state + action.number case 'DECREMENT': return state - 1 case 'aaa': return state + xxx case 'bbb': return state - xxx case 'ccc': return state * xxx case 'ddd': return state / xxx // ... default: return state }} 综上 我们不是直接去修改 state，而是指定了一个简单的 JSON 对象（类似指令，type）去描述我们想要什么事情发生，这个 JSON 称之为 action 然后声明一个特定的 reducer 的函数去指定每一个 action 要如何改变整个 App 的 store 注意这个『整个』，看下面的示例，我们先将 state 默认值设置为一个对象（不再是简单的数字） 12345678910111213141516// reducerfunction counter(state, action) { if (state == undefined) { state = { 'm': 5, 'n': 10 } } switch (action.type) { case 'INCREMENT': return state.m + 1 case 'ADDNUMBER': return state.m + action.number default: return state }} 直接使用类似上面的 return state.m + 1 是没有效果的，这时需要返回的是整个 state 的值（建议使用 ES6 中的 ... 运算符）即 123456789101112131415161718192021222324252627282930313233343536// reducerfunction counter(state, action) { if (state == undefined) { state = { 'm': 5, 'n': 10 } } // switch (action.type) { // case 'INCREMENT': // return { 'm': state.m + 1 } // case 'DECREMENT': // return { 'm': state.m - 1 } // case 'ADDNUMBER': // return { 'm': state.m + action.number } // default: // return state // } switch (action.type) { case 'INCREMENT': return { ...state, 'm': state.m + 1 } case 'DECREMENT': return { ...state, 'm': state.m - 1 } case 'ADDNUMBER': return { ...state, 'm': state.m + action.number } default: return state }}// ...// 渲染函数并且调用function render() { valueEl.innerHTML = store.getState().m}","link":"/2019/02/22/React/01/"},{"title":"React 生命周期","text":"React 在 16.0 的版本当中，针对其之前的生命周期钩子进行了一定层度上的调整，所以在本章当中我们就来简单的汇总一下两个版本的生命周期有什么区别，以及为什么要进行这样的调整，更多关于 React 生命周期相关内容可以参考 官方文档 React 16.0 之前的生命周期其实简单来说，React 16.0 之前的生命周期可以分为四个阶段 一、组件初始化阶段（Initialization） constructor() 主要用来做一些组件的初始化工作，如定义 this.state 的初始内容，如下示例，Test 类继承了 React Component 这个基类，也是因为继承了这个基类，才能拥有 render()，生命周期等方法可以使用，这也说明了为什么函数组件不能使用这些方法的原因 super(props) 用来调用基类的构造方法 constructor()，也将父组件的 props 注入给子组件，供子组件读取，组件中的 props 只读不可变，state 可变，也可以根据 props 来设置 state 12345678class Test extends Comonent { constructor(props) { super(props) this.state = { counter: props.initialCounterValue, } }} 当然，使用构造函数的方式是可选的，如果 Babel 设置了支持 类字段，则可以像下面这样初始化 state 12345class Test extends Component { state = { counter: 0 }} 这种方法使用较为常见，我们仍然可以根据 props 设置 state 12345class Test extends Component { state = { counter: this.props.initialCounterValue, }} 但是，如果需要使用 ref，可能仍需要构造函数 123456789class Test extends Component { constructor(props) { super(props) this.state = { counter: props.initialCounterValue, } this.myRef = React.createRef() }} 我们需要构造函数调用 createRef 来创建对元素的引用，以便我们可以将它传递给某个组件，另外还可以在构造函数当中进行函数绑定，这也是可选的 二、组件的挂载阶段（Mounting）此阶段分为 componentWillMount()，render()，componentDidMount() 三个时期 componentWillMount() 在组件挂载到 DOM 前调用，且只会被调用一次，在这个生命周期函数中调用 this.setState() 不会引起组件重新渲染，也可以把写在这里面的内容提前到 constructor() 中，所以项目中很少使用，所以这个生命周期钩子将『被废弃』 render() 根据组件的 props 和 state 变化来执行渲染工作，render 是纯函数，所谓的纯函数指的是函数的返回结果只依赖于它的参数，函数执行的过程中没有副作用产生 componentDidMount() 组件挂载到 DOM 后调用，且只会调用一次，一般数据请求都会放到这个钩子当中来进行执行 三、组件的更新阶段（Updation）此阶段分为以下几个流程，这个阶段涉及到的内容较多，所以我们来稍微深入的了解一些 UNSAFE_componentWillReceiveProps()（即将过时） shouldComponentUpdate() UNSAFE_componentWillUpdate()（即将过时） render() componentDidUpdate() 首先要明确 React 组件更新机制，setState 引起的 state 更新或者父组件重新 render 引起的 props 更新，更新后的 state 和 props 相对之前无论是否有变化，都将引起子组件的重新 render 造成组件更新主要有两类情况，我们分类来进行阐述，其中『第一大类』是父组件重新 render，它引起子组件重新 render 的情况又有两种，第一种情况就是直接使用父组件传递进来的 props 这种方式，父组件改变 props 后，子组件重新渲染，由于直接使用的 props，所以我们不需要做什么就可以正常显示最新的 props，每当父组件重新 render 导致的重新传递 props，子组件将直接跟着重新渲染，无论 props 是否有变化，这种方式还可以通过 shouldComponentUpdate 方法优化 1234567891011class Child extends Component { // 应该使用这个方法，否则无论 props 是否有变化都会导致组件跟着重新渲染 shouldComponentUpdate(nextProps) { if (nextProps.someThings === this.props.someThings) { return false } } render() { return &lt;div&gt;{this.props.someThings}&lt;/div&gt; }} 第二种则是在 componentWillReceiveProps 方法中，将 props 转换成自己的 state，这种方式，我们使用的是 state，所以每当父组件每次重新传递 props 时，我们需要重新处理下，将 props 转换成自己的 state，这里就用到了 componentWillReceiveProps 1234567891011121314151617181920class Child extends Component { constructor(props) { super(props) this.state = { someThings: props.someThings } } // 父组件重传 props 时候就会调用这个方法 componentWillReceiveProps(nextProps) { // 将父组件传入进来的 props 赋值给 state this.setState({ someThings: nextProps.someThings }) } render() { return &lt;div&gt;{this.state.someThings}&lt;/div&gt; }} 根据官方描述『在该函数（componentWillReceiveProps）中调用 this.setState() 将不会引起第二次渲染』，这是因为 componentWillReceiveProps 中判断 props 是否变化了，若变化了则 this.setState() 将引起 state 的变化，从而引起 render，此时就没有必要再做第二次因重传 props 引起的 render 了，不然重复做一样的渲染 『第二大类』是组件本身调用 setState 无论 state 有没有变化，都会引起重新渲染，这种情况可以通过 shouldComponentUpdate 方法优化 1234567891011121314151617181920212223242526272829class Child extends Component { constructor(props) { super(props) this.state = { someThings: 1 } } // 应该使用这个方法，否则无论 state 是否有变化都将会引起组件的重新渲染 shouldComponentUpdate(nextStates) { // 如果更新后的 state 和当前的 state 对比没有变化，阻止重新渲染 if (nextStates.someThings === this.state.someThings) { return false } } // 虽然调用了setState，但是state并没有变化 handleClick = () =&gt; { const preSomeThings = this.state.someThings this.setState({ someThings: preSomeThings }) } render() { return &lt;div onClick={this.handleClick}&gt;{this.state.someThings}&lt;/div&gt; }} 弄清楚了 React 组件的更新机制，我们回归正题，来详细看看之前提到过的各个更新阶段 UNSAFE_componentWillReceiveProps()(nextProps) 此方法只调用于 props 引起的组件更新过程中，响应 props 变化之后进行更新的唯一方式，参数 nextProps 是父组件传递给当前组件的新的 props 但是父组件 render 方法的调用不能保证重传给当前组件 props 是有变化的，所以在此方法中根据 nextProps 和 this.props 来查明重传的 props 是否有改变，以及如果改变了要执行什么操作，比如根据新的 props 调用 this.setState 来触发当前组件的重新 render shouldComponentUpdate(nextProps, nextState) 此方法通过比较 nextProps，nextState 以及当前组件的 this.props，this.state，如果返回 true 时当前组件将继续执行更新操作，返回 false 则当前组件更新停止，借助此特性来减少组件的不必要渲染，优化组件的性能 这里也可以看出，就算 componentWillReceiveProps() 中执行了 this.setState 更新了 state，但是在 render 之前（比如 shouldshouldComponentUpdate 和 componentWillUpdate）this.state 依然指向更新前的 state，不然 nextState 以及当前组件的 this.state 的对比就一直是 true 了 如果 shouldComponentUpdate 返回 false 那就一定不用重新渲染（rerender）这个组件了，组件当中的组件元素（React Elements）也不用去对比，但是如果 shouldComponentUpdate 返回true 会进行组件的组件元素（React Elements）对比，如果相同，则不用重新渲染（rerender）这个组件，如果不同，会调用 render 函数进行重新渲染（rerender） UNSAFE_componentWillUpdate() 此方法在调用 render 方法前执行，在这边可以执行一些组件的更新发生前的工作，一般比较少用 render render 方法触发组件的重新渲染 componentDidUpdate(prevProps, preState) 此方法在组件更新后被调用，可以操作更新的 DOM，prevProps 和 preState 这两个参数指向组件更新前的 props 和 state 四、组件的卸载阶段（Unmounting） componentWillUnmount 此阶段只有一个生命周期方法 componentWillUnmount，此方法在组价被卸载时候调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器，清除 componentDidMount 中手动创建的 DOM 元素等等，避免内存泄露 React 16.0 之后的生命周期 变更缘由原来的生命周期在 React 16 推出的 Fiber 之后就不合适了（关于 React Fiber 相关内容可以见 深入 React Fiber），因为如果要开启 async rendering，那么在 render 函数之前的所有函数，都有可能执行多次，也就是 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 如果开启了 async rendering 而且又在以上这些生命周期方法当中去使用 Ajax 请求的话，那么 Ajax 将被无谓的多次调用，这明显不是我们期望的结果，而且在 componentWillMount 里面发起请求不管多快得到结果也赶不上首次 render 除了 shouldComponentUpdate 以外，其他在 render 函数之前的几个函数（componentWillMount/componentWillReceiveProps/componentWillUpdate）都将被 getDerivedStateFromProps 替代，也就是说，使用一个静态函数 getDerivedStateFromProps 来取代即将被废弃的这几个生命周期函数，就是建议或者说是强制我们在 render 之前只做无副作用的操作 React 16 刚推出的时候增加了一个 componentDidCatch 生命周期函数，这只是一个增量式的修改，完全不影响原有的生命周期函数，但是到了 React 16.3 版本推出了大改动，引入了两个新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 下面我们就来结合上面已经介绍过的一些生命周期，再加上新增的两个一起来梳理一下在变更之后的先后流程，更为详细的流程可以参考官方文档或是 React 生命周期 这个网站来进行查看 挂载阶段 constructor() 构造函数，最先被执行，一般会在构造函数里初始化 state 对象或者给自定义方法绑定 this，也是唯一可以直接修改 state 的地方 static getDerivedStateFromProps(nextProps, prevState) 每次 render() 都会调用，通常当 state 需要从 props 初始化时使用，不过建议尽量不要使用，因为维护两者状态一致性会增加复杂度 典型的应用场景是表单控件获取默认值 render() 纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑，可以返回原生的 DOM、React 组件、Fragment、Portals、字符串、数字、布尔和 null 等内容 componentDidMount() 组件挂载后（插入 DOM 树中）立即调用，并且只会执行一次，此时我们可以获取到 DOM 节点并操作 典型的应用场景是获取（订阅）外部资源，但是记得在卸载阶段中取消订阅 更新阶段 static getDerivedStateFromProps() 此方法在更新个挂载阶段都可能会调用 shouldComponentUpdate(nextProps, nextState) 有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true 一般可以由 PureComponent 自动实现，通常利用此生命周期来优化 React 程序性能 render() 更新阶段也会触发此生命周期 getSnapshotBeforeUpdate(prevProps, prevState) 这个方法在最近一次 render() 之前调用，一般不太常用，利用它可以获取 render() 之前的 DOM 状态（比如滚动位置等） 有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，一个返回值，会作为第三个参数传给 componentDidUpdate()，如果你不想要返回值，可以返回 null 通常与 componentDidUpdate() 搭配使用（但是需要注意 getSnapshotBeforeUpdate() 和 componentDidUpdate() 之间可能存在延迟） componentDidUpdate(prevProps, prevState, snapshot) 该方法会在每次 UI 更新后会被立即调用（首次渲染不会执行此方法），有三个参数 prevProps，prevState，snapshot，表示之前的 props，state 和 snapshot，可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里 如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate() 典型的应用场景是页面内容需要根据 props 变化重新获取数据 卸载阶段 componentWillUnmount() 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作 错误处理 static getDerivedStateFromError() 渲染备用 UI componentDidCatch() 主要用来打印错误信息，但是有一点需要注意，该方法仅适用于 渲染/生命周期 函数中的错误，如果应用程序在点击事件中抛出错误，它不会被捕获 下面我们主要来看看新增的两个方法 static getDerivedStateFromProps()1static getDerivedStateFromProps(props, state) 在 React 16.4 版本中，getDerivedStateFromProps() 方法无论是挂载（mounting）还是更新（updating），又或是其他什么引起的更新，全部都会被调用 这个生命周期就是为了替代 componentWillReceiveProps 存在的，所以在你需要使用 componentWillReceiveProps 的时候，就可以考虑使用 getDerivedStateFromProps 来进行替代了，两者的参数是不相同的，而 getDerivedStateFromProps 是一个静态函数，也就是这个函数不能通过 this 访问到 Class 的属性，也并不推荐直接访问属性，而是应该通过参数提供的 nextProps 以及 prevState 来进行判断，根据新传入的 props 来映射到 state 在 React 16.4 之后，getDerivedStateFromProps(nextProps, prevState) 方法会在组件创建和更新时的 render 方法之前被调用，值得注意的是，如果 props 传入的内容不影响你的 state，那么你就返回一个 null，这个返回值是必须的，所以尽量写在函数末尾 这里有一个需要注意的地方，即 getDerivedStateFromProps 前面要添加 static 保留字，声明为静态方法，否则会被 React 忽略掉，getDerivedStateFromProps 中的 this 指向为 undefined，因为静态方法只能被构造函数调用，而不能被实例调用 1234567891011static getDerivedStateFromProps(nextProps, prevState) { const { type } = nextProps // 当传入的 type 发生变化的时候，更新 state if (type !== prevState.type) { return { type, } } // 否则，对于 state 不进行任何操作 return null} 其实简单来说，getDerivedStateFromProps 的作用就是为了让 props 能更新到组件内部 state 中，它的可能使用场景大概有两个 第一个，无条件的根据 props 来更新内部 state，也就是只要有传入 prop 值，就更新 state 我们来看下面这个例子，假设我们有个一个表格组件，它会根据传入的列表数据来更新视图 12345678910111213141516class Table extends React.Component { state = { list: [] } static getDerivedStateFromProps(props, state) { return { list: props.list } } render() { // 展示 list // ... }} 上面的例子就是第一种使用场景，但是无条件从 prop 中更新 state 我们完全没必要使用这个生命周期，直接对 prop 值进行操作就好了，无需用 state 进行一个值的映射 第二个，只有 prop 值和 state 值不同时才更新 state 值 再看一个例子，这个例子是一个颜色选择器，这个组件能选择相应的颜色并显示，同时它能根据传入 prop 值显示颜色 1234567891011121314151617181920Class ColorPicker extends React.Component { state = { color: '#000000' } static getDerivedStateFromProps(props, state) { if (props.color !== state.color) { return { color: props.color } } return null } // 选择颜色方法 render() { // 显示颜色和选择颜色操作 // ... }} 现在我们可以使用这个颜色选择器来选择颜色，同时我们能传入一个颜色值并显示，但是这个组件存在一些问题，比如如果我们传入一个颜色值后，再使用组件内部的选择颜色方法，我们会发现颜色不会变化，一直是传入的颜色值 这也是使用这个生命周期的一个比较常见的问题，为什么会出现这样的问题呢？我们在之前提到过，在 React 16.4^ 的版本中，setState 和 forceUpdate 也会触发这个生命周期，所以内部 state 变化后，又会走 getDerivedStateFromProps 方法，并把 state 值更新为传入的 prop，所以下面我们来稍微的调整一下 12345678910111213141516171819202122Class ColorPicker extends React.Component { state = { color: '#000000', prevPropColor: '' } static getDerivedStateFromProps(props, state) { if (props.color !== state.prevPropColor) { return { color: props.color prevPropColor: props.color } } return null } // 选择颜色方法 render() { // 显示颜色和选择颜色操作 // ... }} getSnapshotBeforeUpdate()getSnapshotBeforeUpdate() 被调用于 render 之后，可以读取但无法使用 DOM 的时候，它可以让我们的组件在可能更改之前从 DOM 捕获一些信息（例如滚动位置），此生命周期返回的任何值都将作为参数传递给 componentDidUpdate，但是一般使用不是很多，了解即可 1234567891011121314151617181920212223242526272829class ScrollingList extends React.Component { constructor(props) { super(props) this.listRef = React.createRef() } getSnapshotBeforeUpdate(prevProps, prevState) { // 我们是否要添加新的 items 到列表 // 捕捉滚动位置，以便我们可以稍后调整滚动 if (prevProps.list.length &lt; this.props.list.length) { const list = this.listRef.current return list.scrollHeight - list.scrollTop } return null } componentDidUpdate(prevProps, prevState, snapshot) { // 如果我们有 snapshot 值，调整滚动以至于这些新的 items 不会将旧 items 推出视图 // snapshot 是 getSnapshotBeforeUpdate 方法的返回值 if (snapshot !== null) { const list = this.listRef.current list.scrollTop = list.scrollHeight - snapshot } } render() { return &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt; }}","link":"/2020/06/25/React/10/"},{"title":"Redux 的实现","text":"最近在复习 React 的过程当中，在网上发现了一篇关于 Redux 手动实现方式的 系列文章，收益良多，所以打算在这里汇总整理一下，一方面加深一下对于 Redux 的理解，另一方面也方便以后可以经常回来温习温习，内容有所删减和补充，更多内容可以参考原文 我们都知道，Redux 和 React-Redux 并不是同一个东西，Redux 是一种架构模式（Flux 架构的一种变种），它不关注你到底用什么库，你可以把它应用到 React 和 Vue，甚至跟 jQuery 结合都没有问题，而 React-Redux 就是把 Redux 这种架构模式和 React 结合起来的一个库，就是 Redux 架构在 React 中的体现（关于 React-Redux 的实现我们会在后面进行介绍） 所以在这里我们也就不直接介绍 Redux 当中的 reducers、actions、store 等这些 API 的关系和用法，而是从一个示例开始，一步一步来进行推演 共享状态的修改我们先从示例的搭建开始，页面结构如下，很简单的两个容器，一个标题，一个内容 12&lt;div id='title'&gt;&lt;/div&gt;&lt;div id='content'&gt;&lt;/div&gt; 下面我们再来添加一些用于渲染的数据和几个渲染函数，它们的作用是将我们的数据渲染到上面的容器当中，如下 1234567891011121314151617181920212223242526272829const appState = { title: { text: '标题', color: 'red', }, content: { text: '内容', color: 'blue' }}function renderApp(appState) { renderTitle(appState.title) renderContent(appState.content)}function renderTitle(title) { const titleDOM = document.getElementById('title') titleDOM.innerHTML = title.text titleDOM.style.color = title.color}function renderContent(content) { const contentDOM = document.getElementById('content') contentDOM.innerHTML = content.text contentDOM.style.color = content.color}renderApp(appState) 逻辑比较简单，我们调用了 renderApp() 方法，它会分别再去调用 rendeTitle() 和 renderContent()，而这两者会把 appState 里面的数据通过原始的 DOM 操作更新到页面上，很明显的页面当中会显现红色的标题和蓝色的内容文字 内容虽然十分简单，但是这里存在一个重大隐患，那就是我们在渲染数据的时候，使用的是一个共享状态 appState，这也就意味着每个人都可以修改它，如果我们在 renderApp(appState) 之前执行了一大堆函数操作，你可能根本不知道它们会对 appState 做什么事情，所以 renderApp(appState) 的结果根本没法得到保障 所以我们来看看如何解决这个问题，针对这种情况我们约定，数据并不能直接去进行修改，如果想要修改，必须显式的声明你想要修改哪些数据，所以我们定义一个函数，叫 dispatch，它专门负责数据的修改 123456789101112function dispatch(action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': appState.title.text = action.text break case 'UPDATE_TITLE_COLOR': appState.title.color = action.color break default: break }} 所有对数据的操作必须通过 dispatch 函数，它接受一个参数 action，这个 action 是一个普通的 JavaScript 对象，里面必须包含一个 type 字段来声明你到底想干什么，dispatch 在 swtich 里面会识别这个 type 字段，能够识别出来的操作才会执行对 appState 的修改，上面的 dispatch 它只能识别两种操作 一种是 UPDATE_TITLE_TEXT 它会用 action 的 text 字段去更新 appState.title.text 一种是 UPDATE_TITLE_COLOR，它会用 action 的 color 字段去更新 appState.title.color 任何的模块如果想要修改 appState.title.text，必须大张旗鼓地调用 dispatch 123456renderApp(appState) // 首次渲染dispatch({ type: 'UPDATE_TITLE_TEXT', text: 'newTitle' }) // 修改标题文本dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'green' }) // 修改标题颜色renderApp(appState) // 将新数据渲染到页面上 这样一来，我们就不需要担心在 renderApp(appState) 之前的某些函数操作，因为我们规定不能直接修改 appState，它们对 appState 的修改必须只能通过 dispatch，而我们看看 dispatch 的实现可以知道，你只能修改 title.text 和 title.color，对于原来的模块（组件）修改共享数据的方式是可以直接修改的，也就如下图所示 我们很难把控每一根指向 appState 的箭头，appState 里面的东西就无法把控，但现在我们必须通过一个中间人（dispatch），所有的数据修改必须通过它 这样一来我们就不用担心共享数据状态的修改问题了，我们只要把控住 dispatch，所有对 appState 的修改就无所遁形，毕竟只有一根箭头指向 appState 了 监控数据变化现在我们有了 appState 和 dispatch，所以我们将它们集中起来，起个名字叫做 store，然后构建一个函数 createStore，用来专门生产这种 state 和 dispatch 的集合，这样别的 App 也可以用这种模式了 12345function createStore(state, stateChanger) { const getState = () =&gt; state const dispatch = (action) =&gt; stateChanger(state, action) return { getState, dispatch }} createStore 接受两个参数，一个是表示应用程序状态的 state，另外一个是 stateChanger，它来描述应用程序状态会根据 action 发生什么变化，createStore 会返回一个对象，这个对象包含两个方法 getState 和 dispatch，getState 用于获取 state 数据，其实就是简单地把 state 参数返回，dispatch 用于修改数据，它会把 state 和 action 一并传给 stateChanger 现在我们就可以利用 createStore 来修改数据生成的方式了，如下 1234567891011121314151617181920212223242526272829303132const appState = { title: { text: '标题', color: 'red', }, content: { text: '内容', color: 'blue' }}function stateChanger(state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': state.title.text = action.text break case 'UPDATE_TITLE_COLOR': state.title.color = action.color break default: break }}const store = createStore(appState, stateChanger)renderApp(store.getState()) // 首次渲染store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: 'newTitle' }) // 修改标题文本store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'green' }) // 修改标题颜色renderApp(store.getState()) // 将新数据渲染到页面上 针对每个不同的 App，我们可以给 createStore 传入初始的数据 appState，和一个描述数据变化的函数 stateChanger，然后生成一个 store，需要修改数据的时候通过 store.dispatch，需要获取数据的时候通过 store.getState 但是此时还存在一些问题，就是我们每次通过 dispatch 去修改数据的时候，都需要手动的调用 renderApp() 才能重新渲染页面，我们来稍微的调整一下，即通过监听的方式，一旦数据有所变化，就会自动的重新渲染页面，所以这里就会用到观察者模式 12345678910function createStore(state, stateChanger) { const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { stateChanger(state, action) listeners.forEach((listener) =&gt; listener()) } return { getState, dispatch, subscribe }} 我们在 createStore 里面定义了一个数组 listeners，还有一个新的方法 subscribe，通过 store.subscribe(listener) 的方式给 subscribe 传入一个监听函数，这个函数会被 push 到数组当中 每当我们 dispatch 的时候，除了会调用 stateChanger 进行数据的修改，还会遍历 listeners 数组里面的函数，然后一个个地去调用，这样我们就可以在每当数据变化时候进行重新渲染 123456789const store = createStore(appState, stateChanger)store.subscribe(() =&gt; renderApp(store.getState()))renderApp(store.getState()) // 首次渲染store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: 'newTitle' }) // 修改标题文本store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'green' }) // 修改标题颜色// 后续操作就无需再次调用 store.getState() 共享数据的性能优化如果细心观察我们之前的示例，是可以发现其中是有比较严重的性能问题，即每当更新数据的时候就重新渲染整个 App，比如我们之前只是修改了 Title 当中的内容，但是 Content 中的内容也同步会被更新 这里提出的解决方案是，在每个渲染函数执行渲染操作之前先做个判断，判断传入的新数据和旧的数据是不是相同，相同的话就不渲染了 12345678910111213141516171819function renderApp(newAppState, oldAppState = {}) { if (newAppState === oldAppState) return renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content)}function renderTitle(newTitle, oldTitle = {}) { if (newTitle === oldTitle) return const titleDOM = document.getElementById('title') titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color}function renderContent(newContent, oldContent = {}) { if (newContent === oldContent) return const contentDOM = document.getElementById('content') contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color} 然后我们用一个 oldState 变量保存旧的应用状态，在需要重新渲染的时候把新旧数据传进入去 123456789const store = createStore(appState, stateChanger)let oldState = store.getState() // 缓存旧的 statestore.subscribe(() =&gt; { const newState = store.getState() // 数据可能变化，获取新的 state renderApp(newState, oldState) // 把新旧的 state 传进去渲染 oldState = newState // 渲染完以后，从新赋值，等待下一次数据变化重新渲染}) 但是仔细观察我们的 state 可以发现，上面的代码根本无法达到我们想要的效果 123456789101112function stateChanger(state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': state.title.text = action.text break case 'UPDATE_TITLE_COLOR': state.title.color = action.color break default: break }} 因为即使我们修改了 state.title.text，但是 state 还是那个 state，每次调用 getState() 的时候返回的还是那个 state，所以我们来调整一下 stateChanger，让它修改数据的时候，并不会直接修改原来的数据 state，而是返回一个新的对象 12345678910111213141516171819202122function stateChanger(state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': return { ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { ...state, title: { ...state.title, color: action.color } } default: return state }} 因为 stateChanger 不会修改原来对象了，而是返回对象，所以我们需要修改一下 createStore，让它用每次 stateChanger(state, action) 的调用结果覆盖原来的 state 12345678910function createStore(state, stateChanger) { const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = stateChanger(state, action) // 直接覆盖 listeners.forEach((listener) =&gt; listener()) } return { getState, dispatch, subscribe }} Reducer现在我们已经有了一个比较通用的 createStore，但是我们还可以将 appState 和 stateChanger 合并到一起，如下 12345678910111213141516171819202122232425262728293031323334function stateChanger(state, action) { if (!state) { return { title: { text: '标题', color: 'red', }, content: { text: '内容', color: 'blue' } } } switch (action.type) { case 'UPDATE_TITLE_TEXT': return { ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { ...state, title: { ...state.title, color: action.color } } default: return state }} stateChanger 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能，如果有传入 state 就生成更新数据，否则就是初始化数据，这样一来我们就可以优化 createStore 成一个参数，因为 state 和 stateChanger 合并到一起了 123456789101112function createStore(stateChanger) { let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = stateChanger(state, action) listeners.forEach((listener) =&gt; listener()) } dispatch({}) // 初始化 state return { getState, dispatch, subscribe }} createStore 内部的 state 不再通过参数传入，而是一个局部变量 let state = null，createStore 的最后会手动调用一次 dispatch({})，dispatch 内部会调用 stateChanger，这时候的 state 是 null，所以这次的 dispatch 其实就是初始化数据了，createStore 内部第一次的 dispatch 导致 state 初始化完成，后续外部的 dispatch 就是修改数据的行为了 最后，我们给 stateChanger 起一个比较通用的名字，那就是 reducer，所以我们最终版本的 createStore 如下 123456789101112function createStore(reducer) { let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) } dispatch({}) // 初始化 state return { getState, dispatch, subscribe }} createStore 接受一个叫 reducer 的函数作为参数，这个函数规定是一个纯函数，它接受两个参数，一个是 state，一个是 action 如果没有传入 state 或者 state 是 null，那么它就会返回一个初始化的数据 如果有传入 state 的话，就会根据 action 来修改数据（其实是返回一个合并后的新对象） 如果它不能识别你的 action，它就不会产生新的数据，而是（在 default 内部）把 state 原封不动地返回 reducer 是不允许有副作用的，你不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改 state，它要做的仅仅只是初始化和计算新的 state 总结至此，我们的 createStore 可以直接拿来使用了，方式就是 12345678910111213141516// 定一个 reducerfunction reducer(state, action) { // 初始化 state 和 switch case}// 生成 storeconst store = createStore(reducer)// 监听数据变化重新渲染页面store.subscribe(() =&gt; renderApp(store.getState()))// 首次渲染页面renderApp(store.getState())// 后面可以随意 dispatch 了，页面自动更新store.dispatch(...) 最终的汇总代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function renderApp(newAppState, oldAppState = {}) { if (newAppState === oldAppState) return renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content)}function renderTitle(newTitle, oldTitle = {}) { if (newTitle === oldTitle) return const titleDOM = document.getElementById('title') titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color}function renderContent(newContent, oldContent = {}) { if (newContent === oldContent) return const contentDOM = document.getElementById('content') contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color}function stateChanger(state, action) { if (!state) { return { title: { text: '标题', color: 'red', }, content: { text: '内容', color: 'blue' } } } switch (action.type) { case 'UPDATE_TITLE_TEXT': return { ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { ...state, title: { ...state.title, color: action.color } } default: return state }}function createStore(reducer) { let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) } dispatch({}) return { getState, dispatch, subscribe }}const store = createStore(stateChanger)let oldState = store.getState()store.subscribe(() =&gt; { const newState = store.getState() renderApp(newState, oldState) oldState = newState})renderApp(store.getState())store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: 'newTitle' })store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'green' }) 在上面我们虽然手动实现了 Redux 的整体流程，但是需要注意的是，现在的实现跟 React 一点关系都没有，但是接下来我们会把 React 和 Redux 结合起来，用 Redux 模式帮助我们来管理 React 的应用状态，其实也就是 React-Redux 的实现，关于这部分内容，我们会另起篇幅来进行介绍","link":"/2020/10/04/React/12/"},{"title":"自定义 Hook","text":"因为最近在项目当中使用了较多的 Hook 来进行开发，用到了不少的自定义 Hook，期间也踩了不少的坑，所以打算在这里简单的总结梳理一下 因为我们在之前的 React 中的 Hook 章节当中已经梳理过了关于 Hook 的一些基本使用内容，所以这里也就不再多做提及，我们主要来深入的了解一些自定义 Hook 的封装和使用方式 其实简单来说，就像之前我们介绍过的 HOC 和 Mixin 一样，我们之所以使用自定义 Hook，其实目的还是将组件中类似的状态逻辑抽取出来，自定义 Hook 的实现比较简单，我们只需要定义一个函数，并且把相应需要的状态和 effect 封装进去，同时 Hook 之间也是可以相互引用的，并且约定成俗的使用 use 开头来命名自定义 Hook，这样也可以方便我们使用 eslint 来进行检查 下面我们就来分别看看几类不同的 Hook 封装 Util顾名思义也就是我们常用的工具类，一些比较常见的有 useFetch、useDebounce、useInterval、useWindowSize 等等，下面我们就来看看它们具体如何实现 useWindowSize这个不用介绍太多，定义十分简单，而使用方式也正如其名，我们可以使用它来获取元素 resize 后的长宽 1234567891011121314151617181920import { useEffect, useState } from 'react'export default function useWindowSize(el) { const [windowSize, setWindowSize] = useState({ width: undefined, height: undefined, }) useEffect(() =&gt; { function handleResize() { setWindowSize({ width: window.innerWidth, height: window.innerHeight, }) } window.addEventListener('resize', handleResize) handleResize() return () =&gt; window.removeEventListener('resize', handleResize) }, [el]) return windowSize} useFetch这个也是我们平常接触较多的一个自定义 Hook，因为在项目当中不可避免的遇到与请求数据打交道的场景，其实简单来说，不管我们选择哪种方式来获取数据，Axios、Fetch API，还是其它，我们很有可能在 React 组件当中一次又一次地编写相同的代码，因此我们来看看如何构建一个简单但有用的自定义 Hook，以便在需要在应用程序内部获取数据时调用该 Hook 这里我们就姑且称其为 useFetch，因为我们这里就使用最为基本的 Fetch API 来进行介绍，这个 Hook 可以接受两个参数，一个是获取数据所需查询的 URL，另一个是表示要应用于请求的选项的对象，它的大致轮廓如下 12345import { useState, useEffect } from 'react'const useFetch = (url = '', options = null) =&gt; {}export default useFetch 由于获取数据是一个副作用，所以我们应该在 useEffect 当中来进行执行，我们会传递 URL 和 options，而对于返回的 Promise 则使用 json() 方法处理后将它存储在一个 state 变量中即可 123456789101112import { useState, useEffect } from 'react'const useFetch = (url = '', options = null) =&gt; { const [data, setData] = useState(null) useEffect(() =&gt; { fetch(url, options) .then(res =&gt; res.json()) .then(data =&gt; setData(data)) }, [url, options])}export default useFetch 现在一个最基本的轮廓已经有了，但是我们还需要处理网络错误，以防我们的请求出错，所以我们要用另一个 state 变量来存储错误，这样我们就能从 Hook 中返回它并能够判断是否发生了错误 123456789101112131415161718192021import { useState, useEffect } from 'react'const useFetch = (url = '', options = null) =&gt; { const [data, setData] = useState(null) const [error, setError] = useState(null) useEffect(() =&gt; { fetch(url, options) .then(res =&gt; res.json()) .then(data =&gt; { setData(data) setError(null) }) .catch(error =&gt; { setError(error) setData(null) }) }, [url, options])}export default useFetch 处理完了数据和错误之后，下面我们再来看看返回值，我们的 useFetch 应该返回一个对象，其中包含从 URL 中获取的数据，并且如果发生了任何错误，则应该返回错误 另外为了表明异步请求的状态，比如在呈现结果之前显示 loading，所以我们还需要添加第三个 state 变量来跟踪请求的状态，在请求之前将 loading 设置为 true，并在请求之后完成后设置为 false 12345678910111213141516171819202122const useFetch = (url = '', options = null) =&gt; { const [data, setData] = useState(null) const [error, setError] = useState(null) const [loading, setLoading] = useState(false) useEffect(() =&gt; { setLoading(true) fetch(url, options) .then(res =&gt; res.json()) .then(data =&gt; { setData(data) setError(null) }) .catch(error =&gt; { setError(error) setData(null) }) .finally(() =&gt; setLoading(false)) }, [url, options]) return { loading, error, data }} 最后，在使用 userFetch 之前，我们还有一件事情需要处理，那就是我们需要检查使用我们 Hook 的组件是否仍然被挂载，以更新我们的状态变量，否则会有内存泄漏 1234567891011121314151617181920212223242526272829303132333435import { useState, useEffect } from 'react'const useFetch = (url = '', options = null) =&gt; { const [data, setData] = useState(null) const [error, setError] = useState(null) const [loading, setLoading] = useState(false) useEffect(() =&gt; { let isMounted = true setLoading(true) fetch(url, options) .then(res =&gt; res.json()) .then(data =&gt; { if (isMounted) { setData(data) setError(null) } }) .catch(error =&gt; { if (isMounted) { setError(error) setData(null) } }) .finally(() =&gt; isMounted &amp;&amp; setLoading(false)) return () =&gt; (isMounted = false) }, [url, options]) return { loading, error, data }}export default useFetch 这样一来我们就完成了一个比较通用的 userFetch 方法，下面我们再来看看如何进行使用，其实我们只需要传递我们想要检索的资源的 URL 即可，然后我们可以得到一个对象，这样我们就可以使用得到的数据来渲染我们的应用程序 12345678910111213141516171819202122import useFetch from './useFetch'const App = () =&gt; { const { loading, error, data = [] } = useFetch('url') if (error) return &lt;p&gt;Error!&lt;/p&gt; if (loading) return &lt;p&gt;Loading...&lt;/p&gt; return ( &lt;div&gt; &lt;ul&gt; {data?.map(item =&gt; ( &lt;li key={item.id}&gt; &lt;a href={item.url}&gt;{item.title}&lt;/a&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; )}export default App useEventListener这个 Hook 也是我们平常使用较多的一种，它主要负责在组件内部设置和清理事件监听器，它接收如下几个参数 eventType 事件类型 listener 监听函数 target 监听对象 options 可选参数 基本轮廓如下 12345678910import { useEffect, useRef } from 'react'const useEventListener = ( eventType = '', listener = () =&gt; null, target = null, options = null) =&gt; {}export default useEventListener 与上面的 useFetch 一样，我们使用 useEffect 来添加一个事件监听器，首先我们需要确保 target 是否支持 addEventListener 方法，否则我们什么也不做 1234567891011121314import { useEffect, useRef } from 'react'const useEventListener = ( eventType = '', listener = () =&gt; null, target = null, options = null) =&gt; { useEffect(() =&gt; { if (!target?.addEventListener) return }, [target])}export default useEventListener 然后我们可以添加实际的事件监听器并在卸载函数中删除它 1234567891011121314151617181920import { useEffect, useRef } from 'react'const useEventListener = ( eventType = '', listener = () =&gt; null, target = null, options = null) =&gt; { useEffect(() =&gt; { if (!target?.addEventListener) return target.addEventListener(eventType, listener, options) return () =&gt; { target.removeEventListener(eventType, listener, options) } }, [eventType, target, options, listener])}export default useEventListener 但是通常来说，更为常见的做法是使用一个引用对象来存储和持久化监听器函数，只有当监听器函数发生变化并在事件监听器方法中使用该引用时，我们才会更新该引用，也就像下面这样的 12345678910111213141516171819202122232425262728import { useEffect, useRef } from 'react'const useEventListener = ( eventType = '', listener = () =&gt; null, target = null, options = null) =&gt; { const savedListener = useRef() useEffect(() =&gt; { savedListener.current = listener }, [listener]) useEffect(() =&gt; { if (!target?.addEventListener) return const eventListener = event =&gt; savedListener.current(event) target.addEventListener(eventType, eventListener, options) return () =&gt; { target.removeEventListener(eventType, eventListener, options) } }, [eventType, target, options])}export default useEventListener 这样一来我们就不需要从此 Hook 返回任何内容，因为我们只是侦听事件并运行处理程序函数传入作为参数 以下面这个组件为例，我们来看看如何使用，该组件的作用是检测 DOM 元素外部的点击，如果用户单击对话框组件，则在此处关闭对话框组件，这里关于样式部分的处理已经剔除掉了，只保留了逻辑的部分 1234567891011121314151617181920212223242526import { useRef } from 'react'import ReactDOM from 'react-dom'import { useEventListener } from './hooks'const Dialog = ({ show = false, onClose = () =&gt; null }) =&gt; { const dialogRef = useRef() useEventListener( 'mousedown', event =&gt; { if (event.defaultPrevented) { return } if (dialogRef.current &amp;&amp; !dialogRef.current.contains(event.target)) { onClose() } }, window ) return show ? ReactDOM.createPortal(&lt;div ref={dialogRef}&gt;dialog&lt;/div&gt;, document.body) : null}export default Dialog useLocalStorage这个 Hook 主要有两个参数，一个是 key，一个是 value，轮廓如下 12345import { useState } from 'react'const useLocalStorage = (key = '', initialValue = '') =&gt; {}export default useLocalStorage 这个 Hook 会返回一个数组，类似于使用 useState 获得的数组，因此此数组将包含有状态值和在将其持久存储在 localStorage 中时对其进行更新的函数，下面我们先来创建将与 localStorage 同步的 React 状态变量 123456789101112131415import { useState } from 'react'const useLocalStorage = (key = '', initialValue = '') =&gt; { const [state, setState] = useState(() =&gt; { try { const item = window.localStorage.getItem(key) return item ? JSON.parse(item) : initialValue } catch (error) { console.log(error) return initialValue } })}export default useLocalStorage 这里我们使用惰性初始化来读取 localStorage 以获取键的值，如果找到该值，则解析该值，否则返回传入的 initialValue，如果在读取 localStorage 时出现错误，我们只记录一个错误并返回初始值 最后我们需要创建 update 函数来返回它将在 localStorage 中存储任何状态的更新，而不是使用 useState 返回的默认更新 12345678910111213141516171819202122232425import { useState } from 'react'const useLocalStorage = (key = '', initialValue = '') =&gt; { const [state, setState] = useState(() =&gt; { try { const item = window.localStorage.getItem(key) return item ? JSON.parse(item) : initialValue } catch (error) { return initialValue } }) const setLocalStorageState = newState =&gt; { try { const newStateValue = typeof newState === 'function' ? newState(state) : newState setState(newStateValue) window.localStorage.setItem(key, JSON.stringify(newStateValue)) } catch (error) { console.error(`Unable to store new value for ${key} in localStorage.`) } } return [state, setLocalStorageState]}export default useLocalStorage 更新函数可以同时更新 React 状态和 localStorage 中的相应键值，另外还可以支持函数更新，例如常规的 useState，最后我们返回状态值和我们的自定义更新函数，最后我们再来看看如何进行使用，比如将组件中的数据持久化到 localStorage 中 1234567891011121314151617181920212223242526272829303132333435363738import { useLocalStorage } from './hooks'const defaultSettings = { notifications: 'weekly',}const App = () =&gt; { const [appSettings, setAppSettings] = useLocalStorage( 'app-settings', defaultSettings ) return ( &lt;div&gt; &lt;div&gt; &lt;p&gt;Your application's settings:&lt;/p&gt; &lt;select value={appSettings.notifications} onChange={e =&gt; setAppSettings(settings =&gt; ({ ...settings, notifications: e.target.value, })) } &gt; &lt;option value=\"daily\"&gt;daily&lt;/option&gt; &lt;option value=\"weekly\"&gt;weekly&lt;/option&gt; &lt;option value=\"monthly\"&gt;monthly&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;button onClick={() =&gt; setAppSettings(defaultSettings)}&gt; Reset settings &lt;/button&gt; &lt;/div&gt; )}export default App useMediaQuery这个 Hook 可以帮助我们在组件中监控媒体查询，例如当我们需要渲染不同的 UI 取决于设备的类型或特定的特征，它接受三个参数 首先，对应媒体查询的字符串数组 然后，以与前一个数组相同的顺序匹配这些媒体查询的值数组 最后，如果没有匹配的媒体查询，则使用默认值 12345import { useState, useCallback, useEffect } from 'react'const useMediaQuery = (queries = [], values = [], defaultValue) =&gt; {}export default useMediaQuery 我们在这个 Hook 中做的第一件事是为每个匹配的媒体查询构建一个媒体查询列表，使用这个数组通过匹配媒体查询来获得相应的值 1234567import { useState, useCallback, useEffect } from 'react'const useMediaQuery = (queries = [], values = [], defaultValue) =&gt; { const mediaQueryList = queries.map(q =&gt; window.matchMedia(q))}export default useMediaQuery 为此我们创建了一个包装在 useCallback 中的回调函数，检索列表中第一个匹配的媒体查询的值，如果没有匹配则返回默认值 123456789101112import { useState, useCallback, useEffect } from 'react'const useMediaQuery = (queries = [], values = [], defaultValue) =&gt; { const mediaQueryList = queries.map(q =&gt; window.matchMedia(q)) const getValue = useCallback(() =&gt; { const index = mediaQueryList.findIndex(mql =&gt; mql.matches) return typeof values[index] !== 'undefined' ? values[index] : defaultValue }, [mediaQueryList, values, defaultValue])}export default useMediaQuery 然后我们创建一个 React 状态来存储匹配的值，并使用上面定义的函数来初始化它 1234567891011121314import { useState, useCallback, useEffect } from 'react'const useMediaQuery = (queries = [], values = [], defaultValue) =&gt; { const mediaQueryList = queries.map(q =&gt; window.matchMedia(q)) const getValue = useCallback(() =&gt; { const index = mediaQueryList.findIndex(mql =&gt; mql.matches) return typeof values[index] !== 'undefined' ? values[index] : defaultValue }, [mediaQueryList, values, defaultValue]) const [value, setValue] = useState(getValue)}export default useMediaQuery 最后我们在 useEffect 中添加一个事件监听器来监听每个媒体查询的更改，当发生变化时我们运行更新函数 123456789101112131415161718192021222324import { useState, useCallback, useEffect } from 'react'const useMediaQuery = (queries = [], values = [], defaultValue) =&gt; { const mediaQueryList = queries.map(q =&gt; window.matchMedia(q)) const getValue = useCallback(() =&gt; { const index = mediaQueryList.findIndex(mql =&gt; mql.matches) return typeof values[index] !== 'undefined' ? values[index] : defaultValue }, [mediaQueryList, values, defaultValue]) const [value, setValue] = useState(getValue) useEffect(() =&gt; { const handler = () =&gt; setValue(getValue) mediaQueryList.forEach(mql =&gt; mql.addEventListener('change', handler)) return () =&gt; mediaQueryList.forEach(mql =&gt; mql.removeEventListener('change', handler)) }, [getValue, mediaQueryList]) return value}export default useMediaQuery 下面我们再来测试一下，比如添加一个媒体查询来检查设备是否允许用户悬停在元素上，如果用户可以悬停或应用基本样式，我就可以添加特定的不透明样式 123456789101112import { useMediaQuery } from './hooks'function App() { const canHover = useMediaQuery(['(hover: hover)'], [true], false) const canHoverClass = 'opacity-0 hover:opacity-100 transition-opacity' const defaultClass = 'opacity-100' return ( &lt;div className={canHover ? canHoverClass : defaultClass}&gt;Hover me!&lt;/div&gt; )}export default App useDarkMode简单来说，这个 Hook 的主要作用就是按需启用和禁用 dark 模式，其实也就是一个在网页当中比较常见的效果，那就是主题切换 我们将当前状态存储在 localStorage 中，在 localStorage 中初始化，存储和保留当前状态（暗或亮模式），这里我们就可以借用上面介绍到的 useLocalStorage 来进行实现 12345678910111213import { useEffect } from 'react'import useMediaQuery from './useMediaQuery'import useLocalStorage from './useLocalStorage'const useDarkMode = () =&gt; { const preferDarkMode = useMediaQuery( ['(prefers-color-scheme: dark)'], [true], false )}export default useDarkMode 最后就是触发 useEffect 以向 document.body 元素添加或删除 dark 类，这样我们就可以简单地将 dark 样式应用于我们的应用程序 12345678910111213141516171819202122232425import { useEffect } from 'react'import useMediaQuery from './useMediaQuery'import useLocalStorage from './useLocalStorage'const useDarkMode = () =&gt; { const preferDarkMode = useMediaQuery( ['(prefers-color-scheme: dark)'], [true], false ) const [enabled, setEnabled] = useLocalStorage('dark-mode', preferDarkMode) useEffect(() =&gt; { if (enabled) { document.body.classList.add('dark') } else { document.body.classList.remove('dark') } }, [enabled]) return [enabled, setEnabled]}export default useDarkMode API比如我们有一个公用的城市列表接口，在用 Redux 的时候可以放在全局公用，有了 Hook 以后我们只需要 use 一下就可以在其他地方复用了 1234567891011121314151617181920import { useState, useEffect } from 'react'import { getCityList } from '@/services/static'const useCityList = (params) =&gt; { const [cityList, setList] = useState([]) const [loading, setLoading] = useState(true) const getList = async () =&gt; { const { success, data } = await getCityList(params) if (success) setList(data) setLoading(false) } useEffect(() =&gt; { getList() }, []) return { cityList, loading }}// 使用const { cityList, loading } = useCityList('beijing') UI我们在平常开发过程当中也会遇到一些和 UI 绑定在一起的 Hook，最为常见的就是模态框，比如下面这个模态框示例 123456789101112131415161718192021222324252627282930import React, { useState } from 'react'import { Modal } from 'antd'export default function useModal(key = 'open') { const [opens, setOpen] = useState({ [key]: false }) const onCancel = () =&gt; { setOpen({ [key]: false }) } const showModal = (type = key) =&gt; { setOpen({ [type]: true }) } const MyModal = (props) =&gt; { return &lt;Modal key={key} visible={opens[key]} onCancel={onCancel} {...props} /&gt; } return { showModal, MyModal, }}// 使用const { showModal, MyModal } = useModal()return ( &lt;&gt; &lt;button onClick={showModal}&gt;展开&lt;/button&gt; &lt;MyModal onOk={console.log} /&gt; &lt;/&gt;) Logic逻辑类，比如我们有一个点击用户头像关注用户或者取消关注的逻辑，可能在评论列表、用户列表都会用到，我们可以这样做 12345678910111213141516171819202122232425import { useState, useEffect } from 'react'import { followUser } from '@/services/user'const useFollow = ({ accountId, isFollowing }) =&gt; { const [isFollow, setFollow] = useState(false) const [operationLoading, setLoading] = useState(false) const toggleSection = async () =&gt; { setLoading(true) const { success } = await followUser({ accountId }) if (success) { setFollow(!isFollow) } setLoading(false) } useEffect(() =&gt; { setFollow(isFollowing) }, [isFollowing]) return { isFollow, toggleSection, operationLoading }}export default useFollow 双向绑定接着我们再来看一个平常在业务当中可能是会经常遇到的情况，那就是双向绑定，不过在这里我们会分别采用 HOC、Render Props 和 Hook 的三种实现方式，同时也可以对比一下它们几者之间的优缺点，下面我们就先从 HOC 的实现方式开始看起 HOC首先我们定义了一个高阶组件 HocInput 和一个普通组件 Input，在返回的时候我们使用高阶组件 HocInput() 将 Input 包裹以后在进行返回 12345678910111213141516171819202122232425262728const HocInput = WrapperComponent =&gt; class extends React.Component { state = { value: this.props.initialValue } onChange = e =&gt; { this.setState({ value: e.target.value }) if (this.props.onChange) { this.props.onChange(e.target.value) } } render() { const newProps = { value: this.state.value, onChange: this.onChange } return &lt;WrapperComponent {...newProps} /&gt; } }const Input = props =&gt; ( &lt;&gt; &lt;p&gt;{props.value}&lt;/p&gt; &lt;input placeholder=\"input\" {...props} /&gt; &lt;/&gt;)export default HocInput(Input) 然后像下面这样使用既可 1&lt;HocInput initialValue=\"init\" onChange={val =&gt; console.log(`HocInput`, val) } /&gt; Render Props与 HOC 不同的是，我们这次在 render() 的时候返回的是 this.props.children()，props 接受两个参数，初始值 initialValue 以及 onChange 方法 1234567891011121314151617181920212223242526class HocBind extends React.Component { constructor(props) { super(props) this.state = { value: props.initialValue } } onChange = e =&gt; { this.setState({ value: e.target.value }) if (this.props.onChange) { this.props.onChange(e.target.value) } } render() { return ( &lt;&gt; {this.props.children({ value: this.state.value, onChange: this.onChange })} &lt;/&gt; ) }}export default HocBind 使用 123456&lt;HocBind initialValue=\"init\" onChange={val =&gt; console.log(`HocBind`, val) } &gt; {props =&gt; (&lt;&gt; &lt;p&gt;{props.value}&lt;/p&gt; &lt;input placeholder=\"input\" {...props} /&gt; &lt;/&gt;)}&lt;/HocBind&gt; Hook最后我们再来看看 Hook 的实现方式，我们定义了一个 useBind 方法，接受一个 initialValue 参数作为默认输入，使用的时候我们使用 inputProps 来接收调用 useBind() 以后的返回值，然后在使用的时候我们就可以直接用 inputProps.value，然后将剩余的 props（也就是 onChange）传递给 input 12345678910111213141516171819202122232425function useBind(initialValue) { const [value, setValue] = useState(initialValue || '') const onChange = e =&gt; { setValue(e.target.value) } return { value, onChange }}function InputBind() { const inputProps = useBind('init') return ( &lt;div&gt; &lt;p&gt;{inputProps.value}&lt;/p&gt; &lt;input {...inputProps} /&gt; &lt;/div&gt; )}class App extends Component { render() { return &lt;InputBind /&gt; }}export default App","link":"/2021/03/28/React/20/"},{"title":"关于 Hook 的一些总结","text":"因为手头上了项目暂时告一段落，也终于有时间可以回过头来总结总结，因为在之前关于 React 的使用也仅仅只局限在小型应用当中，而目前完结的这个项目算是整体基于 React 全家桶搭建而成的项目 当然在开发当中也遇到了不少棘手的问题，也踩了不少的坑，尤其是关于 Hook 的一些使用方面，所以也就打算抽些时间，重新温故一下文档以及参考一些前辈们整理的文章，简单的梳理一下在使用 Hook 过程当中遇到的一些问题和总结 单个 state 与多个 stateuseState 的出现，让我们可以使用多个 state 变量来保存 state，比如 1234const [width, setWidth] = useState(100)const [height, setHeight] = useState(100)const [left, setLeft] = useState(0)const [top, setTop] = useState(0) 但同时我们也可以像 Class 组件的 this.state 一样，将所有的 state 放到一个对象中，这样我们就只需一个 state 变量即可 123456const [state, setState] = useState({ width: 100, height: 100, left: 0, top: 0,}) 那么问题来了，我们到底应该使用单个的 state 变量还是多个的 state 变量呢？ 如果使用单个 state 变量，每次更新 state 时需要合并之前的 state，因为 useState 返回的 setState 会替换原来的值，这一点和 Class 组件的 this.setState 有所不同，this.setState 会把更新的字段自动合并到 this.state 对象中 1234567const handleMouseMove = e =&gt; { setState(prevState =&gt; ({ ...prevState, left: e.pageX, top: e.pageY, }))} 如果使用多个 state 变量可以让 state 的粒度更细，更易于逻辑的拆分和组合，比如们可以将关联的逻辑提取到自定义 Hook 中 12345678910const usePosition = () =&gt; { const [left, setLeft] = useState(0) const [top, setTop] = useState(0) useEffect(() =&gt; { // ... }, []) return [left, top, setLeft, setTop]} 这样一来，我们每次在更新 left 的时候 top 也会随之更新，因此把 top 和 left 拆分为两个 state 变量显得有点多余 在使用 state 之前，我们通常需要考虑状态拆分的『粒度』问题，如果粒度过细，代码就会变得比较冗余，如果粒度过粗，代码的可复用性就会降低，那么到底哪些 state 应该合并，哪些 state 又应该拆分呢？ 简单来说我们遵循的规律主要有以下两点 将完全不相关的 state 拆分为多组 state，比如 size 和 position 如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state，比如 left 和 top 123456789101112131415const Box = () =&gt; { const [position, setPosition] = usePosition() const [size, setSize] = useState({ width: 100, height: 100 }) // ...}const usePosition = () =&gt; { const [position, setPosition] = useState({ left: 0, top: 0 }) useEffect(() =&gt; { // ... }, []) return [position, setPosition]} 依赖过多的问题我们在使用 useEffect Hook 时，为了避免每次 render 都去执行它的 callback，通常会传入第二个参数 dependency array，也就是我们常说的『依赖数组』，这样一来只有当依赖数组发生变化时，才会执行 useEffect 的回调函数 12345const Example = ({ id, name }) =&gt; { useEffect(() =&gt; { console.log(id, name) }, [id, name])} 在上面的例子中，只有当 id 或 name 发生变化时，才会打印日志，依赖数组中必须包含在 callback 内部用到的所有参与 React 数据流的值，比如 state、props 以及它们的衍生物，如果有遗漏，可能会埋下隐患 123456const Example = ({ id, name }) =&gt; { useEffect(() =&gt; { // 由于依赖数组中不包含 name，所以当 name 发生变化时，无法打印日志 console.log(id, name) }, [id])} 在 React 中，除了 useEffect 外，接收依赖数组作为参数的 Hook 还有 useMemo、useCallback 和 useImperativeHandle，我们在上面也提到过，依赖数组中千万不要遗漏回调函数内部依赖的值，但是如果依赖数组依赖了过多东西，可能导致代码难以维护，比如下面这段代码 123const refresh = useCallback(() =&gt; { // ...}, [name, searchState, address, status, personA, personB, progress, page, size]) 光是看到这一堆依赖就令人头大，如果项目中到处都是这样的代码，可想而知维护起来多么痛苦，所以针对于这样的情况，我们就需要重新的思考一下这些 deps 是否真的都需要？看下面这个例子 123456789101112131415const Example = ({ id }) =&gt; { const requestParams = useRef({}) useEffect(() =&gt; { requestParams.current = { page: 1, size: 20, id } }) const refresh = useCallback(() =&gt; { doRefresh(requestParams.current) }, []) useEffect(() =&gt; { id &amp;&amp; refresh() }, [id, refresh])} 虽然 useEffect 的回调函数依赖了 id 和 refresh 方法，但是我们观察 refresh 方法可以发现，它在首次 render 被创建之后，就永远不会发生改变了，因此把它作为 useEffect 的 deps 是多余的 其次，如果这些依赖真的都是需要的，那么这些逻辑是否应该放到同一个 Hook 中 1234567891011121314151617const Example = ({ id, name, address, status, personA, personB, progress }) =&gt; { const [page, setPage] = useState() const [size, setSize] = useState() const doSearch = useCallback(() =&gt; { // ... }, []) const doRefresh = useCallback(() =&gt; { // ... }, []) useEffect(() =&gt; { id &amp;&amp; doSearch({ name, address, status, personA, personB, progress }) page &amp;&amp; doRefresh({ name, page, size }) }, [id, name, address, status, personA, personB, progress, page, size])} 可以看出，在 useEffect 中有两段逻辑，而且这两段逻辑是相互独立的，因此我们可以将这两段逻辑放到不同 useEffect 中 1234567useEffect(() =&gt; { id &amp;&amp; doSearch({ name, address, status, personA, personB, progress })}, [id, name, address, status, personA, personB, progress])useEffect(() =&gt; { page &amp;&amp; doRefresh({ name, page, size })}, [name, page, size]) 但是如果逻辑无法继续拆分，但是依赖数组还是依赖了过多东西，该怎么办呢？就比如我们上面的代码 123useEffect(() =&gt; { id &amp;&amp; doSearch({ name, address, status, personA, personB, progress })}, [id, name, address, status, personA, personB, progress]) 这段代码中的 useEffect 依赖了七个值，但是我们仔细观察上面的代码，可以发现这些值都是『过滤条件』的一部分，通过这些条件可以过滤页面上的数据，因此我们可以将它们看做一个整体，也就是我们前面讲过的合并 state 123456789101112const [filters, setFilters] = useState({ name: '', address: '', status: '', personA: '', personB: '', progress: '',})useEffect(() =&gt; { id &amp;&amp; doSearch(filters)}, [id, filters]) 但是如果 state 不能合并，并且在 callback 内部又使用了 setState 方法的话，在这种情况下，我们就可以考虑使用 setState callback 来减少一些依赖，比如 12345678910111213141516171819const useValues = () =&gt; { const [values, setValues] = useState({ data: {}, count: 0, }) const [updateData] = useCallback( nextData =&gt; { setValues({ data: nextData, // 因为 callback 内部依赖了外部的 values 变量，所以必须在依赖数组中指定它 count: values.count + 1, }) }, [values] ) return [values, updateData]} 上面的代码中，我们必须在 useCallback 的依赖数组中指定 values，否则我们无法在 callback 中获取到最新的 values 状态，但是通过 setState 回调函数，我们就不用再依赖外部的 values 变量，因此也无需在依赖数组中指定它，就像下面这样 123456789101112131415const useValues = () =&gt; { const [values, setValues] = useState({}) const [updateData] = useCallback(nextData =&gt; { setValues(prevValues =&gt; ({ data: nextData, // 通过 setState 回调函数获取最新的 values 状态，这时 callback 不再依赖于外部的 values 变量了 // 因此依赖数组中不需要指定任何值 count: prevValues.count + 1, })) // 这个 callback 永远不会重新创建 }, []) return [values, updateData]} 最后我们还可以通过 ref 来保存可变变量，以前我们只是把 ref 用作保持 DOM 节点引用的工具，可是 useRef Hook 能做的事情远不止如此，我们可以用它来保存一些值的引用，并对它进行读写，举个例子 1234567891011121314151617const useValues = () =&gt; { const [values, setValues] = useState({}) const latestValues = useRef(values) useEffect(() =&gt; { latestValues.current = values }) const [updateData] = useCallback(nextData =&gt; { setValues({ data: nextData, count: latestValues.current.count + 1, }) }, []) return [values, updateData]} 但是需要注意的是，我们在使用 ref 的过程当中要特别小心，因为它可以随意赋值，所以一定要控制好修改它的方法，特别是一些底层模块，在封装的时候千万不要直接暴露 ref，而是提供一些修改它的方法 说了这么多，归根到底都是为了写出更加清晰、易于维护的代码，如果发现依赖数组依赖过多，我们就需要重新审视自己的代码 依赖数组依赖的值最好不要超过三个，否则会导致代码会难以维护 如果发现依赖数组依赖的值过多，我们应该采取一些方法来减少它 去掉不必要的依赖 将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组 通过合并相关的 state，将多个依赖值聚合为一个 通过 setState 回调函数获取最新的 state，以减少外部依赖 通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径 该不该使用 useMemo对于这个问题，有的人从来没有思考过，有的人甚至不觉得这是个问题，因为我们在网上经常见到的做法是，那就是不管什么情况，只要用 useMemo 或者 useCallback 简单的『包裹一下』，似乎就能使应用远离性能的问题，但真的是这样吗？有的时候 useMemo 没有任何作用，甚至还会影响应用的性能 为什么这么说呢？首先我们需要知道，useMemo 本身也有开销，useMemo 会『记住』一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回『记住』的值，这个过程本身就会消耗一定的内存和计算资源，因此过度使用 useMemo 可能会影响程序的性能 所以说要想合理使用 useMemo，我们需要搞清楚 useMemo 适用的场景 有些计算开销很大，我们就需要『记住』它的返回值，避免每次 render 都去重新计算 由于值的引用发生变化，导致下游组件重新渲染，我们也需要『记住』这个值 让我们来看个例子 1234567const Example = ({ page, type }) =&gt; { const resolvedValue = useMemo(() =&gt; { return getResolvedValue(page, type) }, [page, type]) return &lt;ExpensiveComponent resolvedValue={resolvedValue} /&gt;} 在上面的例子中，渲染 ExpensiveComponent 的开销很大，所以当 resolvedValue 的引用发生变化时，我们不想重新渲染这个组件，因此使用 useMemo 来避免每次 render 的时候重新计算 resolvedValue，导致它的引用发生改变，从而使下游组件 re-render 这个担忧是正确的，但是使用 useMemo 之前，我们应该先思考两个问题 传递给 useMemo 的函数开销大不大？ 在上面的例子中，就是考虑 getResolvedValue 函数的开销大不大，JavaScript 中大多数方法都是优化过的，比如 Array.map、Array.forEach 等，如果你执行的操作开销不大，那么就不需要记住返回值，否则使用 useMemo 本身的开销就可能超过重新计算这个值的开销，因此对于一些简单的 JavaScript 运算来说，我们不需要使用 useMemo 来记住它的返回值 当输入相同时，记忆的值的引用是否会发生改变？ 在上面的例子中，就是当 page 和 type 相同时，resolvedValue 的引用是否会发生改变？这里我们就需要考虑 resolvedValue 的类型了，如果 resolvedValue 是一个对象，由于我们项目上使用『函数式编程』，每次函数调用都会产生一个新的引用，但是如果 resolvedValue 是一个原始值（string，boolean，null，undefined，number，symbol），也就不存在『引用』的概念了，每次计算出来的这个值一定是相等的，也就是说 ExpensiveComponent 组件不会被重新渲染 因此，如果 getResolvedValue 的开销不大，并且 resolvedValue 返回一个字符串之类的原始值，那我们完全可以去掉 useMemo，就像下面这样 1234const Example = ({ page, type }) =&gt; { const resolvedValue = getResolvedValue(page, type) return &lt;ExpensiveComponent resolvedValue={resolvedValue} /&gt;} 还有一个误区就是对创建函数开销的评估，有的人觉得在 render 中创建函数可能会开销比较大，为了避免函数多次创建，使用了 useMemo 或者 useCallback，但是对于现代浏览器来说，创建函数的成本微乎其微 因此我们没有必要使用 useMemo 或者 useCallback 去节省这部分性能开销，当然如果是为了保证每次 render 时回调的引用相等，你可以放心使用 useMemo 或者 useCallback 12345678const Example = () =&gt; { // 考虑这里的 useCallback 是否必要 const onSubmit = useCallback(() =&gt; { doSomething() }, []) return &lt;form onSubmit={onSubmit}&gt;&lt;/form&gt;} 其实通常来说在这里可能会存在一些争议，那就是如果只是想在重新渲染时保持值的引用不变，除了可以使用 useMemo 外，还可以使用 useRef，那么它们两者之间有什么区别呢？ 1234567891011// 使用 useMemoconst Example = () =&gt; { const users = useMemo(() =&gt; [1, 2, 3], []) return &lt;ExpensiveComponent users={users} /&gt;}// 使用 useRefconst Example = () =&gt; { const { current: users } = useRef([1, 2, 3]) return &lt;ExpensiveComponent users={users} /&gt;} 在上面的例子中，我们用 useMemo 来『记住』users 数组，不是因为数组本身的开销大，而是因为 users 的引用在每次 render 时都会发生改变，从而导致子组件 ExpensiveComponent 重新渲染（可能会带来较大开销） 虽然在 React 中 useRef 和 useMemo 的实现有一点差别，但是当 useMemo 的依赖数组为空数组时，它和 useRef 的开销可以说相差无几，useRef 甚至可以直接用 useMemo 来实现，就像下面这样 123const useRef = v =&gt; { return useMemo(() =&gt; ({ current: v }), [])} 因此，使用 useMemo 或者是 useRef 都可以用来保持值的引用一致 我们在编写自定义 Hook 时，返回值一定要保持引用的一致性，因为你无法确定外部要如何使用它的返回值，如果返回值被用做其他 Hook 的依赖，并且每次 re-render 时引用不一致（当值相等的情况），就可能就会产生问题，比如 12345678910111213141516171819202122232425const useData = () =&gt; { // 获取异步数据 const resp = getAsyncData([]) // 处理获取到的异步数据，这里使用了 Array.map // 因此即使 data 相同，每次调用得到的引用也是不同的 const mapper = data =&gt; data.map(item =&gt; ({ ...item, selected: false })) return resp ? mapper(resp) : resp}const Example = () =&gt; { const data = useData() const [dataChanged, setDataChanged] = useState(false) useEffect(() =&gt; { // 当 data 发生变化时，调用 setState // 如果 data 值相同而引用不同，就可能会产生非预期的结果 setDataChanged(prevDataChanged =&gt; !prevDataChanged) }, [data]) console.log(dataChanged) return &lt;ExpensiveComponent data={data} /&gt;} 在上面的例子中，我们通过 useData Hook 获取了 data，每次 render 时 data 的值没有发生变化，但是引用却不一致，如果把 data 用到 useEffect 的依赖数组中，就可能产生非预期的结果，另外由于引用的不同，也会导致 ExpensiveComponent 组件 re-render，产生性能问题 如果因为 prop 的值相同而引用不同，从而导致子组件发生 re-render，不一定会造成性能问题，因为 Virtual DOM re-render 并不等同于 DOM re-render，但是当子组件特别大时，Virtual DOM 的 Diff 开销也很大，因此还是应该尽量避免子组件 re-render 所以在使用 useMemo 之前，我们不妨先问自己几个问题 要记住的函数开销很大吗？ 返回的值是原始值吗？ 记忆的值会被其他 Hook 或者子组件用到吗？ 下面我们就来看看 useMemo 的具体使用场景 应该使用 useMemo 的场景 保持引用相等 对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo 自定义 Hook 中暴露出来的 object、array、函数等，都应该使用 useMemo，以确保当值相同时，引用不发生变化 使用 Context 时，如果 Provider 的 value 中定义的值（第一层）发生了变化，即便用了 Pure Component 或者 React.memo，仍然会导致子组件 re-render，这种情况下，仍然建议使用 useMemo 保持引用的一致性 成本很高的计算 比如 cloneDeep 一个很大并且层级很深的数据 无需使用 useMemo 的场景 如果返回的值是原始值 string、boolean、null、undefined、number、symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo 仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo 一些好的实践方式 若 Hook 类型相同，且依赖数组一致时，应该合并成一个 Hook，否则会产生更多开销 12345678910111213const dataA = useMemo(() =&gt; { return getDataA()}, [A, B])const dataB = useMemo(() =&gt; { return getDataB()}, [A, B])// 应该合并为 ==&gt;const [dataA, dataB] = useMemo(() =&gt; { return [getDataA(), getDataB()]}, [A, B]) 参考原生 Hooks 的设计，自定义 Hooks 的返回值可以使用 Tuple 类型，更易于在外部重命名，但如果返回值的数量超过三个，还是建议返回一个对象 12345678910export const useToggle = (defaultVisible: boolean = false) =&gt; { const [visible, setVisible] = useState(defaultVisible) const show = () =&gt; setVisible(true) const hide = () =&gt; setVisible(false) return [visible, show, hide] as [typeof visible, typeof show, typeof hide]}// 在外部可以更方便地修改名字const [isOpen, open, close] = useToggle()const [visible, show, hide] = useToggle() ref 不要直接暴露给外部使用，而是提供一个修改值的方法 在使用 useMemo 或者 useCallback 时，确保返回的函数只创建一次，也就是说，函数不会根据依赖数组的变化而二次创建，举个例子 123456789101112131415export const useCount = () =&gt; { const [count, setCount] = useState(0) const [increase, decrease] = useMemo(() =&gt; { const increase = () =&gt; { setCount(count + 1) } const decrease = () =&gt; { setCount(count - 1) } return [increase, decrease] }, [count]) return [count, increase, decrease]} 在 useCount Hook 中，count 状态的改变会让 useMemo 中的 increase 和 decrease 函数被重新创建，由于闭包特性，如果这两个函数被其他 Hook 用到了，我们应该将这两个函数也添加到相应 Hook 的依赖数组中，否则就会产生问题，比如 12345678910111213141516const Counter = () =&gt; { const [count, increase] = useCount() useEffect(() =&gt; { const handleClick = () =&gt; { // 执行后 count 的值永远都是 1 increase() } document.body.addEventListener('click', handleClick) return () =&gt; { document.body.removeEventListener('click', handleClick) } }, []) return &lt;h1&gt;{count}&lt;/h1&gt;} 在 useCount 中，increase 会随着 count 的变化而被重新创建，但是 increase 被重新创建之后，useEffect 并不会再次执行，所以 useEffect 中取到的 increase 永远都是首次创建时的 increase，而首次创建时 count 的值为 0，因此无论点击多少次，count 的值永远都是 1 既然这样的话，那把 increase 函数放到 useEffect 的依赖数组中不就好了吗？事实上，这会带来更多问题 首先 increase 的变化会导致频繁地绑定事件监听，以及解除事件监听 其次需求是只在组件 mount 时执行一次 useEffect，但是 increase 的变化会导致 useEffect 多次执行，不能满足需求 那么我们如何解决这些问题呢？有下面两种方式 通过 setState 回调，让函数不依赖外部变量，例如 1234567891011121314151617export const useCount = () =&gt; { const [count, setCount] = useState(0) const [increase, decrease] = useMemo(() =&gt; { const increase = () =&gt; { setCount(latestCount =&gt; latestCount + 1) } const decrease = () =&gt; { setCount(latestCount =&gt; latestCount - 1) } return [increase, decrease] // 保持依赖数组为空，这样 increase 和 decrease 方法都只会被创建一次 }, []) return [count, increase, decrease]} 通过 ref 来保存可变变量，例如 12345678910111213141516171819202122export const useCount = () =&gt; { const [count, setCount] = useState(0) const countRef = useRef(count) useEffect(() =&gt; { countRef.current = count }) const [increase, decrease] = useMemo(() =&gt; { const increase = () =&gt; { setCount(countRef.current + 1) } const decrease = () =&gt; { setCount(countRef.current - 1) } return [increase, decrease] // 保持依赖数组为空，这样 increase 和 decrease 方法都只会被创建一次 }, []) return [count, increase, decrease]} 总结最后的最后，我们再来将上面涉及到的内容整体的回顾一下 将完全不相关的 state 拆分为多组 state 如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state 依赖数组的值最好不要过多，如果发现依赖数组依赖的值过多，我们应该采取一些方法来减少它 去掉不必要的依赖 将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组 通过合并相关的 state，将多个依赖值聚合为一个 通过 setState 回调函数获取最新的 state，以减少外部依赖 通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径 应该使用 useMemo 的场景 保持引用相等 成本很高的计算 无需使用 useMemo 的场景 如果返回的值是原始值，一般不需要使用 useMemo 仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo 若 Hook 类型相同，且依赖数组一致时，应该合并成一个 Hook 自定义 Hook 的返回值可以使用 Tuple 类型，更易于在外部重命名，如果返回的值过多，则不建议使用 ref 不要直接暴露给外部使用，而是提供一个修改值的方法 在使用 useMemo 或者 useCallback 时，可以借助 ref 或者 setState callback，确保返回的函数只创建一次，也就是说，函数不会根据依赖数组的变化而二次创建","link":"/2021/04/18/React/21/"},{"title":"Vite 的工程化流程","text":"最近在学习 Vue 3 的相关内容，而在 Vue 3 当中则采用了 Vite 来作为构建工具，所以在这里简单的梳理一下 Vite 的相关内容，也算是记录一下 什么是 ViteVite 是一款开发构建工具，在开发期，它是利用浏览的 Native ES Modules 特性来导入并且组织代码，生产环境中则是利用 Rollup 作为打包工具，它主要有以下几个特点 启动速度很快 热模块替换 按需编译 安装和使用的方式十分简单，并不需要过多的配置，安装流程如下 1npm install -g create-vite-app 安装完成以后我们就可以使用它来初始化我们的 Vue 3 项目 1234567$ npm init vite-app &lt;project-name&gt;$ cd &lt;project-name&gt;$ npm install$ npm run dev 代码组织方式这里我们来借助上面默认初始化完成以后的项目来进行简单的结构梳理，首先先从入口文件开始看起，也就是我们的 index.html，它在代码当中的引入方式是下面这样的 1&lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt; 这里可以发现，我们引用了 /src/main.js 这个文件，但是是使用了 type=&quot;module&quot; 的方式来进行引用，我们再来看看 main.js 12345import { createApp } from 'vue'import App from './App.vue'import './index.css'createApp(App).mount('#app') 我们先来简单的梳理几个可能会有疑惑的地方，首先就是这里直接采用了裸模块的方式直接进行了引用，也就是 import { createApp } from 'vue' 这样的使用方式，我们在上面也提到过，Vite 是利用浏览的 Native ES Modules 特性来导入并且组织代码，但是浏览器是如何知道这个文件具体是在什么位置的呢？ 另外对于 import App from './App.vue' 这样的相对路径的引入方式我们很熟悉，但是它又是如何解析 App.vue 这样的文件的呢？同理下面的 index.css 也是一样的道理，也许它是一个纯的 CSS，但是如果是使用了预编译器的 Sass，那又该如何对它进行处理呢？ 关于上面的这些疑问，我们可以在项目启动以后，借助 Chrome 浏览的开发者工具当中的 Network 标签来进行分析，我们先来看它的加载过程，这里我们主要关注以下几个文件的加载解析过程，它们按序加载的顺序如下 localhost main.js vue.js App.vue index.css?import HelloWorld.vue App.vue?type=template 一开始首先加载 localhost，也就是请求本地服务器上的 index.html，它发现内部引用了 main.js，所以又发送了另外一条请求去请求该文件，但是我们可以发现，现在返回的 main.js 有了一些变化，如下所示 12345import { createApp } from '/@modules/vue.js'import App from '/src/App.vue'import '/src/index.css?import'createApp(App).mount('#app') 我们可以发现，返回的路径在 Vite 的处理下变成了 '/@modules/vue.js'，所以此时浏览器便会再次发送请求，去请求一个相对路径下的 vue.js，所以就会去 node_modules 下寻找 vue 文件夹，接下来就会去访问 vue 文件夹下的 package.json，如下 123456789// node_modules/vue/package.json{ // ... \"main\": \"index.js\", \"module\": \"dist/vue.runtime.esm-bundler.js\", // ...} 通过 package.json 我们可以知道，所谓的入口文件也就是 vue.runtime.esm-bundler.js 这个文件，从命名上我们也可以看出，就是一个运行时的使用 ES 模块来打包的 vue 版本 所以我们在调用了 import { createApp } from '/@modules/vue.js' 这行代码以后就相当于在我们的代码当中从 vue 当中导出了 createApp 这个方法，然后就可以在后续过程当中执行 createApp(App).mount('#app') 来进行程序的创建了 接下来我们再来看看 import App from '/src/App.vue' 这一行，因为是相对路径，所以会去请求当前目录下的 App.vue，我们来对比看一下它的先后变化，首先是我们代码当中实现的 App.vue，如下 123456789101112131415&lt;template&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt; &lt;HelloWorld msg=\"Hello Vue 3.0 + Vite\" /&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from './components/HelloWorld.vue'export default { name: 'App', components: { HelloWorld }}&lt;/script&gt; 而下面则是经过 Vite 处理后返回的 App.vue 123456789101112131415import HelloWorld from '/src/components/HelloWorld.vue'const __script = { name: 'App', components: { HelloWorld }}import { render as __render } from '/src/App.vue?type=template'__script.render = __render__script.__hmrId = '/src/App.vue'typeof __VUE_HMR_RUNTIME__ !== 'undefined' &amp;&amp; __VUE_HMR_RUNTIME__.createRecord(__script.__hmrId, __script)__script.__file = '/path/src/App.vue'export default __script 可以发现，我们之前所写的 &lt;template&gt;&lt;/template&gt;，&lt;script&gt;&lt;/script&gt; 等相关代码全部被经过了一次编译，然后将它们组合，输出最终的代码，而返回的最终代码也就如上所示，简单梳理一下就是 首先将我们的路径替换成了相对路径 '/src/components/HelloWorld.vue' 之前 export default { } 的部分变成了一个名为 __script 的组件配置对象 通过请求 App.vue 引入了 render 函数，但是添加了 type=template 的查询参数，这样 Vite 就会对这个请求做特殊处理，也就是解析 &lt;template&gt;&lt;/template&gt; 这个模板，将其变成渲染函数 得到渲染函数以后，再将其合并到我们之前的组件配置对象当中 以上就是任务的整个流程，剩余的一些都是一些标识文件，这里我们就不过多探讨了，然后最后将我们的组件配置对象导出 其实简单总结的话就是『解析当前组件，并且把我们的最终解析结果导出』，所以这样一来 App.vue 就变成了一个组件配置对象返回到了前台，所以我们在使用这个组件配置对象的时候就可以正常的去使用了 小结最后我们来简单的总结一下上面梳理的内容，从开头部分开始说起，关键变化的是 index.html 中的入口文件的导入方式 1&lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt; 这样 main.js 中就可以使用 ES6 Module 的方式来组织代码 123import { createApp } from 'vue'import App from './App.vue'import './index.css' 浏览器会自动加载这些导入，Vite 会启动一个本地服务器处理这些不同的加载请求 对于相对地址的导入，要根据后缀名处理文件内容并返回 而对于裸模块导入要修改它的路径为相对地址并再次请求处理 123import { createApp } from '/@modules/vue.js'import App from '/src/App.vue'import '/src/index.css?import' 资源加载下面我们再来看看 Vite 当中的资源加载，也就是图片，CSS 等一些静态资源是如何处理的，这也是工程化当中的一个十分重要的点 CSS 文件导入Vite 中可以直接导入 CSS 文件，样式将影响导入的页面，还是以我们的 main.js 为例，它是以全局的方式进行引入的 123import { createApp } from 'vue'import App from './App.vue'import './index.css' 同 JavaScript 的处理方式类似，Vite 会对这个 CSS 进行开发阶段的预处理，将其转换成 JavaScript 代码，然后热更新到界面当中，但是需要注意的是，最后还是会被打包到 style.css 当中，下面是处理后的 main.js 文件当中的引入方式 1import '/src/index.css?import' 可以发现，针对于 CSS 的处理，添加了 import 的标识，再来看看现在的 index.css 的样子，如下 1234import { updateStyle } from \"/vite/client\"const css = \"#app {\\n font-family: Avenir, Helvetica, Arial, sans-serif;\\n -webkit-font-smoothing: antialiased;\\n -moz-osx-font-smoothing: grayscale;\\n text-align: center;\\n color: #2c3e50;\\n margin-top: 60px;\\n}\\n\"updateStyle(\"\\\"2418ba23\\\"\", css)export default css 可以发现，其实最终的处理是以 JavaScript 的形式传递到前端，下面我们再来看看 CSS Module 的使用方式 CSS Module我们除了在模版当中的 style 里直接定义对应 class 的样式以外，还可以使用 Module 的方式，我们通常的使用方式是下面这样的 123456789&lt;template&gt; &lt;img class=\"img\" alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt;&lt;/template&gt;&lt;style scoped&gt; .img { width: 500px; }&lt;/style&gt; 但是我们可以将其调整为 CSS Module 的形式，这样一来我们的 CSS 在将来编译的时候会将我们的 style 变成计算属性，所以在模板当中使用的时候就不再是使用单纯的 class 了，而是使用 $style 来进行使用，也就是下面这样的使用方式 123456789&lt;template&gt; &lt;img :class=\"$style.img\" alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt;&lt;/template&gt;&lt;style module&gt; .img { width: 500px; }&lt;/style&gt; 运行以后可以发现，结果是和上面是一致的，并且最终生成的样式结果当中会自动帮助我们加上 hash，也就是下面这样的 1&lt;img class=\"img_7ac74a55\" alt=\"Vue logo\" src=\"/src/assets/logo.png\"&gt; 而这也是模块化带来的好处，因为有 hash 的存在，所以我们也不用担心它未来会重名，而这也是与使用 scoped 的区别 不过这里需要注意的一点就是，如果我们之前定义的 class 是使用 - 命名的话，则需要将其调整为驼峰命名，另外如果需要在 JavaScript 当中导入 CSS Module，只需要将 CSS 文件命名为 *.module.css，这样一来 Vite 也会自动对其进行模块化的处理 12345678910import style from './HelloWorld.module.css'export default { emits: ['close'], computed: { $style() { return style } }} PostCSSVite 自动会对 *.vue 文件和导入的 .css 文件应用 PostCSS 配置，我们只需要安装必要的插件和添加 postcss.config.js 文件即可 12345module.exports = { plugins: [ require('autoprefixer') ]} 这里需要注意的一个地方就是，如果需要安装 autoprefixer 这个插件，最好保持和 PostCSS 相同的版本，否则会有不兼容的错误提示 资源 URL 处理我们可以在 *.vue 文件的 &lt;template&gt;，&lt;style&gt; 和纯的 .css 文件当中以相对和绝对路径方式引用静态资源，我们先来看看静态资源如何引用的 12345&lt;!-- 相对路径 --&gt;&lt;img src=\"./assets/logo.png\" /&gt;&lt;!-- 绝对路径 --&gt;&lt;img src=\"/src/assets/logo.png\" /&gt; 另外一个就是 public 目录，public 目录下可以存放未在源码中引用的资源，它们会被留下且文件名不会有哈希处理，这些文件会原封不动的拷贝到发布目录的根目录下 1&lt;img src=\"./logo.png\"&gt; 但是需要注意的是，引用放置在 public 下的文件需要使用绝对路径，例如 public/icon.png 应该使用 /icon.png 进行引用 eslint其实在 Vite 当中使用 eslint 并不会对我们进行约束，该怎么配置还是怎样配置，通常我们借助 eslint 规范项目代码，通过 prettier 做代码格式化，所以我们就需要进行两部分配置，而且我们希望两者是相匹配的，因为如果不匹配的话，在我们格式化以后是通过不了 eslint 的检查，这样就会引起很多的麻烦，下面我们来看看如何进行配置，首先在项目当中安装依赖，package.json 如下 12345678910111213{ \"scripts\": { \"lint\": \"elint \\\"src/**/*.{js,vue}\\\"\" }, \"devDependencies\": { \"@vue/elint-config-prettier\": \"^6.0.0\", \"babel-eslint\": \"^10.1.0\", \"eslint\": \"^6.7.2\", \"eslint-plugin-prettier\": \"^3.1.3\", \"eslint-plugin-vue\": \"^7.0.0-0\", \"prettier\": \"^1.19.1\" }} 接下来就是进行 lint 的规则配置，主要有两种方式，一种是采用 .eslintrc 的方式，也就是没有后缀的形式，但是这种方式需要写 JSON，它的好处是代码提示很好，并且如果安装了 eslint 扩展可以很好的帮助我们来进行提示有哪些项是可以选择的，可以使用的 另外一种是采用 .eslintrc.js 的方式，也就是带后缀的方式，它的好处是可以在配置文件当中加上一些动态的配置，比如环境变量等，这里我们采用带有后缀的方式，如下 123456789101112131415161718192021222324module.exports = { root: true, env: { node: true }, // 引入三个扩展，一个是 vue3 核心的 lint 规则，exlint 的建议规则 和 prettier 建议的规则 extends: ['plugin: vue/vue3-essential', 'eslint: recommended', ' @vue/prettier'], parserOptions: { parser: 'babel-eslint' }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', 'prettier/prettier': [ 'warn', { // 一些冲突项可以自定义设定 // singleQuote: true, // semi: false, trailingComma: 'es5 ', }, ], }} 另外如果有必要我们还可以配置 prettier.config.js 来修改 prettier 的默认格式化规则，因为开发工具的不一致可能导致格式化后的结果不一致，所以我们将其配置成一致的 1234567891011module.exports = { printWidth: 80, // 毎行代长度（默认 80） tabWidth: 2, // 每个 tab 相当于多少个空格（默认 2） useTabs: false, // 是否使用 tab 进行缩进（默认 false） singleQuote: true, // 使用单引号（默认 false） semi: true, // 声明结尾使用分号（默认 true） trailingComma: 'es5', // 多行使用拖尾逗号（默认 none），es5 表示只针对对象或数组才使用 bracketSpacing: true, // 对象字面量的大阔好间使用空格（默认 true） jsxBracketSameLine: false, // 多行 jsx 中的 &gt; 放置在最后一行的结尾，而不是另起一行（默认 false） arrowParens: 'avoid', // 只有一个参数的箭头函数的参数是否带圆括号（默认 avoid）} 测试当我们当项目规模变大，或者我们在写一些通用组件的时候，我们肯定需要实现一些测试，避免一些新的调整影响到了之前的代码，下面我们就来看看如何在 Vite 项目当中配置测试 这里我们采用的是 jest 测试框架和针对于组件测试的 @vue/test-utils，我们先来看看需要安装哪些依赖，如下 1234567{ \"jest\": \"^24.0.0\", // 包括测试运行库和断言库 \"vue-jest\": \"^5.0.0-alpha.3\", // 测试组件 \"babel-jest\": \"^26.1.0\", // 语法转换 \"@babel/preset-env\": \"^7.10.4\", // 配合 babel 转换 \"@vue/test-utils\": \"^2.0.0-beta.9\" // 测试套件} 依赖安装完成以后我们还需要配置 babel.config.js 1234567891011module.exports = { presets: [ [ '@babel/preset-env', { targets: { node: 'current' } } ] ]} 然后再来配置 jest.config.js 12345678910111213module.exports = { testEnvironment: 'jsdom', // 转换 transform: { '^.+\\\\.vue$': 'vue-jest', '^.+\\\\js$': 'babel-jest', }, moduleFileExtensions: ['vue', 'js', 'json', 'jsx', 'ts', 'tsx', 'node'], testMatch: ['**/tests/**/*.spec.js', '**/__tests__/**/* .spec.js'], moduleNameMapper: { '^main(.*)$': '&lt;rootDir&gt;/src$1', }} 启动脚本为 12// runInBand 代表按照序列的方式来执行\"test\": \"jest --runInBand\" 最后就是我们的测试代码，因为我们在上面配置了测试目录，所以我们直接将其放置在 tests/example.spec.js 目录下 12345678910111213import HelloWorld from 'main/components/HelloWorld.vue'import { shallowMount } from 'vue/test-utils'describe('aaa', () =&gt; { test('should', () =&gt; { const wrapper = shallowMount(HelloWorld, { props: { msg: 'hello, vue3', }, }) expect(wrapper.text()).toMatch('hello, vue3') })}) 另外需要注意的就是我们还需要在 lint 配置当中添加 jest 环境 12345module. exports = { env: { jest: true }} 完成以后就可以来执行我们的测试代码了 1npm run test 但是这样我们每次都需要手动执行命令来进行测试，所以我们可以将 lint，test 和 git 挂钩起来，让其每次在提交代码之前自动执行测试，首先我们需要来安装两个插件 1npm install lint-staged yorkie -D 接着需要在 package.json 当中添加配置 12345678910// yorkie 的配置项，监控我们的提交// commit 之前执行 lint-staged，也就是代码检查// push 之前去执行我们的测试\"gitHooks\": { \"pre-commit\": \"lint-staged\", \"pre-push\": \"npm run test\"},\"lint-staged\": { \"*.{js, vue}\": \"eslint\"} 这样一来，在我们提交代码之前就会自动的执行检查与测试，只有全部通过以后才会正常的提交 TypeScript 的整合其实在 Vite 当中我们是可以直接导入 .ts 的文件来进行使用的，即直接在模版文件当中通过添加 &lt;script lang=&quot;ts&quot;&gt; 来进行使用，如下 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=\"item in list\" :key=\"item.id\"&gt;{{ item.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import { defineComponent, ref } from 'vue'interface Course { id: number, name: string}export default defineComponent({ setup() { const list = ref&lt;Course[]&gt;([]) setTimeout(() =&gt; { list.value.push({ id: 1, name: 'hello' }) }, 1000); return { list } }})&lt;/script&gt; 另外在我们使用过程当中，最好指定一下 TypeScript 的版本号 12345{ \"devDependencies\": { \"typescript\": \"^3.9.7\" }} 然后在加上 TypeScript 的相关配置即可 1234567891011121314{ \"compilerOptions\": { \"target\": \"esnext \", \"module\": \"esnext\", \"moduleResolution\": \"node\", \"isolatedModules\": true, \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"experimentalDecorators\": true, \"lib\": [\"dom\", \"esnext\"] }, \"exclude\": [\"node_modules\", \"dist\"]} 项目配置对于使用 Vite 构建的项目，我们只需要在项目的根目录下添加 vite.config.js 文件，即可针对项目进行深度配置，下面我们就来看看如何使用 定义别名我们通常在导入组件的时候，可能会像下面这样使用 1import HelloWorld from './components/HelloWorld.vue' 但在这样操作可能会出现大量相对路径，非常的不优雅和容易出错，所以我们可以通过导入别名的方式来进行简化，首先我们先来配置我们的 vite.config.js，如下 12345678const path = require('path')module.exports = { alias: { // 路径映射必须以 / 开头和结尾 \"/comps/\": path.resolve(__dirname, \"src/components\") }} 比如上面的配置就表示我们给 src/components 进行别名定义，这样一来我们在导入组件的时候就可以直接使用别名当中定义的方式 12345// 配置之前import HelloWorld from './components/HelloWorld.vue'// 配置之后import HelloWorld from '/comps/HelloWorld.vue' 代理配置下面我们再来看看代理服务器的配置，这个也是使用较多的一个配置，配置如下 12345678proxy: { '/api': { target: 'http://paoxy.com', changeOrigin: true, // 使用对象方式进行配置也可 rewrite: path =&gt; path.replace(/^\\/api/, '') }} 使用也很简单 123fetch('/api/users') .then(res =&gt; res.json()) .then(data =&gt; console.log(data)) 数据配置我们通常在开发过程当中会使用 mock 来进行数据模拟，下面我们来看看如何配置，首先安装依赖 1234npm i mockjs -S// 因为需要安装环境变量，所以我们加上 cross-env 这个库npm i vite-plugin-mock cross-env -D 依赖安装完成以后，我们就可以在我们的 vite.config.js 当中来进行插件配置 1234567891011const { createMockServer } = require('vite-plugin-mock')module.exports = { plugins: [ createMockServer({ // 由于该库默认支持 TS，所以项目不是使用 TS 开发的话就将其关掉 // 如果项目使用 TS 开发则无需配置这项 supportTs: false }) ]} 然后在 package.json 当中进行环境变量的配置，这个算是一个小坑，需要注意 123\"scripts\": { \"dev\": \"cross-env NODE_ENV=development vite\"}, 最后就可以来定义我们的 mock 数据了 123456789101112131415161718192021222324252627// mock/test.jsexport default [ { url: '/api/users', method: 'GET', response: req =&gt; { return { code: 0, data: [ { name: 'zhangsan' }, { name: 'lisi' } ] } } }, { url: '/api/post', method: 'POST', timeout: 2000, response: { code: 0, data: { name: 'zhangsan' } } },] 然后重启我们的服务，这时就可以在控制台当中看到以下信息 1[vite: mock-server]: request invoke: /api/users 说明此时已经检测到了我们的 mock 数据，这时我们就可以在浏览器当中来验证我们的数据了 模式和环境变量我们在使用模式做多环境配置的时候，vite serve 的模式默认是 development，而 vite build 的时候则是 production，所以我们可以针对开发环境来创建对应的配置文件，我们可以在根目录当中创建一个名为 .emv.development 的文件，其中包括的内容如下 12// 需要注意的是，需要在前面添加 VITE_ 才可以在代码中去使用这个变量VITE_TOKEN = this is token 这样在代码中我们就可以来使用它了，测试如下 1console.log(import.meta.env.VITE_TOKEN) 类似这样的方式我们还可以去配置 .emv.production 文件，这时候两种不同的配置就可以分别在这两种环境下生效 打包和部署打包的话很简单，直接执行如下命令即可 1npm run build 这里我们主要来看看部署方面的内容，当然我们可以使用类似 FTP，SSH 等工具直接连接到我们的服务器，然后将打包后的 dist 文件传上去即可，但是这里我们来看看如何使用自动化处理流程来避免前面的那些繁琐的操作，这里我们主要采用的是 GitHub 的 Actions 来实现 CI/CD 的过程 GitHub Actions 可以让我们在 GitHub 仓库中直接创建自定义的软件开发生命周期工作流程，如下图所示 待续","link":"/2021/03/07/Vue/06/"},{"title":"JavaScript 中的作用域","text":"在深入了解作用域之前，我们先来看看什么是变量提升 变量提升（Hoisting）我们通过一个例子来进行理解，如下 12345678910var a = 1function foo () { if (!a) { var a = 2 } alert(a)}foo() // 输出 2 之所以输出 2，这就是所谓的变量提升了，所谓声明变量 1var a 而定义变量 1var a = 1 声明，是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已 定义，是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义 总结下来就是 123var a // 这是声明a = 1 // 这是定义（赋值）var a = 1 // 合二为一，声明变量的存在并赋值给它 当你以为你只做了一件事情的时候（var a = 1），实际上解释器把这件事情分解成了两个步骤，一个是声明（var a），另一个是定义（a = 1），可以把之前的例子稍微转换一下，就成了如下 123456789101112var aa = 1function foo() { var a // 关键在这里 if (!a) { a = 2 } alert(a) // 此时的 a 并非函数体外的那个全局变量}foo() 如代码所示，在进入函数体后解释器声明了新的变量 a，所以当 !a 的时候，将为新的变量 a 赋值为 2，我们再来看一下函数当中的提升，同样我们也是通过一个例子来理解 12345678910111213141516171819// test1function test () { foo() function foo() { alert('出现') }}test()// test2function test () { foo() var foo = function() { alert('不会出现') }}test() 在第一个例子里，函数 foo 是一个声明，既然是声明就会被提升（特意包裹了一个外层作用域，因为全局作用域需要你的想象，不是那么直观，但是道理是一样的），所以在执行 foo() 之前，作用域就知道函数 foo 的存在了，这被称为函数声明（Function Declaration），函数声明会连通命名和函数体一起被提升至作用域顶部 然而在第二个例子里，被提升的仅仅是变量名 foo，至于它的定义依然停留在原处，因此在执行 foo() 之前，作用域只知道 foo 的命名，不知道它到底是什么，所以执行会报错（通常会是 foo is not a function），这被称为函数表达式（Function Expression），函数表达式只有命名会被提升，定义的函数体则不会 作用域（Scoping）JavaScript 在 ES6 之前是没有块级作用域的（Block Scoping），只有函数作用域（Function Scoping），并且函数的作用域在函数定义的时候就决定了，当解析器读到一个变量声明和赋值的时候，解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 Hoisting 在 ES6 之前，JavaScript 只有函数作用域 比如下面这个例子，若是想要 alert(a) 弹出那个 1，也可以创建一个新的作用域，就是利用 IIFE 123456789101112131415var a = 1function foo() { // 这个就是 IIFE，它会创建一个新的函数作用域 // 并且该作用域在 foo() 的内部，所以 alert 访问不到 // 不过这个作用域可以访问上层作用域，这就叫 闭包 if (!a) { (function() { var a = 2 }()) } alert(a) // 1}foo() 请始终保持作用域内所有变量的声明放置在作用域的顶部 因为这样可以避免 Hoisting 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问，但是，变量声明的提升并非 Hoisting 的全部，在 JavaScript 中，有四种方式可以让命名进入到作用域中（按优先级） 语言定义的命名，比如 this 或者 arguments，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 this 之类的，这样是没有意义的 形式参数，函数定义时声明的形式参数会作为变量被 hoisting 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了 函数声明，函数体内部还可以声明函数，不过它们也都是本地的了 变量声明，这个优先级其实还是最低的，不过它们也都是最常用的 Hosting 只提升了命名，没有提升定义 这里顺便简单的提及一下什么是 IIFE，也就是所谓的『立即执行函数』，那么为什么需要 IIFE 传统的方法啰嗦，定义和执行分开写 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window） 转变表达式的办法有很多，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了立即执行函数，一个简单的 IIFE 如下 123// 这里是故意换行，实际上可以和下面的括号连起来(function foo() {...})() 这就等价于 1234// 这就不是定义，而是表达式了var foo = function () {...}foo() 但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式 1(function foo(){...}()) 另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如 123456789101112131415!function foo() { // ...}()// or+function foo() { // ...}()// orvoid function () { // ...}() 所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的函数作用域，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了，如果你需要全局对象，可以传递给 IIFE 123void function (global) { // 在这里，global 就是全局对象了}(this) // 在浏览器里，this 就是 window 对象 执行上下文环境简单来说，函数『每被』调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数，需要注意一点，函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了 JavaScript 在执行一个代码段之前，都会进行这些『准备工作』来生成执行上下文，其中又分三种情况，分别是全局代码，函数体 和 Eval（不推荐使用这个，所以我们主要介绍前两种） 全局执行上下文环境在产生执行全局上下文时，浏览器通常会做以下三个准备工作 提取 var 声明的变量，并赋值（默认）为 undefined（变量提升） 提取声明式函数（function foo () {..}） 给 this 赋值（指向 window 或当前对象） 函数体上下文环境（也就是所谓的局部）会在以上三个的基础上增加以下三条 给函数参数赋值 给 arguments 赋值（是一个实参副本，与实参保持一致） 自由变量的取值作用域，查找并赋值 所以总结来说就是 在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空 而在执行 JavaScript 代码时，会有数不清的函数调用次数，自然就会产生许多个上下文环境，那么这么多的上下文环境该如何管理，以及如何销毁而释放内存呢？其实这个就主要依靠我们下面将会介绍到的『执行上下文栈』，不过在此之前，我们先来针对上面提到过的上下文环境在深入的了解一下 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明，JavaScript 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（VO），变量对象（Variable Object，缩写为 VO）是一个抽象概念中的对象，它用于存储执行上下文中的 变量 函数声明 函数参数 VO 一般是按照如下顺序填充的 函数参数（若为传入，初始化该参数值为 undefined） 函数声明（若发生命名冲突，会覆盖） 变量声明（初始化变量值为 undefined，若发生命名冲突，会忽略） 来看看以下几个实例，可以加深我们理解 VO 123456function foo (x, y, z) { alert(x) // function x () {} function x () {}}foo(100) 在初始化阶段，先初始化函数的参数，参数 x 即为传进来的参数，为 100，但是在处理函数声明的时候，发生冲突，x 会被覆盖，所以返回的是一个函数对象，我们将上面的示例稍微调整一下，如下 123456789101112131415// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略function foo(x, y, z) { function fn() { } var fn console.log(fn) // function fn () {}}foo(100)// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作function foo(x, y, z) { function fn() { } var fn = 1 console.log(fn) // 1}foo(100) 函数表达式不会影响 VO，比如 var a = function foo() { } 这里的 foo 是函数表达式的名称，这个是不会记录到 VO 中的，这也是为什么我们不能在外部通过 foo 来获取到这个函数对象，最后我们再来看一个比较容易出错的，巩固一下上面所介绍的，如下 123456789var num = 0function a() { num = 100 console.log(num)}a()console.log(num) 很明显，在执行了函数 a() 以后，将全局当中的 num 修改成了 100，所以两次输出均为 100，但是如果我们给函数 a() 添加一个参数呢，如下 123456789var num = 0function a(num) { num = 100 console.log(num)}a()console.log(num) // ? 这里就需要注意一下了，如果调整成这样的话，最后的结果依次为 100 和 0，而不再是两个 100 了 活动对象在函数上下文中，我们用活动对象（Activation Object，AO）来表示变量对象，活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问 只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 Activation Object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问，活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化，arguments 属性值是 Arguments 对象，举个例子 12345678function foo(a) { var b = 2 function c() { } var d = function () { } b = 3}foo(1) 在进入执行上下文后，这时候的 AO 是 12345678910AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){ }, d: undefined} 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值，当代码执行完后，这时候的 AO 是 12345678910AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){ }, d: reference to FunctionExpression 'd'} 我们来简单总结一下变量对象的创建过程 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 在看个例子加深一下 1234567891011function foo() { console.log(a) a = 1}foo() // ???function bar() { a = 1 console.log(a)}bar() // ??? 第一段会报错 Uncaught ReferenceError: a is not defined，第二段会打印 1，这是因为函数中的 a 并没有通过 var 等关键字声明，所有不会被存放在 AO 中，第一段执行 console 的时候，AO 的值是 12345AO = { arguments: { length: 0 }} 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错，当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1 执行上下文栈我们都知道在代码执行的时候，JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行，当执行一段代码的时候，会进行一个准备工作，就比如之前我们提到过的的变量提升和函数提升，这其实就是所谓的执行上下文 执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境，处于活动状态的执行上下文环境只有『一个』，其实简单来说，就是一个『压栈』==&gt;『出栈』的过程，如下图所示 压栈，函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈 出栈，函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境 注意，若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的），上面这种只是较为理想的情况，另外还存在一种情况是无法做到这样干净利落的说销毁就销毁，而这种情况就是闭包，但是关于闭包的内容我们会在后面另起篇幅来进行介绍，在代码执行过程中，JavaScript 引擎会创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，我们可以通过数组来进行模拟 1ECStack = [] 当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前，ECStack 最底部永远有个 globalContext 123ECStack = [ globalContext] 假设遇到下面这段代码 12345678910111213function fun3() { console.log('fun3')}function fun2() { fun3()}function fun1() { fun2()}fun1() 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出，所以我们可以尝试使用伪代码来描述上述过程 12345678910111213141516ECStack.push(&lt;fun1&gt; functionContext)// fun1 中调用了 fun2，创建 fun2 的执行上下文ECStack.push(&lt;fun2&gt; functionContext)// fun2 还调用了 fun3ECStack.push(&lt;fun3&gt; functionContext)// fun3 执行完毕ECStack.pop()// fun2 执行完毕ECStack.pop()// fun1 执行完毕ECStack.pop() 但是需要注意的是，JavaScript 虽然执行完毕了，但是 ECStack 底层永远有个 globalContext 作用域链在上面我们介绍 AO 部分概念的时候，我们曾经提到过，在查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象，这样由多个执行上下文的变量对象构成的链表就叫做『作用域链』 又因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，比如下面这个例子，函数创建时，各自的 [[scope]] 为 12345678910111213141516function foo() { function bar() { // ... }}// ==&gt;foo.[[scope]] = [ globalContext.VO]bar.[[scope]] = [ fooContext.AO, globalContext.VO] 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端，这时候执行上下文的作用域链，我们命名为 Scope 1Scope = [AO].concat([[Scope]]) 至此，作用域链创建完毕，下面我们便以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的，例子如下 123456var scope = 'global scope'function checkscope() { var scope2 = 'local scope' return scope2}checkscope() checkscope 函数被创建，保存作用域链到内部属性 [[scope]] 123checkscope.[[scope]] = [ globalContext.VO] 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext] checkscope 函数并不立刻执行，开始做准备工作，第一步，复制函数 [[scope]] 属性创建作用域链 123checkscopeContext = { Scope: checkscope.[[scope]],} 第二步，用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }， Scope: checkscope.[[scope]],} 第三步，将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }, Scope: [AO, [[Scope]]]} 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: 'local scope' }, Scope: [AO, [[Scope]]]} 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext]","link":"/2017/01/18/JavaScript/03/"},{"title":"BOM 和 DOM","text":"在网上经常会看到 ECMAScript，DOM，BOM 这几个概念，今天我们就来缕一缕它们到底是什么东西，其实简单来说，如下 核心（ECMAScript），提供核心语言功能 文档对象模型（Document Object Model，简称 DOM），提供访问和操作网页内容的方法和接口 浏览器对象模型（Broser Object Model，简称 BOM），提供与浏览器交互的方法和接口 简单的来说，DOM 和 BOM 并不属于 JavaScript（ECMAScript）语言的一部分，DOM 和 BOM 是 JavaScript 的运行平台（浏览器）提供的，比如在 Node.js 当中就没有 DOM 和 BOM，JavaScript 类型分为两大类，『原生类型』和『对象类型』，而 DOM 和 BOM 都是『对象类型』，下面我们就一个一个来进行了解 BOMBOM（Browser Object Model）即浏览器对象模型，主要是指一些浏览器内置对象如 window，location，navigator，screen，history 等对象，用于完成一些操作浏览器的特定 API，主要用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构 BOM 由多个对象组成，其中代表浏览器窗口的 window 对象是 BOM 的顶层对象，其他对象都是『该对象的子对象』 BOM 提供了独立于内容而与浏览器窗口进行交互的对象 由于 BOM 主要用于管理窗口与窗口之间的通讯，因此其核心对象是 window BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C BOM 最初是 Netscape 浏览器标准的一部分 BOM 结构如下图所示 从上图可以看出 DOM 是属于 BOM 的一个属性，window 对象是 BOM 的顶层（核心）对象，所有对象都是通过它延伸出来的，所以可以称它们为 window 的子对象，由于 window 是顶层对象，因此调用它的子对象时可以不显示的指明 window 对象，比如如下两种写法均可 12345document.title = '123'// ==&gt; 两者是等价的window.document.title = '123' BOM 导图BOM 部分主要是针对浏览器的内容，下面是一些比较常用的对象 window，是全局对象，很多关于浏览器的脚本设置都是通过它 location，则是与地址栏内容相关，比如想要跳转到某个页面，或者通过 URL 获取一定的内容 navigator，通常判断浏览器类型都是通过这个对象 screen，常常用来判断屏幕的高度宽度等 history，访问浏览器的历史记录，如前进、后台、跳转到指定位置 具体关系可以如下图所示 window 对象window 对象在浏览器中具有双重角色，它既是 ECMAscript 规定的全局 global 对象，又是 JavaScript 访问浏览器窗口的一个接口，所有浏览器都支持 window 对象，它表示浏览器窗口 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员 全局变量是 window 对象的属性，全局函数是 window 对象的方法 下面是一些常用的 window 方法 window.innerHeight，浏览器窗口的内部高度 window.innerWidth，浏览器窗口的内部宽度 window.open()，打开新窗口 window.close()，关闭当前窗口 window 的子对象下面我们来看看一些 window 的子对象 Navigator 对象浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息 1234567navigator.appName // Web 浏览器全称navigator.appVersion // Web 浏览器厂商和版本的详细字符串navigator.userAgent // 客户端绝大部分信息navigator.platform // 浏览器运行所在的操作系统navigator.userAgent // 用户代理字符串，用于浏览器监测中navigator.plugins // 浏览器插件数组，用于插件监测navigator.registerContentHandler // 注册处理程序，如提供 RSS 阅读器等在线处理程序 Screen 对象屏幕对象，一般不太常用，一些常见属性如下 screen.availWidth，可用的屏幕宽度 screen.availHeight，可用的屏幕高度 History 对象浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，只能简单的用来前进或后退一个页面，也可以使用 go() 实现在用户的浏览记录中跳转 1234history.go(-1) // 等价于 history.back()history.go(1) // 等价于 history.forward()history.back() // 后退一页history.forward() // 前进一页 Location 对象location 对象提供了当前窗口加载的文档的相关信息，还提供了一些导航功能，事实上这是一个很特殊的对象，location 既是 window 对象的属性，又是 document 对象的属性，window.location 对象用于获得当前页面的地址（URL），并把浏览器重定向到新的页面，常用属性和方法有 123location.href // 获取 URLlocation.href = 'xxx' // 跳转到指定页面location.reload() // 重新加载页面 弹出框可以在 JavaScript 中创建三种消息框，警告框、确认框、提示框 12345678// 警告框alert(123)// 确认框confirm('是否提交？')// 提示框prompt('请在下方输入收货地址', '收货地址') DOMDOM 是一套对文档的内容进行抽象和概念化的方法，当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），而 HTML DOM 模型会被构造为对象的树，如下图所示 DOM 模型将整个文档（XML 文档和 HTML 文档）看成一个树形结构，并用 document 对象表示该文档，DOM 规定 HTML 文档中的每个成分都是一个节点（node） 文档节点（Document），代表整个文档 元素节点（Element），文档中的一个标记 文本节点（Text），标记中的文本 属性节点（Attr），代表一个属性，元素才有属性 注释节点（Comment），表示注释 JavaScript 可以通过 DOM 创建动态的 HTML 可以改变页面中的所有 HTML 元素及其属性 可以改变页面中的所有 CSS 样式 可以对页面中的所有事件做出反应 节点类型使用 NodeType 属性来表明节点类型 节点类型 描述 1 Element 代表元素，普通元素节点，比如 div，p 等 2 Attr 代表属性 3 Text 代表元素或属性中的文本内容，文本节点 4 CDATASection 代表文档中的 CDATA 部分（不会由解析器解析的文本） 5 EntityReference 代表实体引用 6 Entity 代表实体 7 ProcessingInstruction 代表处理指令 8 Comment 代表注释，注释节点 9 Document 代表整个文档（DOM 树的根节点） 10 DocumentType 向为文档定义的实体提供接口 11 DocumentFragment 代表轻量级的 Document 对象，能够容纳文档的某个部分 12 Notation 代表 DTD 中声明的符号 节点关系 属性 描述 nodeType 返回节点类型的数字值（1 ~ 12） nodeName 节点名称 nodeValue 节点值 parentNode 父节点 parentElement 父节点标签元素 childNodes 所有子节点 children 第一层子节点 firstChild 第一个子节点，Node 对象形式 firstElementChild 第一个子标签元素 lastChild 最后一个子节点 lastElementChild 最后一个子标签元素 previousSibling 上一个兄弟节点 previousElementSibling 上一个兄弟标签元素 nextSibling 下一个兄弟节点 nextElementSibling 下一个兄弟标签元素 childElementCount 第一层子元素的个数（不包括文本节点和注释） ownerDocument 指向整个文档的文档节点 一些判断节点之间关系的方法 hasChildNodes()，包含一个或多个节点时返回 true contains()，如果是后代节点返回 true isSameNode() 和 isEqualNode()，传入节点与引用节点的引用为同一个对象返回 true compareDocumentPostion()，确定节点之间的各种关系 节点操作这一部分主要涉及节点相关的一些操作，也是在平常开发当中经常会遇到的地方，所以我们会介绍的稍微详细一些 操作 描述 nodeName 访问元素的标签名 tagName 访问元素的标签名 createElement() 创建节点 appendChild() 末尾添加节点，并返回新增节点 insertBefore() 参照节点之前插入节点，参数有两个，要插入的节点和参照节点 insertAfter() 参照节点之后插入节点，参数有两个，要插入的节点和参照节点 replaceChild() 替换节点，参数有两个，要插入的节点和要替换的节点（被移除） removeChild() 移除节点 cloneNode() 克隆，一个布尔值参数，true 为深拷贝，false 为浅拷贝 importNode() 从文档中复制一个节点，参数有两个，要复制的节点和布尔值（是否复制子节点） 有一个比较特殊的 insertAdjacentHTML()，作用是插入文本，参数有两个，插入的位置和要插入文本 beforebegin，在该元素前插入 afterbegin，在该元素第一个子元素前插入 beforeend，在该元素最后一个子元素后面插入 afterend，在该元素后插入 childNodes用来获取子节点，注意，返回的是一个『类数组对象』 1var childs = oDiv.childNodes 这里存在一个坑，比如如下 123456&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 当 div 中没有文本节点的时候，此时应该为 4 个节点，但是 IE9，Chrome，FireFox 会认为存在 9 个节点，而 IE8 则认为只有 4 个节点，这是因为高级浏览器会把空文本节点也当作为一个节点，标签前后的空文本也会被算作一个节点，而且对于注释的前后算不算空文本节点，每个浏览器的解释也有不相同，所以我们在使用节点的时候，一定要过滤，比如判断节点的 nodeType 是不是 1（普通元素节点） 12345678910// 得到真正的标签子节点function getRealChild(elem) { var result = [] for (var i = 0; i &lt; elem.childNodes.length; i++) { if (elem.childNodes[i].nodeType == 1) { result.push(elem.childNodes[i]) } } return result} 另外，如果要改变文本节点的内容（nodeType 为 3），需要改变其 nodeValue 属性 1oDiv.childNodes[0].nodeValue = '张三' parentNodeparentNode 属性表示父节点，任何节点的 parentNode 的 nodeType 一定为 1，也就是说父节点一定是标签节点 previousSibling 和 nextSibling表示一个兄弟节点，需要注意的是，其可能是文本或者注释节点，而原生 JavaScript 当中并没有提供 prevAll()，nextAll()，siblings() 等方法，如果不存在兄弟节点，则会返回 null，所以可以利用这个特性来写一个方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// prevfunction getRealPrev(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem // 循环遍历，将循环的结果再次赋予 o，依次向上查询 while (o = o.previousSibling) { if (o.nodeType == 1) { return o } return null }}// next，同 prev 类似，不过这次换成了后面function getRealNext(elem) { var o = elem while (o = o.nextSibling) { if (o.nodeType == 1) { return o } return null }}// prevAll，同 prev 类似，不过将遍历到的元素放到了一个结果数组当中function getRealprevAll(elem) { var o = elem, result = [] while (o = o.previousSibling) { if (o.nodeType == 1) { result.unshift(o) } return result }}// nextAllfunction getRealnextAll(elem) { var o = elem, result = [] while (o = o.nextSibling) { if (o.nodeType == 1) { result.push(o) } return result }} 而 siblings() 方法则可以使用双重循环来实现，比如下面这个方法 123456789101112function toggleActive() { var span = document.querySelectorAll('span') for (var i = 0; i &lt; span.length; i++) { span[i].addEventListener('click', function () { // 点击的时候清空所有，然后为当前选中的添加焦点 for (var j = 0; j &lt; span.length; j++) { span[j].classList.remove('active') } this.classList.add('active') }) }} 创建节点使用 document.createElement('标签名') 来创建一个节点，需要注意的是，创建出来的节点是不存在与 DOM 树上的，即孤儿节点，需要手动添加至 DOM 树中 1234var oBox = document.getElementById('div')var oDiv = document.createElement('div')oBox.appendChild(oDiv) 一个需要注意的地方，JavaScript 中存储 DOM 节点的变量是动态的，比如如下例子 123456789var oBox = document.getElementById('box')var oDiv = oBox.getElementsByTagName('div')// 会造成死循环，因为 oDiv.length 会动态增加for (var i = 0; i &lt; oDiv.length; i++) { var oP = document.createElement('p') oP.innerHTML = '123' oBox.appendChild(oP)} 解决方法很简单，用一个变量将 length 存储起来即可 123for (var i = 0; l = oDiv.length, i &lt; l; i++) { // ...} 插入节点appendChild()常用的方法是使用 appendChild() 来追加至元素的末尾，需要注意的地方就是，如果节点已经存在（比如 DOM 树中已经存在），而不是新创建的，这个时候则会移动该节点（不会克隆） insetBefore()接收两个参数，一个是新创建的元素，另一个为参照点 1oBox.insetBefore('新创建的元素', '参照元素') 这样插入的元素会以参照的元素依次往上添加（即添加的为 3，2，1参照），如果想让顺序变为正序，使用 oBox.childNodes[0] 为参照点即可 需要注意，如果使用 childNodes[0] 来做参照删除元素的话，会存在空白节点 删除节点节点不能自己删除，如果想要删除节点，必须使用父元素参照 1'父元素'.removeChild('删除的元素') 如果不知道父元素是谁，则可以使用 1'需要删除的元素'.parentNode.removeChild('需要删除的元素') 替换节点使用 replaceChild() 方法，一般使用的不是很多 1'父元素'.replaceChild('新节点', '旧节点') 比如 oBox.replaceChild(div1, div2) 结果是将 div1 节点处的内容替换至 div2 处（div1 处的节点内容就不存在了） 克隆节点比较常用的方式是使用 innerHTML 的方式来进行克隆（亦或是修改），但是执行效率没有 DOM 原生方法速度快，原生的方法是 cloneNode([true])，可以追加一个布尔值参数 true，表示深度克隆，克隆其所有的子节点 对象类型部分内容截取自 知乎 - justjavac 的回答，这里主要涉及到 ECMAScript 中的对象和 DOM/BOM 对象，我们在文章的开头部分提到过，JavaScript 类型分为原生类型和对象类型，而 DOM 和 BOM 都是对象类型，下面我们就来深入的了解一下 比如 HTML 中的段落 p 映射为 JavaScript 对象是 HTMLParagraphElement，顾名思义 Paragraph 就是英语段落的意思，我们看看 HTMLParagraphElement 的继承关系 123456HTMLParagraphElement - HTMLElement - Element - Node - EventTarget - Object 所有的 DOM 和 BOM 没有任何特殊之处，都是一个 Object 的子类 123456789// 创建一个 div domvar div = document.createElement('div')// 给 div 添加属性div.foo = 1234div.sayHello = function (str) { console.log('hello ' + str)} 当我们创建了一个 DOM Object 后，我们就可以把这个 DOM Object 当作一个普通的 JavaScript 对象来使用，说他特殊，大概是因为 DOM 的属性和方法会被引擎映射到 HTML 标签上，有些会，有些不会，有些只能从 HTML 到 DOM 映射，有些只能从 DOM 到 HTML 映射，如果但从对象的角度讲，特殊的不是 DOM 和 BOM，而是另一个值 1Object.create(null) 所有的 JavaScript 对象都是继承自 Object，即使我们经常创建的空对象也是 Object 的子类，如下 1let obj = { } 如下图所示 但是 Object.create(null) 却是实实在在的空对象 在引擎（V8）内部，DOM 对象映射为 C++ Object 而每个 HTML 标签都对应一个 DOM Object，我们看如下代码： 123456var div = document.createElement('div') // 创建一个 div domdiv.foo = 1234 // 给 div 添加属性var p = document.createElement('p') // 创建一个 p domp.appendChild(div) // 把 div 添加为 p 的子节点div = null // div 设置为空console.log(p.firstChild.foo) 可能我们会觉得最终输出的是 null 或者 undefined 亦或是抛出异常，但是这行代码会输出 1234，DOM 如何与 JavaScript Object 关联在一起的规范定义在 WebIDL Level 1 当中，WebIDL 就是 Web Interface Definition Language 的缩写，DOM Object 在引擎内部是一个 C++ Object，当 JavaScript 操作这个 DOM 时，引擎使用一个 wrapper object，也就是 JavaScript Object Wrapper Object 和 DOM Object 的关系是 n : 1（n &gt;= 0） 其中（n &gt;= 0） 当 n == 0 时，此 DOM Object 不能通过 JavaScript 访问 当 n == 1 时，此 DOM Object 只有一个 JavaScript Object 可以访问 当 n &gt; 1 时，此 DOM Object 可以通过多个 JavaScript 访问 举个例子 123div = document.createElement('div')div.innerHTML = '&lt;p&gt;&lt;span&gt;foo&lt;/span&gt;&lt;br&gt;&lt;/p&gt;'div.firstChild 上面代码的对应关系图 参考 知乎 - justjavac 的回答 ECMAScript、BOM、DOM（核心、浏览器对象模型与文档对象模型）","link":"/2017/11/17/JavaScript/16/"},{"title":"JavaScript 中的 this","text":"this 是 JavaScript 语言的一个关键字，它代表函数运行时自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是『调用函数的那个对象』 this 的调用方式在 JavaScript 中函数的调用有以下几种方式 为对象方法调用 作为函数调用 作为构造函数调用 使用 apply 或 call 调用 下面我们就按照调用方式的不同，分别来讨论各个情况当中的 this 含义 作为对象方法调用在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象 1234567891011var point = { x: 0, y: 0, moveTo: function (x, y) { this.x = this.x + x this.y = this.y + y }}// this 绑定到当前对象，即 point 对象point.moveTo(1, 1) 纯粹的函数调用函数也可以直接被调用，此时 this 绑定到全局对象，在浏览器中，window 就是该全局对象，比如下面的例子，函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的 123456function makeNoSense(x) { this.x = x}// 此时的 x 已经成为一个值为 5 的全局变量makeNoSense(5) 对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题，我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移，结果可能出乎意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y 12345678910111213141516171819202122var point = { x: 0, y: 0, moveTo: function (x, y) { var moveX = function (x) { this.x = x } var moveY = function (y) { this.y = y } moveX(x) moveY(y) }}point.moveTo(1, 1)point.x // ==&gt; 0 point.y // ==&gt; 0 x // ==&gt; 1 y // ==&gt; 1 内部函数中的 this 成为全局的了，为了规避这一设计缺陷，一般使用变量替代的方法，该变量常被命名为 that/_this/self 1234567891011121314151617181920var point = { x: 0, y: 0, moveTo: function (x, y) { var that = this var moveX = function (x) { that.x = x } var moveY = function (y) { that.y = y } moveX(x) moveY(y) }}point.moveTo(1, 1)point.x // ==&gt; 1 point.y // ==&gt; 1 一个简单的记忆方法，当函数当中嵌套函数就可能会形成闭包环境，这时的 this 指向就可能是 window 了 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（Object），实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已，包括内置对象函数在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用，实际上并不存在所谓的构造函数，只有对于函数的构造调用，使用 new 来调用函数，会自动执行以下操作 创建（或者说构造）一个全新的对象 这个新对象会被执行 [[原型]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数会自动返回这个新对象 这时 this 就指这个新对象， 如果不使用 new 调用，则和普通函数一样 123456789101112131415function C() { this.a = 37}var o = new C()console.log(o.a) // 37function C2() { this.a = 37 return { a: 38 } // 手动的设置了返回对象，与 this 绑定的默认对象被取消}o = new C2()console.log(o.a) // 38 使用 apply 或 call 调用apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，因此 this 指的就是这第一个参数 1234567891011121314function Point(x, y) { this.x = x this.y = y this.moveTo = function (x, y) { this.x = x this.y = y }}var p1 = new Point(0, 0)var p2 = { x: 0, y: 0 }p1.moveTo(1, 1)p1.moveTo.apply(p2, [10, 10]) 在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法，然后使用对象字面量创建了另一个对象 p2，需要注意此时的 p2 是没有 moveTo 这个方法的，但是我们可以使用 apply 来将 p1 的方法应用到 p2 上，这时候 this 也被绑定到对象 p2 上，另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的 注意，当使用过程中参数为空时，默认调用全局对象，也就是下面这种情况 123456function fun() { alert(this)}fun.call(null) // windowfun.call(undefined) // window 更为详细的内容可以参考规范当中的 Function.prototype.call() 四种方式的优先级如下所示，优先级从上往下 由 new 调用绑定到新创建的对象 如果是由 call 或者 apply（或者 bind）调用则绑定到指定的对象 如果是由上下文对象调用则绑定到那个上下文对象 默认：在严格模式下绑定到 undefined，否则绑定到全局对象 不太常见的调用方式上文介绍了 this 比较常见的几种调用方式，下面来看看一些不太常见的场景 原型链中的 this相同的概念在定义在原型链中的方法也是一致的，如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样 123456789101112var o = { f: function () { return this.a + this.b }}var p = Object.create(o)p.a = 1p.b = 4console.log(p.f()) // 5 对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型，但是这对于最终在 o 中找到 f 属性的查找过程来说没有关系，查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p，也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p getter 与 setter 中的 this作为 getter 或 setter 函数都会绑定 this 到从设置属性或得到属性的那个对象 1234567891011121314151617181920function modulus() { return Math.sqrt(this.re * this.re + this.im * this.im)}var o = { re: 1, im: -1, get phase() { return Math.atan2(this.im, this.re) }}Object.defineProperty(o, 'modulus', { enumerable: true, configurable: true, get: modulus})// -0.78... 1.4142...console.log(o.phase, o.modulus) DOM 事件处理函数中的 this当函数被用作事件处理函数时，它的 this 指向触发事件的元素，需要注意 IE 的 attachEvent() 中的 this 是指向 window 的（不过 IE11+ 已经支持 addEventListener()） 1234567891011121314151617// 被调用时，将关联的元素变成蓝色function bluify(e) { // 总是 true console.log(this === e.currentTarget) // 当 currentTarget 和 target 是同一个对象是为 true console.log(this === e.target) this.style.backgroundColor = '#A5D9F3'}// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('*')// 将 bluify 作为元素的点击监听函数，当元素被点击时，就会变成蓝色for (var i = 0; i &lt; elements.length; i++) { elements[i].addEventListener('click', bluify, false)} 内联事件处理函数中的 this当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素 123&lt;button onclick=\"alert(this.tagName.toLowerCase())\"&gt; Show inner this&lt;/button&gt; 上面的 alert 会显示 button，但是注意只有外层代码中的 this 是这样设置的，如果使用闭包（如下所示），则里面的 this 是指向 window/global 的 123&lt;button onclick=\"alert((function(){return this})())\"&gt; Show inner this&lt;/button&gt; 箭头函数中的 this下面我们在来看一种比较特殊的情况，即箭头函数当中的 this，不过在此之前，我们先来了解一下什么是箭头函数，箭头函数是 ES6 当中新增的一种比函数表达式更简洁的语法，比如下面这个例子 1234567const foo = val =&gt; console.log(val)// 等同于 ==&gt;function foo(val) { console.log(val)} 我们在这里主要关注箭头函数当中的 this 指向和它与普通函数之前的区别，所以关于箭头函数更为详细的内容可以参考 箭头函数 箭头函数与普通函数之间的差异主要涉及以下几点 因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向 没有 arguments，但是箭头函数可以访问外围函数的 arguments 对象 箭头函数不能用作构造器，和 new 一起用会抛出错误 因为不能使用 new 调用，所以也没有 new.target 值，也就没有 prototype 属性 没有原型，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 arguments、new.target 一样，这些值由外围最近一层非箭头函数决定 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内），因此箭头函数不能用作函数生成器 下面我们来着重看一下箭头函数当中的 this 没有 this箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，简单来说就是，箭头函数不会创建自己的 this，它会从自己的作用域链的上一层继承 this，比如下面这个例子，其中的 this 会正确地指向 p 实例 12345678function Person() { this.age = 0 setInterval(() =&gt; { this.age++ }, 1000)}var p = new Person() 但是这里需要注意，在严格模式下，与 this 相关的规则都将被忽略 123456789101112var foo = () =&gt; { 'use strict' return this}var bar = function () { 'use strict' return this}foo() === window // truebar() === undefined // true 最后我们来看一个小例子，下面的输出结果是什么 1(() =&gt; { console.log(this) }()) 运行以后可以发现，是会报错的，至于原因可以参考 这里，其实我们可以来把它还原一下就知道为什么了 1234567(() =&gt; { console.log(this) }())// ==&gt; 等同于(function f() { console.log(this) }())// ==&gt; 也就是function f() { console.log(this) } () 可以发现，其实写法是有问题的，至于解决办法，可以采用下面这种方式，用括号将函数包裹起来 1((() =&gt; { console.log(this) })()) 深入 this在前文部分，我们花了大量章节来对各个场景下的 this 做了介绍，总结了 this 在不同场景下的指向结果，但是都没有从根本上解释现象出现的原因，所以今天我们就借助 ECMAScript 规范 来深入的来了解一下，到底 this 是个什么东西，它是如何来进行定义的，在规范当中规定，ECMAScript 有三种可执行代码 全局代码（Global code） eval 代码（Eval code） 函数代码（Function code） 其中，对于全局代码直接指向 window，eval 代码由于已经不推荐使用我们就暂不做讨论，所以我们主要关注点就是函数代码中的 this 如何指定 函数调用规范指出，当执行流进入函数代码时，由函数调用者提供 thisArg 和 argumentsList，在 11.2.3 函数调用 当中我们可以发现，在函数调用发生时，首先会对『函数名部分进行计算』并赋值给 ref，并且通过一系列的判断就可以来决定 this 会指向何方，如下图所示 但是在展开之前，我们需要先来了解一下什么是 Reference Type(ref) is Reference在 8.7 引用规范类型 当中可知，Reference 的构成，由三个组成部分 base value，指向引用的原值 referenced name，引用的名称 strict reference flag，标示是否严格模式 简单来说就是，规范中定义了一种类型叫做 Reference，作用是用来引用其他变量，它有一个规定的数据结构，base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined，an Object，a Boolean，a String，a Number，or an Environment Record 其中的一种 词法环境为环境记录项 Environment Record 的组成，它是规范用来管理当前作用域下面变量的类型，了解即可 referenced name 就是属性的名称，比如 12345678var foo = 1// 对应的 Reference 为var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false} 又或者 1234567891011121314var foo = { bar: function () { return this }}foo.bar() // foo// bar 对应的 Reference 为var BarReference = { base: foo, propertyName: 'bar', strict: false} 而且规范中还提供了获取 Reference 组成部分的方法，方法有很多，但是这里我们仅仅关心下面这几个方法 GetBase(V)，返回 reference 的 base value IsPropertyReference(V)，如果 base value 是个对象或 HasPrimitiveBase 是 true，那么返回 true，否则返回 false 在这里，我们可以简单的理解为，如果其 base value 是一个对象，那么就返回 true HasPrimitiveBase(V)，如果 base value 是布尔，字符串，数值，那么返回 true GetValue在规范 8.7.1 GetValue(v) 当中提供了一个用于从 Reference 类型获取对应值的方法 GetValue，该方法会返回对象属性真正的值，简单来说就是 123456789var foo = 1var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false}GetValue(fooReference) // 1 但是要注意：调用 GetValue，返回的将是具体的值，而『不再是』一个 Reference（这个很重要，下面示例当中会多次用到） 下面我们就来正式的了解一下，如何确定 this 的值 确定 this 的值在 11.2.3 函数调用 当中，我们可以了解到可以如何来确定 this 的值，其实也就是上面图中所表达的意思，我们简单的总结一下就是 计算 MemberExpression 的结果赋值给 ref 判断 ref 是不是一个 Reference 类型 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true，那么 this 的值为 GetBase(ref) 如果 ref 是 Reference，并且 base value 值是 Environment Record，那么 this 的值为 ImplicitThisValue(ref) 如果 ref 不是 Reference，那么 this 的值为 undefined 下面我们对照上面提到的步骤，一步一步的详细来看 MemberExpression首先第一步就是计算 MemberExpression 的结果赋值给 ref，那么什么是 MemberExpression 呢？我们来看规范 11.2 左值表达式 12345PrimaryExpression // 原始表达式，最简单的表达式，JavaScript 的原始表达式包含常量或直接量、关键字和变量FunctionExpression // 函数定义表达式，var f = function() { ... }MemberExpression [ Expression ] // 属性访问表达式，用 [] 的方式访问值MemberExpression . IdentifierName // 属性访问表达式，用 . 的方式访问值new MemberExpression Arguments // 对象创建表达式，使用 new 好像是看到了 MemberExpression 的身影，我们通过几个例子来看看 1234567891011121314151617181920212223function foo() { console.log(this)}// MemberExpression 是 foofoo()function foo() { return function () { console.log(this) }}// MemberExpression 是 foo()foo()()var foo = { bar: function () { return this }}// MemberExpression 是 foo.barfoo.bar() 通过例子可以发现，其实可以简单的理解为，MemberExpression 其实就是 () 左边的部分 计算 Reference现在到了最关键的一步，即判断 ref 是不是一个 Reference 类型，如果知道了 Reference 的类型，那么我们就可以得出对应的 this 的值，还是老规矩，我们通过实际的示例来进行了解 1234567891011121314var value = 1var foo = { value: 2, bar: function () { return this.value }}console.log(foo.bar()) // 示例 1console.log((foo.bar)()) // 示例 2console.log((foo.bar = foo.bar)()) // 示例 3console.log((false || foo.bar)()) // 示例 4console.log((foo.bar, foo.bar)()) // 示例 5 根据之前的内容，我们可以知道 12345var Reference = { base: foo, name: 'bar', strict: false} 所以我们就依次来看上面的五个示例 foo.bar()第一个我们就慢慢来看，根据上面的流程可知，我们首先需要做的工作就是计算 MemberExpression 的结果，通过计算可以得出，第一个示例的 MemberExpression 的结果是 foo.bar，即是通过属性表达式来进行访问的，而我们在之前的左值表达式当中已经介绍过了，该表达式返回了一个 Reference 类型，所以我们第一步的工作已经完成了，即确定了它是 Reference 类型 有了 ref 以后，所以接下来我们就可以先来进行第一次的判断，即判断 IsPropertyReference(ref) 的值，通过之前的内容我们可以知道，如果 IsPropertyReference 的 base value 是一个对象，那么就返回 true，观察可知该示例的 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true，到了这一步，就不用继续往下走了，我们已经可以断定 this 的值了，也就是取 GetBase(ref)，而 GetBase(ref) 就是返回 reference 的 base value，所以 this 的值就是 foo 绕了一个大弯，我们终于知道了第一个示例的结果，不过既然已经知道了流程，那么剩下的解决起来就很快了 (foo.bar)()foo.bar 被 () 包住，通过 11.1.6 分组表达式 可知 返回执行 Expression 的结果，它可能是 Reference 类型 注：这一算法并不会作用 GetValue 于执行 Expression 的结果 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的 (foo.bar = foo.bar)()我们可以发现，在这个示例当中有赋值操作符，所以我们查看 11.13.1 简单赋值 可知 令 rval 为 GetValue(rref) 简单赋值语句返回的是针对 = 号右边进行 GetValue 之后的结果，又因为调用 GetValue 后，返回的值『不再是』一个 Reference，所以根据 MemberExpression 我们可以得出，如果 ref 不是 Reference，那么 this 的值为 undefined，这里需要注意，如果在非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象 (false || foo.bar)()同示例 3 类似，不过这里调用的不再是赋值操作，而是逻辑与算法，同样的，我们查看 11.11 二元逻辑运算符 可知 令 lval 为 GetValue(lref) 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()逗号操作符，我们查看 11.14 逗号运算符 可知 Call GetValue(lref) 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 结果汇总综上所述，示例的运行结果如下 1234567891011121314var value = 1var foo = { value: 2, bar: function () { return this.value }}console.log(foo.bar()) // 示例 1，结果为 2console.log((foo.bar)()) // 示例 2，结果为 2console.log((foo.bar = foo.bar)()) // 示例 3，结果为 1（这里需要注意，严格模式下因为 this 返回 undefined，所以示例 3 会报错）console.log((false || foo.bar)()) // 示例 4，结果为 1console.log((foo.bar, foo.bar)()) // 示例 5，结果为 1 此外，还有一个比较常见的情况 12345function foo() { console.log(this)}foo() 我们可以知道，MemberExpression 的结果 foo，通过 11.1.2 标识符引用 可知 执行遵循 10.3.1 所规定的标识符查找，标识符执行的结果总是一个 Reference 类型的值 继续查看 10.3.1 所代表的标识符解析可知 以 env、Identifier 和 strict 为参数，调用 GetIdentifierReference 函数，并返回调用的结果 继续查看 GetIdentifierReference，见 10.2.2.1 GetIdentifierReference(lex, name, strict) 返回一个类型为 Reference 的对象，其 base value 为 envRec，Reference 的名称为 name，严格模式标识的值为 strict 可以看到返回了一个 Reference，而 其 base value 是 envRec 也就是 10.3.1 中传入的 lex（execution context’s LexicalEnvironment），所以其抽象数据结构为下 12345var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false} 又因为 ref 是一个 Reference，但是其 base value 却是 EnvironmentRecord，并不是一个对象类型，所以不会走 IsPropertyReference(ref) 的判断，而是使用 ImplicitThisValue(ref) 来界定 this 的值，同样的查看 10.2.1.2.6 ImplicitThisValue() 可知 始终返回 undefined 作为其 ImplicitThisValue 所以最后 this 的值就是 undefined 总结经过上面的一些示例，我们可以大致总结出一个规律，其实最关键的就是判断返回值是不是 reference，如果不是，直接可以推出等于 window，如果是则只需要看是不是属性 reference，然后在进行判断，但是每次查询规范也有点麻烦，所以就有外国友人帮我们整理了一张速查表 Example Reference? Notes 'foo' No 123 No /x/ No ({}) No (function(){}) No foo Yes Could be unresolved reference if foo is not defined foo.bar Yes Property reference (123).toString Yes Property reference (function(){}).toString Yes Property reference (1,foo.bar) No Already evaluated, BUT see grouping operator exception (f = foo.bar) No Already evaluated, BUT see grouping operator exception (foo) Yes Grouping operator does not evaluate reference (foo.bar) Yes Ditto with property reference","link":"/2017/10/09/JavaScript/22/"},{"title":"JavaScript 的同步执行过程","text":"最后更新于 2020-05-24 在之前的文章当中，我们梳理了 JavaScript 中的作用域 和 JavaScript 中的闭包 相关内容，其中涉及到一些作用域链，[[Scopes]]，VO/AO 等可能理解起来比较隐晦的内容，所以在本章当中，我们就从头开始重新的梳理一下这方面的相关内容，也算是针对 JavaScript 当中的作用域以及闭包的一个更为深层次的梳理，下面就让我们来一起看看 JavaScript 当中的的执行过程到底是怎样的 这里在这里需要注意，本章当中我们主要关注的是 JavaScript 的同步执行过程，关于其异步执行过程的相关内容可以参考之前整理过的 JavaScript 并发模型 EC 概念结构我们在之前的 JavaScript 中的作用域 当中的执行上下文环境部分曾经提到过，JavaScript 在执行一个代码段之前，都会进行这些『准备工作』来生成执行上下文，这其中就涉及到了变量对象和活动对象相关概念，而在执行 JavaScript 代码时，会有数不清的函数调用次数，自然就会产生许多个上下文环境，而这些则主要依赖『执行上下文栈』来帮助我们进行管理，以及销毁而释放内存的 而这些其实就是我们将要介绍的 EC 结构，它的结构是下面这样的 123456789101112{ VO/AO：{ arguments?: ArrayLike&lt;ANY&gt;, [declarations]: ANY, }, [[Scopes]]: [ Scope {}, // * 父级作用域 Scope {}, // * 多级父级作用域 Global {}, // * 栈底是全局作用域 ], this: {} || undefined,} 是不是感觉比较熟系，有我们知道的变量对象（Variable Object，VO）和活动对象（Activation Object，AO），以及作用域 [[Scopes]]，但是在这里我们也要明确这些容易混淆的概念之间的区别，因为它们看上去都是栈或数组的形式，而且随着代码运行和函数调用，也都会产生入栈出栈动作，但是它们都是不同的东西 Callback Stack，调用栈（概念），函数调用时产生的进度信息，当子过程结束时需要继续执行父过程 Execution Context Stack，执行上下文栈，包含一组 EC，是 Callback Stack 背后的实际数据结构，用于过程管理 Scope Chain，作用域链，是每个 EC 的一部分，包含一组词法作用域父级，用于外部变量查找 Closure，闭包，视为作用域链的持久化的快照 引用外层变量 下面我们就来简单的梳理一下 Program 生命周期和 EC 生命周期 Program 生命周期它的执行流程是下面这样的 创建 ECS 开始 Global EC 流程（Global Code） Code 类型 Global Code，产生 ECS 的第一个 EC，唯一顶层全局 EC Function Code，将创建并入栈一个新 EC Eval Code，根据浏览器不同（另有性能和安全问题，避免使用） 当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，这里我们使用 globalContext 来表示它 并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前，ECStack 最底部永远有个 globalContext，所以对应的 ECS 大致是下面这样的 123ECStack = [ globalContext] 而下面的 Code 类型则对应着我们之前提到过的『准备工作』当中的三种情况，分别是全局代码，函数体 和 Eval，其实简单总结一下，这个过程就是一个初始化的过程，下面我们再来看看比较重要的 EC 生命周期 EC 生命周期我们都知道在代码执行的时候，JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行，当执行一段代码的时候，会进行一个准备工作，就比如之前我们提到过的的变量提升和函数提升，这其实就是所谓的执行上下文 执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境，处于活动状态的执行上下文环境只有『一个』，其实简单来说，就是一个『压栈』==&gt;『出栈』的过程，这其实也就对应着我们 EC 生命周期当中的三个过程 Creation（准备环境，创建并入栈一个新 EC） Execution（执行代码） Finished（执行结束，出栈 EC） 不过这里有一点需要注意，那就是若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的），我们上面提及到的三个过程只是较为理想的情况，另外还存在一种情况是无法做到这样干净利落的说销毁就销毁，而这种情况就是闭包，但是关于闭包的概念结构我们会在下面来进行介绍，下面我们就先来看看 EC 生命周期当中的三个过程 Creation（准备环境，创建并入栈一个新 EC）这个过程分为三个步骤 创建当前 EC 的 VO/AO 创建当前 EC 的作用域链（是根据词法作用域解析得到的，和 Callback Stack 是两回事） 创建当前 EC 的 this（ObjectThis || global || window || undefined） 其中关于第一点是较为重要的，我们详细来看看，其实在创建当前 EC 的 VO/AO 的过程当中，不仅仅只是创建，它还会涉及到 VO 填充的过程，主要有以下三点 函数参数（若为传入，初始化该参数值为 undefined） 函数声明（若发生命名冲突，会覆盖） 变量声明（初始化变量值为 undefined，若发生命名冲突，会忽略） 对应到我们的生命周期则是 创建 arguments 对象 Hoisting（提升、声明解析） 映射 arguments 的形参，可以视为 var 声明，在提升阶段时一同加入分析，如果有函数体代码有同名 function，则 function 总是优先，丢弃了传入的实参 不同类型的声明（根据代码分类） Function 声明 （FunctionDeclaration） 变量声明 （VariableDeclaration） Class 声明 （ClassDeclaration） 而这其中的 Hoisting 过程便是我们熟知的变量提升的过程，它会根据不同类型的声明分别进行不同的处理 function 总是优先提升 函数表达式（FunctionExpression）如 var fn = function () {} 中的函数是一个表达式语句，不是声明，例子中只会提升变量 fn 的声明，不会提升函数 function 实际上是对象，函数名就是 Identifier（类似 var），但也提升函数体 var 只提升声明，不提升赋值，初始化为 undefined let、const、Class 只提升声明，不提升赋值，内部标记初始化为『未初始化』 在执行到声明代码所在行之前就调用，就会产生报错（因为未初始化），这个现象称之为『暂时性死区』 同名声明（Identifier） function、var（视为）总是能覆盖，其中 function 以最后一个为准（带函数体），而 var 由于只提升声明，所以覆盖不覆盖无所谓（视为忽略） 但同名问题一旦涉及 ES6 新语法（let、const、Class），则会报错 这里我们也需要注意提升幅度 var（函数级） let、const、Class（块级） function（块级 + 函数级），严格模式只提升到块级作用域，非严格模式，除了块级提升，也会同时提升到函数作用域（旧标准特性） 另外需要注意的就是，如果不加 var 的且上下文没有该变量赋值操作会（隐式地）声明成全局变量（Global/Window），严格模式报错 ReferenceError Execution（执行代码）其实简单来说，在 JavaScript 中，所有代码大致都可理解为三个部分，即『左侧 ==&gt; 操作 ==&gt; 右侧』 左右两个部分都或可继续进行拆分（递归，也就形成了 AST 中的 Tree 的结构） 每句代码执行时（如『赋值的变量名』或『函数名』）先对左侧进行标识查找 左侧部分可能是 Identifier 或 MemberExpression 等 查找失败则 ReferenceError 或 TypeError 等 然后以相似的过程解析右侧（如『赋值的值』或『函数参数』） 然后基于解析完的左右侧，执行相应的操作（如『执行赋值操作』或『进入函数调用流程』） 简单总结就是，查找变量先直接查找当前 VO/AO，如果找不到则基于当前作用域链依次向上查找，依然找不到则失败报错 这里关于语法顺序相关内容我们简单提及一二，在很多编程语言当中都有类似 JavaScript 当中的『中缀的语法顺序』，但有些语言可能有不同的顺序，如 Lisp 的顺序是前缀的，即『操作符 ==&gt; 左侧 ==&gt; 右侧』 12345// JavaScript3 &gt; 2 === true// LispEQUAL (&gt; 3 2) T Finished（执行结束，出栈 EC）也就是卸载过程 显式的 Return Statement 或隐式的（视为 return undefined），return 值将用于上一层相应位置（调用处） 卸载当前上下文，卸载时可能会产生闭包 继续执行上一层后续代码 一些细节下面我们来看一些其中涉及到的细节，加深一下理解 arguments 不使用高级特性（严格、默认值、剩余运算符）且有非空实参时，会跟踪形参数值（双向同步），否则不会 默认参数只对 undefined 实参有效，其他 falsy 值不会判断 箭头函数的 arguments 是绑定词法作用域的父级的 arguments length someArray.length，数组长度，修改直接影响数组表现 arguments.length，实参个数，修改后影响类数组操作时的表现 someFn.length，必要形参个数（不包含默认和剩余参数），修改无效果 window.length，iframe 个数，修改后不再表示 iframe 计数 global.length，undefined，未定义变量 箭头函数 没有自己的 this/arguments，所谓的 this/arguments 是词法作用域中的 this（相当于创建时自动 bind 父级环境中的 this/arguments） 所以也不能进行 bind 和 call，但因为依然还是函数，所以支持闭包的特性 this Global Code 直接读取 this == window（浏览器），如果是 module 的情况，则 this == module.exports（初始是 {}，且不会像 arguments 一样进行跟踪） function 或 Eval 会创建新的 this（新的 EC），裸块（只有花括号）不会 方法调用 this == Host Object 函数调用 this == global/window，但是严格模式下 this == undefined，因为严格来讲没有宿主 箭头函数没有自己的 this，它的 this 等同于绑定词法作用域的父级的 this 严格模式 作用域（use strict 的影响范围）是函数级的 以上，当我们了解了 Program 生命周期和 EC 生命周期相关内容以后在回过头来看 JavaScript 中的作用域 和 JavaScript 中的闭包 当中的相关内容就清晰许多 闭包闭包我们可以理解为函数所需的『作用域链』的持久化的快照，由于 JavaScript 中的函数可以作为变量传递，所以当函数注册后，若所在位置发生改变，ECS 就会发生改变，函数的执行效果就会变得不可控（这将违反静态作用域的特性） 为了解决这个问题，引擎会对函数体中的变量进行词法解析，将当前『作用域链』（保留所需的变量）转为闭包，（隐式地）标记到函数上，以便函数能够正常工作，传统的 function 将排除 this/arguments，因为根据执行流程，这些值在每次函数调用时都重新生成，而箭头函数将会绑定这两个值（根据箭头函数的的特性，它们本来就是绑定的） 当函数调用时，使用闭包作为当前的作用域链（用于变量查找），JavaScript 的闭包特性是引擎的内部实现，无法通过 JavaScript 代码显式操控，但是根据模块化和 Webpack 打包的原理，显然每个 Module 中的函数基本都有自己的闭包，这也说明闭包基本上无处不在 虽然闭包是一个正常的 JavaScript 特性，但是我们还是需要注意正确的使用以避免内存泄露（毕竟 JavaScript 没有显式的垃圾回收，以及闭包无法直接操控），下面我们就先来看看它的概念结构 1234567891011fn { prototype: { constructor: fn, }, // * 作用域链（解构就像正常执行时那样） [[Scopes]]: [ Closure {}, // * 闭包 Closure {}, // * 根据作用域链的概念，可能存在多级闭包 Global {}, ]} 而闭包对于性能的影响，主要有两点，也就是时间和空间 时间 减少执行时间（变量值的解析），闭包中的变量由于已经被解析完成，驻于内存（直到函数销毁垃圾回收），所以相同逻辑下能够提高执行速度 增加变量查找时间，显然闭包需要多一层或者几层变量查找动作，但根据不同浏览器的优化，一般情况下，这个耗时或可忽略不计 空间 占用内存空间（直到所涉及的函数本体被回收） 所以我们在某些场景下可以利用闭包来进行空间换时间的操作，最后我们在通过一个简单的示例看下闭包的使用，更多关于闭包的内容可以参考 JavaScript 中的闭包 这篇文章 123456789101112131415161718192021222324var AA = ((a1) =&gt; { var a2 = 2 return function (a4) { var a3 = 3 console.warn([a1, a2, a3, a4]) // * nest scope search test // console.warn([b1, b2]) console.warn(this) }})(1)AA('direct call')var obj = { AA }obj.AA('obj call');(() =&gt; { var b1 = 'q'; (() =&gt; { var b2 = 'w' console.warn([b1, b2]) AA('nested scope call') })()})() JavaScript 并不支持动态作用域，所以生成闭包的时候需要解析和固定当前所有（所需）变量，比如在上面的示例当中，变量 b1、b2 就并不会携带进闭包中（因为在那时的 ECS 中本来也不存在），其实从任意处调用，观察到调用时的作用域依然是相同的（闭包）结构，如果我们将注释掉的那一行代码放开，将会在控制台看到到 Uncaught ReferenceError: b1 is not defined 代码文件的上下文我们在上面了解了一些 JavaScript 标准的原理和特性，但是在实际的代码文件中，在不同运行环境下，会拥有略有不同的执行环境，下面我们就来看简单的了解一下在各个不同环境下的情况 这里需要注意，下文中的顶层是层级的层，指代码文件中的顶层书写层级（不在函数体或块中的） HTML 中的情况其实也就是 &lt;script&gt; 标签，无论是 src 引用，还是直接位于标签内部的 JavaScript 代码，每个 &lt;script&gt; 的顶层代码都位于 Global 层（ECS 栈底），在页面打开后，显然 Window（GO）总是存在（直到页面关闭），所以每组代码都共用同一个 Window，也就是 this == window 但不同的 &lt;script&gt; 相当于不同的 Program 任务，都会创建一套独立的完整的 Program 生命周期（当然其中的 GO 还是同一个），所以其中一个 &lt;script&gt; 报错中断也不会影响后续 &lt;script&gt; 执行 Node.js 的情况通过 Node.js 命令直接启动环境后，直接位于 Global 层，即 this == global，而通过 Node.js 当中的 filename.js 命令执行代码以后，则会以模块化的形式读取和执行文件，Node.js 将使用内建的包装函数加载文件代码，这时文件中的顶层代码并不位于 Global 层，此时 this == module.exports Webpack 打包的情况虽然一般用途也是在浏览器运行，但是类似 Node.js 中的模块化，Webpack 也有一个加载器来加载代码（JavaScript 实现的） 每个 Module 的顶层代码并不位于 Global 层，所以同样的 this == module.exports，但是打包会默认会加上 use strict，所以默认 this == undefined 顶层声明挂载到 GlobalGlobal 的 VO 是引擎提供的 Global/Window 对象，当位于顶层时，ES5 旧标准的 var、function 声明会成为 Global 对象的属性 而 ES6 新标准中，对新加入的关键字 let、const、Class 进行了调整，如果是这些声明在顶层，会创建一层新的 EC 层来存放变量，避免直接挂载到 Global 上（Chrome 中可以直接观察到该 EC 类名为 Script ） 相关词汇在这里简单整理汇总一下以上内容当中涉及到的一些词汇，加深理解 EC（Execution Context），执行上下文，包含当前词法环境中的变量等信息 ECS（Execution Context Stack），执行上下文栈，包括调用时产生的父级环境的一组 EC Hoisting（声明），提升（为了预分配内存空间） Scope，作用域（可能是 Global、Closure、Block 等） Scope Chain，作用域链，存在于 EC 中，在浏览器内或表现为 [[Scopes]]: Array Closure，闭包，视为持久化的作用域 VO（Variable Object），变量对象，每个 EC 的一部分，存放变量的地方 AO（Activation Object），活动对象，可视为函数级作用域中的 VO （多了 arguments） GO（Global Object），特指 Global 层的 VO Stack Frame，栈帧，指单个 EC Stack Overflow，执行栈溢出（函数嵌套调用深度过大达到引擎设定的上限） Segfault（Segmentation Fault），段错误（访问非法内存地址） TCO（Tail Call Optimization），尾调用优化（如果函数最后一句是另一个调用，则直接替换而不是入栈） TDZ（Temporal Dead Zone），暂时性死区（let、const 某特性的民间称呼） JIT（Just in time），及时化（运行时逐字解析编译） AOT（Ahead of Time），预处理（全部编译完再运行） IIFE（Immediately Invoked Function Expression），立即执行函数表达式，如 (() =&gt; { })() 以下是作用域当中涉及的一些词汇，不过针对于作用域，由于函数有一层自己的作用域，可以利用 IIFE 来对代码过程进行局部封装，以便更好地管理变量 Lexical Scope，词法作用域（以代码字面结构为依据的解析，不会根据调用位置而动态改变） Static Scope，静态作用域（词法作用域） Dynamic Scope，动态作用域（ECMAScript 包括大多数编程语言中都不采用） Global Scope，全局作用域 Function Scope，函数作用域 Block Scope，块级作用域 with（严格模式禁止，有变量指向歧义，避免使用，可以用解构代替） try-catch let、const 参考 使用断点暂停代码 从 JavaScript 作用域说开去 JavaScript 闭包 反思闭包 严格模式 块级作用域的函数提升 The Ultimate Guide to Execution Contexts, Hoisting, Scopes, and Closures in JavaScript JavaScript Visualizer What is the Execution Context &amp; Stack in JavaScript? JavaScript. The Core. temporal dead zone Tail call optimization in ECMAScript 6 What is this? ECMAScript Language Specification ECMAScript compatibility table","link":"/2018/05/20/JavaScript/36/"},{"title":"JavaScript 中的 call 和 apply","text":"JavaScript 中的 call() 和 apply() 方法主要是用来扩充函数的作用域和改变 this 的指向（改变被调用函数的上下文），它们都接收两个参数 apply() 方法，第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是 arguments 对象 call() 方法，也接收两个参数，仅仅在于和 apply() 的传参方式不同，传递函数的参数必须逐个写入，而不再是传递数组 不过需要注意的是，调用 call 或者 apply 的对象必须是个函数，因为这两者是挂载在 Function 对象上的两个方法，只有函数才有这些方法 两者的区别两者的使用方式如下 123function().apply(object, [a, b, c ...])function().call(object, a, b, c ...) 功能基本一样，都是对象 Object 调用这里的 funciton()，不同之处是 call 参数从第二个开始都是传递给 funciton 的，可以依次罗列用 ',' 隔开，而 apply 只有两个参数，第二个是一个数组，其中存储了所有传递给 function 的参数 12345678910var bar = {baz: 'baz'}function foo () { console.log(this)}foo.call('bar')// 输出 Object {baz: 'baz'}// 其实就是让一个对象调用一个函数，在使用了 call 以后，即调用了显式绑定，this 就指向了所传进去的对象 call 和 apply 的第一个参数call 和 apply 用来改变函数的执行上下文（this），它们的第一个参数 thisArg 是个对象，即作为函数内的 this，在多数时候你传递什么给函数，那么它就是什么 12345678function fun() { alert(this)}fun.call(1) // 1fun.call('a') // afun.call(true) // truefun.call({name: 'aaa'}) // [object Object] 但是有两种情况需要注意，就是在传递 null 或 undefined 的时候，执行环境会是全局的（window/global），至于原因可以参考 15.3.4.4 - Function.prototype.call() 12fun.call(null) // windowfun.call(undefined) // window 但是在严格模式下，给 call 和 apply 传入的任何参数也不再会转换 1234567'use strict'function fun() { alert(this)}fun.call(null) // nullfun.call(undefined) // undefined 另外一个例子 1234567function foo(x, y) { 'use strict' console.log(x, y, this)}foo.apply(null) // undefined undefined nullfoo.apply(undefined) // undefined undefined undefined 简单总结就是 如果不传值或者第一个值为 null，undefined 时，this 指向 window 如果第一个参数是 string、number、boolean，call/apply 内部会调用其相应的构造器 String、Numer、Boolean 将其转换为相应的实例对象 严格模式下，给 call 和 apply 传入的任何参数也不再会转换 原理call 和 apply 本质是一样的，区别就在于参数的不同，这里我们就以 call 方法为例来进行介绍，call 方法的定义是 Function.prototype.call()，简单来说就是 call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法 apply() 方法在使用一个指定的 this 值和参数值必须是数组类型的前提下调用某个函数或方法 call() 和 apply() 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 this 来获得它的引用，比如以对象 o 的方法来调用函数 f() 123f.call(o)f.apply(o) 大致原理如下所示 1234o.m = f // 将 f 存储为 o 的临时方法o.m() // 调用它，不传入参数delete o.m // 将临时方法删除 在严格模式中，call() 和 apply() 的第一个参数都会变成 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined，而在非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代，简单来说就是，f.call(o) 其原理就是先通过 o.m = f 将 f 作为 o 的某个临时属性 m 存储，然后执行 m，执行完毕后将 m 属性删除 接下来，我们就可以尝试着手动来实现我们自己的 call 和 apply 方法，一步一步的理清它们到底是如何实现的 实现我们先来看看 call 的实现，如果想要手动来实现一个 call 方法，我们首先需要了解在使用 call 的过程中到底发生了哪些事情，根据上面提到的原理，我们可以整理出大致的实现思路，总的来说，分为四个步骤 首先需要设置上下文对象，简单来说，也就是 this 的指向，因为第一个参数是要调用函数的母对象，它是调用上下文 通过设置 Context（上下文），来将函数的 this 绑定到 Context 上 执行函数并且传递参数 删除临时属性，并且返回函数执行结果 我们可以根据以上来得出我们的第一版代码，如下 12345Function.prototype.call = function (context) { context.fn = this context.fn() delete context.fn} 虽然可以勉强实现效果，但是不够完善，因为原生的 call 还具备一些其他功能，如下 首先，call 方法是可以接收参数的 this 参数可以传递 null 或者不传，当为 null 的时候，需要将其指向 window 而且函数是可以指定返回值的 下面我们就来逐一完善 12345678910111213141516171819Function.prototype.call = function (context, ...args) { // 根据之前关于 call 和 apply 的第一个参数可知，传递 null 或 undefined 时，执行环境会是全局的（window/global） // 而对于原始值，this 则会指向该原始值的实例对象 if (context === null || context === undefined) { context = window } else { context = Object(context) } // 绑定到 context 上 context.fn = this // 这里注解见下方 let result = context.fn(...args) // 删除临时属性并且返回函数执行结果 delete context.fn return result} 其中 let result = context.fn(...args) 的作用是因为我们最终的目的是为了达到类似于 context.fn(arg1, arg2, arg3 ...) 这样的调用方式，这里使用扩展运算符来达到参数传递的功能，如果不采用该方法，也可以使用字符串拼接的方式在配合 eval() 方法来实现 12345678var args = []// 从第二位开始循环for (var i = 1; i &lt; arguments.length; i++) { args.push('arguments[' + i + ']')}var result = eval('context.fn(' + args + ')') 如果为了追求完美，那么这里还存在一个小小的问题，即 context.fn = this，这里我们只是假设不存在名为 fn 的属性，所以这里我们需要保证 fn 的唯一性，所以在这里可以采用 ES6 提供的 Symbol 数据类型，直接添加即可 12var fn = Symbol()context[fn] = this 如果不使用 Symbol，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下 123456789101112function symbol(obj) { var unique_prop = '00' + Math.random() if (obj.hasOwnProperty(unique_prop)) { // 如果已经存在这个属性，则递归调用，直到没有这个属性 arguments.callee(obj) } else { return unique_prop }}// 使用var fn = symbol(context) 完整代码如下 123456789101112Function.prototype.call = function (context, ...args) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = context[fn](...args) delete context[fn] return result} 现在我们有了 call 方法，那么实现 apply 方法也是同样的思路，只需要针对不同的地方略作调整即可，如下 传递给函数的参数与 call 方法不一样，其他部分则跟 call 方法是一致的 apply 方法的第二个参数为类数组对象 实现如下 123456789101112131415161718Function.prototype.apply = function (context) { if (context === null || context === undefined) { context = window } else { context = Object(context) } // 绑定到 context 上 let fn = Symbol() context[fn] = this // 这里注解也见下方 let result = arguments[1] ? context[fn](...arguments[1]) : context[fn]() // 删除临时属性并且返回函数执行结果 delete context[fn] return result} 在这里我们需要判断一下，如果只传入了一个参数，则直接执行函数即可，如果传递了第二个参数，则依次执行函数并且传递函数参数，基本原理就是这样了，如果为了完善一些，在这里可以针对 apply 的第二个参数（类数组对象）来进行判断一下 123456789101112const args = arguments[1]let resultif (args) { if (!Array.isArray(args) &amp;&amp; !isArrayLike(args)) { throw new TypeError(`second parameter needs to be an array or class array object`) } else { args = Array.from(args) result = context[fn](...args) }} else { result = context[fn]()} 当中使用的 isArrayLike 方法如下 1234567891011function isArrayLike(o) { if (o &amp;&amp; // o 不是 null、undefined 等 typeof o === 'object' &amp;&amp; // o 是对象 isFinite(o.length) &amp;&amp; // o.length 是有限数值 o.length &gt;= 0 &amp;&amp; // o.length 为非负值 o.length === Math.floor(o.length) &amp;&amp; // o.length 是整数 o.length &lt; 4294967296) // o.length &lt; 2^32 return true else return false} 在了解完了 call 和 apply 的实现原理以后，下面我们再来看看它们的一些实际使用场景 延伸下面再来看两个实际的使用场景 123456789101112131415161718192021222324function sum(num1, num2) { return num1 + num2}function callSum1(num1, num2) { // 使用 sum 这个函数来完成一次调用，调用的参数就是 callSum1 这个函数的参数 // apply 的第二个参数表示一组参数数组 return sum.apply(this, arguments)}function callSum2(num1, num2) { // 第二个参数是数组 return sum.apply(this, [num1, num2])}callSum1(12, 22)callSum2(22, 32)function callSum3(num1, num2) { // call 是通过参数列表来完成传递，其余和 apply 没什么区别 return sum.call(this, num1, num2)}callSum3(32, 42) 另外一个实例 12345678910111213var color = 'red'function showColor () { alert(this.color)}function Circle (color) { this.color = color}var c = new Circle('yellow')showColor.call(this) // 使用上下文来调用 showColor，结果是redshowColor.call(c) // 上下文对象是 c，结果就是 yellow 通过以上发现，使用 call 和 apply 以后，对象中可以不需要定义重复的方法了，这就是 call 和 apply 的一种运用 this.init.apply(this, arguments)在 prototype 框架中有如下一段代码 12345678910111213141516171819202122var Class = { create: function () { return function () { this.initialize.apply(this, arguments); } }}// Class 使用方法如下var A = Class.create()A.prototype = { initialize: function (v) { this.value = v }, showValue: function () { alert(this.value) }}var a = new A('hello')a.showValue() var a = new A('hello') 其实这句话的含义就是构造个一个 function 复制给 a，这个 function 是 123function () { this.initialize.apply(this, arguments)} 这个 function 方法是用来做构造函数的，使用 function 构造对象时，会让构造出来的对象的 initialize 方法执行 apply() 方法，function 中的第一个 this 是指用 new 调用构造函数之后生成的对象，也就是前面的 a，那么第二个 this 也当然应该是指同一个对象 this 调用 initialize 方法，参数是 arguments 对象（参数的数组对象），在构造函数执行时，对象 a 就会去执行 initialize 方法来初始化 arguments 作为 create 返回的构造函数的实参数组，传递给方法 apply，在调用 initialize 时作为参数传递给初始化函数 initialize，那么在 var a = new A('hello') 的时候 'hello' 就是实参数组（虽然只有一个字符串），传递给方法 apply，然后在调用 initialize 的时候作为参数传递给初始化函数 initialize 下面是一个与其类似的的实际使用场景 12345678910111213141516171819+function () { function Circle(nRadius, sMessage) { this.init.apply(this, arguments) } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius this.sMessage = sMessage }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR } }; var c = new Circle(5, '构造初始化 面积') alert(c.fnGetArea()) //构造初始化 面积: 78.5}() Math.max.apply(null, arr)求取数组中的最大值或者最小值是开发中比较常见的需求，我们一般会使用 Math.max() 或者 Math.min() 来进行实现，我们这里就以 max() 为例来进行说明，max() 方法可以返回两个指定的数中较大的那个数 Math.max() 方法，支持传递多个参数，比如 Math.max(1, 3, 5, 7, 9, 11)，但是它不支持直接传递一个数组作为参数，比如 Math.max(new Array(1, 3, 5, 7, 9, 11))，这里，只要我们有方法把数组，一个一个拆分开来，传递到 Math.max() 方法中，就实现了传递数组的方法，这里就可以利用到 apply() 函数 12345var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10]console.log(Math.max.apply(null, arr))// 使用 call 方法可以达到同样目的// Math.max.call(null, 1, 2, 3, 4, 5) 所有函数都有 apply(作用域链, 参数) 这个方法，这个函数的参数接收一个数组，并且是将数组中的每个值分开来，传递给调用函数，所以就实现了传递一个数组，取得最大值的方法 Function.apply() 是 JavaScript 的一个 OOP 特性，一般用来模拟继承和扩展 this 的用途，xx.apply 是一个调用函数的方法，其参数为 apply(Function, Args)，Function 为要调用的方法，Args 是参数列表，当 Function 为 null 时，默认为上文，即 1Math.max.apply(null, arr) 下面我们再来看几种其他方法来求取数组中的最大值或者最小值，可以与上面的方法可以进行一下对比，第一种，比较原始的方法，即使用循环来进行比对 12345678var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10]var result = arr[0]for (let i = 1; i &lt; arr.length; i++) { result = Math.max(result, arr[i])}console.log(result) 第二种，也是现在使用较多的，即在 ES6 以后，我们可以使用 ... 运算符来简化操作 1Math.max(...arr) 第三种，既然是通过遍历数组求出一个最终值，那么我们也可以使用 reduce 方法 1234567var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10]var result = arr.reduce((a, b) =&gt; { return Math.max(a, b)})console.log(result) 第四种，使用排序，因为我们进行过排序，那么最大值就是最后一个值，但是这个方法是存在缺陷的，因为 sort() 返回的结果不一定准确 1234567var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10]arr.sort((a, b) =&gt; { return a - b})console.log(arr[arr.length - 1]) Array.prototype.slice.call(arguments, 0)在平常开发过程当中，我们经常会在一些第三方库等地方会看到类似 Array.prototype.slice.call(arguments, 0) 这样的写法，其实这个方法的本质作用就是『把类数组对象转换成一个真正的数组』，这里主要涉及到 slice() 方法和 call() 方法，我们先来简单的了解一下 slice() 方法，在数组和字符串当中都有这个 slice 方法，这个方法的作用是截取一段数据 在数组中，该方法的返回值是『包含』截取元素的组成的数组 在字符串中，该方法的返回值是『包含』截取字符串组成的字符串 1234// 参数 start 表示数组片段开始处的下标，如果是负数，它声明从数组末尾开始算起的位置// 参数 end 表示数组片段结束处的后一个元素的下标，如果没有指定这个参数，切分的数组包含从 start 开始到数组结束的所有元素// 如果这个参数是负数，它声明的是从数组尾部开始算起的元素（不包括结束位置）array.slice(start, end) 如果 slice() 方法没有传递参数，则默认是从 index 序列为 0 开始截取（见 MDN - Array.prototype.slice()） 需要注意的是，操作使用 slice() 生成的数组不会影响原数组，也就是说使用 slice() 后会生成原对象的一个浅拷贝的副本，如下 12345678// slice() 方法var a = [1, 2, 3]var b = a.slice()b.push(4)console.log(a) // [1, 2, 3]console.log(b) // [1, 2, 3, 4] 下面来看几个示例 1234567[1, 2, 3, 4, 5, 6].slice(2, 4)[1, 2, 3, 4, 5, 6].slice(-4, -2)[1, 2, 3, 4, 5, 6].slice()'everything'.slice(2, 4)'everything'.slice(-4, -2)'everything'.slice() 前两个的返回值均为 [3, 4]，为数组，而后两个的返回值分别为 'er' 和 'hi'，为字符串 如果之传入一个参数的话，那就是输出从开始位置到结束位置的所有元素 而如果不传递参数，则是从 0 开始计算（可以认为返回一个原对象的副本，因为 slice 方法返回的是一个新的数组） 在字符串中，和 slice() 方法类型的还有两个方法 substring() 和 substr() 方法，其中，substring() 方法表示『返回从开始位置到结束位置的字符串』，substr() 接收两个参数，『第一个参数表示开始位置，第二个参数表示要截取的字符个数』，和前两个方法略有不同，当传入方法的参数为负数时，这三种方法又略有不同 slice()，像上面说的，是负数加上字符串的长度得出相应的正值 substring()，方法的参数均置为零 substr()，方法的第一个参数为负值加上字符串长度得到的正值，第二个参数置为零 在了解了 slice() 方法的基本用法以后，我们就正式的来看看 Array.prototype.slice.call(arguments, 0) 具体含义，在 Array.prototype.slice.call(arguments, 0) 中，Array.prototype.slice 调用的是 Array 的原型方法 对于正真的数组是有 slice() 方法，但是对于像 arguments 或者自己定义的一些『类数组对象』，虽然存在 length 等若干属性，但是并没有 slice() 方法，所以对于这种类数组对象就得使用原型方法来使用 slice() 方法，即 Array.prototype.slice（如果在自定义中的类数组对象中自定义了 slice() 方法，那么自然可以直接调用） 简单点说就是对于 arguments 类数组，我们调用 Array.prototype.slice 原型方法，并用 call() 方法，将作用域限定在 arguments 中，这里 Array.prototype 就可以理解为 arguments，同参数 0 为 slice() 方法的第一个参数，即开始位置索引，通过这种方法就将 arguments 类数组转换成了真数组 Array.prototype.slice.call(arguments) 能将具有 length 属性的对象转成数组，除了 IE 下的节点集合 因为 IE 中的所有 DOM 对象都是以 COM 对象的形式实现的，这意味着 IE 中的 DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致 12345678910111213var a = { length: 2, 0: 'first', 1: 'second' }Array.prototype.slice.call(a) // ['first', 'second']var a = { length: 2 }Array.prototype.slice.call(a) // [undefined, undefined] call 和 apply 哪个速度更快一些最后我们在来看一个有趣的问题，那就是 call 和 apply 哪个速度更快一些，通常来说，call 是要比 apply 快一些的，至于为什么，这就要看它们在被调用之后发生了什么，关于发生了什么我们可以通过查询规范来进行了解，可以见 15.3.4.3 Function.prototype.apply (thisArg, argArray) 和 15.3.4.4 Function.prototype.call(thisArg, arg1, arg2 …)，两者对比如下 Function.prototype.apply (thisArg, argArray) 如果 IsCallable(Function) 为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常 如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 和一个空数组作为参数 如果 Type(argArray) 不是 Object，则抛出 TypeError 异常 获取 argArray 的长度，调用 argArray 的 [[Get]] 内部方法，找到属性 length， 赋值给 len 定义 n 为 ToUint32(len) 初始化 argList 为一个空列表 初始化 index 为 0 循环迭代取出 argArray，重复循环 while(index &lt; n) 将下标转换成 string 类型，初始化 indexName 为 ToString(index) 定义 nextArg 为 使用 indexName 作为参数调用 argArray 的 [[Get]] 内部方法的结果 将 nextArg 添加到 argList 中，作为最后一个元素 设置 index ＝ index＋1 返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表 Function.prototype.call (thisArg [ , arg1 [ , arg2, .. ] ] ) 如果 IsCallable(Function) 为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常 定义 argList 为一个空列表 如果使用超过一个参数调用此方法，则以从 arg1 开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 返回调用 func 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表 经过对比，可以很明显的发现，call 的执行步骤要比 apply 少的多，这是因为 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤 8 中所示）， 同时也有一些对参数的检查（步骤 2），而在 call 中却是不必要的，另外在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6 到 8，而在 call 中也就是对应步骤 3 ，是有需要才会被执行","link":"/2018/04/16/JavaScript/27/"},{"title":"迭代器与生成器","text":"在 JavaScript 当中对集合中每个元素进行处理是很常见的操作，比如数组遍历、对象的属性遍历，以往这些操作是通过 for 循环、.forEach、.map 等方式进行，借由迭代器机制为 Map、Array、string 等对象提供了统一的遍历语法，以及更方便的相互转换 在最新的 ES6 当中为方便编写迭代器还提供了生成器（Generator）语法，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for-of 循环的行为，下面我们就来看看迭代器到底是一种怎样的语法 迭代器所谓迭代器，其实简单来说就是一个具有 next() 方法的对象，每次调用 next() 方法都必须要返回一个『对象』，被返回对象拥有两个属性（如果返回一个非对象值，则需要抛出一个错误） done，布尔值，表示遍历是否结束，如果为 true，则表示迭代器已经超过了可迭代次数，在这种情况下 value 的值可以被省略，如果迭代器可以产生序列中的下一个值，则为 false value，表示当前的值，迭代器可以返回的任何 JavaScript 值，在 done 为 true 的时候可省略 比如我们来看下面这个例子 123456789101112131415161718192021function createIterator(items) { var i = 0 return { next: function () { var done = i &gt;= items.length var value = !done ? items[i++] : undefined return { done: done, value: value } } }}// iterator 就是一个迭代器对象var iterator = createIterator([1, 2, 3])iterator.next() // { done: false, value: 1 }iterator.next() // { done: false, value: 2 }iterator.next() // { done: false, value: 3 }iterator.next() // { done: true, value: undefined } 在了解了上面的例子以后，我们就会考虑，那么这样一来我们的迭代器对象是不是就可以进行遍历了呢？，我们来试一下 1234567var iterator = createIterator([1, 2, 3])for (let value of iterator) { console.log(value)}// iterator is not iterable 结果会发现运行报错，那么这就表明我们生成的 iterator 对象并不是 iterable（可遍历的），那么什么又是可遍历的呢？在 ES6 当中规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说一个数据结构只要具有 Symbol.iterator 属性，就可以认为是可遍历的（iterable），简单来说就是，只要『一种数据结构部署了 Iterator 接口，我们就称这种数据结构是可遍历的（iterable）』，比如下面这个例子 12345678910const obj = { value: 1}for (value of obj) { console.log(value)}// 直接运行会报错// TypeError: iterator is not iterable 如果我们直接使用 for-of 遍历一个对象会报错，然而如果我们给该对象添加 Symbol.iterator 属性 123456789101112131415const obj = { value: 1}obj[Symbol.iterator] = function () { return createIterator([1, 2, 3])}for (value of obj) { console.log(value)}// 1// 2// 3 由此可以发现，for-of 遍历的其实是对象的 Symbol.iterator 属性，这里就可以引出我们的迭代器协议 迭代器协议『迭代器协议』又称生成器协议，该协议定义了什么是迭代器对象，迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值，一些内置类型都是内置的可迭代类型并且有默认的迭代行为，比如 Array 或者 Map，另一些类型则不是（比如 Object，下方会进行介绍） 当使用 for-of 循环遍历某种数据结构时，它会首先调用被遍历集合对象的 Symbol.iterator() 方法，该方法返回一个迭代器对象，它的基本语法为 123456var myIterator = { next: function () { // ... }, [Symbol.iterator]: function () { return this }} 比如 string，就是一个内置的可迭代对象 123var str = 'hi'typeof str[Symbol.iterator] // 'function' string 的默认迭代器会一个接一个返回该字符串的字符 123456const str = 'hi'const iterator = str[Symbol.iterator]()iterator.next() // {value: 'h', done: false}iterator.next() // {value: 'i', done: false}iterator.next() // {value: undefined, done: true} 我们也可以通过自己的 @@iterator 方法重新定义迭代行为 1234567891011121314151617181920var str = new String('hi')str[Symbol.iterator] = function () { return { next: function () { if (this._first) { this._first = false return { value: 'hello', done: false } } else { return { done: true } } }, _first: true }}for (let i of str) { // hello console.log(i)} 在对象上实现 Iterator 接口在上面我们提到过，string、Array、TypedArray、Map 和 Set 是所有内置可迭代对象，因为它们的原型对象都有一个 @@iterator 方法，而针对于对象（Object）默认是没有 Iterator 接口的，如果我们想让它变为可遍历的，有两种方法 一种是在其 [Symbol.iterator] 属性当中实现一个上文所述的 next 方法 或者像上方基本语法一样，在外部实现 next() 方法，然后在 [Symbol.iterator] 当中返回 this 也可 那么这里就会存在一个问题，为什么 string、Array 等对象都有部署 Iterator 接口，而偏偏 Object 没有呢？其实是有两个原因 一是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定，然而遍历遍历器是一种线性处理，对于非线性的数据结构，部署遍历器接口，就等于要部署一种线性转换 二是对对象部署 Iterator 接口并不是很必要，因为 Map 弥补了它的缺陷，又正好有 Iteraotr 接口 但是我们可以手动的为对象添加一个 Iterator 接口，比如下面这个实现 50 以内的斐波纳契数列的示例 12345678910111213141516171819202122232425let obj = { [Symbol.iterator]: function () { let a = 0, b = 0 return { next: function () { let value = 0 if (!a) { value = a = 1 } else if (!b) { value = b = 1 } else if (b &lt; 50) { value = a + b a = b b = value } return { done: value === 0, value } } } }}for (let i of obj) { // 1 1 2 3 5 8 13 21 34 55 console.log(i)} 模拟实现 for-of下面我们可以尝试模拟一下 for-of 的实现，简单来说，就是通过 Symbol.iterator 获取迭代器对象，然后使用 while 遍历，当迭代器的 done 为 false 的时候退出循环，因为迭代器对象既然可以被 for-of 遍历，那么它肯定就存在 Symbol.iterator属性 123456789101112function forOf(obj, cb) { let iterable, result if (typeof obj[Symbol.iterator] !== 'function') throw new TypeError(result + ' is not iterable') if (typeof cb !== 'function') throw new TypeError('cb must be callable') iterable = obj[Symbol.iterator]() result = iterable.next() while (!result.done) { cb(result.value) result = iterable.next() }} 内建迭代器为了更好的访问对象中的内容，比如有的时候我们仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，在 ES6 当中为数组，Map，Set 集合内建了以下三种迭代器 entries()，返回一个遍历器对象，用来遍历 [key, value] 组成的数组，对于数组，键名就是索引值 keys()，返回一个遍历器对象，用来遍历所有的键名 values()，返回一个遍历器对象，用来遍历所有的键值 比如以数组为例 12345678910111213141516171819202122232425var colors = ['red', 'green', 'blue']for (let index of colors.keys()) { console.log(index)}// 0// 1// 2for (let color of colors.values()) { console.log(color)}// red// green// bluefor (let item of colors.entries()) { console.log(item)}// [ 0, 'red' ]// [ 1, 'green' ]// [ 2, 'blue' ] Map 类型与数组类似，但是对于 Set 类型需要注意 12345678910111213141516171819202122232425var colors = new Set(['red', 'green', 'blue'])for (let index of colors.keys()) { console.log(index)}// red// green// bluefor (let color of colors.values()) { console.log(color)}// red// green// bluefor (let item of colors.entries()) { console.log(item)}// [ 'red', 'red' ]// [ 'green', 'green' ]// [ 'blue', 'blue' ] 通过上面的例子可以发现，Set 类型的 keys() 和 values() 返回的是相同的迭代器，这也意味着在 Set 这种数据结构中键名与键值相同，这里需要注意一点，每个集合类型都是有一个默认的迭代器的，在 for-of 循环中，如果没有显式指定则使用默认的迭代器，则 数组和 Set 集合的默认迭代器是 values() 方法 Map 集合的默认迭代器是 entries() 方法 这也就是为什么直接 for-of 遍历 Set 和 Map 数据结构，会有不同的数据结构返回，这里有一个小技巧，就是遍历 Map 数据结构的时候可以结合解构赋值来输出想要的格式 12345678const valuess = new Map([['key1', 'value1'], ['key2', 'value2']])for (let [key, value] of valuess) { console.log(key + ' ==&gt; ' + value)}// key1 ==&gt; value1// key2 ==&gt; value2 生成器对象生成器对象是由一个 Generator 函数（function*）返回的，并且它符合可迭代协议和迭代器协议 12345678910function* g() { yield 1 yield 2}var iterator = g()iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: undefined, done: true } 生成器函数在执行时能暂停，后面又能从暂停处继续执行，调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象，当这个迭代器的 next() 方法被首次调用时，其内的语句会执行到第一个出现 yield 的位置为止，yield 后紧跟迭代器要返回的值，或者如果用的是 yield*（有星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），而 next() 方法则会返回一个对象，这个对象包含两个属性 value 和 done value 属性表示本次 yield 表达式的返回值 done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回 这里有一个需要注意的地方，如果在生成器函数当中使用了 return ，会立即结束执行，done 会立即变为 true 1234567891011function* g() { yield 1 return 2 yield 2}var iterator = g()iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: true }iterator.next() // { value: undefined, done: true } 在调用 next() 方法的时候，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值 12345678910111213function* g() { let first = yield 1 let second = yield first + 2 // 10 + 2，first 的值是由 next(10) 传递的 yield second + 3 // 5 + 3，需要注意的是，如果在调用的时候不传递参数，则会返回 // { value: NaN, done: false }}let iterator = g()iterator.next() // { value: 1, done: false }iterator.next(10) // { value: 12, done: false }iterator.next(5) // { value: 8, done: false }iterator.next() // { value: undefined, done: true } 现在可以使用生成器方法重新实现之前的的斐波纳契数列示例 12345678910111213141516let obj = { [Symbol.iterator]: function* () { let a = 1, b = 1 yield a yield b while (b &lt; 50) { yield b = a + b a = b - a } }}for (let i of obj) { // 1 1 2 3 5 8 13 21 34 55 console.log(i)} yield*yield* 表达式用于委托给另一个 Generator 或可迭代对象，下面是一个简单的示例 12345678910111213141516function* g1() { yield 2}function* g2() { yield 1 yield* g1() yield 3}var iterator = g2()iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: 3, done: false }iterator.next() // { value: undefined, done: true } 除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等 123456789101112131415function* g3() { yield* [1, 2] yield* '34' yield* arguments}var iterator = g3(5, 6)iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: '3', done: false }iterator.next() // { value: '4', done: false }iterator.next() // { value: 5, done: false }iterator.next() // { value: 6, done: false }iterator.next() // { value: undefined, done: true } 生成器也可以接收参数12345678910function* g() { var index = arguments[0] || 0 while (true) yield index++}var gen = g(5)gen.next().value // 5gen.next().value // 6 Map，Set，String，Array 互相转换可迭代协议给出了统一的迭代协议，使得不同类型的集合间转换更加方便，以下是一些很方便的转换技巧，比如从 Array 生成 Set，可用于数组去重 12345new Set(['1', '2', '3'])// 等价于（但不是 ===）new Set(['1', '2', '3'][Symbol.iterator]()) 从 Set 得到 Array 12345Array.from(new Set(['1', '2', '3'])) // ['1', '2', '3']// 等价于Array.from(['1', '2', '3'][Symbol.iterator]()) 除了 for-of 外，扩展运算符（Spread Syntax）也支持迭代器（Iterables） 1[...new Set(['1', '2', '3'])] 从 string 到 Set，得到字符串中包含的字符 12345678let str = 'abcdefghijklmnopqrstuvwxyz'// Set(26) {'a', 'b', 'c', ...}new Set(str) // 等价于new Set(str[Symbol.iterator]()) 从 Object 到 Map，也就是把传统的 JavaScript 映射转换为 Map 123456let mapping = { 'foo': 'bar'}// {'foo' =&gt; 'bar'}new Map(Object.entries(mapping)) 类似地，Object 的键的集合可以这样获取 123456let mapping = { 'foo': 'bar'}// {'foo'}new Set(Object.keys(mapping)) 生成器对象到底是一个迭代器还是一个可迭代对象生成器对象既是迭代器也是可迭代对象，一个良好的迭代即实现了迭代器协议，又实现了可迭代协议，方式就是可迭代协议返回的是自身 1234567891011121314151617var g = function* () { yield 1 yield 2 yield 3}()// 'function'，因为有 next() 方法，所以是一个迭代器typeof g.next// 'function'，因为有 @@iterator 方法，所以是一个迭代器typeof g[Symbol.iterator]// true，因为 @@iterator 方法返回它自身（也是一个迭代器）g[Symbol.iterator]() === g// [1, 2, 3][...g] 总结 Iterator 接口的目的就是为所有数据结构提供一种统一访问的机制，用 for-of 实现 一个数据结构只要有 Symbol.iterator 属性，就可以认为是『可遍历的』 实现了可迭代协议的对象称为可迭代对象（Iterables），这种对象可以用 for-of 来遍历，Map，Set，Array，string 都属于可迭代对象，自定义的对象也可以使用这一机制，成为可迭代对象 可迭代协议，需要实现一个 @@iterator 方法，即在键 [Symbol.iterator] 上提供一个方法，对象被 for-of 调用时，这个方法会被调用，方法应该返回一个迭代器对象（Iterator）用来迭代 简单来说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是『可迭代的』（iterable） 实现了迭代器协议的对象称为迭代器对象（Iterator），也就是我们说的迭代器对象 迭代器协议，又称 Iteration Protocol，需要实现一个 next() 方法，每次调用会返回一个包含 value（当前指向的值）和 done（是否已经迭代完成）的对象 简单来说，只需要实现 .next() 方法 参考 迭代协议 迭代器和生成器 Generator GeneratorFunction function* yield yield* 可迭代协议与迭代器协议 给对象部署 Iterator 接口","link":"/2019/07/13/JavaScript/44/"},{"title":"Async 和 Await","text":"最后更新于 2019-12-14 因为最近在复习相关内容，所以打算从头开始重新的梳理一下 async 和 await 的相关内容，主要包括它们是什么，有什么作用以及最后我们会来手动的实现一个简易版本的 async，那么我们就先从什么是 async 开始看起吧 Async从字面意思上很好理解，async 是异步的意思，await 有等待的意思，而两者的用法上也是如此，async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成，我们先来看看它是如何使用的，比如下面这个读取文件的例子 1234567891011121314151617181920212223242526const fs = require('fs')const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function (error, data) { if (error) return reject(error) resolve(data) }) })}// generator 函数写法const gen = function* () { const f1 = yield readFile('./1.txt') const f2 = yield readFile('./2.txt') console.log(f1.toString()) console.log(f2.toString())}// async 函数写法const asyncReadFile = async function () { const f1 = await readFile('./1.txt') const f2 = await readFile('./2.txt') console.log(f1.toString()) console.log(f2.toString())} 我们特意声明了一个 generator 函数用来进行对比，对比可以发现 async 其实就是一个函数的修饰符，在异步处理上就是 generator 函数的语法糖，相比较于 generator 当中的 * 和 yield，它的语义更为清楚一些，async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果 下面我们就先来看看 async 的具体用法，async 的语法很简单，就是在函数开头加一个关键字 123async function f() { return 1} 我们可以来试着直接调用一下 1f() // Promise { &lt;resolved&gt;: 1 } 可以发现，输出的是一个 Promise 对象，那么我们就可以推断出，如果在 async 函数中 return 一个直接量，async 会把这个直接量通过 resolve() 封装成 Promise 对象返回，那么针对上面的这个例子，如果在最外层不能用 await 获取其返回值的情况下，我们便可以使用针对 Promise 标准的处理方式来进行处理，即使用 then() 方法，如下 123f().then((res) =&gt; { console.log(res) // 1}) 通过输出的结果我们可以知道，其实 async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数，但是我们思考一下，如果 async 函数没有返回值，那又会如何处理呢？其实很简单，它会直接返回 resolve(undefined)，因为如果在没有 await 的情况下去执行 async 函数，它会立即执行返回一个 Promise 对象，并且绝不会阻塞后面的语句，这和普通返回 Promise 对象的函数并无二致，在简单了解完 async 以后，下面我们在来看看 await 这个关键字 Await关键词 await 是等待的意思，那么它在等待什么呢？根据 MDN 可知，await 操作符用于等待一个 Promise 对象或者任何要等待的值，它会返回 Promise 对象的处理结果，如果等待的不是 Promise 对象，await 会把该值转换为已正常处理的 Promise，然后等待其处理结果，基本语法如下 1[return_value] = await expression 这里有一个需要注意的地方，那就是 await 所要等待的并不一定要是 Promise 对象，后面实际是可以接普通函数调用或者直接量的 1234567891011121314151617// 普通函数function getSomething() { return 'hello'}// async 函数async function testAsync() { return Promise.resolve('world')}async function test() { const v1 = await getSomething() const v2 = await testAsync() console.log(v1, v2)}test() // hello world 那么这里就会存在一个问题，即为什么 await 关键词只能在 async 函数中使用呢？这是因为 async 函数返回的是一个 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，而 await 操作符等的就是这样一个返回的结果，如果是同步的情况，那就直接返回了，但是在异步的情况下，await 会阻塞整一个流程，直到结果返回之后，才会继续下面的代码，如果希望多个请求可以并发执行，可以使用 Promise.all 或者 Promise.allSettled 12345678910111213141516171819async function dbFuc(db) { let docs = [{}, {}, {}] // 这里会报错，因为 await 的上一级函数不是 async 函数 docs.forEach(function (doc) { await db.post(doc) }) // 针对于这种情况可以采用 for 循环或者使用数组的 reduce 方法，第一种，使用 for 循环 for (let doc of docs) { await db.post(doc) } // 第二种，使用数组的 reduce 方法 await docs.reduce(async (_, doc) =&gt; { await _ await db.post(doc) }, undefined)} 实战在了解了 async 和 await 的基本概念以后，我们来通过一个示例加深一下理解，如下 12345678910111213async function setTime(time) { await setTimeout(() =&gt; { console.log(1) }, time)}async function log(val, time) { await setTime(time) console.log(val)}log(2, 3000)// 2 ==&gt; 立即输出// 1 ==&gt; 三秒后输出 通过观察可以发现，为何我们明明写了 await setTimeout，但是 log 函数却并没有等到 setTimeout 执行完毕后再打印？带着这个疑问我们先来看下面这几个例子 12345678910// 示例一async function test() { await setTimeout(() =&gt; console.log(1), 3000) console.log(2)}test()// 2 ==&gt; 立即输出// 1 ==&gt; 三秒后输出 是不是和开头的示例类似，不急，我们接着往下看 123456789// 示例二async function test() { await new Promise(resolve =&gt; setTimeout(() =&gt; console.log(1), 3000)) console.log(2)}test()// 1 ==&gt; 三秒后输出 这一次我们使用一个 new Promise() 将 setTimeout 包裹了起来，但是并没有设置成功或者失败的回调，可以发现 console.log(2) 这一句并没有执行，再来简单的调整一下 12345678910// 示例三async function test() { await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(console.log(1)), 3000)) console.log(2)}test()// 1 ==&gt; 三秒后输出// 2 ==&gt; 三秒后输出 这一次我们将 setTimeout 的结果放入到 resolve 回调当中，发现是可以达到我们预期的输出，首先 await 后面如果跟的是一个 Promise对象，所以它会去等该 promise resolve 后才会继续下面的执行，所以会在三秒后输出 1 和 2，以为这样就完了？我们接着往下看 12345678910// 示例四async function test() { await Promise.resolve(setTimeout(() =&gt; console.log(1), 3000)) console.log(2)}test()// 2 ==&gt; 立即输出// 1 ==&gt; 三秒后输出 我们这次没有使用 new Promise() 将 setTimeout 包裹，而是直接使用 Promise.resolve()，发现结果又和开头部分的几个示例一样了，这是因为 await 后面是一个已经 resolve 的 Promise，所以会直接进入到下一步 12345678910// 示例五async function test() { await Promise.all([setTimeout(() =&gt; console.log(1), 3000)]) console.log(2)}test()// 2 ==&gt; 立即输出// 1 ==&gt; 三秒后输出 我们这一次换成了 Promise.all，可以发现当 all 的数组元素不是 Promise 的时候会调用 Promise.resolve 方法进行包装，所以产生的结果与示例四是一样的，通过上面连续的几个示例我们可以发现，await 后面跟着的函数是会被立即调用的（非 Promise） 1234567891011async function test() { await setTimeout(() =&gt; console.log(1), 1000) await setTimeout(() =&gt; console.log(2), 3000) await console.log(3)}test()// 3 ==&gt; 立即输出// 1 ==&gt; 一秒后输出// 2 ==&gt; 三秒后输出 但是这并不代表它们执行全是同步的，请看下列代码的输出 12345678910111213async function test() { console.log(1) await console.log(2) console.log(4)}test()console.log(3)// 1// 2// 3// 4 为什么会造成这样的结果呢，我们来将其稍微调整一下，就成为了下面的这个样子 12345678async function foo() { console.log(1) await Promise.resolve(console.log(2)) console.log(4)}foo()console.log(3) 这样写的话看起来就好理解了，先输出 1，然后发现了 await，又发现等待的不是 Promise 对象，所以就会调用 Promise.resolve 方法进行包装，然后就输出了 2，但是却会有个异步的过程，这样 3 就会被输出，最后在输出 4 Async 和 Await 的优势严谨的说，async 是一种语法，Promise 是一个内置对象，两者并不具备可比性，更何况 async 函数实际上返回的也是一个 Promise 对象，所以下面我们就来看看几种异步处理方法之间的比较，其实在 ES6 之前，异步编程的方法，大概有下面这几种 回调函数 事件监听 发布/订阅 不过今天我们不会介绍这些，我们今天主要来看 Promise、generator 函数与 async 函数的比较，如果想了解其他部分可以自行查阅相关知识点，我们还是以一个示例进行比较，我们假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个，如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值，先来看看 Promise 的写法 123456789101112131415function chainAnimationsPromise(elem, animations) { let ret = null // 变量 ret 用来保存上一个动画的返回值 let p = Promise.resolve() // 新建一个空的 promise for (let anim of animations) { // 使用 then 方法，添加所有动画 p = p.then(function (val) { ret = val return anim(elem) }) } return p.catch(function (e) { // 返回一个部署了错误捕捉机制的 promise /* 忽略错误，继续执行 */ }).then(function () { return ret })} 一眼看上去，代码完全都是 Promise 的相关 API（then、catch 等等），操作本身的语义反而不容易看出来，下面我们再来看看 generator 函数的写法 12345678910111213function chainAnimationsGenerator(elem, animations) { return spawn(function* () { let ret = null try { for (let anim of animations) { ret = yield anim(elem) } } catch (e) { /* 忽略错误，继续执行 */ } return ret })} 可以发现 generator 函数的写法语义比 Promise 写法更清晰，用户定义的操作全部都出现在 spawn 函数的内部，但是问题在于必须有一个任务运行器来自动执行 generator 函数，上面代码的 spawn 函数就是自动执行器，它返回一个 Promise 对象，而且必须保证 yield 语句后面的表达式，必须返回一个 Promise，最后我们再来看看 async 函数的写法 1234567891011async function chainAnimationsAsync(elem, animations) { let ret = null try { for (let anim of animations) { ret = await anim(elem) } } catch (e) { /* 忽略错误，继续执行 */ } return ret} 可以发现 async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码，但是也不要为了使用 async 而去使用 async，所有的异步处理方法存在即合理，没有那个最好，只有最合适，在处理不同的实际情况时，我们选择最适合的处理方法即可 错误处理Promise 并不是只有一种 resolve，还有一种 reject 的情况，而 await 只会等待一个结果，那么发生错误了该怎么处理呢？一般有两种方式来进行处理，第一种就是用 try-catch 来做错误捕捉，如果 await 命令后面跟的是 Promise 对象，并且运行结果可能是 rejected 的话，最好把 await 命令放在 try-catch 代码块中 123456789async function test() { try { await Promise.reject('1') } catch (err) { console.log(err) }}test() // 1 第二种就是用 Promise 的 catch 来做错误捕捉 123456async function test() { await Promise.reject('1').catch((err) =&gt; { console.log(err) })}test() // 1 简单实现我们下面来看一下如何手动的来实现一个 async，其实简单来说，async 函数的实现原理，就是将 generator 函数和自动执行器，包装在一个函数里，比如下面这样 1234567891011async function fn(args) { // ...}// 等同于 ==&gt;function fn(args) { return spawn(function* () { // ... })} 其实所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器，不过还是老规矩，我们先从一个示例开始看起，如下 123456789101112const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('data'), 1000))async function test() { const data = await getData() console.log('data: ', data) const data2 = await getData() console.log('data2: ', data2) return 'success'}// 1 秒后打印 data，再过一秒打印 data2，最后打印 successtest().then(res =&gt; console.log(res)) 我们将其改为 generator 的方式是下面这样的 1234567function* testG() { const data = yield getData() console.log('data: ', data) const data2 = yield getData() console.log('data2: ', data2) return 'success'} 但是我们都知道，generator 函数是不会自动执行的，需要我们每一次手动的去调用它的 next 方法，才会停留在下一个 yield 的位置，所以利用这个特性，我们只要编写一个自动执行的函数，就可以让这个 generator 函数完全实现 async 函数的功能，也就是下面这样的 12345678910111213const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('data'), 1000))var test = spawn( function* testG() { const data = yield getData() console.log('data: ', data) const data2 = yield getData() console.log('data2: ', data2) return 'success' })test().then(res =&gt; console.log(res)) 是不是有点思路了，spawn 方法接受一个 generator 函数，返回一个 Promise，下面我们就来看看 spawn 函数的具体实现 12345678910111213141516171819202122function spawn(genF) { return new Promise(function (resolve, reject) { // 返回的是一个 promise const gen = genF() // 直接调用来生成迭代器 function step(nextF) { let next try { // 包裹在 try-catch 中，如果报错了就把 promise 给 reject 掉，外部就可以通过 .catch 获取到错误 next = nextF() // next 的结果是一个 { value, done } 的结构 } catch (e) { return reject(e) } if (next.done) { // 如果已经完成，就直接 resolve 这个 promise return resolve(next.value) } Promise.resolve(next.value).then(function (v) { // 除了最后结束的时候外，每次调用 .next()，其实是返回的都是 { value: Promise, done: false } 的结构 step(function () { return gen.next(v) }) // 只要 done 不是 true 的时候，就会递归的往下解开 promise }, function (e) { step(function () { return gen.throw(e) }) }) } step(function () { return gen.next(undefined) }) // 开启 })} 其实也就是我们经常听闻的 Node.js 中的 co 模块 的实现方式，它的目的也是为了 generator 函数的自动执行 顶层 Await我们在上面曾介绍到说 await 关键词只能在 async 函数中使用，否则都会报错，但是现在有一个 语法提案（目前提案处于 Status: Stage 3），允许在模块的顶层独立使用 await 命令，这个提案的目的，是借用 await 解决模块异步加载的问题，比如下面这种情况 12345678910111213141516// awaiting.js，模块的输出值 output 取决于异步操作let output(async function main() { const dynamic = await import(someMission) const data = await fetch(url) output = someProcess(dynamic.default, data)})()export { output }// usage.js，加载 awaiting.js 的模块import { output } from './awaiting.js'function outputPlusValue(value) { return output + value }console.log(outputPlusValue(100))setTimeout(() =&gt; console.log(outputPlusValue(100), 1000) 如果运行了可以发现，outputPlusValue() 的执行结果，完全取决于执行的时间，如果 awaiting.js 里面的异步操作没执行完，加载进来的 output 的值就是 undefined，目前的解决方法是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束 12345678// usage.jsimport promise, { output } from './awaiting.js'function outputPlusValue(value) { return output + value }promise.then(() =&gt; { console.log(outputPlusValue(100)) setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000)}) 上面代码中，将 awaiting.js 对象的输出，放在 promise.then() 里面，这样就能保证异步操作完成以后，才去读取 output，但是这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块，一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错，而且如果上面的 usage.js 又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载 但是如果有了顶层 await 以后就简单了许多，顶层的 await 命令，它会保证只有异步操作完成，模块才会输出值 123456789101112// awaiting.jsconst dynamic = import(someMission)const data = fetch(url)export const output = someProcess((await dynamic).default, await data)// usage.jsimport { output } from './awaiting.js'function outputPlusValue(value) { return output + value }console.log(outputPlusValue(100))setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000) 上面代码中，两个异步操作在输出的时候，都加上了 await 命令，只有等到异步操作完成，这个模块才会输出值，下面再来看几个顶层 await 的一些使用场景 12345678910111213// import() 方法加载const strings = await import(`/i18n/${navigator.language}`)// 数据库操作const connection = await dbConnector()// 依赖回滚let jQuerytry { jQuery = await import('https://cdn-a.com/jQuery')} catch { jQuery = await import('https://cdn-b.com/jQuery')} 另外如果加载多个包含顶层 await 命令的模块，加载命令是同步执行的 123456789101112// x.jsconsole.log('X1')await new Promise(r =&gt; setTimeout(r, 1000))console.log('X2')// y.jsconsole.log('Y')// z.jsimport './x.js'import './y.js'console.log('Z') 上面代码有三个模块，最后的 z.js 加载 x.js 和 y.js，打印结果是 X1、Y、X2、Z，这说明 z.js 并没有等待 x.js 加载完成再去加载 y.js，顶层 await 命令有点像交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行 参考 async 函数 理解 JavaScript 的 async/await AsyncFunction await","link":"/2020/01/16/JavaScript/50/"},{"title":"ES6 中的 Symbol，Set 和 Map","text":"在平常的开发当中，我们会经常用到 ES6 相关语法，大致总结一下，ES6 更新的内容可以分为以下几点 表达式，声明、解构赋值 内置对象，字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect 语句与运算，Class、Module、Iterator 异步编程，Promise、Generator、Async 有一些是我们经常会遇到和用到的，比如 let，const，扩展运算，Promise 等，之前也单独整理过一些，比如 Class，Iterator，Async，Await 和 Reflect 等 今天我们就来看看剩下的几个可能是平常用的不太多的 Symbol，Set 和 Map，主要参考的是 ECMAScript 6 入门 SymbolES6 引入了一种新的原始数据类型 Symbol，每个从 Symbol() 返回的 symbol 值都是唯一的，一个 symbol 值能作为对象属性的标识符，这是该数据类型仅有的目的，下面我们就来看看 Symbol 类型具有哪些特性 独一无二直接使用 Symbol() 创建新的 symbo l变量，可选用一个字符串用于描述，当参数为对象时，将调用对象的 toString() 方法 12345var sym1 = Symbol() // Symbol() var sym2 = Symbol('foo') // Symbol(foo)var sym3 = Symbol('foo') // Symbol(foo)var sym4 = Symbol({ name: 'foo' }) // Symbol([object Object])console.log(sym2 === sym3) // false 我们用两个相同的字符串创建两个 Symbol 变量，它们是不相等的，可见每个 Symbol 变量都是独一无二的，如果我们想创造两个相等的 Symbol 变量，可以使用 Symbol.for(key) Symbol.for(key) 使用给定的 key 搜索现有的 symbol，如果找到则返回该 symbol，否则将使用给定的 key 在全局 symbol 注册表中创建一个新的 symbol 12345var sym1 = Symbol.for('foo')var sym2 = Symbol.for('foo')// trueconsole.log(sym1 === sym2) 另外还有一个 Symbol.keyFor() 的方法，它则是用于返回已登记的 Symbol 类型值的 key，但是需要注意，只能返回 Symbol.for() 的 key 12345let s1 = Symbol.for('foo')Symbol.keyFor(s1) // 'foo'let s2 = Symbol('foo')Symbol.keyFor(s2) // undefined 原始类型需要注意的是，Symbol 函数前不能使用 new 命令，否则会报错，这是因为生成的 Symbol 是一个原始类型的值，不是对象 1new Symbol() // Uncaught TypeError: Symbol is not a constructor 我们可以使用 typeof 运算符判断一个 Symbol 类型 123typeof Symbol() === 'symbol' // truetypeof Symbol('foo') === 'symbol' // true 不可枚举Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for-in、for-of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回，但是可以使用 Object.getOwnPropertySymbols() 方法来获取指定对象的所有 Symbol 属性名，该方法返回一个数组 12345678910const obj = {}let a = Symbol('a')let b = Symbol('b')obj[a] = 'hello'obj[b] = 'world'const objectSymbols = Object.getOwnPropertySymbols(obj)objectSymbols // [Symbol(a), Symbol(b)] 另外也可以使用 Reflect.ownKeys() 方法来获取 1Reflect.ownKeys(obj) // [Symbol(a), Symbol(b)] 所以可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法 1234567891011121314151617181920212223242526let size = Symbol('size')class Collection { constructor() { this[size] = 0 } add(item) { this[this[size]] = item this[size]++ } static sizeOf(instance) { return instance[size] }}let x = new Collection()Collection.sizeOf(x) // 0x.add('foo')Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 应用场景我们下面简单的来看几个 Symbol 在程序中的应用场景 应用一，防止 XSS 在 React 的 ReactElement 对象中，有一个 typeof 属性，它是一个 Symbol 类型的变量 123var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &amp;&amp; Symbol.for &amp;&amp; Symbol.for('react.element')) || 0xeac7 ReactElement.isValidElement 函数用来判断一个 React 组件是否是有效的，下面是它的具体实现 123456789101112131415/** * Verifies the object is a ReactElement. * See https://reactjs.org/docs/react-api.html#isvalidelement * @param {?object} object * @return {boolean} True if `object` is a ReactElement. * @final */export function isValidElement(object) { // 还是很严谨的 return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE )} 可见 React 渲染时会把没有 $$typeof 标识，以及规则校验不通过的组件过滤掉，比如我们的服务器有一个漏洞，允许用户存储任意 JSON 对象，而客户端代码需要一个字符串，这可能会成为一个问题 1234567891011// JSONlet expectedTextButGotJSON = { type: 'div', props: { dangerouslySetInnerHTML: { __html: '/* put your exploit here */' }, },}let message = { text: expectedTextButGotJSON } 而 JSON 中不能存储 Symbol 类型的变量，这就是防止 XSS 的一种手段 应用二，私有属性 借助 Symbol 类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写 12345678910111213const privateField = Symbol()class myClass { constructor() { this[privateField] = 'abc' } getField() { return this[privateField] } setField(val) { this[privateField] = val }} 应用三，防止属性污染 在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用 Symbol 作为对象属性可以保证永远不会出现同名属性，例如下面的场景，我们模拟实现一个 call 方法 123456789101112Function.prototype.call = function (context, ...args) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = context[fn](...args) delete context[fn] return result} SetES6 提供了新的数据结构 Set，它类似于数组，但是成员的值都是唯一的，没有重复的值，在平常开发当中，使用较多的就是用来进行去重，如下数组去重 1[...new Set(array)] 也可以用于字符串去重 1[...new Set('ababbc')].join('') // abc 但是除了去重之外，Set 还有许多其他的方法，因为 Set 本身是一个构造函数，可以用来生成 Set 数据结构 1234567const s = new Set()[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x))for (let i of s) { console.log(i) // 2 3 5 4} Set 实例的属性和方法我们先来看看 Set 当中的操作方法，主要有以下这些 add()，添加值，返回实例 delete()，删除值，返回布尔值 has()，检查值，返回布尔值 clear()，清除所有成员 123456789101112131415let s = new Set()s.add(1).add(2).add(2)s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2)s.has(2) // falses.clear()s.size // 0 除了操作方法之外，还有遍历方法 keys()，返回以属性值为遍历器的对象 values()，返回以属性值为遍历器的对象 entries()，返回以属性值和属性值为遍历器的对象 forEach()，使用回调函数遍历每个成员 keys 方法、values 方法、entries 方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue'])for (let item of set.keys()) { console.log(item)}// red// green// bluefor (let item of set.values()) { console.log(item)}// red// green// bluefor (let item of set.entries()) { console.log(item)}// ['red', 'red']// ['green', 'green']// ['blue', 'blue'] Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法，所以可以省略 values 方法，直接用 for-of 循环遍历 Set 12345678let set = new Set(['red', 'green', 'blue'])for (let x of set) { console.log(x)}// red// green// blue Set 结构的实例与数组一样，也拥有 forEach 方法，用于对每个成员执行某种操作，『没有返回值』 12345678let set = new Set([1, 4, 9])set.forEach((v, k) =&gt; { console.log(k + ' : ' + v)})// 1 : 1// 4 : 4// 9 : 9 而且，数组的 map 和 filter 方法也可以间接用于 Set 12345let set = new Set([1, 2, 3])new Set([...set].map(x =&gt; x * 2)) // Set {2, 4, 6}let set = new Set([1, 2, 3, 4, 5])new Set([...set].filter(x =&gt; (x % 2) == 0)) // Set {2, 4} 因此使用 Set 可以很容易地实现并集、交集和差集 1234567891011let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b]) // Set {1, 2, 3, 4}// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x))) // set {2, 3}// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x))) // Set {1} WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合，但是 WeakSet 的成员『只能是对象，而不能是其他类型的值』，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中，并且 WeakSet 结构是『不可遍历』的 12345const a = [[1, 2], [3, 4]]const ws = new WeakSet(a) // WeakSet {[1, 2], [3, 4]}const b = [1, 2]const ws = new WeakSet(b) // Uncaught TypeError WeakSet 结构有以下三个方法 add()，添加值，返回实例 delete()，删除值，返回布尔值 has()，检查值，返回布尔值 123456789101112const ws = new WeakSet()const obj = {}const foo = {}ws.add(window)ws.add(obj)ws.has(window) // truews.has(foo) // falsews.delete(window)ws.has(window) // false WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏 MapMap 数据结构类似于对象的数据结构，成员键可以是任何类型的值，也就是说，Object 结构提供了字符串与值的对应，而 Map 结构提供了值与值的对应，是一种更完善的 Hash 结构实现，如果你需要键值对的数据结构，Map 比 Object 更合适 123456789const m = new Map()const o = { p: 'hello world' }m.set(o, 'test')m.get(o) // 'test'm.has(o) // truem.delete(o) // truem.has(o) // false Map 也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组 1234567891011const map = new Map([ ['name', 'zhangsan'], ['name', 'lisi'], ['age', '18']])map.size // 2map.has('name') // truemap.get('name') // 'lisi'map.has('age') // truemap.get('age') // '18' 可以发现，如果对同一个键多次赋值，后面的值将覆盖前面的值，有一个需要注意的地方，只有对同一个对象的引用，Map 结构才将其视为同一个键 1234567891011const m1 = new Map()m1.set(['a'], 555)m1.get(['a']) // undefinedconst m2 = new Map()const a = {}m2.set(a, 555)m2.get(a) // 555 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 与其他数据结构的互相转换关于 Map 数据结构的方法，和 Set 方法使用是类似的，这里就不详细展开了，我们来看看与其他数据结构的互相转换 Map 转为数组，Map 转为数组最方便的方法，就是使用扩展运算符（...） 12345const m = new Map() .set(true, 7) .set({foo: 3}, ['abc'])[...m] // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] 数组转为 Map，将数组传入 Map 构造函数，就可以转为 Map 12345678new Map([ [true, 7], [{ foo: 3 }, ['abc']]])// Map {// true =&gt; 7,// Object { foo: 3 } =&gt; ['abc']// } Map 转为对象，如果所有 Map 的键都是字符串，它可以无损地转为对象，如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名 12345678910111213function strMapToObj(strMap) { let obj = Object.create(null) for (let [k, v] of strMap) { obj[k] = v } return obj}const m = new Map() .set('yes', true) .set('no', false)strMapToObj(m) // { yes: true, no: false } 对象转为 Map 123456789function objToStrMap(obj) { let strMap = new Map() for (let k of Object.keys(obj)) { strMap.set(k, obj[k]) } return strMap}objToStrMap({ yes: true, no: false }) // Map {'yes' =&gt; true, 'no' =&gt; false} Map 转为 JSON，Map 转为 JSON 要区分两种情况，一种情况是 Map 的键名都是字符串，在这种情况下可以先将其转换为对象（使用之前的 strMapToObj() 方法），然后在转换为对象 JSON 123456function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap))}let myMap = new Map().set('yes', true).set('no', false)strMapToJson(myMap) // '{ \"yes\": true, \"no\": false }' 另一种情况是 Map 的键名有非字符串，这时可以选择转为数组 JSON，这时可以选择转为数组 JSON 123456function mapToArrayJson(map) { return JSON.stringify([...map])}let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']).set('yes', true)mapToArrayJson(myMap) // '[[true, 7], [{ \"foo\": 3 }, [\"abc\"]], [\"yes\", true]]' JSON 转为 Map，JSON 转为 Map，正常情况下，所有键名都是字符串，也是使用之前的 objToStrMap() 方法 12345function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr))}jsonToStrMap('{\"yes\": true, \"no\": false}') // Map {'yes' =&gt; true, 'no' =&gt; false} 但是有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组 12345function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr))}jsonToMap('[[true, 7], [{\"foo\": 3}, [\"abc\"]]]') // Map { true =&gt; 7, Object { foo: 3 } =&gt; ['abc'] } WeakMapWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合 1234567891011// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap()const key = { foo: 1 }wm1.set(key, 2)wm1.get(key) // 2// WeakMap 也可以接受一个数组，作为构造函数的参数const k1 = [1, 2, 3]const k2 = [4, 5, 6]const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']])wm2.get(k2) // 'bar' WeakMap 与 Map 的区别有两点 WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 WeakMap 的键名所指向的对象，不计入垃圾回收机制 同 WeakSet 一致，WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内，WeakMap 与 Map 在 API 上的区别主要是两个 一是没有遍历操作（即没有 keys()、values() 和 entries() 方法），也没有 size 属性，因为没有办法列出所有键名 二是无法清空，即不支持 clear() 方法 因此，WeakMap 只有四个方法可用 get()、set()、has()、delete() get()，返回键值对 set()，添加键值对，返回实例 delete()，删除键值对，返回布尔值 has()，检查键值对，返回布尔值 下面我们来看一些 WeakMap 的使用场景 在 DOM 对象上保存相关数据传统使用 jQuery 的时候，我们会通过 $.data() 方法在 DOM 对象上储存相关信息，当你将 DOM 元素删除，DOM 对象置为空的时候，相关联的数据并不会被删除，你必须手动执行 $.removeData() 方法才能删除掉相关联的数据，WeakMap 就可以简化这一操作 12345678let wm = new WeakMap(), el = document.querySelector('.el')wm.set(el, 'data')let value = wm.get(el)console.log(value) // datael.parentNode.removeChild(el)el = null 数据缓存从之前的例子我们可以看出，当我们需要关联对象和数据，比如在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等，而又不想管理这些数据的时候就可以考虑使用 WeakMap，数据缓存就是一个非常好的例子 123456789101112const cache = new WeakMap()function countOwnKeys(obj) { if (cache.has(obj)) { console.log('Cached') return cache.get(obj) } else { console.log('Computed') const count = Object.keys(obj).length cache.set(obj, count) return count }} 部署私有属性WeakMap 也可以被用于实现私有变量，不过在 ES6 中实现私有变量的方式有很多种，这只是其中一种 1234567891011121314151617181920212223const privateData = new WeakMap()class Person { constructor(name, age) { privateData.set(this, { name, age }) } getName() { return privateData.get(this).name } getAge() { return privateData.get(this).age }}const p = new Person('zhangsan', 20)p.name // undefinedp.getName() // zhangsan 结论 &amp;&amp; 区别 Set、Map、WeakSet、WeakMap、都是一种集合的数据结构 Set 和 WeakSet 是一种值-值的集合，且元素唯一不重复 Map 和 WeakMap 是一种键-值对的集合，Map 的键可以是任意类型，WeakMap 的键只能是对象类型 Set 添加值使用 add()，Map 添加值和返回键值对使用 set()/get() Set 和 Map 可遍历，WeakSet 和 WeakMap 不可遍历 WeakSet 和 WeakMap 键名所指向的对象，不计入垃圾回收机制","link":"/2019/11/07/JavaScript/48/"},{"title":"JavaScript 中的位运算符","text":"在平常开发过程当中，你可能听说过位运算符，但是相信大部分人在实际工作中用到位操作的机会也是寥寥无几，而且在一些源码当中，也会经常会碰到类似 !!、~~ 、&gt;&gt; 之类的运算符，所以在本章当中，我们就来深入的探讨一下 JavaScript 当中的位运算符 分类在 JavaScript 中位运算符一共有七个，如下 运算符 用法 描述 按位与（ AND） a &amp; b 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0 按位或（OR） a | b 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0 按位异或（XOR） a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0 按位非（NOT） ~ a 反转操作数的比特位，即 0 变成 1，1 变成 0 左移（Left shift） a &lt;&lt; b 将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用 0 填充 有符号右移 a &gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位 无符号右移 a &gt;&gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充 但是在正式展开之前，我们先来看两个平常使用较多的逻辑运算符 !!这个我们可能经常会遇到，也就是双重否定，通常来说它不是一个独特的 JavaScript 运算符，也不是一个特殊的语法，而只是一个两个否定的序列，它用于任何类型的值转换为它的相应的 true 或 false 取决于它是否是 truthy 或 falsy 布尔值 12345!!1 // true!!0 // false!!undefined // false!!{} // true!![] // true 首先否定转换为任意值 false，然后第二个否定对正常的布尔值进行操作，他们一起可以转换任何 truthy 值为 true 和任何 falsy 值为 false，但是许多专业人士认为使用这种语法的做法是不可接受的，并建议更简单的阅读替代方案 12x !== 0 // instead of !!x in case x is a numberx != null // instead of !!x in case x is an object, a string, or an undefined 由于以下原因，使用 !!x 被视为不良做法 从风格上看，它可能看起来像一个独特的特殊语法，而实际上除了两个连续的隐式类型转换否定之外，它没有做任何事情 最好通过代码提供有关存储在变量和属性中的值类型的信息，例如 x !== 0 表示 x 可能是一个数字，而 !!x 并没有向代码的读者传达任何这样的优势 Boolean(x) 用法允许类似的功能，并且是类型的更明确的转换 但是在这里我们并不是要去探究使用它的好坏，而是来稍微深入一些，看看它的的运行原理，但是要想了解 !! 的运行原理，我们首先要了解逻辑非运算符 ! ，关于逻辑非我们可以参考规范 11.4.9 逻辑非运算符，它是这样定义的 产生式 UnaryExpression : ! UnaryExpression 按照下面的过程执行 1、令 expr 为解释执行 UnaryExpression 的结果2、令 oldValue 为 ToBoolean(GetValue(expr))3、如果 oldValue 为 true，返回 false4、返回 true 说白了就是 ToBoolean 返回的 oldValue 为 true，就为 false，否则为 true，理解了逻辑非以后就不难理解 !! 了，!! 的意思就是直接返回 ToBoolean(GetValue(expr))，就相当于又套了一层，其目的是将操作数转化为布尔类型，相当于 Boolean(value)，我们来看几个例子加深一下印象 12345678!! 1 // true!! 0 // false!! null // false!! undefined // false!! NaN // false!! '' // false!! 'abc' // true!! 100 // true ~~与上面的 !! 类似，我们如果想要理解 ~~，首先要知道按位非操作符 ~ 的概念，通过开头部分的介绍，按位非的意思是反转操作数的比特位，可能不太好理解，换个说法就是对一个二进制位取反，还是先来看规范 11.4.8 按位非运算符，它是这样定义的 产生式 UnaryExpression : ~ UnaryExpression 按照下面的过程执行 1、令 expr 为解释执行 UnaryExpression 的结果2、令 oldValue 为 ToInt32(GetValue(expr))3、返回 oldValue 按位取反的结果，结果为 32 位有符号整数 我们来看一个 MDN 上的例子来了解，如下 123 9 (base 10) = 00000000000000000000000000001001 (base 2) --------------------------------~9 (base 10) = 11111111111111111111111111110110 (base 2) = -10 (base 10) 如果不去看什么转换，取反等操作，我们可以简单的理解为，对任一数值 x 进行按位非操作的结果为 -(x + 1)，例如上面的 ~9 结果为 -10，如果反过来 ~-10 的结果则为 9，当然有这个特性的话，也可以使用在 indexOf() 当中 12345if (~str.indexOf(key)) { // key 包含在字符串 str 中} else { // key 不包含在字符串 str 中} 在明白了按位非 ~ 的意思后，我们就再来看看 ~~，顾名思义，它的作用就是在 ~ 的基础上再做一次按位非，等于省略掉定义中的第三步返回 ToInt32(GetValue(expr))，目的是将操作数转化为 32 位有符号的整数类型，得到结果为 -(-(x + 1) + 1)，我们来看几个例子加深一下印象 1234567891011~~ 0 // 0~~ 1 // 1~~ null // 0~~ undefined // 0~~ NaN // 0~~ '' // 0~~ 'abc' // 1~~ 1.4 // 1~~ -1.4 // -1~~ 1.5 // 1~~ -1.5 // -1 但是在使用 ~~ 进行取整的时候，有一个需要注意的地方，就是注意区分与 parseInt 的区别，两者在本质上是完全不同的 parseInt 的用途是字符串转整数 位运算符是浮点数转 Int32（ToInt32） 但是位运算符和 parseInt 都存在越界问题，其中位运算符限定为 32 位整数，而 parseInt 在转换 number 不能精确表示的数字时会出现问题，parseInt 可能返回 double 类型中的所有整数，也可能返回 NaN、±Infinity，而位运算总是返回 Int32（NaN 和 ±Infinity 会被转为 0） 12345678// ==========console.log(parseInt(1e21)) // 1console.log(parseInt(2e21)) // 2console.log(parseInt('abc')) // NaNconsole.log(~~'abc') // 0console.log(~~999999999.909) // 999999999console.log(~~9999999999.909) // 1410065407 在看完了上面的一些示例以后，我们就正式的来看看 JavaScript 中的位运算符 &amp;（按位与）它的作用是对每一对比特位执行与（&amp;）操作，其实简单来说就是，如 a &amp; b，意思就是将 a 和 b 的每个比特位进行 &amp; 运算，即相对应的两个比特位都是 1 时结果为 1，否则为 0，将任一数值 x 与 0 执行按位与操作，其结果都为 0，也就是下表这样 a b a &amp; b 0 0 0 0 1 0 1 0 0 1 1 1 可能直接看上去有点模糊，我们来看下面这个例子 15 &amp; 6 // 4 从结果可知，是为 4 的，那么我们是如何得到 4 这个结果的呢？我们可以先来看看它们两者对应的二进制 5 的二进制为 101 6 的二进制为 110 然后我们按照上表当中的流程执行后，结果为 100，转换为十进制后为 4，所以结果为 4，下面我们来看一个使用 &amp; 判断奇偶数的小技巧 124 &amp; 1 // 0 偶数5 &amp; 1 // 1 奇数 它的原理是，由于数字 1 的二进制是 00000000000000000000000000000001，并且奇数的二进制最低位也是 1，所以可以用任意整数和 1 进行 &amp; 运算来判断奇偶 |（按位或）它的作用是对每一对比特位执行或（|）操作，如果 a 或 b 为 1，则 a | b 结果为 1，也就是下表这样 a b a | b 0 0 0 0 1 1 1 0 1 1 1 1 同样的，我们也通过下面这个例子来进行了解 15 | 6 // 7 从结果可知，是为 7 的，我们在上面已经知道了它们两者对应的二进制是下面这样的 5 的二进制为 101 6 的二进制为 110 同理按照上表流程执行后，结果为 111，转换为十进制后为 7，所以结果为 7，同样的，我们也来看一个 | 的小技巧，因为位运算只对整数有效，所以在遇到小数时，会将小数部分舍去，只保留整数部分，所以我们可以利用这个特性将一个小数与 0 进行二进制或（|）运算，等同于对该数去除小数部分（向下取整），即只取整数位（需要注意，这种取整方法不适用超过 32 位整数最大值 2147483647 的数） 123.14159 | 0 // 3-3.14159 | 0 // -3 下面我们再来看一些示例加深一下印象 12345678910111213141516171 | 0 // 11.1 | 0 // 1'asd' | 0 // 0'123456' | 0 // 1234560 | 0 // 0(-1) | 0 // -1(-1.5646) | 0 // -1[] | 0 // 0({}) | 0 // 01.23E2 | 0 // 123-1.23E2 | 0 // -1231.23E12 | 0 // 1639353344-1.23E12 | 0 // -1639353344 ^（按位异或）异或运算（^）在两个二进制位不同时返回 1，相同时返回 0，如下表 a b a ^ b 0 0 0 0 1 1 1 0 1 1 1 0 同样的，我们还是通过之前的例子来进行了解 15 ^ 6 // 3 在上面我们已经得知它们对应的二进制值，按照上表执行后的结果为 011，转换为十进制后结果为 3，同样的，异或运算（^）也有一个小技巧，当我们连续对两个数 a 和 b 进行三次异或运算 a ^= b，b ^= a，a ^= b 后可以互换它们的值，这意味着，使用异或运算（^）可以在不引入临时变量的前提下，互换两个变量的值 1234567var a = 5var b = 6a ^= b, b ^= a, a ^= ba // 6b // 5 同样的，异或运算也可以用来取整 13.14 ^ 0 // 3 &lt;&lt;（左移运算符）左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补 0，即乘以 2 的指定次方（最高位即符号位不参与移动），所以我们可以得到操作公式如下 1x &lt;&lt; y = x * Math.pow(2, y) 比如下面这个 9 &lt;&lt; 2 的示例 123 9 (base 10): 00000000000000000000000000001001 (base 2) // 转换为二进制原码 --------------------------------9 &lt;&lt; 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10) // 向左移动两位，丢弃左侧两位，右侧补 0 得到二进制 也就是 9 * Math.pow(2, 2)，所以结果为 36， 看完了上面这个 MDN 提供的示例以后，我们再来看一个使用 &gt;&gt; 的小技巧，那就是在使用 &gt;&gt; 1 的时候其实就相当于除以 2 的操作，但是会忽略余数，在某些场景下会比较适用 1211 &gt;&gt; 1 // 523 &gt;&gt; 1 // 11 另外左移运算符用于二进制数值非常方便，这也是我们在一些操作颜色等第三方类库中经常可以看到的操作 12345678910var color = { r: 186, g: 218, b: 85 }// RGB to HEX，(1 &lt;&lt; 24) 的作用为保证结果是 6 位数var rgb2hex = function (r, g, b) { return '#' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b) .toString(16) // 先转成十六进制，然后返回字符串 .substr(1) // 去除字符串的最高位，返回后面六个字符串}rgb2hex(color.r, color.g, color.b) // '#bada55' 最后再来看几个示例加深一下印象 12345678910111213141516null &lt;&lt; 0 // 0undefined &lt;&lt; 0 // 0NaN &lt;&lt; 0 // 012345 &lt;&lt; 0 // 12345-12345 &lt;&lt; 0 // -1234530.12 &lt;&lt; 0 // 3030.54 &lt;&lt; 0 // 301 &lt;&lt; 1 // 21 &lt;&lt; 2 // 4-1 &lt;&lt; 1 // -2'12345' &lt;&lt; 0 // 12345'' &lt;&lt; 0 // 0'abc' &lt;&lt; 0 // 0 &gt;&gt;（有符号右移）与左移类似，右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧，由于新的最左侧的位总是和以前相同，符号位没有被改变，所以被称作『符号传播』，看下面例子 123 9 (base 10): 00000000000000000000000000001001 (base 2) // 转换为二进制原码 --------------------------------9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10) // 向右移两位，左侧补两位符号位 00 相比之下，-9 &gt;&gt; 2 得到 -3，因为符号被保留了 123 -9 (base 10): 11111111111111111111111111110111 (base 2) ---------------------------------9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10) 另外，右移运算符（&gt;&gt;）可以模拟 2 的整除运算 12345675 &gt;&gt; 1 // 2，相当于 5 / 2 = 221 &gt;&gt; 2 // 5，相当于 21 / 4 = 521 &gt;&gt; 3 // 2，相当于 21 / 8 = 221 &gt;&gt; 4 // 1，相当于 21 / 16 = 1 也可以和我们上面介绍的异或运算（^）一起使用来实现取绝对值 12345function abs(a) { // 如果 a 为正数或 0 则 b 为 0，如果 a 是负数则 b 为 -1 var b = a &gt;&gt; 31 return (a ^ b) - b} 同样的，看几个例子加深一下印象 1234567891011121314null &gt;&gt; 0 // 0undefined &gt;&gt; 0 // 0NaN &gt;&gt; 0 // 012345 &gt;&gt; 0 // 12345-12345 &gt;&gt; 0 // -1234530.12 &gt;&gt; 0 // 3030.54 &gt;&gt; 0 // 301 &gt;&gt; 1 // 0-1 &lt;&lt; 1 // -1'12345' &gt;&gt; 0 // 12345'' &gt;&gt; 0 // 0'abc' &gt;&gt; 0 // 0 &gt;&gt;&gt;（无符号右移）该操作符会将第一个操作数向右移动指定的位数，向右被移出的位被丢弃，左侧用 0 填充，它与有符号右移（&gt;&gt;）的区别就是在于负数的处理不同，因为符号位变成了 0，所以结果总是非负的，即便右移 0 个比特，结果也是非负的，对于非负数，有符号右移和无符号右移总是返回相同的结果，例如 9 &gt;&gt;&gt; 2 和 9 &gt;&gt; 2 一样返回 2 123 9 (base 10): 00000000000000000000000000001001 (base 2) --------------------------------9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10) 而如果是负数，结果却有很大不同 123 -9 (base 10): 11111111111111111111111111110111 (base 2) ---------------------------------9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10) 其实简单来说，例如 length &gt;&gt;&gt; 0，字面上的意思是指『右移 0 位』，但实际上是把前面的空位用 0 填充，这里的作用是保证结果为数字且为整数，再来看下面几个示例加深一下印象 12345678910111213141516171819202122232425null &gt;&gt;&gt; 0 // 0undefined &gt;&gt;&gt; 0 // 0void (0) &gt;&gt;&gt; 0 // 0[] &gt;&gt;&gt; 0 // 0123123 &gt;&gt;&gt; 0 // 12312345.2 &gt;&gt;&gt; 0 // 450 &gt;&gt;&gt; 0 // 0- 0 &gt;&gt;&gt; 0 // 0- 1 &gt;&gt;&gt; 0 // 4294967295- 1212 &gt;&gt;&gt; 0 // 4294966084function a() { }a &gt;&gt;&gt; 0 // 0var a = {}a &gt;&gt;&gt; 0 // 0 一个综合示例最后的最后，我们再来看一个综合的使用方式，即使用我们之前的介绍的位运算符来实现一个 rgb 值和 16 进制颜色值之间的转换，如下 123456789101112131415161718192021222324252627/** * 16 进制颜色值转 RGB * @param {String} hex 16 进制颜色字符串 * @return {String} RGB 颜色字符串 */function hexToRGB(hex) { var hexx = hex.replace('#', '0x') var r = hexx &gt;&gt; 16 var g = hexx &gt;&gt; 8 &amp; 0xff var b = hexx &amp; 0xff return `rgb(${r}, ${g}, ${b})`}/*** RGB 颜色转 16 进制颜色* @param {String} rgb RGB 进制颜色字符串* @return {String} 16 进制颜色字符串*/function RGBToHex(rgb) { var rgbArr = rgb.split(/[^\\d]+/) var color = rgbArr[1] &lt;&lt; 16 | rgbArr[2] &lt;&lt; 8 | rgbArr[3] return '#' + color.toString(16)}// 使用hexToRGB('#ccc') // 'rgb(0, 12, 204)'RGBToHex('rgb(0, 12, 204)') // '#ccc' 参考 MDN - 按位操作符 位运算符","link":"/2020/07/17/JavaScript/52/"},{"title":"Object 上的原生 API","text":"在平常开发过程当中，虽然 Object 上的一些原生方法经常会看到，比如在一些扩展的第三方插件中可能会遇到，但是遇到了类似于 Object.fromEntries() 和 Object.entries() 这种长的比较像的但是使用频率较低的 API，往往又是傻傻分不清楚，更别说它们具体是做什么用的，所以今天就打算将其汇总一下，将 Object 上涉及到的平常可能会遇到的 API 整体的学习记录一下，免得下次再次遇到又是一头雾水 其实简单来说，Object 上的原生 API 主要分为两部分，一部分是 Object 上面的方法，而另一部分则是 Object.prototype 上面的方法，下面我们就一个一个来看 Object 上的方法Object 上面涉及到的方法其实不算很多，大致都可以按类别划分，所以我们将会分类来进行介绍，下表是一些本文当中没有涉及到的方法，其中有一些在之前的文章当中我们也都已经介绍过了，感兴趣的话可以自行参考，所以这里就不详细展开了 方法 描述 Object.assign() 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，一般克隆场景使用较多，详细可见 对象的浅拷贝 Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__，详细可见 Object.create() Object.is(value1, value2) 判断两个值是否是 相同的值（同 ===），但是这个可以比对 NaN Object.getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组，详细可见 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() 返回一个给定对象自身的所有 Symbol 属性的数组 Object.values() 返回一个给定对象自身的所有可枚举属性值的数组 Object.keys() 返回一个由一个给定对象的自身可枚举属性组成的数组，这两个详细可见 Object.keys() Object.defineProperty() 和 Object.defineProperties()涉及到的两个方法如下 方法 描述 Object.defineProperty() 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象，详细可见 Object.defineProperty() Object.defineProperties() 这个同上面那个类似，但是可以同时定义和修改多个属性 Object.defineProperty() 这个属性在之前我们已经介绍过了，该方法允许精确添加或修改对象的属性，比如 enumerable，configurable 和 writable 等，也可以用其来实现数据双向绑定，可谓是用处多多，不过我们今天主要来看这个跟它长的十分相像的 Object.defineProperties() 其实它俩是一个东西，不过当定义或修改对象的多个属性时，使用 Object.defineProperty() 就会比较麻烦了，在这种情况下我们可以考虑使用 Object.defineProperties() 123456789101112131415var man = {}Object.defineProperties(man, { name: { value: 'zhangsan', writable: true }, age: { value: 20, writable: true }})console.log(man.name) // zhangsanconsole.log(man.age) // 20 Object.entries() 和 Object.fromEntries()涉及到的两个方法如下 方法 描述 Object.entries() 返回一个给定对象自身可枚举属性的键值对数组，详细可见 Object.entries(obj) Object.fromEntries() 可以把把键值对列表转换为一个对象 Object.entries() 在迭代器相关章节我们曾经使用过这个方法，它接收一个可以返回其可枚举属性的键值对的对象，返回给定对象自身可枚举属性的键值对数组，Object 之所以不能被 for-of 遍历，主要是因为它没有部署 Iterator 接口，在这种情况下我们可以使用 Object.entries() 将其包裹一下，利用其返回的键值对数组再来进行遍历（会存在一定问题，以实际使用场景来决定是否这样使用），看下面这两个例子 1234567const obj = { 100: 'a', 2: 'b', 7: 'c'}console.log(Object.entries(obj)) // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ] 这里需要注意，上面例子的返回结果的排序是改变过的，至于为什么可以参考 为什么 Object.keys 的返回值会自动排序，另外一个例子就是将 Object 转换为 Map，new Map() 函数接受一个可迭代的 entries，借助 Object.entries 方法可以很容易的将 Object 转换为 Map 123var obj = { foo: 'bar', baz: 42 }console.log(new Map(Object.entries(obj))) // Map(2) { 'foo' =&gt; 'bar', 'baz' =&gt; 42 } 下面我们再来看看 Object.fromEntries() 这个方法，其实简单来说，就是 Object.entries 的反转 但是需要注意的是，这个 API 现在的兼容性还不是很好，可以考虑使用 polyfill 该方法接收一个键值对的列表参数（可迭代对象，类似 Array，Map 或者其它实现了可迭代协议的对象）并返回一个由该迭代对象条目提供对应属性的新对象，生成的是一个具有两个元素的类数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值，来看几个例子，比如将 Map 转化为 Object 123const map = new Map([['foo', 'bar'], ['baz', 42]])console.log(Object.fromEntries(map)) // { foo: 'bar', baz: 42 } 也可以将 Array 转化为 Object 123const arr = [['0', 'a'], ['1', 'b'], ['2', 'c']]console.log(Object.fromEntries(arr)) // { 0: 'a', 1: 'b', 2: 'c' } getOwnPropertyDescriptor() 和 getOwnPropertyDescriptors()涉及到的几个方法如下 方法 描述 Object.getOwnPropertyDescriptor() 返回指定对象上一个自有属性对应的属性描述符（直接赋予的，不需要从原型链上进行查找的属性） Object.getOwnPropertyDescriptors() 获取一个对象的所有自身属性的描述符 Object.setPrototypeOf() 这个方法不建议使用，它的作用是设置一个指定的对象的原型到另一个对象，更推荐使用 Object.create() Object.getPrototypeOf() 返回指定对象的原型（内部 [[Prototype]] 属性的值） 这两个方法的作用也是一样的，都是返回指定对象『自有属性』对应的属性描述符，不过一个是返回指定的，一个是返回全部的 需要注意，这里指的是自有属性，意思是直接赋予该对象的属性，而不需要从原型链上进行查找的属性 两者的语法如下 123Object.getOwnPropertyDescriptor(obj, prop)Object.getOwnPropertyDescriptors(obj) 下面我们通过一个例子来了解它们如何使用 12345678910111213141516171819202122232425var obj = {}Object.defineProperty(obj, 'age', { value: 20, writable: false, enumerable: false})Object.getOwnPropertyDescriptor(obj, 'age')// {// configurable: false// enumerable: false// value: 20// writable: false// }Object.getOwnPropertyDescriptors(obj)// age: {// configurable: false// enumerable: false// value: 20// writable: false// } 关于 Object.getOwnPropertyDescriptor(obj, prop) 方法有一个需要注意的地方 在 ES5 中，如果该方法的第一个参数不是对象（而是基本类型），那么就会产生出现 TypeError 而在 ES6 中，第一个的参数不是对象的话就会被强制转换为对象 但是 Object.getOwnPropertyDescriptors(obj) 这个方法的作用不仅仅只是用于查看对象的属性描述符，比如还可以用来『浅拷贝』对象 123456789101112131415161718var obj = { a: 1, b: { name: 'zhangsan' }}var newObj = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) )console.log(newObj) // { a: 1, b: { name: 'zhangsan' } }newObj.a = 2newObj.b.name = 'lisi'console.log(obj) // { a: 1, b: { name: 'lisi' } } 另外还可以用来创建子类，创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性，其实就是我们常说的继承，也就是原来经常使用的 123456father.call(this)child.prototype = new father()// 但是推荐使用下面这种方式child.prototype = Object.create(father.prototype)child.prototype.constructor = child 但是现在我们可以通过 Object.getOwnPropertyDescriptors() 更为优雅的来实现 1234567891011function Foo() { }Foo.prototype = { // 在这里定义方法和属性}function Bar() { }Bar.prototype = Object.create(Foo.prototype, Object.getOwnPropertyDescriptors({ // 在这里定义方法和属性})) 在上面浅拷贝的例子当中涉及到一个方法 Object.getPrototypeOf(obj)，它的作用是返回指定对象的原型（内部 [[Prototype]] 属性的值），比如下面这个例子 12345var reg = /^\\s/Object.getPrototypeOf(reg) === RegExp.prototype // truevar obj = { }Object.getPrototypeOf(obj) === Object.prototype // true 但是这里特别需要注意了，Object.getPrototypeOf(Object) 返回的并不是 Object.prototype，看下面这个特殊的例子 1234567Object.prototype === Function.prototype.__proto__ // trueObject.prototype === Function.prototype // falseObject.getPrototypeOf(Object) // ƒ () { [native code] }Object.getPrototypeOf(Function) // ƒ () { [native code] }Object.getPrototypeOf(Object) === Function.prototype // true 在 JavaScript 中的 Object 其实是构造函数，即是创建对象的包装器，所以我们一般用法是 1var obj = new Object() 而 Object.getPrototypeOf(Object) 的意思是把 Object 这一构造函数看作对象，返回的当然是函数对象的原型，也就是 Function.prototype，所以结果是 true，所以正确的方法应该是，Object.prototype 是构造出来的对象的原型 1234var obj = new Object()Object.getPrototypeOf(obj) === Object.prototype // trueObject.getPrototypeOf({}) === Object.prototype // true 同样的，Object.getPrototypeOf(obj) 方法在 ES5 中的参数如果不是对象，也会出现 TypeError，而 ES6 中会被强制转换为对象 Object.preventExtensions()，Object.seal() 和 Object.freeze()涉及到的几个方法如下 方法 描述 Object.preventExtensions() 让一个对象变的不可扩展，也就是永远不能再添加新的属性 Object.isExtensible() 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性） Object.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置 Object.isSealed() 判断一个对象是否被密封 Object.freeze() 冻结一个对象，一个被冻结的对象再也不能被修改 Object.isFrozen() 判断一个对象是否被冻结 最后这六个我们放到一起来进行介绍，因为它们主要涉及到的都是对象的扩展、密封和冻结，通过字面意思也可以发现，它们针对于对象限制的严格程度是一层更胜一层 Object.preventExtensions()先来看看 Object.preventExtensions()，它的作用是阻止对象扩展，让一个对象变的不可扩展，也就是永远不能再添加新的属性，但是也有几个需要注意的地方 一般来说，不可扩展对象的属性可能仍然可被删除，只是不可扩展 Object.preventExtensions() 仅阻止添加属性，但属性仍然可以添加到对象原型 12345678910111213141516171819// 示例一var obj = { name: 'zhangsan'}Object.preventExtensions(obj)obj.age = 20console.log(obj.age) // undefined// 示例二var obj = { name: 'zhangsan'}Object.preventExtensions(obj)delete obj.nameconsole.log(obj.name) // undefined 如果是严格模式，则会报错 123456789'use strict'var obj = { name: 'zhangsan'}Object.preventExtensions(obj)obj.age = 20 // TypeError 在 JavaScript 当中新增了一个 Object.isExtensible() 方法用来判断一个对象是否是可扩展的 123456789101112131415// 新对象默认是可扩展的var obj = {}Object.isExtensible(obj) // ==&gt; true// 让其不可扩展Object.preventExtensions(obj)Object.isExtensible(obj) // ==&gt; false// 密封对象是不可扩展的var sealed = Object.seal({})Object.isExtensible(sealed) // ==&gt; false// 冻结对象也是不可扩展var frozen = Object.freeze({})Object.isExtensible(frozen) // ==&gt; false Object.seal()下面我们再来看看密封，密封则会在不可扩展的基础之上更进一步，Object.seal() 方法会封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，简单来说就是不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象 12345678910111213141516var obj = { name: 'zhangsan' }// 密封Object.seal(obj)// 不能添加新属性obj.age = 20console.log(obj.age) // undefined// 注意，现在删除属性也是无效的delete obj.nameconsole.log(obj.name) // zhangsan// 但是可以修改已有属性obj.name = 'lisi'console.log(obj.name) // lisi 如果修改已有属性的可枚举性、可配置性、可写性，会提示报错 12345678910111213var obj = { name: 'zhangsan'}Object.seal(obj)Object.defineProperty(obj, name, { configurable: true, writable: true, enumerable: true})// TypeError 同样的，也提供了 Object.isSealed() 方法用来判断一个对象是否被密封 1234var obj = {}Object.seal(obj)Object.isSealed(obj) // true 如果一个对象不可扩展，并且它的属性也变的不可配置，则这个对象也就成了密封对象 12345678910var obj = { name: 'zhangsan'}Object.preventExtensions(obj)Object.defineProperty(obj, 'name', { configurable: false})Object.isSealed(obj) // true Object.freeze()最后我们再来看看 Object.freeze() 这个方法，这个方法比 Object.seal 更绝，冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象，也就是说，这个对象永远是不可变的，比如在一般情况下任何修改尝试都会静默失败 123456789var obj = { a: 1}Object.freeze(obj)obj.a = 2 // 不报错，但是会静默失败console.log(obj.a) // 1 但是在严格模式下则会报错 123456789'use strict'var obj = { a: 1}Object.freeze(obj)obj.a = 2 // TypeError 比如之前的示例当中，密封一个对象还是可以修改的，但是 Object.freeze() 这个方法 1234567891011121314var obj = { name: 'zhangsan' }// 密封Object.seal(obj)// 但是可以修改已有属性obj.name = 'lisi'console.log(obj.name) // lisi// 冻结Object.freeze(obj)obj.name = 'wangwu'console.log(obj) // { name: 'lisi' } 不仅仅适用于对象，数组也是一样的情况，不过被冻结的对象也不是不可变的，比如冻结对象不是常量对象 12345678obj = { a: { }}Object.freeze(obj)obj.a.name = 'zhangsan'console.log(obj.a.name) // zhangsan 同拷贝一样，要使对象不可变，需要递归冻结每个属性 123456789101112131415161718192021222324252627// 深冻结函数function deepFreeze(obj) { // 取回定义在 obj 上的属性名 var propNames = Object.getOwnPropertyNames(obj) // 在冻结自身之前冻结属性 propNames.forEach(function (name) { var prop = obj[name] // 如果 prop 是个对象，冻结它 if (typeof prop == 'object' &amp;&amp; prop !== null) deepFreeze(prop) }) // 最后在冻结自身 return Object.freeze(obj)}obj = { a: {}}deepFreeze(obj)obj.a.name = 'zhangsan'console.log(obj.a.name) // undefined Object.prototype 上的方法相较于 Object 而言，Object.prototype 上的方法就少了许多，排除掉一些实验性的，主要有下面这些 方法 描述 Object.prototype.hasOwnProperty() 返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键），见 JavaScript 中的类型判断 Object.prototype.toString() 返回一个表示该对象的字符串，见 JavaScript 中的类型判断 Object.prototype.isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上，见 JavaScript 中的类型判断 Object.prototype.propertyIsEnumerable() 返回一个布尔值，表示指定的属性是否可枚举 Object.prototype.valueOf() 返回指定对象的原始值 一眼看去，是不是发现很多熟悉的面孔，一些之前我们已经详细介绍过的方法就不再展开了，这里主要看几个比较少见的 Object.prototype.propertyIsEnumerable()该方法返回一个布尔值，表示指定的属性是否可枚举，看下面这个例子 1234567891011const obj = {}const newObj = { name: 123}Object.defineProperty(obj, 'name', { enumerable: false})obj.propertyIsEnumerable('name') // falsenewObj.propertyIsEnumerable('name') // true 每个对象都有一个 propertyIsEnumerable 方法，此方法可以确定对象中指定的属性是否可以被 for-in 循环枚举，但是通过原型链继承的属性除外，如果对象没有指定的属性，则此方法返回 false Object.prototype.valueOf()最后的最后，我们来看一个特殊的方法 Object.prototype.valueOf()，调用该方法会返回指定对象的原始值，但是很少需要我们自己手动的调用 valueOf 方法，因为当遇到要预期的原始值的对象时，JavaScript 会自动调用它 默认情况下，valueOf 方法由 Object 后面的每个对象继承，每个内置的核心对象都会覆盖此方法以返回适当的值，如果对象没有原始值，则 valueOf 将返回对象本身，JavaScript 的许多内置对象都重写了该函数，以实现更适合自身的功能需要，因此不同类型对象的 valueOf() 方法的返回值和返回值类型均可能不同，具体可见下表 对象 返回值 Array 返回数组对象本身 boolean 布尔值 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC Function 函数本身 number 数字值 Object 对象本身，这是默认情况 string 字符串值 Math 和 Error 没有 valueOf 方法 下面我们主要来看几个特殊的例子，先来看看布尔类型 12345// 布尔类型var newBool = new Boolean(true)console.log(newBool.valueOf() == newBool) // true ==&gt; valueOf() 返回的是 true，两者的值相等（注意是 ==）console.log(newBool.valueOf() === newBool) // false ==&gt; 但是不全等，两者类型不相等，前者是 Boolean 类型，后者是 Object 类型 函数 12345678910function foo() { }var bar = new Function('x', 'y', 'return x + y')console.log(foo.valueOf() === foo) // true ==&gt; Function 返回函数本身console.log(bar.valueOf() === bar) // true ==&gt; 虽然它返回的结果是下面这样bar.valueOf()// ƒ anonymous(x, y) {// return x + y// } 字符串 12345var str = 'string'var newStr = new String('string')console.log(str.valueOf() === str) // true ==&gt; String 返回字符串值console.log(newStr.valueOf() === newStr) // false ==&gt; 两者的值相等，但不全等，因为类型不同，前者为 String 类型，后者为 Object 类型","link":"/2020/01/17/JavaScript/51/"},{"title":"在 React 当中使用 TypeScript","text":"本文的主要目的是梳理一下在 React 当中使用 TypeScript，也就是 React 和 TypeScript 的结合使用，主要参考的是 React+TypeScript Cheatsheets，在原文基础之上有所调整，主要是方便自己理解，想要了解更为详细的内容可以参考原文 前半部分会梳理一下在 React 当中经常用到的一些 TypeScript 类型定义，后半部分会梳理一些在实际应用过程当中遇到的问题 组件 Props我们先从几种定义 Props 经常用到的类型开始看起 基础类型1234567type BasicProps = { message: string count: number disabled: boolean names: string[] // 数组类型 status: 'waiting' | 'success' // 用『联合类型』限制为下面两种『字符串字面量』类型 } 对象类型12345678910111213141516type ObjectOrArrayProps = { obj: object // ❌ 不推荐，除非不太需要用到具体的属性 obj2: {} // ❌ 同上 obj3: { // ✅ 拥有具体属性的对象类型 id: string title: string } objArr: { // ✅ 比较常用的对象数组 id: string title: string }[] dict1: { // ✅ key 可以为任意 string，值限制为 MyType 类型 [key: string]: MyType } dict2: Record&lt;string, MyType&gt; // ✅ 基本上和 dict1 相同，使用了 TypeScript 内置的 Record 类型} 函数类型1234567type FunctionProps = { onSomething: Function // ❌ 因为不能设定参数以及返回值类型 onClick: () =&gt; void // ✅ 对于没有参数的函数比较常用 onChange: (id: number) =&gt; void // ✅ 带函数的参数 onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void // ✅ 参数为 React 的按钮事件 optional?: OptionalType // ✅ 可选参数类型} React 相关类型12345678910export declare interface AppProps { children1: JSX.Element; // ❌ 因为没有考虑数组 children2: JSX.Element | JSX.Element[]; // ❌ 因为没有考虑字符串 children children4: React.ReactChild[]; // 勉强可用，但是没考虑 null children: React.ReactNode; // ✅ 包含所有 children 情况 functionChildren: (name: string) =&gt; React.ReactNode; // ✅ 返回 React 节点的函数 style?: React.CSSProperties; // ✅ 在内联 style 时使用 props: React.ComponentProps&lt;'button'&gt;; // ✅ 原生 button 标签自带的所有 props 类型，也可以在泛型的位置传入组件 提取组件的 Props 类型 onClickButton：React.ComponentProps&lt;'button'&gt;['onClick']; // ✅ 在上一步的基础之上提取出原生的 onClick 函数类型，此时函数的第一个参数会自动推断为 React 的点击事件类型} 函数式组件比较常见方式 123interface AppProps = { message: string }const App = ({ message }: AppProps) =&gt; &lt;div&gt;{message}&lt;/div&gt; 另外还有一种包含 children 的函数式组件，我们可以直接使用内置类型 React.FC，这样不光会包含我们定义的 AppProps 还会自动加上一个 children 类型，以及其他组件上会出现的类型 1234567891011121314151617181920// 等同于AppProps &amp; { children: React.ReactNode propTypes?: WeakValidationMap&lt;P&gt; contextTypes?: ValidationMap&lt;any&gt; defaultProps?: Partial&lt;P&gt; displayName?: string}// 使用interface AppProps = { message: string }const App: React.FC&lt;AppProps&gt; = ({ message, children }) =&gt; { return ( &lt;&gt; {children} &lt;div&gt;{message}&lt;/div&gt; &lt;/&gt; )} 不过针对于简单的函数式组件，还是建议使用下面的第二种方式 123456789interface Greeting { name: string age: number}const Hello: React.FC&lt;Greeting&gt; = (props) =&gt; &lt;h1&gt;Hello {props.name}&lt;/h1&gt;// 推荐使用第二种const Hello2 = (props: Greeting) =&gt; &lt;h1&gt;Hello {props.name}&lt;/h1&gt; Hooks@types/react 包在 16.8 以上的版本开始对 Hooks 的支持 useState这里分为两种情况，如果我们的默认值已经可以说明类型，那么不用手动声明类型，交给 TypeScript 自动推断即可 1234const [val, toggle] = React.useState(false)toggle(false)toggle(true) 但是如果初始值是 null 或 undefined，那就需要通过泛型手动传入我们所期望的类型 123const [user, setUser] = React.useState&lt;IUser | null&gt;(null)setUser(newUser) 这样也可以保证在我们直接访问 user 上的属性时，提示你它有可能是 null，可以通过 optional-chaining 语法（TypeScript 3.7 以上支持）来避免这个错误 12// ✅const name = user?.name useReducer通常会使用 Discriminated Unions 来标注 action 的类型 12345678910111213141516171819202122232425262728293031const initialState = { count: 0 }type ACTIONTYPE = | { type: 'increment'; payload: number } | { type: 'decrement'; payload: string }function reducer(state: typeof initialState, action: ACTIONTYPE) { switch (action.type) { case 'increment': return { count: state.count + action.payload } case 'decrement': return { count: state.count - Number(action.payload) } default: throw new Error() }}function Counter() { const [state, dispatch] = React.useReducer(reducer, initialState) return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt; - &lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt; + &lt;/button&gt; &lt;/&gt; )} Discriminated Unions 一般是一个联合类型，其中每一个类型都需要通过类似 type 这种特定的字段来区分，当你传入特定的 type 时，剩下的类型 payload 就会自动匹配推断，类似于下面这样 当我们写入的 type 匹配到 decrement 的时候，TypeScript 会自动推断出相应的 payload 应该是 string 类型 当我们写入的 type 匹配到 increment 的时候，则 payload 应该是 number 类型 这样一来，在我们使用 dispatch 的时候，输入对应的 type，编辑器就会自动提示我们剩余的参数类型 useEffectuseEffect 有些特殊，因为 useEffect 传入的函数，它的返回值要么是一个方法（清理函数），要么就是 undefined，其他情况都会报错，比较常见的一个情况是我们的 useEffect 需要执行一个 async 函数，比如 12345// Type 'Promise&lt;void&gt;' provides no match for the signature '(): void | undefined'useEffect(async () =&gt; { const user = await getUser() setUser(user)}, []) 上面的写法在编辑器当中会有报错提示，因为我们虽然没有在 async 函数里显式的返回值，但是我们都知道 async 函数默认会返回一个 Promise，这就导致了 TypeScript 的报错，所以我们来稍微调整一下上面的示例 1234567useEffect(() =&gt; { const getUser = async () =&gt; { const user = await getUser() setUser(user) } getUser()}, []) 或者也可以采用下面这种自执行函数的方式，不过可读性不太好，不推荐 123456useEffect(() =&gt; { (async () =&gt; { const user = await getUser() setUser(user) })()}, []) useRef这个 Hook 在很多时候是没有初始值的，这样可以声明返回对象中 current 属性的类型 1const ref = useRef&lt;HTMLElement&gt;(null) 以一个按钮场景为例 1234567891011121314function TextInputWithFocusButton() { const inputEl = React.useRef&lt;HTMLInputElement&gt;(null) const onButtonClick = () =&gt; { if (inputEl &amp;&amp; inputEl.current) { inputEl.current.focus() } } return ( &lt;&gt; &lt;input ref={inputEl} type=\"text\" /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/&gt; )} 当 onButtonClick 事件触发时，可以肯定 inputEl 也是有值的，因为组件是同级别渲染的，但是还是依然要做冗余的非空判断，针对于这种情况可以使用『非空断言』的方式 1const ref = useRef&lt;HTMLElement&gt;(null!) null! 这种语法称为非空断言，跟在一个值后面表示我们断定它是有值的，所以在我们使用 inputEl.current.focus() 的时候，TypeScript 不会给出报错，不过需要注意的是，但是这种语法比较危险，建议『尽量少的去使用它』 一种更为好的解决方式就是使用『可选链』，如下 123if (inputEl &amp;&amp; inputEl.current) { inputEl.current?.focus()} 在绝大部分情况下，『可选链』的方式是个更为安全的选择，除非这个值真的不可能为空（比如在使用之前就赋值了） useImperativeHandle在此之前，我们先来简单的了解一下 forwardRef 这个 API，因为函数式组件默认不可以加 ref，所以它不像类组件那样有自己的实例，这个 API 一般是函数式组件用来接收父组件传来的 ref，所以需要标注好实例类型，也就是父组件通过 ref 可以拿到什么样类型的值 123456789type Props = {}export type Ref = HTMLButtonElementexport const FancyButton = React.forwardRef&lt;Ref, Props&gt;((props, ref) =&gt; ( &lt;button ref={ref} className=\"MyClassName\"&gt; {props.children} &lt;/button&gt;)) 由于这个例子里直接把 ref 转发给 button 了，所以直接把类型标注为 HTMLButtonElement 即可，这样一来，父组件向下面这样调用，就可以拿到正确类型 123456export const App = () =&gt; { const ref = useRef&lt;HTMLButtonElement&gt;() return ( &lt;FancyButton ref={ref} /&gt; )} 下面在回到 useImperativeHandle 上，useImperativeHandle 的作用是可以让我们在使用 ref 时自定义暴露给父组件的实例值，通常来说这在开发一些通用组件的情况下比较适用，但是在和 TypeScript 结合使用的时候就会遇到不小的问题，比如我们有一个通用的列表组件，它的样子可能会是下面这样的 1234567891011121314151617181920type ListRef&lt;ItemType&gt; = { scrollToItem: (item: ItemType) =&gt; void}type ListProps&lt;ItemType&gt; = { items: ItemType[]}const List = forwardRef(function List&lt;ItemType&gt;(props: ListProps&lt;ItemType&gt;) { useImperativeHandle&lt;ListRef&lt;ItemType&gt;, ListRef&lt;ItemType&gt;&gt;(ref, () =&gt; ({ scrollToItem: (item: ItemType) =&gt; undefined })) return null}) as &lt;ItemType&gt;( p: ListProps&lt;ItemType&gt; &amp; { ref: Ref&lt;ListRef&lt;ItemType&gt;&gt; }) =&gt; ReactElement&lt;any&gt; | nulllet ref = useRef&lt;ListRef&lt;number&gt;&gt;(null)&lt;List items={[1, 2, 3]} ref={ref} /&gt; 不幸的是 TypeScript 在执行高阶函数编程时无法保留自由类型参数，这确实是最好的方法，因为 forwardRef 原则上返回类型只是一个 普通函数，针对于这种情况，我们更为推荐使用一个自定义的 innerRef 来代替原生的 ref 12345678910type ListProps = { innerRef?: React.Ref&lt;{ scrollToTop(): void }&gt;}function List(props: ListProps) { useImperativeHandle(props.innerRef, () =&gt; ({ scrollToTop() { } })) return null} 结合我们之前提到的 useRef，使用是这样的 1234567891011function Use() { const listRef = useRef&lt;{ scrollToTop(): void }&gt;(null!) useEffect(() =&gt; { listRef.current.scrollToTop() }, []) return ( &lt;List innerRef={listRef} /&gt; )} 看上去是不是清晰许多，但是在这里我们也只是简单的提及一二，因为平时遇到的实在是有限（除非专门开发一些通用的组件库等），关于 React.forwardRef 更为复杂的用法和示例可以参考下面几个链接 React 实现 forwardRef 的 TypeScript 泛型匿名函数组件 Generics while using React.forwardRef Vue3 当中的 ref 相关源码 自定义 Hook如果我们想仿照 useState 的形式，返回一个数组给用户使用，一定要记得在适当的时候使用 as const 来标记这个返回值是个常量，告诉 TypeScript 数组里的值不会删除，改变顺序等，否则返回的每一项都会被 TypeScript 推断成是『所有类型可能性的联合类型』，这会影响正常使用 12345678export function useLoading() { const [isLoading, setState] = React.useState(false) const load = (aPromise: Promise&lt;any&gt;) =&gt; { setState(true) return aPromise.finally(() =&gt; setState(false)) } return [isLoading, load] as const} 如上，只有我们添加了 as const 才会推断出 [boolean, typeof load]，否则会是 (boolean | typeof load)[] React + TypeScript下面我们再来看一些在实际当中结合使用 React 和 TypeScript 过程当中会遇到的一些问题 模块导入相关问题通常我们在使用 import 引入非 JavaScript 模块的时候，TypeScript 会提示我们找不到相关模块，而此时使用 require 却是可以的，如下 123456import styles from './login.less'import logo from '@assets/images/logo.svg'const logo2 = require('@assets/images/logo.svg')console.log(logo2) 针对于这种情况，我们需要给非 JavaScript 模块添加申明 123456789101112/* style */declare module '*.css'declare module '*.less'declare module '*.scss'/* 图片 */declare module '*.svg'declare module '*.png'declare module '*.jpg'declare module '*.jpeg'declare module '*.gif'declare module '*.bmp' 另外我们可能见到过 import * as React from 'react' 这样的引入方式，那么它与 import React from 'react' 有什么区别呢？简单来说有两点 第一种写法是将所有用 export 导出的成员赋值给 React，导入后用 React.xx 来进行访问 第二种写法仅是将默认导出（export default）的内容赋值给 React 我们也可以通过配置 tsconfig.json 来解决 import * as xx from 'xx' 这样的引入方式，如下 1234{ // 允许默认导入没有设置默认导出（export default xxx）的模块可以以 import xx from 'xx' 的形式来引入模块 \"allowSyntheticDefaultImports\": true} 而配置前后的对比如下 1234567// 配置前import * as React from 'react'import * as ReactDOM from 'react-dom'// 配置后import React from 'react'import ReactDOM from 'react-dom' antd 的按需加载方案有很多种，我们这里采用的是 ts-loader 转译 TypeScript 的方案，更多方案可以参考 Webpack 转译 Typescript 现有方案 这篇文章 .babelrc 1234567891011121314151617{ \"presets\": [ \"@babel/preset-react\", \"@babel/preset-env\" ], \"plugins\": [ [ \"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" /* `style: true` 会加载 less 文件*/ } ] ]} tsconfig.json 1234567{ \"compilerOptions\": { \"target\": \"es5\", \"jsx\": \"preserve\", // 保留 jsx // ... }} webpack.config.js 1234567{ test: /\\.tsx?$/, use: [ 'babel-loader', 'ts-loader' ]} 使用 React.createRef()定义如下 1234// 源码interface RefObject&lt;T&gt; { readonly current: T | null} 使用 12345678910const ref1: React.RefObject&lt;HTMLDivElement&gt; = React.createRef()const inputRef = React.createRef&lt;Comp&gt;()class EditScene extends React.Component&lt;Props&gt; { inputRef: React.RefObject&lt;Comp&gt; constructor(props) { super(props) this.inputRef = React.createRef&lt;Comp&gt;() }} @connect 装饰器相关问题在 TypeScript 3.0 版本之前，我们在使用 React 配合 Redux 一类 HOC 库的时候，经常会用到诸如 connect(TodoList)，withRouter(TodoList) 之类的封装，而这些函数其实都可以用装饰器的方式来调用，如下 1234567891011export interface TodoListProps extends RouteComponentProps&lt;{}&gt; { todos: Todo[]}@withRouter@connect(mapStateToProps)export class TodoList extends PureComponent&lt;TodoListProps, {}&gt; { render() { return null }} 其中的 @connect 装饰器在平常正常使用的过程中是没有问题的，但是一旦和 TypeScript 结合使用的时候就会报错，这是因为我们在使用装饰器的过程当中会自动注入一些 props 给组件，这一部分属性不需要外部传入，因此是可选的，但是在 strictNullChecks 属性开启的时候（它的作用是不允许把 null、undefined 赋值给其他类型变量）就会出现属性冲突，因为 TypeScript 不允许装饰器修改被装饰的对象的类型，因此在 props 定义中为 required 的属性依然为 required 比如对于上面的示例，在实例化 TodoList 这个组件的时候，必需要传入所有的 TodoListProps 所定义的属性，否则会提示我们有错误存在 而在 TypeScript 3.0 以后，我们就可以声明 defaultProps 属性用来表明某些属性对外部组件而言是可选的（具体可见 Support for defaultProps in JSX），如下 12345678@withRouter@connect((state) =&gt; ({ todos: state.todos })export class TodoList extends PureComponent&lt;TodoListProps, {}&gt; { static defaultProps: TodoListProps render() { return null }} 这里的 static defaultProps: TodoListProps 表明所有的 TodoList 的 props TodoListProps 对外部组件都是可选的，这就意味着外部组件可以什么属性都不用传也不会有错误，同时对于内部而言所有的属性都是 NotNullable 综上，通常情况下我们的一个组件会有一部分属性由装饰器注入，而另一部分则需要外部实例化时传入，因此可以将一个组件的 props 接口声明成两层结构，第一层为由装饰器注入的部分，第二层则为完整的属性接口，然后将 defaultProps 设置成为第一层接口即可，比如 1234567891011121314151617export interface TodoListInnerProps extends RouteComponentProps&lt;{}&gt; { todos: Todo[]}export interface TodoListProps extends TodoListInnerProps { className?: string onLoad?(): void}@withRouter@connect((state) =&gt; ({ todos: state.todos })export class TodoList extends PureComponent&lt;TodoListProps, {}&gt; { static defaultProps: TodoListInnerProps render() { return null }} 最后我们再来简单的总结一下其中需要注意的地方 首先 TypeScript 要要 3.0.1 版本以上 其次 @types/react 需要是最新版 最后 withRouter，connect 等函数的 @types 中的签名需要手动修改一下 12345678910111213141516import { ComponentClass } from 'react'import { connect as nativeConnect, MapDispatchToPropsParam, MapStateToPropsParam} from 'react-redux'import { withRouter as nativeWithRouter } from 'react-router'export type ComponentDecorator&lt;P = any&gt; = &lt;T extends ComponentClass&lt;P&gt;&gt;(WrappedComponent: T) =&gt; Texport const connect: &lt;P, S = Todo&gt;( mapState: MapStateToPropsParam&lt;Partial&lt;P&gt;, P, S&gt;, mapDispatch?: MapDispatchToPropsParam&lt;Partial&lt;P&gt;, P&gt;) =&gt; ComponentDecorator = nativeConnect as anyexport const withRouter: ComponentDecorator = nativeWithRouter as any HOC 的类型定义12345678910111213141516171819import React, { Component } from 'react'import HelloClass from './HelloClass'interface Loading { loading: boolean}// HOC 可以接收一个类组件，也可以接收一个函数组件，所以参数的类型是 React.ComponentType// 源码当中的定义为 type ComponentType&lt;P = {}&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;function HelloHOC&lt;P&gt;(WrappedComponent: React.ComponentType&lt;P&gt;) { return class extends Component&lt;P &amp; Loading&gt; { render() { const { loading, ...props } = this.props return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;WrappedComponent {...props as P} /&gt; } }}export default HelloHOC(HelloClass) 参考 forwardRef React 实现 forwardRef 的 TypeScript 泛型匿名函数组件 Generics while using React.forwardRef Vue3 当中的 ref 相关源码","link":"/2021/01/10/JavaScript/59/"},{"title":"CSS 常见布局方式","text":"今天在网上看到一张图，是关于 CSS 常见的布局方式汇总的一张图，如下 最近刚好也在复习相关内容，所以就借着这个机会从新整理一下 CSS 当中比较常见的一些布局方式，就当是复习复习布局相关知识点，下面我们就一个一个来介绍，示例集合可见 demos 当中的 CSS 板块 文档流布局示例可见 文档流布局，也是 CSS 当中最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行，如下 浮动布局示例可见 浮动布局，也是比较常见的布局方式，不过在 flex 流行以后，这种方式已经使用的比较少了，原理是使用 float 属性，使元素脱离文档流，浮动起来，不过需要注意在使用该属性时引起的其他问题（譬如高度崩塌） 定位布局示例可见 定位布局，与浮动布局类似，也是使元素脱离文档流，浮动起来，不过使用的是 position 属性，结果与浮动布局是一致的 至于两者有何区别，简单来说各有各的优缺点，很多时候我们希望控制的布局流问题不需要 float 和 position 实现，而应该通过显示模型定义来解决，比如现在的 column layout、flex box 等等，也就是下面将要说到的，都是在这个角度解决我们遇到的问题，它们应该才是正解 圣杯布局和双飞翼布局两者的本质其实是差不多的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染，详细的可以参考 CSS布局中圣杯布局与双飞翼布局的实现思路差异在哪里？，这里只截取部分 简单来说就是，双飞翼布局比圣杯布局多创建了一个 div，但是不需要使用相对布局了，圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部 float 浮动，但左右两栏加上负 margin 让其跟中间栏 div 并排，以形成三栏布局，不同之处在于解决中间栏 div 内容不被遮挡问题的思路不一样 圣杯布局，为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div 双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置 对比下来可以发现，双飞翼布局多了一个 div，少用大致四个 CSS 属性，至于具体使用哪种方案可以根据实际情况来选择 圣杯布局实现以后如下所示，示例可见 圣杯布局 页面布局如下，很简单的三个 div 被外层父元素包裹，没用多余的额外元素 12345&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt; 核心 CSS 代码如下 123456789101112131415161718192021222324252627.wrapper { padding: 0 200px;}.content { width: 100%; height: 200px; float: left;}.left { width: 200px; height: 200px; float: left; position: relative; left: -200px; margin-left: -100%;}.right { width: 200px; height: 200px; float: left; position: relative; right: -200px; margin-left: -200px;} 双飞翼布局如果你手动实现一遍以后就会发现，圣杯布局是有弊端的，当你将浏览器宽度缩短到一定程度的时候，会使得中间子元素的宽度比左右子元素宽度小的时候，这时候布局就会出现问题，而双飞翼布局的出现就是为了解决此类问题，实现的结果与圣杯布局是一致的，示例可见 双飞翼布局 页面布局如下，与圣杯布局相比有些许不同，可以发现在 Content 的外部多了一层 div，而这个 div 就是用来解决上述问题的 12345&lt;div class=\"content-wrapper\"&gt; &lt;div class=\"content\"&gt;Content&lt;/div&gt;&lt;/div&gt;&lt;div class=\"left\"&gt;Left&lt;/div&gt;&lt;div class=\"right\"&gt;Right&lt;/div&gt; 核心 CSS 代码如下 123456789101112131415161718192021222324.content-wrapper { width: 100%; height: 200px; float: left;}.content { margin-left: 200px; margin-right: 200px;}.left { width: 200px; height: 200px; float: left; margin-left: -100%;}.right { width: 200px; height: 200px; float: left; margin-left: -200px;} flex 布局关于 flex 部分内容主要截取自 flex 布局，感觉讲的比较好理解，图文相对应，不过其中有一些调整，并且添加了一些内容，主要是方便自己比较好理解，如果想了解更多的话可以参考原文 flex 是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果，但是要注意其浏览器的兼容性，flex 只支持 IE 10 以上，flex 的使用方法很简单，只需要将元素的 display 属性设置为 flex 就可以，也可以设置行内的 flex（inline-flex） 有一个特别需要需要的地方，当设置元素为 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效 在 flex 中，最核心的概念就是容器和轴，所有的属性都是围绕容器和轴设置的，其中容器分为父容器和子容器，轴分为主轴和交叉轴 主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90° 在使用 flex 的元素中，默认存在两根轴 水平的主轴（main axis） 主轴开始的位置称为 main start 结束的位置称为 main end 垂直的交叉轴（cross axis） 交叉轴开始的位置称为 cross start 结束的位置称为 cross end 在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size，如下图所示 之前整理过一篇关于子容器的 flex 取值相关问题，可见 关于子容器属性 flex 取值问题，不过关于容器和元素的属性也只是一笔带过，所以就在之前的基础上扩充一下吧 父容器首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局 父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准 有下面六种属性可以设置在父容器上，它们分别是 flex-direction，主轴的方向 flex-wrap，超出父容器子容器的排列样式 flex-flow，flex-direction 属性和 flex-wrap 属性的简写形式 justify-content，子容器在主轴的排列方向 align-items，子容器在交叉轴的排列方向 align-content，多根轴线的对齐方式 下面我们就来一个一个深入了解一下 flex-direction决定主轴的方向（即项目的排列方向），但是主轴的方向不一定是水平的，这个属性就是设置主轴的方向，默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90° 123456.div { flex-direction: row; // 默认值，主轴为水平方向，起点在左端 flex-direction: row-reverse; // 主轴为水平方向，起点在右端 flex-direction: column; // 主轴为垂直方向，起点在上 flex-direction: column-reverse; // 主轴为垂直方向，起点在下} flex-wrapflex-wrap 属性决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行 12345.ele { flex-wrap: nowrap; // 默认，不换行 flex-wrap: wrap; // 换行，第一行在上方 flex-wrap: wrap-reverse // 换行，第一行在下方，也就是逆序换行} justify-content主要用于定义如何沿着主轴方向排列子容器 12345678.ele{ justify-content: flex-start; // 默认，左对齐 justify-content: flex-end; // 右对齐 justify-content: center; // 居中 justify-content: space-between; // 两端对齐，项目之间的间隔都相等 justify-content: space-around; // 每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍 //（即位于首尾两端的子容器到父容器的距离是子容器间距的一半）} flex-flowflow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 flex-flow: row wrap，flex-flow 是一个复合属性，相当于 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap row、column 等，可单独设置主轴方向 wrap、nowrap 等，可单独设置换行方式 row nowrap、column wrap 等，也可两者同时设置 align-itemsalign-items 属性定义子容器在交叉轴上如何对齐，具体的对齐方式与交叉轴的方向有关，假设交叉轴从上到下 12345678910.ele{ align-items: flex-start; // 交叉轴的起点对齐， align-items: flex-end; // 交叉轴的终点对齐， align-items: center; // 交叉轴的中点对齐， align-items: baseline; // 项目的第一行文字的基线对齐 // 这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐 // 交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线） align-items: stretch; // 默认，如果项目未设置高度或设为 auto，将占满整个容器的高度 //（子容器沿交叉轴方向的尺寸拉伸至与父容器一致）} align-contentalign-content 属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用，简单来说就是当子容器多行排列时，设置行与行之间的对齐方式 12345678.ele{ align-content: flex-start; // 与交叉轴的起点对齐 align-content; flex-end; // 与交叉轴的终点对齐 align-content: center; // 与交叉轴的中点对齐 align-content: space-between; // 与交叉轴两端对齐，轴线之间的间隔平均分布 align-content: space-around; // 每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍 align-content: stretch; // 默认 轴线占满整个交叉轴} 子容器子容器也有六个属性 order，子容器的排列顺序 flex-grow，子容器剩余空间的拉伸比例 flex-shrink，子容器超出空间的压缩比例 flex-basis，子容器在不伸缩情况下的原始尺寸 flex，flex-grow，flex-shrink 和 flex-basis 的简写 align-self，允许子容器与其他项目采用不一样的对齐方式 orderorder 属性定义项目的排列顺序，可以为负值，数值越小，排列越靠前，默认为 0 123.ele{ order: num; } flex-growflex-grow 属性定义子容器的伸缩比例，按照该比例给子容器分配空间，默认值为 0 123.ele{ flex-grow: &lt;number&gt;;} flex-shrinkflex-shrink 属性定义了子容器弹性收缩的比例，如图，超出的部分按 1: 2 的比例从给子容器中减去 此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap，默认值为 0 123.ele{ flex-shrink: &lt;number&gt;;} flex-basisflex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度，默认值为 0 123.ele{ flex-basis: &lt;length&gt; | auto;} flex子容器是有弹性的，它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定，flex 的值可以是无单位数字（如：1，2，3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字，子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩，虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图 具体取值规则可以参考之前整理的一篇文章 关于子容器属性 flex 取值问题 align-self子容器的 align-self 属性允许单个项目有与其他项目不一样的对齐方式，它会覆盖父容器 align-items 属性，如果两者同时设置则以子容器的 align-self 属性为准，默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 12345678.ele{ align-self: auto; // 继承父元素的 align-items 属性 align-self: flex-start; // 交叉轴的起点对齐 align-self: flex-end; // 交叉轴的终点对齐 align-self: center; // 交叉轴的中点对齐 align-self: baseline; // 项目的第一行文字的基线对齐 align-self: stretch; // 默认，如果项目未设置高度或设为 auto，将占满整个容器的高度} 下面是一张各属性的汇总图 grid 布局主要参考的 Learn CSS Grid in 5 minutes，按照惯例，在使用之前我们先来看一下 CSS Grid 的兼容性，如下 可以发现，主流浏览器（Safari，Chrome，Firefox，Edge）的支持还是不错的，那么我们就来看看 CSS Grid 到底是个什么东西，全部示例可见 网格布局 和 网格版圣杯布局 基本概念我们先从一个简单的示例开始，然后在深入了解其中的概念，CSS Grid 布局由两个核心组成部分是 wrapper（父元素）和 items（子元素），wrapper 是实际的 grid（网格），items 是网格内的内容，下面是一个 wrapper 元素，内部包含六个 items 12345678&lt;div class=\"wrapper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个网格，只要简单地把其 display 属性设置为 grid 即可 123.wrapper { display: grid;} 在这种情况下，我们并没有做其他的操作，它只会简单地将六个 div 堆叠在一起，如下图所示 为了使其成为二维的网格容器，我们需要定义列和行，让我们创建 3 列和 2 行，我们将使用 grid-template-row 和 grid-template-column 属性 12345.wrapper { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 50px 50px;} 这些值决定了我们希望我们的列有多宽（100px），以及我们希望行数是多高（50px），结果如下 也可以来稍微的调整一下，比如应用以下 CSS 样式 12345.wrapper { display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;} 就变成了如下 此时，我们已经了解了 CSS Grid 布局的基本过程，下面我们就来了解一下相应的术语 网格容器（Grid Container）应用 display: grid 的元素，就是所有网格项（grid item）的直接父级元素，在上面的例子中 wrapper 就是网格容器（Grid Container） 123&lt;div class=\"wrapper\"&gt; ...&lt;/div&gt; 网格项（Grid Item）网格容器（Grid Container）的子元素（例如直接子元素），比如下面这里 item 元素就是网格项（Grid Item），但是 sub-item 不是 1234567&lt;div class=\"wrapper\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"sub-item\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 网格线（Grid Line）网格线组成了网格，他是网格的水平和垂直的分界线，一个网格线存在行或列的两侧，我们可以引用它的数目或者定义的网格线名称 网格轨道（Grid Track）网格轨道是就是相邻两条网格线之间的空间，就好比表格中行或列，所在在网格中其分为 grid column 和 grid row，每个网格轨道可以设置一个大小，用来控制宽度或高度 网格单元格（Grid Cell）网格单元格是指四条网格线之间的空间，所以它是最小的单位，就像表格中的单元格 网格区域（Grid Area）网格区域是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格，相当于表格中的合并单元格之后的区域 以上就是网格布局中的一些基本概念，下面我们来看具体的操作方法 使用 Grid 布局我们还是在最开始部分的示例之上来进行扩展，首先还是先创建一个 3×3 的网格 需要注意的是，同 flex 布局一样，当元素设置了网格布局之后，元素的 column、float、clear、vertical-align 属性都是无效的 12345678&lt;div class=\"wrapper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 应用的 CSS 代码如下 12345.wrapper { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;} 将得到以下布局 细心对比可以发现，我们只在页面上看到 3×2 的网格，而我们定义的则是 3×3 的网格，这是因为我们只有六个子元素来填满这个网格，如果我们再加三个子元素，那么最后一行也会被填满 如果还存在更多的子元素，则是被忽略（即默认是不可见的） 如果要定位和调整子元素大小，我们将使用 grid-column 和 grid-row 属性来设置 1234.item1 { grid-column-start: 1; grid-column-end: 4;} 我们在这里要做的是，我们希望 item1 占据从第一条网格线开始，到第四条网格线结束，换句话说，它将独立占据整行， 以下是在屏幕上显示的内容 可以发现，当我们把第一个子元素设置为占据整个第一行时，它会把剩下的子元素都推到了下一行，至于为什么会有四条网格线，可以参考下面这个图 当然，也可以使用简写方式来实现 123.item1 { grid-column: 1/4;} 下面我们就可以将所有的子元素进行自定义排列 1234567891011121314.item1 { grid-column-start: 1; grid-column-end: 3;}.item3 { grid-row-start: 2; grid-row-end: 4;}.item4 { grid-column-start: 2; grid-column-end: 4;} 也可以采用简写的方式 1234567891011.item1 { grid-column: 1/3;}.item3 { grid-row: 2/4;}.item4 { grid-column: 2/4;} 最终结果如下 我们也可以像 flex 一样设置每一列的宽度 1234.wrapper { grid-template-rows: 50px 100px 60px; grid-template-columns: 1fr 1fr 1fr;} 可以发现，在上面的示例当中我们使用了一个新的单位 fr fr 单位是一个自适应单位，fr 单位被用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配 fr 是基于网格容器可用空间来计算的（flex 也是一样），所以我们可以和其他单位混合使用（如果需要的话） 结果如下 也可以利用这个特性来进行单元格的合并 行或列最小和最大尺寸minmax() 函数来创建行或列的最小或最大尺寸，第一个参数定义网格轨道的最小值，第二个参数定义网格轨道的最大值，可以接受任何长度值，也接受 auto 值，auto 值允许网格轨道基于内容的尺寸拉伸或挤压，我们来试试将第一行的高度设置为 minmax(100px, 200px)，第二行的高度设置为 minmax(50px, 200px)，容器总高度设置为 300px，如下 12345.wrapper { height: 300px; grid-template-rows: minmax(100px, 200px) minmax(50px, 200px); grid-template-columns: 1fr 1fr 1fr;} 具体逻辑为，先判断『总高度』和『第一列高度的最大值和第二列高度的最大值之和』的两者之间的大小 如果大于，那么第一列和第二列的高度都为设置的最大值 如果是小于，那么第一列和第二列的高度都为设置的最小值 在上面的情况当中是属于小于的情况，所以会先使用总高度减去两列的最小高度得出一个值，在根据这个值来计算最终的高度 总高度为，第一列最小高度 - 第二列最小高度 = 150px（300px - 100px - 50px = 150px） 第一列高度为，（第一列最小高度 100px） + 150px/2 = 175px 第二列高度为，（第一列最小高度 50px） + 150px/2 = 125px 如下图所示 重复行或者列repeat() 属性可以创建重复的网格轨道，这个适用于创建相等尺寸的网格项目和多个网格项目，repeat() 也接受两个参数，第一个参数定义网格轨道应该重复的次数，第二个参数定义每个轨道的尺寸，简单来说就是简化同样的赋值操作，结果如下图 间距主要使用 grid-column-gap 和 grid-row-gap 两个属性 grid-column-gap，创建列与列之间的距离 grid-row-gap，行与行之间的距离 grid-gap，简写方式，第一个参数为行间距，第二个参数为列间距 1234567891011121314.wrapper { grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; grid-row-gap: 10px; grid-column-gap: 20px;}/* 等同于 ==&gt; */.wrapper { grid-template-rows: 100px 100px; grid-template-columns: 100px 100px 100px; grid-gap: 10px 20px;} 网格区域（grid-template-areas）所谓网格区域（网格区域），简单来说就是一个逻辑空间，主要用来放置一个或多个网格单元格（Grid Cell），它由四条网格线（Grid line）构成，网格区域每边一条，四边相交组织的网格轨道（Grid Track） 简单点理解，网格区域是有四条网格线交织组成的网格空间，这个空间中可能是一个网格单元格，也可能是多个网格单元格，在 CSS Grid Layout 中定义网格区域有两种方式，一种是通过网格线来定义，另一种是通过 grid-template-areas 来定义 网格线定义网格区域简单来说有下面三个步骤 使用网格线定义网格区域的方法非常的简单，首先依赖于 grid-template-columns 和 grid-template-rows 显式定义网格线，甚至是由浏览器隐式创建网格线 然后通过 grid-area 属性通过取网格线，组成网格线交织区域，那么这个区域就是所讲的网格区域 在使用 grid-area 属性调用网格线，其遵循的取值规则如下 1grid-area: row-start/column-start/row-end/column-end 使用 grid-template-areas 定义网格区域除了使用网格线的交组来定义网格区域之外，在 CSS Grid Layout 中还可以通过 grid-template-areas 属性来定义网格区域的名称，然后需要放在对应网格区域的元素，可以通过 grid-area 属性来指定，而且重复区域可以使用同一个名称来实现跨区域，另外对于空的轨道区域，可以使用点号 . 来代表 具体的使用细节我们就通过下面这个实例来充分的了解一下所谓的网格区域 实例我们要实现的最终结果如下 接下来，我们就一步一步来进行实现 HTML 结构首先我们需要一个容器，如下 123456&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;HEADER&lt;/div&gt; &lt;div class=\"menu\"&gt;MENU&lt;/div&gt; &lt;div class=\"content\"&gt;CONTENT&lt;/div&gt; &lt;div class=\"footer\"&gt;FOOTER&lt;/div&gt;&lt;/div&gt; 设置基本的 CSS在来设置一些基本的 CSS 123456.container { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px; grid-gap: 5px;} 经过前面的一些铺垫，这里应用的 CSS 应该很容易理解 使用 grid-template-columns 属性创建一个 12 列的网格，每个列都是一个单位宽度（总宽度的 1/12 ） 使用 grid-template-rows 属性创建 3 行，第一行高度是 50px ，第二行高度是 350px 和第三行高度是 50px 最后，使用 grid-gap 属性在网格中的网格项之间添加一个间隙 添加 grid-template-areas下面就是重点部分，来添加我们的网格区域，简单来说也就是定义 grid-template-areas 属性 12345678910.container { display: grid; grid-gap: 5px; grid-template-columns: repeat(12, 1fr); grid-template-rows: 50px 350px 50px; grid-template-areas: \"h h h h h h h h h h h h\" \"m m c c c c c c c c c c\" \"f f f f f f f f f f f f\";} grid-template-areas 属性背后的逻辑是你在代码中创建的网格可视化表示，正如所见，它有 3 行 12 列，和我们在 grid-template-columns 和 grid-template-rows 中定义的正好呼应，每行代表一行，用网格术语来说是 网格轨道（Grid Track） ，每个字符（h，m，c，f）代表一个网格单元格，四个字母中的每一个现在都形成一个矩形 grid-area（当然你也可以使用自定义字符） 给网格项设定网格区域名称现在我们需要将这些字符与网格中的网格项建立对应的连接，要做到这一点，我们将在网格项使用 grid-area 属性 123456789101112.header { grid-area: h;}.menu { grid-area: m;}.content { grid-area: c;}.footer { grid-area: f;} 最终的结果如下（添加了一些额外的 CSS 样式用于展示） 尝试其他布局现在，我们可以探讨一下使用网格布局的精妙之处，因为我们可以很容易地对布局进行修改尝试，只需修改 grid-template-areas 属性的字符即可，举个例子，比如把 menu 移到右边 123456.wrapper { grid-template-areas: \"h h h h h h h h h h h h\" \"c c c c c c c c c c m m\" \"f f f f f f f f f f f f\";} 可以使用点 . 来创建空白的网格单元格 123456.wrapper { grid-template-areas: \". h h h h h h h h h h .\" \"c c c c c c c c c c m m\" \". f f f f f f f f f f .\";} 还可以添加响应式布局 12345678@media screen and (max-width: 640px) { .container { grid-template-areas: \"m m m m m m h h h h h h\" \"c c c c c c c c c c c c\" \"f f f f f f f f f f f f\"; }} 最终结果如下 参考 CSS Flexible Box Layout Flex 布局教程：语法篇 Flex 布局学习笔记 30 分钟学会 Flex 布局 弹性盒模型 Flex 指南 CSS Grid Layout Learn CSS Grid in 5 minutes A Complete Guide to Grid Learn to prototype websites quickly with CSS Grid 未来布局之星Grid Don’t use flexbox for overall page layout 原生CSS网格布局学习笔记","link":"/2019/09/12/CSS/11/"},{"title":"Node.js 中的 Buffer 模块","text":"JavaScript 语言自身只有字符串数据类型，没有二进制数据类型，但在处理像 TCP 流或文件流时，必须使用到二进制数据，因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区，但是在深入展开之前，我们先来了解一下 JavaScript 当中的 ArrayBuffer，来看看它与 Node.js 当中的 Buffer 到底有什么区别？ 本文部分内容截取自 Node.js 中的缓冲区（Buffer）究竟是什么？ ArrayBufferJavaScript 当中的 ArrayBuffer 对象用来表示『通用的、固定长度的』原始二进制数据缓冲区，代表储存二进制数据的一段内存，它不能直接操作，而是要通过 类型数组对象 或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容 下面的例子创建了一个 8 字节的缓冲区，并使用一个 Int32Array 来引用它 123var buffer = new ArrayBuffer(8)var view = new Int32Array(buffer) TypedArray 视图ArrayBuffer 对象作为内存区域，可以存放多种类型的数据（其本身只是一个 0 和 1 存放在一行里面的一个集合），同一段内存，不同数据有不同的解读方式，这就叫做视图（view），ArrayBuffer 有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型，同一个 ArrayBuffer 对象之上，可以根据不同的数据类型建立多个视图 1234567891011// 创建一个 8 字节的 ArrayBufferconst b = new ArrayBuffer(8)// 创建一个指向 b 的 Int32 视图，开始于字节 0，直到缓冲区的末尾const v1 = new Int32Array(b)// 创建一个指向 b 的 Uint8 视图，开始于字节 2，直到缓冲区的末尾const v2 = new Uint8Array(b, 2)// 创建一个指向 b 的 Int16 视图，开始于字节 2，长度为 2const v3 = new Int16Array(b, 2, 2) 视图的构造函数可以接受三个参数 第一个参数（必需），视图对应的底层 ArrayBuffer 对象 第二个参数（可选），视图开始的字节序号，默认从 0 开始 第三个参数（可选），视图包含的数据个数，默认直到本段内存区域结束 但是有一个需要注意的地方，byteOffset 必须与所要建立的数据类型一致，否则会报错 123const buffer = new ArrayBuffer(8)const i16 = new Int16Array(buffer, 1)// Uncaught RangeError: start offset of Int16Array should be a multiple of 2 上面代码中，新生成一个 8 个字节的 ArrayBuffer 对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错，这是因为带符号的 16 位整数需要两个字节，所以 byteOffset 参数必须能够被 2 整除，关于 ArrayBuffer 的内容就简单的介绍到这里，如果想了解更多可以参考 DataView 在 Node.js 当中的之所以设置 Buffer 这种方式，简单来说就是扮演了一个原生内存的角色，它模拟了像 C 语言才有的那种直接访问内存的方式，你可能想知道为什么我们不让程序直接访问内存，而是添加了这种抽象层，『因为直接访问内存将导致一些安全漏洞』 在简单的了解了一些 JavaScript 当中 ArrayBuffer 内容之后，我们下面就再来看看 Node.js 当中的 Buffer BufferNode.js 里面的 Buffer，是一个二进制数据容器，类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存，Buffer 的大小在被创建时确定，且无法调整，比如我们使用 fs 模块来读取文件内容的时候，返回的就是一个 Buffer 123fs.readFile('filename', function (err, buf) { // &lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ... &gt;}) Buffer 基本使用在 Node.js 的 v6 之前的版本中，Buffer 实例是通过 Buffer 构造函数创建的，但是这种方式存在两个问题 参数复杂，内存分配，还是内存分配和内容写入，需要根据参数来确定 安全隐患，分配到的内存可能还存储着旧数据，这样就存在安全隐患 12345// 本来只想申请一块内存，但是里面却存在旧数据const buf = new Buffer(10) // &lt;Buffer 90 09 70 6b bf 7f 00 00 50 3a&gt;// 但是如果不小心操作，旧数据就会被读取出来buf.toString() // '�\\tpk�\\u0000\\u0000P:' 为了解决上述问题，使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被废弃，并由 Buffer.from()、Buffer.alloc()、和 Buffer.allocUnsafe() 等方法替代，下面我们就来看看这三个方法有什么区别 Buffer.from()返回一个新的 Buffer，其中包含给定内容的副本 123456const b1 = Buffer.from('10')const b2 = Buffer.from('10', 'utf8')const b3 = Buffer.from([10])const b4 = Buffer.from(b3)console.log(b1, b2, b3, b4) // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt; Buffer.alloc(size)返回一个指定大小的新建的的『已初始化』的 Buffer，此方法比 Buffer.allocUnsafe(size) 慢，但能确保新创建的 Buffer 实例『永远不会包含可能敏感的旧数据』，如果 size 不是数字，则将会抛出 TypeError 123const bAlloc1 = Buffer.alloc(10) // 创建一个大小为 10 个字节的缓冲区console.log(bAlloc1) // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; Buffer.allocUnsafe(size)创建一个大小为 size 字节的新的『未初始化』的 Buffer，由于 Buffer 是未初始化的，因此分配的内存片段『可能包含敏感的旧数据』，在 Buffer 内容可读情况下，则可能会泄露它的旧数据，这个是不安全的，使用时要谨慎 123const bAllocUnsafe1 = Buffer.allocUnsafe(10)console.log(bAllocUnsafe1) // &lt;Buffer 80 75 45 00 00 00 00 00 00 20&gt; Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8、 UCS2、 Base64 或十六进制编码的数据，通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换 1234567const buf = Buffer.from('hello world', 'ascii')// 68656c6c6f20776f726c64console.log(buf.toString('hex'))// aGVsbG8gd29ybGQ=console.log(buf.toString('base64')) 目前所支持的字符编码如下所示 ascii，仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的 utf8，多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8 utf16le，2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000 至 U+10FFFF） ucs2，utf16le 的别名 base64，Base64 编码 latin1，一种把 Buffer 编码成一字节编码的字符串的方式 binary，latin1 的别名， hex，将每个字节编码为两个十六进制字符 更多关于 ASCII，Unicode 和 UTF-8 相关内容可见 ASCII，Unicode 和 UTF-8 字符串与 Buffer 类型互转下面我们来看看字符串与 Buffer 之间的类型互转，以及可能会遇到的乱码问题 字符串转 Buffer如果不传递 encoding 默认按照 UTF-8 格式转换存储 1234const buf = Buffer.from('Node.js 技术栈', 'UTF-8')console.log(buf) // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length) // 17 Buffer 转换为字符串Buffer 转换为字符串也很简单，使用 toString([encoding], [start], [end]) 方法，默认编码仍为 UTF-8，如果不传递 start、end 可实现全部转换，传了 start、end 可实现部分转换（这里要注意了） 123456const buf = Buffer.from('Node.js 技术栈', 'UTF-8');console.log(buf) // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length) // 17console.log(buf.toString('UTF-8', 0, 9)) // Node.js � 运行查看，可以看到以上输出结果为 Node.js � 出现了乱码，为什么？ 为什么转换过程中会出现乱码首先在上面示例中使用的默认编码方式 UTF-8，问题就出在这里，一个中文在 UTF-8 下占用三个字节，Node.js 技术栈中的这个技字在 buf 中对应的字节为 8a 80 e6，而我们的设定的范围为 0 ~ 9 因此只输出了 8a，这个时候就会造成字符被截断出现乱码，下面我们稍微调整一下示例的截取范围 123456const buf = Buffer.from('Node.js 技术栈', 'UTF-8')console.log(buf) // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;console.log(buf.length) // 17console.log(buf.toString('UTF-8', 0, 11)) // Node.js 技 可以看到已经正常输出了，所以说平常在使用过程当中如果遇到需要截取中文的情况下应当小心 Buffer 与 TypedArrayBuffer 实例也是 Uint8Array 实例，但是与 ECMAScript 2015 中的 TypedArray 规范还是有些微妙的不同，例如当 ArrayBuffer#slice() 创建一个切片的副本时，Buffer#slice() 的实现是在现有的 Buffer 上不经过拷贝直接进行创建，这也使得 Buffer#slice() 更高效，遵循以下注意事项，也可以从一个 Buffer 创建一个新的 TypedArray 实例 Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的 Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组 也就是说 new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array 而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array也可以通过 TypeArray 对象的 .buffer 属性创建一个新建的且与 TypedArray 实例共享同一分配内存的 Buffer Buffer#slice() 和 Array#slice()Array#slice()Array 当中的 slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且『原始数组不会被修改』 1234var arr = ['AAA', 'BBB', 'CCC', 'DDD', 'EEE']console.log(arr.slice(2)) // ['CCC', 'DDD', 'EEE']console.log(animals) // ['AAA', 'BBB', 'CCC', 'DDD', 'EEE'] Buffer#slice()Buffer 当中的 slice() 方法返回一个『指向相同原始内存』的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪，需要注意的是，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的 1234567const buf = Buffer.from('hello world')const buf1 = buf.slice(0, 3)buf1[4] = 97console.log(buf.toString('utf8')) // hello worldconsole.log(buf) // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;console.log(buf1) // &lt;Buffer 68 65 6c&gt; 通过观察 Array#slice() 示例和 Buffer#slice() 示例的输出结果，我们更加直观地了解它们之间的差异，Buffer 对象的 slice() 方法具体实现如下 12345678Buffer.prototype.slice = function slice(start, end) { const srcLength = this.length start = adjustOffset(start, srcLength) end = end !== undefined ? adjustOffset(end, srcLength) : srcLength const newLength = end &gt; start ? end - start : 0 // 与原始的 Buffer 对象共用内存 return new FastBuffer(this.buffer, this.byteOffset + start, newLength)} Buffer 内存机制由于 Buffer 需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统申请内存调用，所以 Buffer 所占用的内存不再由 V8 分配，而是在 Node.js 的 C++ 层面完成申请，在 JavaScript 中进行内存分配，因此这部分内存我们称之为堆外内存 Buffer 模块的内部结构如下 1234exports.Buffer = Bufferexports.SlowBuffer = SlowBufferexports.INSPECT_MAX_BYTES = 50exports.kMaxLength = binding.kMaxLength 并且提供了四个接口 Buffer，二进制数据容器类，Node.js 启动时默认加载 SlowBuffer，同样也是二进制数据容器类，不过直接进行内存申请 INSPECT_MAX_BYTES，限制 bufObject.inspect() 输出的长度 kMaxLength，一次性内存分配的上限，大小为（2^31 - 1） 其中，由于 Buffer 经常使用，所以 Node.js 在启动的时候，就已经加载了 Buffer，而其他三个仍然需要使用对应的引用来进行使用（require('buffer').xxx），这里需要注意一点，就是关于 Buffer 的内存申请、填充、修改等涉及性能问题的操作，均通过 C++ 里面的 node_buffer.cc 来实现 内存分配的策略Node.js 中 Buffer 内存分配太过常见，从系统性能考虑出发，Buffer 采用了如下的管理策略 Node.js 采用了 slab 机制进行预先申请、事后分配，是一种动态的管理机制，使用 Buffer.alloc(size) 传入一个指定的 size 就会申请一块固定大小的内存区域，slab 具有如下三种状态 full，完全分配状态 partial，部分分配状态 empty，没有被分配状态 8K 内存池在 Node.js 应用程序启动时，为了方便地、高效地使用 Buffer，会创建一个大小为 8K 的内存池，所以是以 8KB 为界限来区分是小对象还是大对象 1234567891011Buffer.poolSize = 8 * 1024 // 8Kvar poolSize, poolOffset, allocPool// 创建内存池function createPool() { poolSize = Buffer.poolSize allocPool = createUnsafeArrayBuffer(poolSize) poolOffset = 0}createPool() 在加载时直接调用了 createPool() 相当于直接初始化了一个 8KB 的内存空间，这样在第一次进行内存分配时也会变得更高效，另外在初始化的同时还初始化了一个新的变量 poolOffset = 0 这个变量会记录已经使用了多少字节，在 createPool() 函数中，通过调用 createUnsafeArrayBuffer() 函数来创建 poolSize（8KB）的 ArrayBuffer 对象，createUnsafeArrayBuffer() 函数的实现如下 123456789function createUnsafeArrayBuffer(size) { zeroFill[0] = 0 try { // 创建指定 size 大小的 ArrayBuffer 对象，其内容被初始化为 0 return new ArrayBuffer(size) } finally { zeroFill[0] = 1 }} 此时，新构造的 slab 如下所示 现在让我们来尝试分配一个大小为 2048 的 Buffer 对象，代码如下所示 1Buffer.alloc(2 * 1024) 现在让我们先看下当前的 slab 内存是怎么样的？如下所示 那么这个分配过程是怎样的呢？让我们再看 buffer.js 另外一个核心的方法 allocate(size) 12345678910111213141516171819202122function allocate(size) { if (size &lt;= 0) { return new FastBuffer() } // 当分配的空间小于 Buffer.poolSize 向右移位，这里得出来的结果为 4KB if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) { if (size &gt; (poolSize - poolOffset)) createPool() var b = new FastBuffer(allocPool, poolOffset, size) // 已使用空间累加 poolOffset += size // 8 字节内存对齐处理（关于字节对齐见最下方） alignPool() return b } else { // C++ 层面申请 return createUnsafeBuffer(size) }} Buffer 内存分配总结 在初次加载时就会初始化 1 个 8KB 的内存空间 根据申请的内存大小，Buffer 对象分为小对象和大对象 Buffer 小对象的情况，会继续判断这个 slab 空间是否足够 如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加 如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配 Buffer 大对象情况，则会直接走 createUnsafeBuffer(size) 函数 不论是小对象的还是大对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收 Buffer.from() 剖析在我们使用 Buffer 的过程中，比如下面这个简单示例 123const buf = Buffer.from('hello world')console.log(buf) 运行以后可以发现，输出变成了 1&lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; 为什么结果会变成一串数字，这就要从源码找起了，如下 123456789101112131415/** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]])『/Buffer.from = function from(value, encodingOrOffset, length) { if (typeof value === \"string\") return fromString(value, encodingOrOffset) // 处理其它数据类型，省略异常处理等其它代码 if (isAnyArrayBuffer(value)) return fromArrayBuffer(value, encodingOrOffset, length) var b = fromObject(value)} 可以看出 Buffer.from() 工厂函数，支持基于多种数据类型（string、Array、Buffer 等）创建 Buffer 对象，对于字符串类型的数据，内部调用 fromString(value, encodingOrOffset) 方法来创建 Buffer 对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class FastBuffer extends Uint8Array { constructor(arg1, arg2, arg3) { super(arg1, arg2, arg3) }}function fromString(string, encoding) { var length if (typeof encoding !== \"string\" || encoding.length === 0) { if (string.length === 0) return new FastBuffer() // 若未设置编码，则默认使用 utf8 编码 encoding = \"utf8\" // 计算 string 的长度 length = byteLengthUtf8(string) } else { // 基于指定的 encoding 计算 string 的长度 length = byteLength(string, encoding, true) if (length === -1) throw new errors.TypeError(\"ERR_UNKNOWN_ENCODING\", encoding) if (string.length === 0) return new FastBuffer() } // 当字符串所需字节数大于 4KB，则直接进行内存分配 if (length &gt;= Buffer.poolSize &gt;&gt;&gt; 1) // 创建 buffer 对象 return createFromString(string, encoding) // 当剩余的空间小于所需的字节长度，则先重新申请 8K 内存 if (length &gt; poolSize - poolOffset) // 上面提到过的 createPool() 方法 // allocPool = createUnsafeArrayBuffer(8K) // poolOffset = 0 createPool() // 创建 FastBuffer 对象，并写入数据 var b = new FastBuffer(allocPool, poolOffset, length) const actual = b.write(string, encoding) if (actual !== length) { // byteLength() may overestimate. That's a rare case, though. b = new FastBuffer(allocPool, poolOffset, actual) } // 更新 pool 的偏移，并执行字节对齐（关于字节对齐可见下方，也就是所谓的 alignPool() 方法） poolOffset += actual alignPool() return b} 简单的梳理如下，可以发现与上面的 Buffer 内存机制是相符的 当未设置编码的时候，默认使用 utf8 编码 当字符串所需字节数大于 4KB，则直接进行内存分配 当字符串所需字节数小于 4KB，但超过预分配的 8K 内存池的剩余空间，则重新申请 8K 的内存池 调用 new FastBuffer(allocPool, poolOffset, length) 创建 FastBuffer 对象，进行数据存储，数据成功保存后，会进行长度校验、更新 poolOffset 偏移量和字节对齐等操作 Buffer 应用场景下面是一些 Buffer 在实际业务中的应用场景 I/O 操作关于 I/O 可以是文件或网络 I/O，以下为通过流的方式将 input.txt 的信息读取出来之后写入到 output.txt 文件 123456const fs = require('fs')const inputStream = fs.createReadStream('input.txt') // 创建可读流const outputStream = fs.createWriteStream('output.txt') // 创建可写流inputStream.pipe(outputStream) // 管道读写 在 Stream 中我们是不需要手动去创建自己的缓冲区，在 Node.js 的流中将会自动创建 zlib.jszlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能，见 zlib.js 加解密在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 string 或 Buffer 类型，使用 Buffer.alloc() 初始化一个实例，然后使用 fill 方法进行填充，语法为 1buf.fill(value[, offset[, end]][, encoding]) value，第一个参数为要填充的内容 offset，偏移量，填充的起始位置 end，结束填充 buf 的偏移量 encoding，编码集 以下为使用 Cipher 对称加密的示例 1234567891011121314151617181920const crypto = require('crypto')const [key, iv, algorithm, encoding, cipherEncoding] = [ 'a123456789', '', 'aes-128-ecb', 'utf8', 'base64']const handleKey = key =&gt; { const bytes = Buffer.alloc(16) // 初始化一个 Buffer 实例，每一项都用 00 填充 console.log(bytes) // &lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt; bytes.fill(key, 0, 10) // 填充 console.log(bytes) // &lt;Buffer 61 31 32 33 34 35 36 37 38 39 00 00 00 00 00 00&gt; return bytes}let cipher = crypto.createCipheriv(algorithm, handleKey(key), iv)let crypted = cipher.update('Node.js 技术栈', encoding, cipherEncoding)crypted += cipher.final(cipherEncoding)console.log(crypted) // jE0ODwuKN6iaKFKqd3RF4xFZkOpasy8WfIDl8tRC5t0= 缓冲（Buffer）与缓存（Cache）的区别缓冲（Buffer）缓冲（Buffer）是用于处理二进制流数据，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来，等缓冲到一定的大小之后在存入硬盘中，视频播放器就是一个经典的例子，有时你会看到一个缓冲的图标，这意味着此时这一组缓冲区并未填满，当数据到达填满缓冲区并且被处理之后，此时缓冲图标消失，你可以看到一些图像数据 缓存（Cache）缓存（Cache）我们可以看作是一个中间层，它可以是永久性的将热点数据进行缓存，使得访问速度更快，例如我们通过 Memory、Redis 等将数据从硬盘或其它第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也是性能优化一个重要的点 更多区别可以参考 Cache 和 Buffer 都是缓存，主要区别是什么？ 字节对齐截取自 数据结构对齐 - 维基百科，所谓的字节对齐，就是各种类型的数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这个就是对齐，我们经常听说的对齐在 N 上，它的含义就是数据的存放起始地址 %N== 0，首先还是让我们来看一下，为什么要进行字节对齐吧 这是因为各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取，比如有些架构的 CPU，诸如 SPARC 在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构上必须编程必须保证字节对齐，而有些平台对于没有进行对齐的数据进行存取时会产生效率的下降 让我们来以 x86 为例看一下如果在不进行对齐的情况下，会带来什么样子的效率低下问题，看下面的数据结构声明 123456struct A { char c; // 字符占一个字节 int i; // 整型占四个字节 }; struct A a; 假设变量 a 存放在内存中的起始地址为 0x00，那么其成员变量 c 的起始地址为 0x00，成员变量 i 的起始地址为0x01，变量 a 一共占用了 5 个字节，当 CPU 要对成员变量 c 进行访问时，只需要一个读周期即可 然而如果要对成员变量 i 进行访问，那么情况就变得有点复杂了，首先 CPU 用了一个读周期，从 0x00 处读取了 4 个字节（注意由于是 32 位架构），然后将 0x01 - 0x03 的 3 个字节暂存，接着又花费了一个读周期读取了从 0x04 - 0x07 的 4 字节数据，将 0x04 这个字节与刚刚暂存的 3 个字节进行拼接从而读取到成员变量 i 的值 为了读取这个成员变量 i，CPU 花费了整整 2 个读周期，试想一下，如果数据成员 i 的起始地址被放在了 0x04 处，那么读取其所花费的周期就变成了 1，显然引入字节对齐可以避免读取效率的下降，但这同时也浪费了 3 个字节的空间（0x01 - 0x03） 了解完字节对齐的概念和使用字节对齐的原因，最后我们来看一下 Buffer.js 文件中的实现字节对齐的 alignPool() 函数 1234567891011121314/** * 如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失 * 比如 32 位的 Intel 处理器通过总线访问内存数据每个总线周期从偶地址开始访问 32 位内存数据 * 内存数据以字节为单位存放，如果一个 32 位的数据没有存放在 4 字节整除的内存地址处 * 那么处理器就需要 2 个总线周期对其进行访问，显然访问效率下降很多 */function alignPool() { // Ensure aligned slices // 后四位：0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 if (poolOffset &amp; 0x7) { poolOffset |= 0x7 poolOffset++ }} 参考 Node.js 中的缓冲区（Buffer）究竟是什么？ buffer buffer.js 深入浅出 Node.js 数据结构对齐 - 维基百科 Cache 和 Buffer 都是缓存，主要区别是什么？ Do you want a better understanding of Buffer in Node.js A cartoon intro to ArrayBuffers and SharedArrayBuffers DataView ArrayBuffer Node.js Buffer 解读 Node 中的 Buffer Cache 和 Buffer 都是缓存，主要区别是什么？","link":"/2019/09/22/Node/07/"},{"title":"Node.js 中的多进程","text":"最后更新于 2020-01-05 最近在深入学习 Node.js，有涉及到这一部分内容，翻出来重新更新整理一下，主要涉及到浏览器与 Node.js 当中的进程与线程相关知识，建议在阅读本文之前先了解一下 体系结构与操作系统 当中的进程和线程相关概念 Node.js 中的进程对于操作系统来说，一个任务就是进程（process），比如打开一个浏览器就是启动了一个浏览器进程，打开一个记事本就启动了一个记事本进程，有些进程还不止同时干一件事，比如 word，它可以同时进行打字、拼写检查，打印等，在一个进程的内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程（thread），由于每个进程至少要干一件事，所以『一个进程至少有一个线程』，当然也可以有多个，也可以多个线程同时执行 简单来说就是，线程是最小的执行单元，而进程由至少一个线程组成 进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器，Node.js 里通过命令行可以开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信（进程间通信技术），进程之间才可数据共享（关于 IPC 通信相关内容可以见文章下方），我们可以通过一个简单的示例来验证一下 123456const http = require('http')http.createServer().listen(3000, () =&gt; { process.title = '测试进程' console.log(`process.pid: `, process.pid)}) 打开任务管理器，可以在进程选项当中发现我们刚开启的 Node.js 进程 为什么需要多进程在展开之前，我们先来来看下面这个 Node.js 的示例，我们实现一个计算耗时过长造成线程阻塞的例子，来了解阻塞所带来的后果 123456789101112131415161718192021222324const http = require('http')const computation = () =&gt; { let sum = 0 console.info('计算开始') console.time('计算耗时') for (let i = 0; i &lt; 10000000000; i++) { sum += i } console.info('计算结束') console.timeEnd('计算耗时') return sum}const server = http.createServer((req, res) =&gt; { const sum = computation() res.end(`Sum is ${sum}`)})server.listen('3000', _ =&gt; { console.log(`app is running at port 3000.`)}) 运行完成后可以发现，页面会处于很长时间的空白状态，而执行完成以后会发现，计算耗时会有 13554.335ms 左右（处理器不同可能造成结果有所不同），不过不用担心，在后面我们会使用 child_process.fork 来实现多个进程来处理 Node.js 的线程与进程Node.js 是 JavaScript 在服务端的运行环境，构建在 Chrome 的 V8 引擎之上，基于事件驱动、非阻塞 I/O 模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务 在单核 CPU 系统之上一般采用『单进程 + 单线程』的模式来开发 在多核 CPU 系统之上，可以用过 child_process.fork 开启多个进程（在 v0.8 版本之后新增了 Cluster 来实现多进程架构），即『多进程 + 单线程』模式 不过需要注意的是，开启多进程不是为了解决高并发，而是主要为了解决单进程模式下 Node.js 的 CPU 利用率不足的情况，充分利用多核 CPU 的性能 processNode.js 中的进程（process）是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息 process.env，环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick，这个在谈及 EventLoop 时经常为会提到 process.pid，获取当前进程 id process.ppid，当前进程对应的父进程 process.cwd()，获取当前进程工作目录 process.platform，获取当前进程运行的操作系统平台 process.uptime()，当前进程已运行时间，例如 pm2 守护进程的 uptime 值 进程事件，process.on('uncaughtException', cb) 捕获异常信息、process.on('exit', cb) 进程退出监听 三个标准流，标准输出（process.stdout）、标准输入（process.stdin）、标准错误输出（process.stderr） 以上仅列举了部分常用到功能点，除了 process 之外，Node.js 还提供了 child_process 模块用来对子进程进行操作，我们下面简单的总结一下 JavaScript 是单线程，但是做为宿主环境的 Node.js 并非是单线程的 由于单线程原故，一些复杂的、消耗 CPU 资源的任务建议不要交给 Node.js 来处理，当你的业务需要一些大量计算、视频编码解码等 CPU 密集型的任务，可以采用 C 语言 Node.js 和 Nginx 均采用事件驱动方式，避免了多线程的线程创建、线程上下文切换的开销，如果业务大多是基于 I/O 操作，那么你可以选择 Node.js 来开发 进程创建Node.js 提供了 child_process 内置模块，用于创建子进程，有四种方式可以选择 child_process.spawn()，适用于返回大量数据，例如图像处理，二进制数据处理 child_process.exec()，适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn child_process.execFile()，类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork()，衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置 .exec()、.execFile()、.fork() 底层都是通过 .spawn() 实现的，.exec()、execFile() 额外提供了回调，当子进程停止的时候执行，下面我们就详细的来看看以上几个方法 child_process.spawn(command[, args][, options])spawn 方法创建一个子进程来执行特定命令，用法与 execFile 方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果，它属于异步执行，适用于子进程长时间运行的情况 12345678910111213141516var child_process = require('child_process')var path = '.'var ls = child_process.spawn('/bin/ls', ['-l', path])ls.stdout.on('data', function (data) { console.log('stdout: ' + data)})ls.stderr.on('data', function (data) { console.log('stderr: ' + data)})ls.on('close', function (code) { console.log('child process exited with code ' + code)}) spawn 方法接受两个参数，第一个是可执行文件，第二个是参数数组，spawn 对象返回一个对象，代表子进程，该对象部署了 EventEmitter 接口，它的 data 事件可以监听，从而得到子进程的输出结果，spawn 方法与 exec 方法非常类似，只是使用格式略有区别 123child_process.exec(command, [options], callback)child_process.spawn(command, [args], [options]) 但是需要区分两者的默认参数不同，spawn 的 options 默认为 12345{ cwd: undefined, env: process.env, setsid: false} exec 的 options 默认为 12345678{ encoding: 'utf8', timeout: 0, /* 子进程最长执行时间 */ maxBuffer: 200*1024, /* stdout 和 stderr 的最大长度 */ killSignal: 'SIGTERM', cwd: null, env: null} child_process.exec(command[, options][, callback])创建一个 shell，然后在 shell 里执行命令，执行完成后，将 stdout、stderr 作为参数传入回调方法 123456789101112131415161718192021var exec = require('child_process').exec// 成功的例子exec('ls -al', function (error, stdout, stderr) { if (error) { console.error('error: ' + error) return } console.log('stdout: ' + stdout) console.log('stderr: ' + typeof stderr)})// 失败的例子exec('ls hello.txt', function (error, stdout, stderr) { if (error) { console.error('error: ' + error) return } console.log('stdout: ' + stdout) console.log('stderr: ' + stderr)}) 不过需要注意的是，如果传入的命令是用户输入的，有可能产生类似 sql 注入的风险，比如 12345678exec('ls hello.txt; rm -rf *', function (error, stdout, stderr) { if (error) { console.error('error: ' + error) // return } console.log('stdout: ' + stdout) console.log('stderr: ' + stderr)}) child_process.execFile(file[, args][, options][, callback])跟 .exec() 类似，不同点在于，没有创建一个新的 shell，至少有两点影响 比 child_process.exec() 效率高一些 一些操作，比如 I/O 重定向，文件 glob 等不支持 123456789101112131415var child_process = require('child_process')child_process.execFile('node', ['--version'], function (error, stdout, stderr) { if (error) { throw error } console.log(stdout)})child_process.execFile('/Users/a/.nvm/versions/node/v6.1.0/bin/node', ['--version'], function (error, stdout, stderr) { if (error) { throw error } console.log(stdout)}) 从源码层面来看，exec() 和 execFile() 最大的差别就在于是否创建了 shell，那么可以手动设置 shell，比如下面的代码差不多是等价的 1234567891011121314151617var child_process = require('child_process')var execFile = child_process.execFilevar exec = child_process.execexec('ls -al .', function (error, stdout, stderr) { if (error) { throw error } console.log(stdout)})execFile('ls -al .', { shell: '/bin/bash' }, function (error, stdout, stderr) { if (error) { throw error } console.log(stdout)}) execFile() 内部最终还是通过 spawn() 实现的，如果没有设置 { shell: '/bin/bash' }，那么 spawm() 内部对命令的解析会有所不同，execFile('ls -al .') 会直接报错 child_process.fork(modulePath[, args][, options])fork 方法直接创建一个子进程来执行脚本，fork('./child.js') 相当于 spawn('node', ['./child.js'])，与 spawn 方法不同的是，fork 会在父进程与子进程之间建立一个通信管道，用于进程之间的通信（IPC） 1234567891011121314151617// parent.jsvar child_process = require('child_process')var child = child_process.fork('./child.js')child.on('message', function (m) { console.log('message from child: ' + JSON.stringify(m))})child.send({ from: 'parent' })// child.jsprocess.on('message', function (m) { console.log('message from parent: ' + JSON.stringify(m))})process.send({ from: 'child' }) 运行结果如下 123message from child: { 'from': 'child' }message from parent: { 'from': 'parent' } 实战在之前章节当中，我们实现了一个计算耗时的函数，可以发现在 CPU 计算密度大的情况程序会造成阻塞导致后续请求需要等待，不过在了解了多进程相关知识以后，我们下面就可以采用 child_process.fork 方法来进行改写，主要流程有以下几步 在进行 cpmpute 计算时创建子进程 子进程计算完成通过 send 方法将结果发送给主进程 主进程通过 message 监听到信息后处理并退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// fork_app.jsconst http = require('http')const fork = require('child_process').forkconst server = http.createServer((req, res) =&gt; { if (req.url == '/compute') { const compute = fork('./fork_compute.js') compute.send('开启一个新的子进程') // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件 compute.on('message', sum =&gt; { res.end(`Sum is ${sum}`) compute.kill() }) // 子进程监听到一些错误消息退出 compute.on('close', (code, signal) =&gt; { console.log(`收到 close 事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`) compute.kill() }) } else { res.end(`ok`) }})server.listen(3000, () =&gt; { console.log(`app is running at port 3000`)})// fork_compute.jsconst computation = () =&gt; { let sum = 0 console.info('计算开始') console.time('计算耗时') for (let i = 0; i &lt; 10000000000; i++) { sum += i } console.info('计算结束') console.timeEnd('计算耗时') return sum}process.on('message', msg =&gt; { console.log(msg, 'process.pid', process.pid) const sum = computation() // 如果 Node.js 进程是通过进程间通信产生的，那么 process.send() 方法可以用来给父进程发送消息 process.send(sum)}) Node.js 多进程架构模型多进程架构解决了单进程、单线程无法充分利用系统多核 CPU 的问题，下面就通过一个示例来了解如何启动一批 Node.js 进程来提供服务 主进程 master.js代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// master.jsconst fork = require('child_process').forkconst cpus = require('os').cpus()const server = require('net').createServer()server.listen(3000)process.title = 'node-master'const workers = {}const createWorker = () =&gt; { const worker = fork('worker.js') worker.on('message', function (message) { if (message.act === 'close') { createWorker() } }) worker.on('exit', function (code, signal) { console.log('worker process exited, code: %s signal: %s', code, signal) delete workers[worker.pid] }) worker.send('server', server) workers[worker.pid] = worker console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);}for (let i = 0; i &lt; cpus.length; i++) { createWorker()}process.once('SIGINT', close.bind(this, 'SIGINT')) // kill(2) Ctrl-Cprocess.once('SIGQUIT', close.bind(this, 'SIGQUIT')) // kill(3) Ctrl-\\process.once('SIGTERM', close.bind(this, 'SIGTERM')) // kill(15) defaultprocess.once('exit', close.bind(this))function close(code) { console.log('进程退出！', code) if (code !== 0) { for (let pid in workers) { console.log('master process exited, kill worker pid: ', pid) workers[pid].kill('SIGINT') } } process.exit(0)} master.js 作为入口文件，主要处理以下逻辑 创建一个 server 并监听 3000 端口 根据系统 CPU 个数开启多个子进程 通过子进程对象的 send 方法发送消息到子进程进行通信 在主进程中监听了子进程的变化，如果是自杀信号重新启动一个工作进程 主进程在监听到退出消息的时候，先退出子进程在退出主进程 工作进程下面来看看上面我们 fork 的 worker.js，主要逻辑如下 创建一个 server 对象，注意最开始并没有监听 3000 端口 通过 message 事件接收主进程 send 方法发送的消息 监听 uncaughtException 事件，捕获未处理的异常，发送关闭信息由主进程重建进程，子进程在链接关闭之后退出 1234567891011121314151617181920212223242526272829// worker.jsconst http = require('http')const server = http.createServer((req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/plan' }) res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid) // 测试异常进程退出、重建 throw new Error('worker process exception!')})let workerprocess.title = 'node-worker'process.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle worker.on('connection', function (socket) { server.emit('connection', socket) }) }})process.on('uncaughtException', function (err) { console.log(err) process.send({ act: 'close' }) worker.close(function () { process.exit(1) })}) 测试控制台执行 node master.js 可以看到已成功创建了四个工作进程 12345$ node masterworker process created, pid: 19280 ppid: 19279worker process created, pid: 19281 ppid: 19279worker process created, pid: 19282 ppid: 19279worker process created, pid: 19283 ppid: 19279 打开活动监视器查看我们的进程情况，由于在创建进程时对进程进行了命名，很清楚的看到一个主进程对应多个子进程，如果想要了解更多相关内容可以参考 Egg 官方文档当中的 多进程模型和进程间通讯 守护进程本章节主要涉及下面几个问题 什么是守护进程 守护进程的作用 如何编写守护进程 守护进程运行在后台不受终端的影响，比如在 Node.js 当中，当我们打开终端执行 node app.js 开启一个服务进程之后，这个终端就会一直被占用，如果关掉终端，服务就会断掉，即前台运行模式，如果采用守护进程进程方式，这个终端在我们使用 node app.js 开启一个服务进程之后，还可以在这个终端上做些别的事情，且不会相互影响 创建步骤主要有下面四个步骤 借助 clild_process 中的 spawn 创建子进程 在子进程中创建新会话，在 spawn 的第三个参数中，可以设置 detached 属性，如果该属性为 true，则会调用系统函数 setsid 方法 改变子进程工作目录（如：/ 或 /usr/ 等），options.cwd 指定当前子进程工作目录若不做设置默认继承当前工作目录 父进程终止（运行 daemon.unref() 退出父进程） 123456789101112131415// index.jsconst spawn = require('child_process').spawnfunction startDaemon() { const daemon = spawn('node', ['daemon.js'], { cwd: '/usr', detached: true, stdio: 'ignore', }) console.log('守护进程开启 父进程 pid: %s, 守护进程 pid: %s', process.pid, daemon.pid) daemon.unref()}startDaemon() daemon.js 文件里处理逻辑开启一个定时器每 10 秒执行一次，使得这个资源不会退出，同时写入日志到子进程当前工作目录下 12345678910// daemon.jsconst fs = require('fs')const { Console } = require('console')// custom simple loggerconst logger = new Console(fs.createWriteStream('./stdout.log'), fs.createWriteStream('./stderr.log'))setInterval(function () { logger.log('daemon pid: ', process.pid, ', ppid: ', process.ppid)}, 1000 * 10) 运行测试123$ node index.js守护进程开启 父进程 pid: 47608, 守护进程 pid: 47609 打开活动监视器查看，目前只有一个进程 47609，这就是我们需要进行守护的进程，当然，以上只是一个简单的示例，在实际工作中对守护进程的健壮性要求还是很高的，比如进程的异常监听、工作进程管理调度、进程挂掉之后重启等等，推荐阅读 编写守护进程 了解更多 问题汇总下面是一些在实际使用当中可能会遇到的问题，主要包括以下内容 什么是进程和线程？两者之间有什么区别？ 什么是孤儿进程？ 创建多进程时，代码里有 app.listen(port) 在进行 fork 时，为什么没有报端口被占用？ 什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？ 父进程与子进程是如何通信的？ Node.js 是单线程还是多线程？ 如何实现一个简单的命令行交互程序？ 如何让一个 js 文件在 Linux 下成为一个可执行命令程序? 进程的当前工作目录是什么? 有什么作用? 多进程或多个 Web 服务之间的状态共享问题？ 下面我们就一个一个来看 什么是进程和线程？两者之间有什么区别？之前已经介绍过了，这里小小的总结一下 关系 进程中包含着至少一个线程 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源 共性 都包含三个状态，就绪、阻塞、运行 阻塞就是资源未到位，等待资源中 就绪，就是资源到位了，但是 CPU 未到位，还在运行其他 什么是孤儿进程？父进程创建子进程之后，父进程退出了，但是父进程对应的一个或多个子进程还在运行，这些子进程会被系统的 init 进程收养，对应的进程 ppid 为 1，这就是孤儿进程 12345678910111213141516171819202122232425262728// master.jsconst fork = require('child_process').forkconst server = require('net').createServer()server.listen(3000)const worker = fork('worker.js')worker.send('server', server)console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid)// 创建子进程之后，主进程退出，此时创建的 worker 进程会成为孤儿进程process.exit(0)// worker.jsconst http = require('http')const server = http.createServer((req, res) =&gt; { // 记录当前工作进程 pid 及父进程 ppid res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid)})let workerprocess.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle worker.on('connection', function (socket) { server.emit('connection', socket) }) }}) 在控制台进行测试，输出当前工作进程 pid 和 父进程 ppid 123$ node masterworker process created, pid: 32971 ppid: 32970 由于在 master.js 里退出了父进程，活动监视器所显示的也就只有工作进程，再次验证，打开控制台调用接口，可以看到工作进程 32971 对应的 ppid 为 1（为 init 进程），此时已经成为了孤儿进程 123$ curl http://127.0.0.1:3000I am worker, pid: 32971, ppid: 1 创建多进程时，代码里有 app.listen(port) 在进行 fork 时，为什么没有报端口被占用？我们先来看一个端口被占用的情况 123456789101112131415// master.jsconst fork = require('child_process').forkconst cpus = require('os').cpus()for (let i = 0; i &lt; cpus.length; i++) { const worker = fork('worker.js') console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid)}//worker.jsconst http = require('http')http.createServer((req, res) =&gt; { res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid)}).listen(3000) 以上代码示例，控制台执行 node master.js 只有一个 worker 可以监听到 3000 端口，其余将会抛出 Error: listen EADDRINUSE :::3000 错误，那么多进程模式下怎么实现多端口监听呢？ 通过上面的多进程当中的示例可以发现，在这种情况下就可以通过句柄传递来实现多端口监听，当父子进程之间建立 IPC 通道之后，通过子进程对象的 send 方法发送消息，第二个参数 sendHandle 就是句柄，可以是 TCP 套接字、TCP 服务器、UDP 套接字等，为了解决上面多进程端口占用问题，我们将主进程的 socket 传递到子进程，修改代码 123456789101112131415161718192021222324252627282930313233343536//master.jsconst fork = require('child_process').forkconst cpus = require('os').cpus()const server = require('net').createServer()server.listen(3000)process.title = 'node-master'for (let i = 0; i &lt; cpus.length; i++) { const worker = fork('worker.js') worker.send('server', server) console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid) if (i + 1 === cpus.length) { console.log('serve close') // 关闭服务器监听，交由子进程处理 server.close() }}// worker.jsconst http = require('http')const server = http.createServer((req, res) =&gt; { res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid)})let workerprocess.title = 'node-worker'process.on('message', function (message, sendHandle) { if (message === 'server') { worker = sendHandle worker.on('connection', function (socket) { server.emit('connection', socket) }) }}) 验证一番，控制台执行 node master.js 以下结果是我们预期的，多进程端口占用问题已经被解决了 123456$ node master.jsworker process created, pid: 34512 ppid: 34511worker process created, pid: 34513 ppid: 34511worker process created, pid: 34514 ppid: 34511worker process created, pid: 34515 ppid: 34511 关于多进程端口占用问题，可以参考 通过源码解析 Node.js 中 cluster 模块的主要功能实现 什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？IPC（Inter-process communication），即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问，实现 IPC 的方式有多种方式，例如管道、消息队列、信号量、Domain Socket 等，在 Node.js 当中是通过 pipe 来实现，我们先来看一个未使用 IPC 的情况 12345678// pipe.jsconst spawn = require('child_process').spawnconst child = spawn('node', ['worker.js'])console.log(process.pid, child.pid)// worker.jsconsole.log('I am worker, PID: ', process.pid) 控制台执行 node pipe.js，输出主进程 id、子进程 id，但是子进程 worker.js 的信息并没有在控制台打印，原因是新创建的子进程有自己的 stdio 流 123$ node pipe.js41948 41949 下面我们再来创建一个父进程和子进程之间传递消息的 IPC 通道实现输出信息的示例，通过修改 pipe.js 让子进程的 stdio 和当前进程的 stdio 之间建立管道链接，还可以通过 spawn() 方法的 stdio 选项建立 IPC 机制 12345// pipe.jsconst spawn = require('child_process').spawnconst child = spawn('node', ['worker.js'])child.stdout.pipe(process.stdout)console.log(process.pid, child.pid) 再次执行 node pipe.js，可以发现 worker.js 的信息也打印了出来 123$ 42473 42474I am worker, PID: 42474 父进程与子进程是如何通信的？父进程在创建子进程之前会先去创建 IPC 通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将 IPC 频道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接 IPC 通道，从而建立父子进程之间的通信机制 Node.js 是单线程还是多线程？JavaScript 是单线程的，但是做为其在服务端运行环境的 Node.js 并非是单线程的，至于 JavaScript 为什么是单线程？这个问题需要从浏览器说起，在浏览器环境中对于 DOM 的操作，不可能存在多个线程来对同一个 DOM 同时操作，那也就意味着对于 DOM 的操作只能是单线程，避免 DOM 渲染冲突，而在浏览器环境中 UI 渲染线程和 JavaScript 执行引擎是互斥的，一方在执行时都会导致另一方被挂起，这是由 JavaScript 引擎所决定的 如何实现一个简单的命令行交互程序？可以采用子进程 child_process 的 spawn 方法，如下所示 12345const spawn = require('child_process').spawnconst child = spawn('echo', ['test'])// 将子进程的输出做为当前进程的输入，打印在控制台child.stdout.pipe(process.stdout) 运行 123$ node execfile// test 如何让一个 js 文件在 Linux 下成为一个可执行命令程序? 新建 hello.js 文件，头部须加上 #!/usr/bin/env node，表示当前脚本使用 Node.js 进行解析 赋予文件可执行权限 chmod + x chmod + x /${dir}/hello.js，目录自定义 在 /usr/local/bin 目录下创建一个软链文件 sudo ln -s /${dir}/hello.js /usr/local/bin/hello，文件名就是我们在终端使用的名字 终端执行 hello 相当于输入 node hello.js 123#!/usr/bin/env nodeconsole.log(&apos;hello world!&apos;) 终端测试 123$ hellohello world! 进程的当前工作目录是什么? 有什么作用?进程的当前工作目录可以通过 process.cwd() 命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可通过 process.chdir() 命令重置，例如通过 spawn 命令创建的子进程可以指定 cwd 选项设置子进程的工作目录，有什么作用？例如通过 fs 模块来读取文件，如果设置为相对路径则相对于当前进程启动的目录进行查找，所以启动目录设置有误的情况下将无法得到正确的结果，还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的 12345// 设置当前进程目录process.chdir('/Users/may/Documents/test/') // 获取当前进程目录console.log(process.cwd()) 多进程或多个 Web 服务之间的状态共享问题？多进程模式下各个进程之间是相互独立的，例如用户登陆之后 Session 的保存，如果保存在服务进程里，那么如果我有 4 个工作进程，每个进程都要保存一份这是没必要的，如果服务重启了数据也会丢失，多个 Web 服务也是一样的，还会出现我在 A 机器上创建了 Session，当负载均衡分发到 B 机器上之后还需要在创建一份，一般的做法是通过 Redis 或者数据库来做数据共享 参考 线程和进程的区别是什么？ Child Process 模块 进阶：如何玩转子进程（child_process）","link":"/2019/05/04/Node/16/"},{"title":"什么是 Virtual DOM？","text":"最近在深入学习 Virtual DOM 的相关知识，参考了许多资料，也拜读了许多大神的文章，所以在这里大致的整理成了比较适合自己理解的方式，方便时不时回来翻翻，复习一下，篇幅较长，主要会分为三个部分来分别进行介绍，具体章节如下，目录名就差不多代表了章节的相关内容 什么是 Virtual DOM？ 渲染器 渲染器的核心 Diff 算法 本篇是第一部分，主要介绍 Virtual DOM 相关内容，主要参考的是 HcySunYang/vue-design，本章相关内容如下 什么是 Virtual DOM 如何将 Virtual DOM 渲染为真实的 DOM 节点 用 VNode 描述真实 DOM VNode 的种类 辅助创建 VNode 的 h 函数 完善 h 函数 使用 h 函数来创建 VNode 下面我们就一步一步来看 什么是 Virtual DOM？在谈论 Virtual DOM 之前，我们必须要先理解什么是 DOM？DOM 即 Document Object Model，是一种通过对象表示结构化文档的方式，DOM 是跨平台的，也是语言无关的（比如 HTML 和 XML 都可以用它表示与操作），浏览器处理 DOM 的实现细节，然后我们可以通过 JavaScript 和 CSS 来与它交互 DOM 的主要问题是没有为创建动态 UI 而优化，虽然可以使用 jQuery 这种可以用来简化 DOM 操作的类库，但是并没有解决大量 DOM 操作的性能问题，因为在大型页面或者单页应用里，动态的创建或销毁 DOM 的操作是很频繁的，DOM 操作是很慢的，比如新创建了一个 div，并不是只有单单一个 div 元素那么简单，这个元素上本身或者继承很多属性如 width，height，offsetHeight，style，title 等，另外还需要注册这个元素的诸多方法，比如 onfucos，onclick 等等，这还只是一个元素，如果元素比较多的时候，还涉及到嵌套，那么元素的属性和方法等等就会很多，效率很低 比如我们来看下图，我们在一个空白网页的 body 中添加一个 div 元素（为了偷懒就直接把百度的首页掏空添加了一个空的 div） 这个元素会挂载默认的 styles，得到这个元素的 computed 属性，注册相应的 Event Listener，DOM Breakpoints 以及大量的 properties，这些属性和方法的注册肯定是需要耗费大量时间的（看右侧的滚动条就知道需要挂载多少内容了） 而 Virtual DOM 就是解决问题的一种探索，Virtual DOM 建立在 DOM 之上，是基于 DOM 的一层抽象，实际可理解为用更轻量的纯 JavaScript 对象（树）来描述 DOM（树），操作 JavaScript 对象当然比操作 DOM 快，因为不用更新屏幕，我们可以随意改变 Virtual DOM，然后仅仅将需要改变的地方再更新到 DOM 上 如何将 Virtual DOM 渲染为真实的 DOM 节点 从这一部分开始，我们为了简便，将会使用 VNode 来简称 Virtual DOM（其实只需要知道它们是同一个东西即可） VNode 是真实 DOM 的描述，比如我们可以用如下对象描述一个 div 标签 123const elementVnode = { tag: 'div'} 想要把 elementVnode 渲染成真实 DOM，我们还需要一个渲染器（Renderer），下面是一个简单的实现 1234567891011function render(vnode, container) { mountElement(vnode, container)}// 这样是有一定缺陷的，我们后面将会来完善它function mountElement(vnode, container) { // 创建元素 const el = document.createElement(vnode.tag) // 将元素添加到容器 container.appendChild(el)} 为了渲染之前的 div 标签，我们可以这样调用 render 函数 12// 把 elementVnode 渲染到 id 为 app 的元素下render(elementVnode, document.getElementById('app')) 上述只是一个简单的示例，只能适用于普通的标签，但并不适用于『组件』，为了能够渲染组件，我们还需要思考组件的 VNode 应该如何表示？对于 HTML 标签的 VNode 来说，其 tag 属性的值就是标签的名字，但如果是组件的话，我们可以将其 VNode 中的 tag 属性指向组件自身，比如如下组件 1234567891011121314// 定义一个 render 方法，里面返回指定的 tagclass MyComponent { // render 函数产出 VNode render() { return { tag: 'div' } }}// 这样来描述const componentVnode = { tag: MyComponent} 但想要正确地渲染该组件，我们还需要修改我们的 render 函数，我们可以通过判断 vnode.tag 是否是字符串 来区分一个 VNode 到底是 HTML 标签还是组件 12345678910111213141516171819function render(vnode, container) { if (typeof vnode.tag === 'string') { // html 标签 mountElement(vnode, container) } else { // 组件 mountComponent(vnode, container) }}// 挂载组件方法function mountComponent(vnode, container) { // 创建组件实例 const instance = new vnode.tag() // 渲染 instance.$vnode = instance.render() // 挂载 mountElement(instance.$vnode, container)} 是不是已经有了一点思路了，我们就可以按照以上的方式逐渐的丰富我们的 VNode 和 render 方法，使其的通用性更强 用 VNode 描述真实 DOM那么一个 VNode 到底需要拥有哪些属性呢，我们一点一点来讨论，如下 首先我们使用 tag 属性来存储标签的名字 可以用 data 属性来存储该标签的附加信息，比如 style、class、event 等，通常我们把一个 VNode 对象的 data 属性称为 VNodeData 为了描述子节点，我们需要给 VNode 对象添加 children 属性，若有多个子节点，则可以把 children 属性设计为一个数组 除了标签元素之外，DOM 中还有文本节点，由于文本节点没有标签名字，所以它的 tag 属性值为 null，由于文本节点也无需用额外的 VNodeData 来描述附加属性，所以其 data 属性值也是 null 针对以上内容，我们可以简单的整理出两种类型的描述，『普通标签』和『文本节点』 12345678910111213141516171819202122232425262728293031// 一个 div 标签，具有 style 属性和两个子节点const elementVNode = { tag: 'div', data: { style: { width: '100px', height: '100px' } }, children: [ { tag: 'h1', data: null }, { tag: 'p', data: null } ]}// 一个以文本节点作为子节点的 div 标签的 VNode 对象const elementVNode = { tag: 'div', data: null, children: { tag: null, data: null, children: '文本内容' }} 下面我们再来看看如何描述组件，我们之前提到过，可以通过检查 tag 属性值是否是字符串来确定一个 VNode 是否是普通标签，即 123&lt;div&gt; &lt;MyComponent /&gt;&lt;/div&gt; 对应的 VNode 12345678const elementVNode = { tag: 'div', data: null, children: { tag: MyComponent, data: null }} 另外还有两种特殊的组件，即 Fragment 和 Portal，具体的使用场景就不详细展开了，我们只来看看如何进行表示，我们使用 tag 来标记 Fragment，当渲染器在渲染 VNode 时，如果发现该 VNode 的类型是 Fragment，就只需要把该 VNode 的子节点渲染到页面 1234567891011121314151617181920const Fragment = Symbol()const fragmentVNode = { // tag 属性值是一个唯一标识 tag: Fragment, data: null, children: [ { tag: 'td', data: null }, { tag: 'td', data: null }, { tag: 'td', data: null } ]} 同样的针对 Portal，我们可以得出以下的对应关系 123456789101112131415161718192021&lt;template&gt; &lt;Portal target=\"#app-root\"&gt; &lt;div class=\"overlay\"&gt;&lt;/div&gt; &lt;/Portal&gt;&lt;/template&gt;// 对应着const Portal = Symbol()const portalVNode = { tag: Portal, data: { target: '#app-root' }, children: { tag: 'div', data: { class: 'overlay' } }} Portal 类型的 VNode 与 Fragment 类型的 VNode 类似，都需要一个唯一的标识，来区分其类型，目的是告诉渲染器如何渲染该 VNode VNode 的种类不同类型的 VNode 拥有不同的设计，我们可以把 VNode 分成五类，分别是 html/svg 元素、组件、纯文本、Fragment 以及 Portal，如下图所示 但是这里会存在一个问题，比如之前我们在判断需要挂载的对象是标签还是组件的时候，使用的是通过检查 tag 属性值是否是字符串来确定一个 VNode 是否是普通标签，这样是不严谨的，所以我们就有必要使用一个唯一的标识，来标明某一个 VNode 具体是属于哪一类，我们只需要为每一个 VNode 种类都分配一个 flags 值即可，在 JavaScript 里就用一个对象来表示即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// flags.jsconst VNodeFlags = { ELEMENT_HTML: 1, // html 标签 ELEMENT_SVG: 1 &lt;&lt; 1, // SVG 标签 COMPONENT_STATEFUL_NORMAL: 1 &lt;&lt; 2, // 普通有状态组件 COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE: 1 &lt;&lt; 3, // 需要被 keepAlive 的有状态组件 COMPONENT_STATEFUL_KEPT_ALIVE: 1 &lt;&lt; 4, // 已经被 keepAlive 的有状态组件 COMPONENT_FUNCTIONAL: 1 &lt;&lt; 5, // 函数式组件 TEXT: 1 &lt;&lt; 6, // 纯文本 FRAGMENT: 1 &lt;&lt; 7, // Fragment PORTAL: 1 &lt;&lt; 8 // Portal}// 上述枚举属性的值基本都是通过将十进制数字 1 左移不同的位数得来的// 根据这些基本的枚举属性值，我们还可以派生出额外的三个标识// html 和 svg 都是标签元素，可以用 ELEMENT 表示VNodeFlags.ELEMENT = VNodeFlags.ELEMENT_HTML | VNodeFlags.ELEMENT_SVG// 普通有状态组件、需要被 keepAlive 的有状态组件、已经被 keepAlice 的有状态组件都是有状态组件，统一用 COMPONENT_STATEFUL 表示VNodeFlags.COMPONENT_STATEFUL = VNodeFlags.COMPONENT_STATEFUL_NORMAL | VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE | VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE// ==========================================================================================// ==========================================================================================// 关于 children 和 ChildrenFlags// 总的来说无非有以下几种// 1. 没有子节点// 2. 只有一个子节点// 3. 多个子节点（分为有 key 和无 key 的情况）// 4. 不知道子节点的情况// 至于为什么 children 也需要标识是为了后续在 diff 当中来进行优化// 有状态组件 和 函数式组件都是 组件，用 COMPONENT 表示VNodeFlags.COMPONENT = VNodeFlags.COMPONENT_STATEFUL | VNodeFlags.COMPONENT_FUNCTIONALconst ChildrenFlags = { UNKNOWN_CHILDREN: 0, // 未知的 children 类型 NO_CHILDREN: 1, // 没有 children SINGLE_VNODE: 1 &lt;&lt; 1, // children 是单个 VNode KEYED_VNODES: 1 &lt;&lt; 2, // children 是多个拥有 key 的 VNode NONE_KEYED_VNODES: 1 &lt;&lt; 3 // children 是多个没有 key 的 VNode}ChildrenFlags.MULTIPLE_VNODES = ChildrenFlags.KEYED_VNODES | ChildrenFlags.NONE_KEYED_VNODESexport { VNodeFlags, ChildrenFlags } 这里简单的介绍一下位运算，如下是利用 VNodeFlags 判断 VNode 类型的例子，比如判断一个 VNode 是否是组件 1234// 使用按位与（&amp;）运算functionalComponentVnode.flags &amp; VNodeFlags.COMPONENT // truenormalComponentVnode.flags &amp; VNodeFlags.COMPONENT // truehtmlVnode.flags &amp; VNodeFlags.COMPONENT // false 来看下表 VNodeFlags 左移运算 32 位的 bit 序列（出于简略，只用 9 位表示） ELEMENT_HTML 无 00000000 1 ELEMENT_SVG 1 &lt;&lt; 1 0000000 1 0 COMPONENT_STATEFUL_NORMAL 1 &lt;&lt; 2 000000 1 00 COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE 1 &lt;&lt; 3 00000 1 000 COMPONENT_STATEFUL_KEPT_ALIVE 1 &lt;&lt; 4 0000 1 0000 COMPONENT_FUNCTIONAL 1 &lt;&lt; 5 000 1 00000 TEXT 1 &lt;&lt; 6 00 1 000000 FRAGMENT 1 &lt;&lt; 7 0 1 0000000 PORTAL 1 &lt;&lt; 8 1 00000000 根据上表展示的基本 flags 值可以很容易地得出下表 VNodeFlags 32 位的 bit 序列（出于简略，只用 9 位表示） ELEMENT 00000001 1 COMPONENT_STATEFUL 00001 1 100 COMPONENT 000 1 1 1 1 00 所以很自然的，只有 VNodeFlags.ELEMENT_HTML 和 VNodeFlags.ELEMENT_SVG 与 VNodeFlags.ELEMENT 进行按位与（&amp;）运算才会得到非零值，即为真 更多关于此处的内容可以参考 MDN-标志位与掩码 有了这些 flags 之后，我们在创建 VNode 的时候就可以预先为其打上 flags，以标明该 VNode 的类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// html 元素节点const htmlVnode = { flags: VNodeFlags.ELEMENT_HTML, tag: 'div', data: null}// svg 元素节点const svgVnode = { flags: VNodeFlags.ELEMENT_SVG, tag: 'svg', data: null}// 函数式组件const functionalComponentVnode = { flags: VNodeFlags.COMPONENT_FUNCTIONAL, tag: MyFunctionalComponent}// 普通的有状态组件const normalComponentVnode = { flags: VNodeFlags.COMPONENT_STATEFUL_NORMAL, tag: MyStatefulComponent}// Fragmentconst fragmentVnode = { flags: VNodeFlags.FRAGMENT, // 注意，由于 flags 的存在，我们已经不需要使用 tag 属性来存储唯一标识 tag: null}// Portalconst portalVnode = { flags: VNodeFlags.PORTAL, // 注意，由于 flags 的存在，我们已经不需要使用 tag 属性来存储唯一标识，tag 属性用来存储 Portal 的 target tag: target}// ========================================================================// ========================================================================// 没有子节点的 div 标签const elementVNode = { flags: VNodeFlags.ELEMENT_HTML, tag: 'div', data: null, children: null, childFlags: ChildrenFlags.NO_CHILDREN}// 文本节点的 childFlags 始终都是 NO_CHILDRENconst textVNode = { tag: null, data: null, children: '我是文本', childFlags: ChildrenFlags.NO_CHILDREN}// 拥有多个使用了key的 li 标签作为子节点的 ul 标签const elementVNode = { flags: VNodeFlags.ELEMENT_HTML, tag: 'ul', data: null, childFlags: ChildrenFlags.KEYED_VNODES, children: [ { tag: 'li', data: null, key: 0 }, { tag: 'li', data: null, key: 1 } ]}// 只有一个子节点的 Fragmentconst elementVNode = { flags: VNodeFlags.FRAGMENT, tag: null, data: null, childFlags: ChildrenFlags.SINGLE_VNODE, children: { tag: 'p', data: null }} 那么最后就只剩下 VNode 的 VNodeData 属性，它其实也是一个对象，不过我们会留在后面进行介绍，至此，我们已经对 VNode 完成了一定的设计，目前为止我们所设计的 VNode 对象如下 1234567891011export interface VNode { // _isVNode 属性在上文中没有提到，它是一个始终为 true 的值，有了它，我们就可以判断一个对象是否是 VNode 对象 _isVNode: true // el 属性在上文中也没有提到，当一个 VNode 被渲染为真实 DOM 之后，el 属性的值会引用该真实DOM el: Element | null flags: VNodeFlags tag: string | FunctionalComponent | ComponentClass | null data: VNodeData | null children: VNodeChildren childFlags: ChildrenFlags} 辅助创建 VNode 的 h 函数我们之前已经介绍了 VNode 的种类和一些其他相关概念，但是在实际开发过程当中，去手写 VNode 肯定是不太现实的，所以我们需要一个可以帮助我们创建 VNode 对象的函数，在这里我们将其命名为 h，先来看一个最简单的 h 函数 1234567891011function h() { return { _isVNode: true, flags: VNodeFlags.ELEMENT_HTML, tag: 'h1', data: null, children: null, childFlags: ChildrenFlags.NO_CHILDREN, el: null }} 这个 h 函数只能生成用来描述一个空的 &lt;h1&gt;&lt;/h1&gt;，实际上并没有太大的意义，接下来我们会来一一完善它 完善 h 函数首先需要确定参数，实际上只需要把 tag、data 和 children 提取为参数即可 12345678// 为什么三个参数就能满足需求，对于 _isVNode 属性，它的值始终都为 true，所以不需要提取到参数中// 对于 flags 属性，我们可以通过检查 tag 属性值的特征来确定该 VNode 的 flags 属性function h(tag, data = null, children = null) { let flags = null if (typeof tag === 'string') { flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML }} 下面我们就来针对各种类型来单独处理，详细内容可以参考注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import { VNodeFlags, ChildrenFlags } from './flags'export const Fragment = Symbol()export const Portal = Symbol()export function h(tag, data = null, children = null) { let flags = null // 如果 tag 是字符串则可以确定该 VNode 是标签元素 // 再次通过 tag === 'svg' 进一步判断是否是 SVG 标签，从而确定了该 VNode 的类型 if (typeof tag === 'string') { flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML // 序列化 class（这个将在后面介绍挂载 class 属性的时候来进行介绍） if (data) { data.class = normalizeClass(data.class) } // 对于 Fragment 类型的 VNode，它的 tag 属性值为 null，但是纯文本类型的 VNode 其 tag 属性值也是 null // 所以为了区分，我们可以增加一个唯一的标识，当 h 函数的第一个参数（tag）的值等于该标识的时候，则意味着创建的是 Fragment 类型的 VNode } else if (tag === Fragment) { flags = VNodeFlags.FRAGMENT // 对于Portal 类型的 VNode，它的 tag 属性值也可以是字符串，这就会与普通标签元素类型的 VNode 冲突 // 所以同上，增加一个 Portal 标识 } else if (tag === Portal) { flags = VNodeFlags.PORTAL // 这里需要注意，其 tag 属性值存储的是 Portal 挂载的目标，即 target // 通常模板在经过编译后，我们把 target 数据存储在 VNodeData 中 tag = data &amp;&amp; data.target // 如果一个 VNode 对象的 tag 属性值不满足以上全部条件，那只有一种可能了，即该 VNode 是组件 // 当然也有可能是文本节点，但是一般不会使用 h 去创建文本节点 // 一般在检测到该节点是文本节点的时候会为其自动创建一个纯文本的 VNode 对象 } else { // 兼容 Vue2 的对象式组件 // 如果是 Vue2 的对象式组件，我们通过检查该对象的 functional 属性的真假来判断该组件是否是函数式组件 if (tag !== null &amp;&amp; typeof tag === 'object') { flags = tag.functional ? VNodeFlags.COMPONENT_FUNCTIONAL // 函数式组件 : VNodeFlags.COMPONENT_STATEFUL_NORMAL // 有状态组件 // Vue3 的类组件 // 在 Vue3 中，因为有状态组件会继承基类，所以通过原型链判断其原型中是否有 render 函数的定义来确定该组件是否是有状态组件 // 因为都是使用的 extends 来继承基类的，而子类通常都会有一个 render 方法 } else if (typeof tag === 'function') { flags = tag.prototype &amp;&amp; tag.prototype.render ? VNodeFlags.COMPONENT_STATEFUL_NORMAL // 有状态组件 : VNodeFlags.COMPONENT_FUNCTIONAL // 函数式组件 } } // 同样的，可以使用上面类似的方法来确定 childFlags // 1. children 是一个数组 ==&gt; h('ul', null, [ h('li'), h('li') ]) // 2. children 是一个 VNode 对象 ==&gt; h('div', null, h('span')) // 3. 无 children ==&gt; h('div') // 4. children 是一个普通文本字符串 ==&gt; h('div', null, '我是文本') let childFlags = null if (Array.isArray(children)) { const { length } = children // 没有 children if (length === 0) { childFlags = ChildrenFlags.NO_CHILDREN // 单个子节点 } else if (length === 1) { childFlags = ChildrenFlags.SINGLE_VNODE children = children[0] // 多个子节点，且子节点使用 key // 这里有个问题，为什么多个子节点时会直接被当做使用了 key 的子节点 // 这个可以参考 normalizeVNodes() 这个函数，如果没有，我们手动进行了添加 } else { childFlags = ChildrenFlags.KEYED_VNODES children = normalizeVNodes(children) } // 如果 children 不是数组，并且没有子节点 } else if (children == null) { childFlags = ChildrenFlags.NO_CHILDREN // 如果 children 不是数组，而且是单个子节点 } else if (children._isVNode) { childFlags = ChildrenFlags.SINGLE_VNODE // 如果 children 不满足以上任何条件，则会把 children 作为纯文本节点的文本内容处理 // 即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode } else { childFlags = ChildrenFlags.SINGLE_VNODE children = createTextVNode(children + '') } /** * * 这里有个需要注意的地方 * 以上用于确定 childFlags 的代码仅限于非组件类型的 VNode，因为对于组件类型的 VNode 来说，它并没有子节点 * 所有子节点都应该作为 slots 存在，所以如果使用 h 函数创建一个组件类型的 VNode * 那么我们应该把 children 的内容转化为 slots，然后再把 children 置为 null * 后续会进行介绍 * */ // 返回 VNode 对象 return { _isVNode: true, flags, tag, data, // 如果 VNodeData 中存在 key 属性，则我们会把其添加到 VNode 对象本身 // 这个属性将在后面用来在 diff 算法当中保持映射关系 key: data &amp;&amp; data.key ? data.key : null, children, childFlags, el: null }}// 序列化 class（针对 class 是字符串，数组或对象单独进行处理）function normalizeClass(classValue) { let res = '' if (typeof classValue === 'string') { res = classValue } else if (Array.isArray(classValue)) { for (let i = 0; i &lt; classValue.length; i++) { res += normalizeClass(classValue[i]) + ' ' } } else if (typeof classValue === 'object') { for (const name in classValue) { if (classValue[name]) { res += name + ' ' } } } return res.trim()}// 手动添加 keyfunction normalizeVNodes(children) { const newChildren = [] // 遍历 children for (let i = 0; i &lt; children.length; i++) { const child = children[i] if (child.key == null) { // 如果原来的 VNode 没有 key，则使用竖线（|）与该 VNode 在数组中的索引拼接而成的字符串作为 key child.key = '|' + i } newChildren.push(child) } // 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES return newChildren}// 创建文本节点function createTextVNode(text) { return { _isVNode: true, // flags 是 VNodeFlags.TEXT flags: VNodeFlags.TEXT, tag: null, data: null, // 纯文本类型的 VNode，其 children 属性存储的是与之相符的文本内容 children: text, // 文本节点没有子节点 childFlags: ChildrenFlags.NO_CHILDREN }} 使用 h 函数来创建 VNode最后我们来看一些使用 h 函数的实际效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// 模版&lt;template&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;// 使用const elementVNode = h('div', null, h('span'))// 生成的 VNode 对象const elementVNode = { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'div', data: null, children: { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'span', data: null, children: null, childFlags: 1, // ChildrenFlags.NO_CHILDREN el: null }, childFlags: 2, // ChildrenFlags.SINGLE_VNODE el: null}// ===============================================================// ===============================================================// 模版&lt;template&gt; &lt;div&gt;我是文本&lt;/div&gt;&lt;/template&gt;// 使用const elementWithTextVNode = h('div', null, '我是文本')// 生成的 VNode 对象const elementWithTextVNode = { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'div', data: null, children: { _isVNode: true, flags: 64, // VNodeFlags.TEXT tag: null, data: null, children: '我是文本', childFlags: 1, // ChildrenFlags.NO_CHILDREN el: null }, childFlags: 2, // ChildrenFlags.SINGLE_VNODE el: null}// ===============================================================// ===============================================================// 模版&lt;template&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/template&gt;// 使用const fragmentVNode = h(Fragment, null, [ h('td'), h('td') ])// 生成的 VNode 对象const fragmentVNode = { _isVNode: true, flags: 128, // VNodeFlags.FRAGMENT data: null, children: [ { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'td', data: null, children: null, childFlags: 1, // ChildrenFlags.NO_CHILDREN key: '|0', // 自动生成的 key（可以发现，children 数组中的每一个 VNode 都自动添加了 key 属性） el: null }, { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'td', data: null, children: null, childFlags: 1, // ChildrenFlags.NO_CHILDREN key: '|1', // 自动生成的 key el: null } ], childFlags: 4, // ChildrenFlags.KEYED_VNODES el: null}// ===============================================================// ===============================================================// 模版&lt;template&gt; &lt;Portal target=\"#box\"&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/Portal&gt;&lt;/template&gt;// 使用const portalVNode = h(Portal, { target: '#box' }, h('h1'))// 生成的 VNode 对象const portalVNode = { _isVNode: true, flags: 256, // VNodeFlags.PORTAL tag: '#box', // 类型为 Portal 的 VNode，其 tag 属性值等于 data.target data: { target: '#box' }, children: { _isVNode: true, flags: 1, // VNodeFlags.ELEMENT_HTML tag: 'h1', data: null, children: null, childFlags: 1, // ChildrenFlags.NO_CHILDREN el: null }, childFlags: 2, // ChildrenFlags.SINGLE_VNODE el: null}// ===============================================================// ===============================================================// 模版（该模板中包含了一个函数式组件，并为该组件提供了一个空的 div 标签作为默认的插槽内容）&lt;template&gt; &lt;MyFunctionalComponent&gt; &lt;div&gt;&lt;/div&gt; &lt;/MyFunctionalComponent&gt;&lt;/template&gt;// 使用（一个函数式组件）function MyFunctionalComponent() {}// 传递给 h 函数的第一个参数就是组件函数本身const functionalComponentVNode = h(MyFunctionalComponent, null, h('div'))// 生成的 VNode 对象// 暂且这样设计，等到后续涉及到插槽内容的时候再来细说// 为什么我们不使用 children 属性来存储插槽内容，以及我们应该如何使用 VNode 来描述插槽const functionalComponentVNode = { _isVNode: true, flags: 32, // VNodeFlags.COMPONENT_FUNCTIONAL tag: MyFunctionalComponent, // tag 属性值引用组件函数 data: null, children: { _isVNode: true, flags: 1, tag: 'div', data: null, children: null, childFlags: 1, el: null }, childFlags: 2, // ChildrenFlags.SINGLE_VNODE el: null}// ===============================================================// ===============================================================// 模版（有状态组件应该继承 Component）class MyStatefulComponent extends Component {}// 使用const statefulComponentVNode = h(MyStatefulComponent, null, h('div'))// 生成的 VNode 对象const statefulComponentVNode = { _isVNode: true, // VNodeFlags.COMPONENT_STATEFUL_NORMAL // 这里需要注意，只有当组件的原型上拥有 render 函数时才会把它当作有状态组件 flags: 4, data: null, children: { _isVNode: true, flags: 1, tag: 'div', data: null, children: null, childFlags: 1, el: null }, childFlags: 2, el: null} 现在，我们的 h 函数已经可以创建任何类型的 VNode 对象了，有了 VNode 对象，我们下一步要做的就是将 VNode 对象渲染成真实 DOM 参考如果想了解更多的相关内容，可以参考以下链接 深度剖析如何实现一个 Virtual DOM 算法 Diff Strategies React 源码深度解读 Vitual DOM 的内部工作原理 深入理解 React 中的虚拟 DOM 和 Diff 算法 解析 Snabbdom 源码 React 源码剖析系列 － 不可思议的 React Diff React Diff 算法 A Survey on Tree Edit Distance and Related（这一篇是介绍标准的 Diff 算法，其复杂度为 O(n ^ 3)）","link":"/2019/12/15/React/06/"},{"title":"Egg.js 实战（实现一个接口服务）","text":"在之前我们已经了解过 Node.js 和 Koa.js 的一些相关知识，今天我们来看看如何使用 Egg.js 来实现一个接口服务，Egg.js 是一个基于 Koa.js 框架而实现的框架，所以它应当属于框架之上的框架，它继承了 Koa.js 的高性能优点，同时又加入了一些『约束与开发规范』，来规避 Koa.js 框架本身的开发自由度太高的问题 Koa.js 是一个比较基层的框架，它本身没有太多约束与规范，自由度非常高，每一个开发者实现自己的服务的时候，代码风格都可以能不太一样，而 Egg.js 为了适应企业开发，加了一些开发时的规范与约束，从而解决 Koa.js 这种自由度过高而导致不适合企业内使用的缺点，Egg.js 便在这种背景下诞生，关于 Egg.js 更多的特性，这里我们只做简单介绍，更多的可以参考官网 egg.js 需求需求比较简单，只需要实现一个接口服务即可，简单来说就是实现一个连接数据库，查询数据库里的数据并且提供一个 HTTP 接口服务，下面我们来看看如何实现 实现首先安装 Egg.js，根据官方文档提供的方法即可 12345$ npm init egg --type=simple$ npm i$ npm run dev 但是这里有一个需要注意的地方，如果想要使用 npm init egg 命令，npm 的版本需要 &gt;= 6.1.0 启动成功以后，我们先来建立一张表，用于我们的后续操作，使用的 SQL 如下 12345678910111213141516171819CREATE TABLE `Tab_User_Info` ( id INT(100) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL COMMENT '姓名', uid VARCHAR(50) NOT NULL, sex tinyint(2) DEFAULT 1 COMMENT '1男2女', age tinyint(2) DEFAULT 1, description VARCHAR(50) DEFAULT NULL, `createdAt` datetime DEFAULT CURRENT_TIMESTAMP, `updatedAt` datetime DEFAULT CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT = 'test user';INSERT INTO Tab_User_Info (`name`, uid, sex, age, description) VALUES ('zhangsan', 'uid123', 1, 24, 'this is boy'), ('lisi', 'uid124', 2, 24, 'this is girl'), ('wangwu', 'uid125', 1, 26, 'this is test user'), ('zhaoliu', 'uid126', 2, 44, 'this is test user5'), ('test01', 'uid127', 2, 64, 'this is test user4'), ('test02', 'uid128', 1, 14, 'this is test user2'), ('test03', 'uid129', 2, 4, 'this is test user9'); 完成后结果如下 123456789101112131415161718192021222324252627282930313233mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || test |+--------------------+2 rows in set (0.00 sec)mysql&gt; use test;Database changedmysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| tab_user_info |+----------------+1 row in set (0.00 sec)mysql&gt; select * from tab_user_info;+----+----------+--------+------+------+--------------------+---------------------+---------------------+| id | name | uid | sex | age | description | createdAt | updatedAt |+----+----------+--------+------+------+--------------------+---------------------+---------------------+| 1 | zhangsan | uid123 | 1 | 24 | this is boy | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 2 | lisi | uid124 | 2 | 24 | this is girl | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 3 | wangwu | uid125 | 1 | 26 | this is test user | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 4 | zhaoliu | uid126 | 2 | 44 | this is test user5 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 5 | test01 | uid127 | 2 | 64 | this is test user4 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 6 | test02 | uid128 | 1 | 14 | this is test user2 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 || 7 | test03 | uid129 | 2 | 4 | this is test user9 | 2019-11-12 17:51:38 | 2019-11-12 17:51:38 |+----+----------+--------+------+------+--------------------+---------------------+---------------------+7 rows in set (0.00 sec) 连接数据库首先安装 mysql 插件 egg-mysql 1$ npm install egg-mysql --save 接下来修改目录下的配置文件，开启 mysql 插件，更多的配置参数可以参考官方文档 egg-mysql 12345678910111213141516171819202122232425262728// app/config/plugin.jsmodule.exports = { mysql: { enable: true, package: 'egg-mysql', },};// app/config/config.default.jsconst mysql = { // 单数据库信息配置 client: { host: '127.0.0.1', port: '3306', user: 'root', password: '', database: 'test', }, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,};return { mysql}; 路由然后再来实现路由 1234567// app/router.jsmodule.exports = app =&gt; { const { router, controller } = app router.get('/', controller.home.index) router.get('/user/list', controller.user.list) router.get('/user/find', controller.user.find)} 服务然后我们来添加两个服务，一个 searchAll() 方法和一个 find(id) 方法 123456789101112131415161718// app/service/user.js'use strict'const Service = require('egg').Serviceclass UserService extends Service { async searchAll() { const users = await this.app.mysql.select('tab_user_info') return { users } } async find(id) { const user = await this.app.mysql.get('tab_user_info', { id }) return { user } }}module.exports = UserService 控制器我们之前设定了两个服务，现在就建立一个对应的控制器来进行使用 1234567891011121314151617181920212223242526272829303132333435363738394041// app/controller/user.js'use strict'const Controller = require('egg').Controllerclass UserController extends Controller { async list() { const { ctx } = this try { const userList = await ctx.service.user.searchAll() ctx.body = { success: true, data: userList, } } catch (error) { ctx.body = { success: false, error, } } } async find() { const { ctx } = this try { if (!ctx.query.id) throw new Error('缺少参数') const userList = await ctx.service.user.find(ctx.query.id) ctx.body = { success: true, data: userList, } } catch (error) { ctx.body = { success: false, error, } } }}module.exports = UserController 验证下面我们就可以在浏览器当中访问 http://127.0.0.1:7001/user/list 来访问我们的接口，可以发现已经将数据库当中所有的列表信息展示了出来，如果想针对单独的 id 进行查询，只需要访问 find 接口，然后传递参数即可，例如 http://127.0.0.1:7001/user/find?id=7 逻辑很简单，当路由匹配到我们对应访问的地址的时候（/user/list）就回去调用我们对应的控制器（controller.user.list），然后在控制器当中又回去访问我们之前定义的服务来进行数据库的数据查询 相关问题汇总本节主要记录在学习 Egg.js 相关知识的时候遇到的一些坑或者知识点 query &amp;&amp; queries在 url 中的 ? 后面的部分是一个 Query String，这一部分经常用于 GET 类型的请求中传递参数，例如 GET /search?name=zhangsan&amp;age=18 中 name=zhangsan&amp;age=18 就是用户传递过来的参数，Egg.js 已经帮我们封装好了获取方式，所以我们可以直接通过 this.ctx.query 来拿到解析过后的这个参数体 12345678910111213'use strict'const Controller = require('egg').Controllerclass NewsController extends Controller { async index() { const query = this.ctx.query console.log(query.age) // 18 console.log(query) // { name: 'zhangsan', age: '18' } }}module.exports = NewsController 不过这样的使用方式上有一点需要注意的地方 当 Query String 中的 key 重复时，this.ctx.query 只会取 key 第一次出现时的值，后面再出现的都会被忽略，比如 GET /search?name=zhangsan&amp;name=lisi 通过 this.ctx.query 拿到的值是 { name: 'zhangsan' } 但是有时候用户会传递相同的 key，例如 GET /search?name=zhangsan&amp;id=123&amp;id=456，针对此类情况，框架提供了 this.ctx.queries 对象，这个对象也解析了 Query String，但是它不会丢弃任何一个重复的数据，而是将他们都放到一个数组中 12345678910111213141516'use strict'const Controller = require('egg').Controllerclass NewsController extends Controller { async index() { // GET /search?name=zhangsan&amp;id=123&amp;id=456 console.log(this.ctx.queries) // { // name: ['zhangsan'], // id: ['123', '456'], // } }}module.exports = NewsController this.ctx.queries 上所有的 key 如果有值，也一定会是数组类型 helperhelper 函数用来提供一些实用的工具函数，它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，下面来看一个比较常见的实例，序列化模版引擎当中的日期格式，我们先在 helper.js 当中定义我们格式化的方法 这里有个需要注意的地方，定义的文件名字需要是一致的，因为框架会把 app/extend/helper.js 中定义的对象与内置 helper 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 helper 对象，这里使用的是 silly-datetime 这个日期库，使用其他的也是可行的 12345678910// app/extend/helper.js'use strict'const sd = require('silly-datetime')module.exports = { formatTime(time) { return sd.format(new Date(time * 1000), 'YYYY-MM-DD HH:mm') },} 然后在模版当中不需要引入之类的操作，直接使用即可（helper.formatTime()） 12345678&lt;!-- app/view/news.html --&gt;&lt;ul&gt; &lt;% for (var i = 0; i &lt; list.length; i++) {%&gt; &lt;li&gt; &lt;a href=\"/newscontent?aid=&lt;%= list[i].aid %&gt;\"&gt;&lt;%= list[i].title %&gt;&lt;/a&gt; --- &lt;span&gt;&lt;%= helper.formatTime(list[i].datetime) %&gt;&lt;/span&gt; &lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt; 跨域请求设置可以使用 egg-cors 这个库，先配置 plugin.js 12345// config/plugin.jsexports.cors = { enable: true, package: 'egg-cors',} 然后在配置 config.default.js 123456789101112131415// config/config.default.jsconfig.security = { csrf: { enable: false, ignoreJSON: true, }, // 配置白名单 domainWhiteList: ['http://www.baidu.com'],}config.cors = { // 允许所有跨域访问，如果注释掉则允许上面 白名单 访问 // origin: '*', allowMethods: 'GET, HEAD, PUT, POST, DELETE, PATCH',} 不要使用全部允许跨域，可能会引起安全方面的问题，建议配置访问白名单（注释掉 origin 即可） 使用 koa 的中间件在框架里面可以非常容易的引入 Koa 中间件生态，以 koa-compress 为例，在 Koa 中使用时 1234567const koa = require('koa')const compress = require('koa-compress')const app = koa()const options = { threshold: 2048 }app.use(compress(options)) 在 Egg.js 当中使用如下 12// app/middleware/compress.jsmodule.exports = require('koa-compress') 一个需要注意的地方，koa-compress 暴露的接口（(options) =&gt; middleware）和框架对中间件要求一致，配置中间件 1234567// config/config.default.jsmodule.exports = { middleware: ['compress'], compress: { threshold: 2048, },} 表单内容的获取先来看如下代码 123456789// app/router.jsmodule.exports = app =&gt; { app.router.post('/form', app.controller.form.post)}// app/controller/form.jsexports.post = async ctx =&gt; { ctx.body = `body: ${JSON.stringify(ctx.request.body)}`} 这里如果直接发起 POST 请求是会报错的，错误提示为 missing csrf token，简单来说，因为框架中内置了安全插件 egg-security，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可 123exports.security = { csrf: false} 路由重定向内部重定向 1234567891011// app/router.jsmodule.exports = app =&gt; { app.router.get('index', '/home/index', app.controller.home.index) // 访问根目录自动重定向到 /home/index app.router.redirect('/', '/home/index', 303)}// app/controller/home.jsexports.index = async ctx =&gt; { ctx.body = 'hello controller'} 外部重定向 12345678910exports.index = async ctx =&gt; { const type = ctx.query.type const q = ctx.query.q || 'nodejs' if (type === 'bing') { ctx.redirect(`http://cn.bing.com/search?q=${q}`) } else { ctx.redirect(`https://www.google.co.kr/search?q=${q}`) }} 自定义控制器基类12345678910111213141516171819202122// app/core/base_controller.jsconst { Controller } = require('egg')class BaseController extends Controller { get user() { return this.ctx.session.user } success(data) { this.ctx.body = { success: true, data, } } notFound(msg) { msg = msg || 'not found' this.ctx.throw(404, msg) }}module.exports = BaseController 此时在编写应用的 Controller 时，可以继承 BaseController，直接使用基类上的方法 1234567891011//app/controller/post.jsconst Controller = require('../core/base_controller')class PostController extends Controller { async list() { const posts = await this.service.listByUser(this.user) // 使用基类的方法 this.success(posts) }} 文件上传一般来说，浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件，首先需要在 config 文件中启用 file 模式 1234// config/config.default.jsexports.multipart = { mode: 'file',} 然后就可以进行使用了，这里主要分为两种情况，上传单个文件和上传多个文件，我们先来看单文件情况 12345&lt;form method=\"POST\" action=\"/upload?_csrf={{ ctx.csrf | safe }}\" enctype=\"multipart/form-data\"&gt; title: &lt;input name=\"title\" /&gt; file: &lt;input name=\"file\" type=\"file\" /&gt; &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;&lt;/form&gt; 12345678910111213141516171819202122232425// app/controller/upload.jsconst Controller = require('egg').Controllerconst fs = require('mz/fs')module.exports = class extends Controller { async upload() { const { ctx } = this const file = ctx.request.files[0] const name = 'egg-multipart-test/' + path.basename(file.filename) let result try { // 处理文件，比如上传到云端 result = await ctx.oss.put(name, file.filepath) } finally { // 需要删除临时文件 await fs.unlink(file.filepath) } ctx.body = { url: result.url, // 获取所有的字段值 requestBody: ctx.request.body, } }} 对于多个文件，我们借助 ctx.request.files 属性进行遍历，然后分别进行处理，HTML 还是一样的，不过添加了可接受多个值的文件上传字段 multiple，这里主要来看后端是如何处理的 123456789101112131415161718192021222324252627282930// app/controller/upload.jsconst Controller = require('egg').Controllerconst fs = require('mz/fs')module.exports = class extends Controller { async upload() { const { ctx } = this console.log(ctx.request.body) console.log('got %d files', ctx.request.files.length) for (const file of ctx.request.files) { console.log('field: ' + file.fieldname) console.log('filename: ' + file.filename) console.log('encoding: ' + file.encoding) console.log('mime: ' + file.mime) console.log('tmp filepath: ' + file.filepath) let result try { // 处理文件，比如上传到云端 result = await ctx.oss.put('egg-multipart-test/' + file.filename, file.filepath) } finally { // 需要删除临时文件 await fs.unlink(file.filepath) } console.log(result) } }} 但是这里有个需要注意的地方，为了保证文件上传的安全，框架限制了支持的的文件格式，框架默认支持白名单如下 12345678910111213141516171819202122232425const whitelist = [ // images '.jpg', '.jpeg', // image/jpeg '.png', // image/png, image/x-png '.gif', // image/gif '.bmp', // image/bmp '.wbmp', // image/vnd.wap.wbmp '.webp', '.tif', '.psd', // text '.svg', '.js', '.jsx', '.json', '.css', '.less', '.html', '.htm', '.xml', // tar '.zip', '.gz', '.tgz', '.gzip', // video '.mp3', '.mp4', '.avi',] 但是我们可以通过在 config/config.default.js 中配置来新增支持的文件扩展名 1234567// 新增支持的文件扩展名module.exports = { multipart: { // 增加对 apk 扩展名的文件支持 fileExtensions: ['.apk'] },} 或者重写整个白名单 123456// 覆盖整个白名单，只允许上传 '.png' 格式module.exports = { multipart: { whitelist: ['.png'], },} 更多详细可以参考文档 egg-multipart 服务（service）注意事项，service 文件必须放在 app/service 目录，可以支持多级目录，访问的时候可以通过目录名级联访问 123app/service/biz/user.js ==&gt; ctx.service.biz.user // 多级目录，依据目录名级联访问app/service/sync_user.js ==&gt; ctx.service.syncUser // 下划线自动转换为自动驼峰app/service/HackerNews.js ==&gt; ctx.service.hackerNews // 大写自动转换为驼峰 一个 service 文件只能包含一个类，这个类需要通过 module.exports 的方式返回 service 需要通过 class 的方式定义，父类必须是 egg.service service 不是单例，是『请求级别』的对象，框架在每次请求中首次访问 ctx.service.xx 时延迟实例化，所以 service 中可以通过 this.ctx 获取到当前请求的上下文 下面是一个实际的使用例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344// app/controller/user.jsconst Controller = require('egg').Controllerclass UserController extends Controller { async info() { const userId = this.ctx.params.id const userInfo = await this.ctx.service.user.find(userId) this.ctx.body = userInfo }}module.exports = UserController// app/service/user.jsconst Service = require('egg').Serviceclass UserService extends Service { // 默认不需要提供构造函数，如果需要在构造函数做一些处理，需要调用 super(ctx) 才能保证后面 this.ctx 的使用 // 调用之后就可以直接通过 this.ctx 获取 ctx 和通过 this.app 获取 app 了 // constructor(ctx) { // super(ctx) // } async find(uid) { // 假如 我们拿到用户 id 从数据库获取用户详细信息 const user = await this.ctx.db.query('select * from user where uid = ?', uid) // 假定这里还有一些复杂的计算，然后返回需要的信息。 const picture = await this.getPicture(uid) return { name: user.user_name, age: user.age, picture, } } async getPicture(uid) { const result = await this.ctx.curl(`http://photoserver/uid=${uid}`, { dataType: 'json' }) return result.data }}module.exports = UserService 属性扩展一般来说属性的计算只需要进行一次，那么一定要实现缓存，否则在多次访问属性时会计算多次，这样会降低应用性能，推荐的方式是使用 Symbol + Getter 的模式 12345678910111213// app/extend/application.jsconst BAR = Symbol('Application#bar')module.exports = { get bar() { // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性 if (!this[BAR]) { // 实际情况肯定更复杂 this[BAR] = this.config.xx + this.config.yy } return this[BAR] },} session 存储框架内置了 egg-session 插件，给我们提供了 ctx.session 来访问或者修改当前用户 Session 1234567891011121314class HomeController extends Controller { async fetchPosts() { const ctx = this.ctx // 获取 Session 上的内容 const userId = ctx.session.userId const posts = await ctx.service.post.fetch(userId) // 修改 Session 的值 ctx.session.visited = ctx.session.visited ? (ctx.session.visited + 1) : 1 ctx.body = { success: true, posts, } }} 但是有一个特别需要注意的地方，在设置 Session 属性时需要避免以下几种情况，因为会造成字段丢失（koa-session） 不要以 _ 开头 不能为 isNew 123456// ❌ 错误的用法ctx.session._visited = 1 // ==&gt; 该字段会在下一次请求时丢失ctx.session.isNew = 'lisi' // ==&gt; 为内部关键字, 不应该去更改// ✔️ 正确的用法ctx.session.visited = 1 // ==&gt; 此处没有问题 Session 默认存放在 Cookie 中，但是如果我们的 Session 对象过于庞大，就会带来一些额外的问题 浏览器通常都有限制最大的 Cookie 长度，当设置的 Session 过大时，浏览器可能拒绝保存 Cookie 在每次请求时都会带上，当 Session 过大时，每次请求都要额外带上庞大的 Cookie 信息 我们只需要设置 app.sessionStore 即可将 Session 存储到指定的存储中 123456789101112131415// app.jsmodule.exports = app =&gt; { app.sessionStore = { // support promise/async async get(key) { // return value }, async set(key, value, maxAge) { // set key to store }, async destroy(key) { // destroy key }, }} sessionStore 的实现我们也可以封装到插件中，例如 egg-session-redis 就提供了将 Session 存储到 redis 中的能力，在应用层我们只需要引入 egg-redis 和 egg-session-redis 插件即可 12345678910// plugin.jsexports.redis = { enable: true, package: 'egg-redis',}exports.sessionRedis = { enable: true, package: 'egg-session-redis',} 但是需要注意的是，一旦选择了将 Session 存入到外部存储中，就意味着系统将强依赖于这个外部存储，当它挂了的时候，就完全无法使用 Session 相关的功能了，因此更推荐只将必要的信息存储在 Session 中，保持 Session 的精简并使用默认的 Cookie 存储，用户级别的缓存不要存储在 Session 中 egg-jwt本章节主要介绍使用 egg 验证 Token 的过程，首先初始化一个项目，然后安装两个用于我们之后操作所使用的包 123456// 使用 ts 版本npm init egg --type=tsnpm install // 安装跨域包以及 token 的生成以及验证包npm install egg-cors egg-jwt --save 安装完成后首先来配置 config/plugin.ts 当中的两个验证包 1234567891011121314import { EggPlugin } from 'egg'const plugin: EggPlugin = { jwt: { enable: true, package: \"egg-jwt\" }, cors: { enable: true, package: 'egg-cors', }}export default plugin 接下来是 config/config.default.ts 123456789101112131415161718config.jwt = { //自定义 token 的加密条件字符串 secret: 'abc'}config.security = { csrf: { enable: false, ignoreJSON: true }, // 允许访问接口的白名单 domainWhiteList: ['http://localhost:8080'],}config.cors = { origin: '*', allowMethods: 'GET, HEAD, PUT, POST, DELETE, PATCH'} 最后一步操作，也是 TypeScript 独有的坑，需要在根目录下的 typings/index.d.ts 文件里声明一个 any 类型，否则会类型错误 1234567import 'egg'declare module 'egg' { interface Application { jwt: any }} 下面就是具体操作流程，首先来定义路由 123456789101112131415// app/router.tsimport { Application } from 'egg'export default (app: Application) =&gt; { const { controller, router, jwt } = app // 正常路由 router.post('/admin/login', controller.admin.login) /* * 这里的第二个对象不再是控制器，而是 jwt 验证对象，第三个地方才是控制器 * 只有在需要验证 token 的路由才需要第二个 是 jwt 否则第二个对象为控制器 『/ router.post('/admin', jwt, controller.admin.index)} 接下来就是设定控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { Controller } from 'egg'export default class AdminController extends Controller { // 验证登录并且生成 token public async login() { const { ctx, app } = this // 获取用户端传递过来的参数 const data = ctx.request.body // 进行验证 data 数据 登录是否成功 // ... // 成功过后进行一下操作 // 生成 token 的方式 const token = app.jwt.sign({ // 需要存储的 token 数据 username: data.username, // ... }, app.config.jwt.secret) // 生成的token = eyJhbGciOiJIUzI1... // 返回 token 到前端 ctx.body = token } // 访问 admin 数据时进行验证 token，并且解析 token 的数据 public async index() { const { ctx, app } = this console.log(ctx.state.user) /* * 打印内容为：{ username : 'admin', iat: 1560346903 } * iat 为过期时间，可以单独写中间件验证，这里不做细究 * 除了 iat 之后，其余的为当时存储的数据 『/ ctx.body = { code: 0, msg: '验证成功' } }} 最后前端在请求的时候需要在 headers 里面上添加上默认的验证字断 Authorization 就可以了 1234567891011121314axios({ method: 'post', url: 'http://127.0.0.1:7001/admin', data: { username: 'admin', lastName: '123456' }, headers: { // 切记 token 不要直接发送，要在前面加上 Bearer 字符串和一个空格 'Authorization': `Bearer ${token}` }}).then(res =&gt; { console.log(res.data)})","link":"/2019/11/01/Node/15/"},{"title":"Node.js 中的 EventEmitter 模块","text":"本章我们继续来看 Node.js 当中的 EventEmitter 模块，在 Node.js 当中许多对象都会分发事件，比如一个 net.Server 对象会在每次有新连接时触发一个事件，一个 fs.readStream 对象会在文件被打开的时候触发一个事件，然而所有这些产生事件的对象都是 events.EventEmitter 的实例 本文主要分为以下几个部分，首先先介绍一下 EventEmitter 类，然后简单的过一遍源码，最后在自己动手来实现一个简单的 EventEmitter 模块，下面就让我们一步一步来实现吧 EventEmitter 类events 模块只提供了一个对象 events.EventEmitter，其核心就是事件触发与事件监听器功能的封装，可以通过 require('events') 来访问该模块，如下 12345// 引入 events 模块var events = require('events')// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter() EventEmitter 对象如果在实例化时发生错误，会触发 error 事件， 关于 EventEmitter 里面的 error 事件有一点需要注意的地方，EventEmitter 即使绑定了 error 事件也是不会输出的，而是会在控制台打印该异常的堆栈信息，并结束进程 如下 123eventEmitter.on('error', function (err) { console.error('Error:', err)}) 经过测试可以发现，绑定 error 事件只能自己触发，比如使用 eventEmitter.emit('error')，当没有错误时，会在控制台打印 Error：undefined，而当有错误时不会打印而是直接打印该异常的堆栈信息，并结束进程 如果想要获取异常只能通过 try catch，更多关于 EventEmitter 模块的异常处理可见 EventEmitter 模块的异常处理 当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发（这两个是 Node.js 的 EventEmitter 模块自带的特殊事件） 以上就是 EventEmitter 的简单使用方式，但是在深入了解 EventEmitter 之前，我们先来了解一些前置知识 观察者模式源码部分主要参考的是 深入 EventEmitter 观察者模式是 软件设计模式 的一种，在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知，这通常透过呼叫各观察者所提供的方法来实现，此种模式通常被用来实时事件处理系统 —— 维基百科 EventEmitter 本质上是一个观察者模式的实现，所谓观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己，我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念，期刊订阅包含两个主要的角色，期刊出版方和订阅者，它们之间的关系如下 期刊出版方，负责期刊的出版和发行工作 订阅者，只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知 在观察者模式中也有两个主要角色，观察者和被观察者，它们之间的关系图如下 观察者模式的优点是支持简单的广播通信，自动通知所有已经订阅过的对象，并且目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用，但是一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 下面我们来看一个观察者模式的应用，最为常见的例子就是为 DOM 对象添加事件监听，如下 1&lt;button id=\"btn\"&gt;确认&lt;/button&gt; 12345function clickHandler(event) { console.log('按钮已点击!')}document.getElementById('btn').addEventListener('click', clickHandler) 当按钮在点击当同时会触发我们事先绑定好的事件 clickHandler，会在控制台打印出 按钮已点击! 字样 发布/订阅模式 在 软件架构 中，发布/订阅模式是一种 消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者），而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在，同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在，—— 维基百科 发布/订阅模式与观察者模式非常类似，它们最大的区别是 发布者和订阅者不知道对方的存在 它们之间需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息 发布/订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在 那么信息中介是如何过滤消息呢？在发布/订阅模型中，订阅者通常接收所有发布的消息的一个子集，选择接受和处理的消息的过程被称作过滤，有两种常用的过滤形式，基于主题的和基于内容的 在『基于主题』的系统中，消息被发布到主题或命名通道上，订阅者将收到其订阅的主题上的所有消息，并且所有订阅同一主题的订阅者将接收到同样的消息，发布者负责定义订阅者所订阅的消息类别 在『基于内容』的系统中，订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者，订阅者需要负责对消息进行分类 一些系统支持两者的混合，即发布者发布消息到主题上，而订阅者将基于内容的订阅注册到一个或多个主题上，基于主题的通信基础结构图如下 最后我们再来总结一下观察者模式与发布/订阅模式之间的区别 观察者模式 VS 发布/订阅模式 根据图片可知，两者的区别如下 在观察者模式中，观察者知道 Subject 的存在，Subject 一直保持对观察者进行记录，然而，在发布/订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过信息中介进行通信 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反 观察者模式大多数时候是同步的，比如当事件触发 Subject 就会去调用观察者的方法，而发布/订阅模式大多数时候是异步的（使用消息队列） 在大致了解了以上内容之后，下面我们就来正式的看一看 Node.js 当中的 EventEmitter 模块 EventEmitter 模块在 Node.js 当中，大多数的核心 API 都采用惯用的异步事件驱动架构，所有能触发事件的对象都是 EventEmitter 类的实例，这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上，当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用， 监听器的返回值会被丢弃，本文主要介绍以下几个核心方法 on(event, listener) 为指定事件添加一个监听器到监听器数组的尾部（还有一个 addListener 方法，本质与 on 是一致的，见下方） emit(event, [arg1], [arg2], [...]) 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器 removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，它接受两个参数，第一个是事件名称，第二个是回调函数名称 EventEmitter 基本使用我们首先先来看一个最基本的 EventEmitter 功能，包含了一个观察者和一个被监听的对象，对应的实现就是 EventEmitter 中的 on 和 emit 1234567891011const EventEmitter = require('events')class MyEmitter extends EventEmitter { }const myEmitter = new MyEmitter()myEmitter.on('event', () =&gt; { console.log('触发了一个事件！')})myEmitter.emit('event') 我们自定义 MyEmitter 类，该类继承于 EventEmitter 类，接着我们通过使用 new 关键字创建了 myEmitter 实例，然后使用 on() 方法监听 event 事件，最后利用 emit() 方法触发 event 事件 EventEmitter 构造函数源码可见 EventEmitter.init.call(this)，如下 123456789function EventEmitter() { EventEmitter.init.call(this)}EventEmitter.usingDomains = falseEventEmitter.prototype._events = undefined // 事件对象（保存指定的事件类型与对应的监听器）EventEmitter.prototype._eventsCount = 0 // 事件数EventEmitter.prototype._maxListeners = undefined // 最大的监听器数 在 EventEmitter 构造函数内部，会调用 EventEmitter.init 方法执行初始化操作，EventEmitter.init 的具体实现如下 1234567EventEmitter.init = function () { if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) { this._events = Object.create(null) this._eventsCount = 0 } this._maxListeners = this._maxListeners || undefined} 在 EventEmitter.init 内部，会根据条件执行初始化操作，这里有一个比较重要的操作 this._events = Object.create(null)，那么问题来了，为什么要使用 Object.create(null) 来初始化一个新对象而不用更简洁的 {} 呢？简单来说，两者的区别可见下图所示 对比可以发现，使用 create 创建的对象，没有任何属性，可以把它当作一个非常纯净的 map 来使用，可以自己定义 hasOwnProperty、toString 方法而不必担心会将原型链上的同名方法覆盖掉 on()源码可见 EventEmitter.prototype.addListener，如下 12345EventEmitter.prototype.addListener = function addListener(type, listener) { return _addListener(this, type, listener, false)}EventEmitter.prototype.on = EventEmitter.prototype.addListener 通过源码可以发现，其实 EventEmitter 实例上的 addListener 和 on 方法均是调用的 _addListener() 方法，下面我们就来看看 _addListener 的具体实现（这里只截取了一些主要实现部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 接收四个参数，依次为// target EventEmitter 实例// type 事件类型// listener 事件监听器// prepend 是否添加在前面function _addListener(target, type, listener, prepend) { var m var events var existing // 这个方式是用于检查监听器是否为函数，如果不是就抛出一个错误 checkListener(listener) events = target._events // 如果未定义，则使用 Object.create(null) 创建一个纯粹的空对象 if (events === undefined) { events = target._events = Object.create(null) target._eventsCount = 0 } else { // To avoid recursion in the case that type === \"newListener\"! Before // adding it to the listeners, first emit \"newListener\". if (events.newListener !== undefined) { target.emit('newListener', type, listener.listener ? listener.listener : listener) // Re-assign `events` because a newListener handler could have caused the // this._events to be assigned to a new object events = target._events } existing = events[type] } if (existing === undefined) { // Optimize the case of one listener. Don't need the extra array object. events[type] = listener ++target._eventsCount } else { if (typeof existing === 'function') { // Adding the second element, need to change to array. existing = events[type] = prepend ? [listener, existing] : [existing, listener] // If we've already got an array, just append. } else if (prepend) { existing.unshift(listener) } else { existing.push(listener) } // Check for listener leak m = _getMaxListeners(target) if (m &gt; 0 &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) { // ... } } return target} 简单的总结一下，主要流程为以下四个步骤 验证监听器是否为函数对象 避免类型为 newListener 的事件类型造成递归调用，优先触发 优化单个监听器的场景，不需使用额外的数组对象 基于 prepend 参数的值，控制监听器的添加顺序 emit()源码见 EventEmitter.prototype.emit，如下 12345678910111213141516171819202122EventEmitter.prototype.emit = function emit(type, ...args) { const events = this._events // 获取对应的处理器 const handler = events[type] if (handler === undefined) return false if (typeof handler === 'function') { apply(handler, this, args) } else { const len = handler.length // arrayClone 方法为一个数组浅拷贝方法 const listeners = arrayClone(handler, len) for (var i = 0; i &lt; len; ++i) apply(listeners[i], this, args) } return true} 剔除掉多余的部分以后可以发现，逻辑还是比较好理解的，先根据事件类型获取对应的处理器，然后根据事件处理器的类型，选择直接调用或者是循环调用 上面我们简单的介绍了 on() 和 emit() 两个方法，它们主要用来添加事件监听和触发事件监听，下面我们再来看看如何移除事件监听 removeListener()源码见 EventEmitter.prototype.emit，removeListener() 方法最多只会从监听器数组里移除一个监听器实例，如果任何单一的监听器被多次添加到指定 type 的监听器数组中，则必须多次调用 removeListener() 方法才能移除每个实例，为了方便一次性移除 type 对应的监听器，EventEmitter 为我们提供了 removeAllListeners() 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859EventEmitter.prototype.removeListener = function removeListener(type, listener) { let originalListener // 这个方式是用于检查监听器是否为函数，如果不是就抛出一个错误 checkListener(listener) const events = this._events if (events === undefined) return this const list = events[type] if (list === undefined) return this if (list === listener || list.listener === listener) { if (--this._eventsCount === 0) this._events = Object.create(null) else { delete events[type] // 如果设置了 removeListener 监听器，则触发 removeListener 事件 if (events.removeListener) this.emit('removeListener', type, list.listener || listener) } } else if (typeof list !== 'function') { let position = -1 // 获取需要移除的监听器的索引值 for (var i = list.length - 1; i &gt;= 0; i--) { if (list[i] === listener || list[i].listener === listener) { originalListener = list[i].listener position = i break } } if (position &lt; 0) return this if (position === 0) list.shift() else { if (spliceOne === undefined) spliceOne = require('internal/util').spliceOne // 关于这个方法，见下方 spliceOne(list, position) } if (list.length === 1) events[type] = list[0] if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener) } return this }EventEmitter.prototype.off = EventEmitter.prototype.removeListener 我们可以简单的梳理一下 removeListener() 方法，当我们在调用 removeListener() 方法时，若 type 事件类型上绑定多个事件处理器，那么内部处理程序会先根据 listener 事件处理器，查找该事件处理器对应的索引值，然后在根据索引值的不同再进行不同的处理 但是可以发现，在处理移除对应的事件处理器的时候使用了 spliceOne() 方法，那么为什么不直接利用 Array 的 splice() 方法呢？官方的回答是 spliceOne() 方法的执行速度比 Array#splice() 快大约 1.5 倍，实现如下 123456// About 1.5x faster than the two-arg version of Array#splice().function spliceOne(list, index) { for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1) list[i] = list[k] list.pop()} 大致原理是从需要删除的位置开始，依次将后一个元素与前一个元素的位置进行互换，在删除掉最后一项 最后我们来介绍一下 EventEmitter 另一个常用的方法 once() once()源码见 EventEmitter.prototype.once，如下 123456789101112131415161718192021222324252627function onceWrapper() { // 如果事件处理器未被调用，则先移除事件监听器并设置 fired 字段值为 true // 然后利用 apply() 方法调用 type 事件类型，对应的事件处理器 if (!this.fired) { this.target.removeListener(this.type, this.wrapFn) this.fired = true if (arguments.length === 0) return this.listener.call(this.target) return this.listener.apply(this.target, arguments) }}function _onceWrap(target, type, listener) { // 创建了一个 state 对象，该对象有一个 fired 属性，用来标识是否已触发，其默认值是 false const state = { fired: false, wrapFn: undefined, target, type, listener } const wrapped = onceWrapper.bind(state) wrapped.listener = listener state.wrapFn = wrapped return wrapped}EventEmitter.prototype.once = function once(type, listener) { checkListener(listener) this.on(type, _onceWrap(this, type, listener)) return this} 梳理后可以发现，once() 方法依次调用了 _onceWrap() 和 onceWrapper() 方法，使用 state 对象的 fired 属性，用来标识是否已触发 手动实现一个 EventEmitter 模块我们下面就来尝试着手动的实现一个 EventEmitter 模块，我们都知道，每一个 EventEmitter 实例都有一个包含所有事件的对象 _events，事件的监听和监听事件的触发，以及监听事件的移除等事件都是在这个 _events 对象的基础上实现，我们首先先成一个 EventEmitter 类，在类的初始化方法中生成这个事件对象 _events 123456789class EventEmitter { constructor() { if (this._events === undefined) { // 创建一个纯粹的空对象用于存放事件对象 this._events = Object.create(null) this._eventsCount = 0 } }} _eventsCount 用于统计事件的个数，也就是 _events 对象有多少个属性，下面我们来实现 emit 方法，emit 所做的事情是在 _events 对象中取出相应 type 的属性，并执行属性所对应的函数 12345678910111213141516171819202122class EventEmitter { constructor() { if (this._events === undefined) { // 创建一个纯粹的空对象用于存放事件对象 this._events = Object.create(null) this._eventsCount = 0 } } emit(type, ...args) { const events = this._events const handler = events[type] // 判断相应 type 的执行函数是否为一个函数还是一个数组 if (typeof handler === 'function') { Reflect.apply(handler, this, args) } else { for (var i = 0; i &lt; handler.length; i++) { Reflect.apply(handler[i], this, args) } } return true }} emit 方法是触发事件，并执行相应的方法，而 on 方法则是对于指定的事件添加监听函数 12345678910111213141516171819202122232425262728293031on(type, listener, prepend){ var m var events var existing events = this._events // 如果 newListener 存在，则每次添加新方法的时候 emit 出一个 newListener if (events.newListener !== undefined) { this.emit('newListener', type, listener) events = target._events } existing = events[type] // 判断相应的 type 的方法是否存在 if (existing === undefined) { // 如果相应的 type 的方法不存在，则新增一个相应 type 的事件 existing = events[type] = listener ++this._eventsCount } else { // 如果是函数，则添加 if (typeof existing === 'function') { existing = events[type] = prepend ? [listener, existing] : [existing, listener] } else if (prepend) { existing.unshift(listener) } else { existing.push(listener) } } return this} 如果 _events 存在 newListener 属性，也就是说 _event 存在监听 newListener 监听事件，那么每次 on 方法添加事件的时候，都会 emit 出一个 newListener 且在 on 方法的参数中，第三个参数用于指定是在相应事件类型属性所对应的数组头部添加还是尾部添加 在 on 方法中为了可以链式的调用，所以返回了 EventEmitter 模块的实例化本身 在 on 方法的基础上可以实现 addListener 方法和 prependListener 方法 12345EventEmitter.prototype.addListener = EventEmitter.prototype.onEventEmitter.prototype.prependListener = function prependListener(type, listener) { return EventEmitter.prototype.on(type, listener, true)} 再来看看 removeListener 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849removeListener(type, listener){ var list, events, position, i, originalListener events = this._events list = events[type] // 如果相应的事件对象的属性值是一个函数，也就是说事件只被一个函数监听 if (list === listener) { // 如果 -- 归零，则重新定义为一个新对象 if (--this._eventsCount === 0) { this._events = Object.create(null) } else { // 否则删除该事件，并且如果存在 removeListener 的监听函数，则触发 removeListener delete events[type] if (events.removeListener) this.emit('removeListener', type, listener) } // 如果不是函数则为函数数组 } else if (typeof list !== 'function') { // 遍历数组，找出 listener 对应函数的索引值 for (i = list.length - 1; i &gt;= 0; i--) { if (list[i] === listener) { position = i break } } // 没有找到这个函数，则返回不做任何改动的对象 if (position) { return this } // 如果数组的第一个函数才是所需要删除的对应 listener 函数，则直接移除 if (position === 0) { list.shift() } else { // 直接使用 splice 删除即可，如果需要优化则可以采用源码当中的 spliceOne() 方法 list.splice(position, 1) } if (list.length === 1) events[type] = list[0] // 同上 if (events.removeListener !== undefined) this.emit('removeListener', type, listener) } return this} 以上就是几个核心方法的实现，removeAllListener 与 removeListener 相似，只要找到传入的 type 所对应属性的值，没有遍历过程，直接删除这个属性即可 EventEmitter 模块的异常处理最后我们再来看看 EventEmitter 模块的异常处理的几种方式，比较常用的有以下几种方式 try-catch domains process.on('uncaughtException') try catch 异常处理方式在 Node.js 中也可以通过 try catch 方式来捕获和处理异常，比如 12345try { let x = x} catch (e) { console.log(e)} 上述 let x = x 赋值语句的错误会被捕获，这里提异常处理，那么跟事件有什么关系呢？Node.js 中有一个特殊的事件 error，如果异常没有被捕获，就会触发 process 的 uncaughtException 事件抛出，如果你没有注册该事件的监听器（即该事件没有被处理），则 Node.js 会在控制台打印该异常的堆栈信息，并结束进程（崩溃），比如 1234var events = require('events')var emitter = new events.EventEmitter()emitter.emit('error') 在上述代码中没有监听 error 的事件函数，因此会触发 process 的 uncaughtException 事件，从而打印异常堆栈信息，并结束进程，对于阻塞或者说非异步的异常捕获，try catch 是没有问题的，但是问题在于 try catch 不能捕获非阻塞或者异步函数里面的异常，举例来说 1234567try { // 第二个 x 在使用前未定义，会抛出异常 let x = x} catch (e) { console.log('该异常已经被捕获') console.log(e)} 上述代码中，因为 try 方法里面是同步的，因此可以捕获异常，但是如果 try 方法里面有异步的函数 12345678try { process.nextTick(function () { let x = x })} catch (e) { console.log('该异常已经被捕获') console.log(e)} 因为 process.nextTick 是异步的，因此在 process.nextTick 内部的错误不能被捕获，也就是说 try catch 不能捕获非阻塞函数内的异常 通过 domains 管理异常Node.js 中 domain 模块能被用来集中地处理多个异常操作，通过 Node.js 的 domain 模块可以捕获非阻塞函数内的异常 1234567891011121314var domain = require('domain')var eventDomain = domain.create()eventDomain.on('error', function (err) { console.log('该异常已经被捕获了') console.log(err)})eventDomain.run(function () { process.nextTick(function () { // 抛出异常 let x = x })}) 同样的，即使 process.nextTick 是一个异步函数，domain.on 方法也可以捕获这个异步函数中的异常，即使更复杂的情况下，比如异步嵌套异步的情况下，domain.on 方法也可以捕获异常 1234567891011121314151617var domain = require('domain')var eventDomain = domain.create()eventDomain.on('error', function (err) { console.log('该异常已经被捕获了') console.log(err)})eventDomain.run(function () { process.nextTick(function () { setTimeout(function () { setTimeout(function () { let x = x }, 0) }, 0) })}) 在上述的情况下，即使异步嵌套很复杂，也能在最外层捕获到异常，但是往往现实并没有那么美好，在 Node.js 最新的文档中，domain 已经被废除了（Deprecated），这是因为 domain 从诞生之日起就有着缺陷，举例来说 123456789101112131415161718192021var domain = require('domain')var EventEmitter = require('events').EventEmittervar e = new EventEmitter()var timer = setTimeout(function () { e.emit('data')}, 10)function next() { e.once('data', function () { throw new Error('something wrong here') })}var d = domain.create()d.on('error', function () { console.log('cache by domain')})d.run(next) 如上述的代码是无法捕获到异常 Error 的，原因在于发出异常的 EventEmitter 实例 e，以及触发异常的定时函数 timer 没有被 domain 包裹，domain 模块是通过重写事件循环中的 nextTick 和 _tickCallback 来事件将 process.domain 注入到 next 包裹的所有异步事件内，解决上述无法捕获异常的情况，只需要将 e 或者 timer 包裹进 domain 12345d.add(e)// ord.add(timer) 就可以成功的捕获异常，但是 domain 模块已经在 Node.js 最新的文档中被废除了 process.on(‘uncaughtException’)Node.js 中提供了一个最外层的捕获异常的方法，非阻塞或者异步函数中的异常都会抛出到最外层，如果异常没有被捕获，那么会暴露出来被最外层的 process.on('uncaughtException') 所捕获 12345678910try { process.nextTick(function () { let x = x }, 0)} catch (e) { console.log('该异常已经被捕获') console.log(e)}process.on('uncaughtException', function (err) { console.log(err) }) 这样就能在最外层捕获异步或者说非阻塞函数中的异常，但是需要注意避免 uncaughtException 错误引起 Node.js 进程崩溃 参考 深入 EventEmitter events.js eventemitter3 domain process 异常处理 uncaughtException 篇","link":"/2019/09/12/Node/06/"},{"title":"React-Redux 的实现","text":"接上回 Redux 的实现，我们在之前的章节当中，从一个简单的示例开始一步一步推导出 Redux 的实现方式，但是之前我们也提到过，它其实跟 React 一点关系都没有，所以在本章当中我们会把 React 和 Redux 结合起来，用 Redux 模式帮助我们来管理 React 的应用状态 在前端当中应用的状态存在的问题就是一个状态可能被多个组件依赖或者影响，而 React 并没有提供好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，也就是我们可以把共享状态放到父组件的 Context 上，让这个父组件以下的所有组件都可以从 Context 中直接获取到状态而不需要一层层地进行传递了 但是直接从 Context 里面存放、获取数据增强了组件的耦合性，并且所有组件都可以修改 Context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料，既然这样，我们为什么不把 Context 和 store 结合起来呢？毕竟 store 的数据不能直接被修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 Context 里面获取 store 从而获取状态，又不用担心它们乱改数据 最终完整代码可见 react-redux 的手动实现 初始化所以我们就来尝试一下，就拿官方文档当中那个主题色的示例，稍微的调整一下，比如我们要做下面这样的组件树 1234└─ App ├─ Header └─ Content └─ ThemeSwitch - Button x 2 主体容器 App 它有两个子组件 Header 和 Content，Header 和 Content 的组件的文本内容会随着主题色的变化而变化，而 Content 下的子组件 ThemeSwitch 有两个按钮，可以切换红色和蓝色两种主题，按钮的颜色也会随着主题色的变化而变化，各组件代码如下 12345export default class Header extends Component { render() { return &lt;h2&gt;标题&lt;/h2&gt; }} 12345678910export default class Content extends Component { render() { return ( &lt;div&gt; &lt;div&gt;内容&lt;/div&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ) }} 12345678910export default class ThemeSwitch extends Component { render() { return ( &lt;div&gt; &lt;button&gt;Red&lt;/button&gt; &lt;button&gt;Blue&lt;/button&gt; &lt;/div&gt; ) }} 12345678910class App extends Component { render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) }} 当然现在文本是没有颜色的，而且点击按钮也不会有什么反应，这些内容我们会在后面慢慢来进行完善 结合 Context 和 Store下面我们就来构建 store，用的也就是我们在之前章节当中实现的 createStore 方法，然后我们在构建一个 themeReducer 来生成一个 store，如下 12345678910111213141516171819202122232425262728function createStore(reducer) { let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) } dispatch({}) return { getState, dispatch, subscribe }}const themeReducer = (state, action) =&gt; { if (!state) return { themeColor: 'red' } switch (action.type) { case 'CHANGE_COLOR': return { ...state, themeColor: action.themeColor } default: return state }}const store = createStore(themeReducer)// ... themeReducer 定义了一个表示主题色的状态 themeColor，并且规定了一种操作 CHNAGE_COLOR，只能通过这种操作修改颜色，现在我们把 store 放到 App 的 Context 里面，这样每个子组件都可以获取到 store 了 1234567891011121314151617181920class App extends Component { static childContextTypes = { store: PropTypes.object } getChildContext() { return { store } } render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) }}export default App 这里有一个看上去可能有些疑惑的 childContextTypes，它的作用其实与 propsType 验证组件 props 参数的作用类似，不过它验证的是 getChildContext 返回的对象，那么为什么又要验证 Context 呢？ 这是因为 Context 是一个危险的特性，所以 React 团队将其使用方式设置的复杂一些，提高使用门槛的同时也会让你注意到它的危险性，如果你要给组件设置 Context，那么 childContextTypes 是必写的（现在可以使用 useContext() 来简化我们的操作） 下面我们就可以来调整 Header 组件，让它从 Context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色 12345678910111213141516171819202122232425262728export default class Header extends Component { static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { themeColor: '' } } componentDidMount() { const { store } = this.context this._updateThemeColor() store.subscribe(() =&gt; this._updateThemeColor()) } _updateThemeColor() { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render() { return &lt;h2 style={{ color: this.state.themeColor }}&gt;标题&lt;/h2&gt; }} 同样的，作为子组件的 Header，想要获取 Context 里面的内容的话，就必须写 contextTypes 来声明和验证你需要获取的状态的类型，它也是必写的，如果你不写就无法获取 Context 里面的状态 运行完成以后可以发现，标题的颜色已经变成了红色，其实上面的代码逻辑很简单，我们在 constructor 里面初始化了组件自己的 themeColor 状态，然后在生命周期中调用 _updateThemeColor，_updateThemeColor 会从 Context 里面把 store 取出来，然后通过 store.getState() 获取当前的 state 对象，并且用里面的 themeColor 字段设置组件的 state.themeColor 同时通过 store.subscribe 进行监听，在数据变化的时候重新调用 _updateThemeColor，而 _updateThemeColor 会去 store 里面取最新的 themeColor 然后通过 setState 重新渲染组件 同理，我们将 Content 组件和 ThemeSwitch 组件也调整成从 store 当中来获取主题色 12345678910111213141516171819202122232425262728293031323334export default class Content extends Component { static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { themeColor: '' } } componentDidMount() { const { store } = this.context this._updateThemeColor() store.subscribe(() =&gt; this._updateThemeColor()) } _updateThemeColor() { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render() { return ( &lt;div&gt; &lt;div style={{ color: this.state.themeColor }}&gt;内容&lt;/div&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ) }} 123456789101112131415161718192021222324252627282930313233export default class ThemeSwitch extends Component { static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { themeColor: '' } } componentDidMount() { const { store } = this.context this._updateThemeColor() store.subscribe(() =&gt; this._updateThemeColor()) } _updateThemeColor() { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render() { return ( &lt;div style={{ color: this.state.themeColor }}&gt; &lt;button&gt;Red&lt;/button&gt; &lt;button&gt;Blue&lt;/button&gt; &lt;/div&gt; ) }} 运行以后可以发现，主题已经完全生效了，此时整个页面当中的元素都是红色的，当然现在点按钮还是没什么效果，所以我们接下来就是给按钮添加点击事件 123456789101112131415161718192021222324252627export default class ThemeSwitch extends Component { // ... handleSwitchColor(color) { const { store } = this.context store.dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } render() { return ( &lt;div&gt; &lt;button style={{ color: this.state.themeColor }} onClick={this.handleSwitchColor.bind(this, 'red')} &gt;Red&lt;/button&gt; &lt;button style={{ color: this.state.themeColor }} onClick={this.handleSwitchColor.bind(this, 'blue')} &gt;Blue&lt;/button&gt; &lt;/div&gt; ) }} 我们给两个按钮都加上了 onClick 事件监听，并绑定到了 handleSwitchColor 方法上，在点击的时候分别给这个方法传入不同的颜色，handleSwitchColor 会根据传入的颜色来 store.dispatch 一个 action 去修改颜色 如此一来，我们就完成了自由的切换主题颜色的功能了，但是其中还有不少可以优化的地方，我们下面慢慢来看 Connect 和 mapStateToProps我们仔细观察我们之前设计的组件，发现有两个比较严重的问题 有大量重复的逻辑，它们基本的逻辑都是取出 Context，得到里面的 store，然后用里面的状态设置自己的状态，这些代码逻辑其实都是相同的 对 Context 依赖性过强，这些组件都要依赖 Context 来取数据，使得这个组件复用性基本为零 所以我们需要针对以上两点问题来进行处理，关于第一点，我们都知道在 React 当中有一个 HOC（高阶组件）的概念，我们可以把一些可复用的逻辑放在高阶组件当中，高阶组件包装的新组件和原来组件之间通过 props 传递信息，减少代码的重复程度 至于第二点，我们可以将其改写成为 UI 组件，关于 UI 组件，也称为 Dumb Component，因为你传递给它什么，它就渲染什么出来，对参数（props）以外的数据零依赖，也不产生副作用，所以我们需要高阶组件来帮助我们从 Context 取数据，使用高阶组件和 Context 打交道，把里面数据取出来通过 props 传给 UI 组件，也就是如下图当中所示 我们把这个高阶组件起名为 connect，因为它把 UI 组件和 Context 连接（connect）起来了 12345678910111213141516import React, { Component } from 'react'import PropTypes from 'prop-types'export const connect = (WrappedComponent) =&gt; { class Connect extends Component { static contextTypes = { store: PropTypes.object } render() { return &lt;WrappedComponent /&gt; } } return Connect} connect 函数接受一个组件 WrappedComponent 作为参数，把这个组件包含在一个新的组件 Connect 里面，Connect 会去 Context 里面取出 store，现在要把 store 里面的数据取出来通过 props 传给 WrappedComponent，但是每个传进去的组件需要 store 里面的数据都不一样的，所以还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据 为了解决这个问题，我们需要一个映射函数来告诉 store 如何返回我们需要的数据，我们将其命名为 mapStateToProps，如下 1234567const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor, themeName: state.themeName, // ... }} 这个函数会接受 store.getState() 的结果作为参数，然后返回一个对象，这个对象是根据 state 生成的，也就是我们使用 mapStateTopProps 去告知 Connect 应该如何去 store 里面取数据，然后得到我们需要的数据以后，再把这个函数的返回结果传给被包装的组件 123456789101112131415161718import React, { Component } from 'react'import PropTypes from 'prop-types'export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; { class Connect extends Component { static contextTypes = { store: PropTypes.object } render() { const { store } = this.context let stateProps = mapStateToProps(store.getState()) return &lt;WrappedComponent {...stateProps} /&gt; } } return Connect} 其中的 {...stateProps} 意思是把这个对象里面的属性全部通过 props 方式传递进去，connect 现在接受一个参数 mapStateToProps，然后返回一个函数，这个返回的函数才是高阶组件，它会接受一个组件作为参数，然后用 Connect 把组件包装以后再返回，connect 的用法是 1234567891011// ...const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor }}Header = connect(mapStateToProps)(Header)// ... 我们把上面 connect 的函数代码单独分离到一个模块当中，再把之前的监听数据变化重新渲染的逻辑放到其中调整一下，并将其取名为 react-redux.js 12345678910111213141516171819202122232425262728293031323334353637export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; { class Connect extends Component { static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { allProps: {} } } componentDidMount() { const { store } = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) } _updateProps() { const { store } = this.context // 额外传入 props，让获取数据更加灵活方便 let stateProps = mapStateToProps(store.getState(), this.props) this.setState({ // 整合普通的 props 和从 state 生成的 props allProps: { ...stateProps, ...this.props } }) } render() { return &lt;WrappedComponent {...this.state.allProps} /&gt; } } return Connect} 我们在 Connect 组件的 constructor 里面初始化了 state.allProps，它是一个对象，用来保存需要传给被包装组件的所有的参数，为了让 connect 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 Connect 的 props 原封不动地传给 WrappedComponent，所以在 _updateProps 里面会把 stateProps 和 this.props 合并到 this.state.allProps 里面，再通过 render 方法把所有参数都传给 WrappedComponent mapStateToProps 也发生点变化，它现在可以接受两个参数了，我们会把传给 Connect 组件的 props 参数也传给它，那么它生成的对象配置性就更强了，我们可以根据 store 里面的 state 和外界传入的 props 生成我们想传给被包装组件的参数，接下来我们就可以在 Header 当中来进行使用了 12345678910111213141516171819class Header extends Component { static propTypes = { themeColor: PropTypes.string } render() { return &lt;h2 style={{ color: this.props.themeColor }}&gt;标题&lt;/h2&gt; }}const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor }}Header = connect(mapStateToProps)(Header)export default Header 如上，可以发现我们在 Header 当中删掉了大部分关于 Context 的代码，它除了 props 什么也不依赖，所以它是一个纯粹的 UI 组件，只需要通过 connect 来取得数据，但是我们不需要知道 connect 是怎么和 Context 打交道的，所以只需要传递一个 mapStateToProps 告诉它应该怎么取数据就可以了，再用同样的方式来修改 Content 123456789101112131415161718192021222324class Content extends Component { static propTypes = { themeColor: PropTypes.string } render() { return ( &lt;div&gt; &lt;div style={{ color: this.props.themeColor }}&gt;内容&lt;/div&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ) }}const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor }}Content = connect(mapStateToProps)(Content)export default Content 修改以后再次刷新界面，发现功能还是跟之前一样，但是我们的 Header 和 Content 的代码都大大减少了，但是我们的事情并没有做完，接下来我们还需要继续重构 ThemeSwitch mapDispatchToProps在重构 ThemeSwitch 的时候我们发现，ThemeSwitch 除了需要 store 里面的数据以外，还需要 store 来 dispatch，但是我们目前版本的 connect 是达不到这个效果的，所以我们需要改进它，但是仔细一想，既然可以通过给 connect 函数传入 mapStateToProps 来告诉它如何获取、整合状态，那么我们也可以给它传入另外一个参数来告诉它我们的组件需要如何触发 dispatch 的，我们把这个参数叫 mapDispatchToProps 1234567const mapDispatchToProps = (dispatch) =&gt; { return { onSwitchColor: (color) =&gt; { dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } }} 和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件，而不一样的是这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action，所以我们调整 connect 让它能接受这样的 mapDispatchToProps 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, { Component } from 'react'import PropTypes from 'prop-types'export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; { class Connect extends Component { static contextTypes = { store: PropTypes.object } constructor() { super() this.state = { allProps: {} } } componentDidMount() { const { store } = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) } _updateProps() { const { store } = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : {} let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : {} this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props } }) } render() { return &lt;WrappedComponent {...this.state.allProps} /&gt; } } return Connect} 在 _updateProps 内部，我们把 store.dispatch 作为参数传给 mapDispatchToProps，它会返回一个对象 dispatchProps，接着把 stateProps、dispatchProps、this.props 三者合并到 this.state.allProps 里面去，这三者的内容都会在 render 函数内全部传给被包装的组件 这时候我们就可以重构 ThemeSwitch，让它摆脱 store.dispatch 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ThemeSwitch extends Component { static propTypes = { themeColor: PropTypes.string, onSwitchColor: PropTypes.func } handleSwitchColor(color) { if (this.props.onSwitchColor) { this.props.onSwitchColor(color) } } render() { return ( &lt;div&gt; &lt;button style={{ color: this.props.themeColor }} onClick={this.handleSwitchColor.bind(this, 'red')} &gt;Red&lt;/button&gt; &lt;button style={{ color: this.props.themeColor }} onClick={this.handleSwitchColor.bind(this, 'blue')} &gt;Blue&lt;/button&gt; &lt;/div&gt; ) }}const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor }}const mapDispatchToProps = (dispatch) =&gt; { return { onSwitchColor: (color) =&gt; { dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } }}ThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)export default ThemeSwitch 现在的 ThemeSwitch 只依赖外界传进来的 themeColor 和 onSwitchColor，但是 ThemeSwitch 内部并不知道这两个参数其实都是我们去 store 里面取的，此时我们的三个组件的重构都已经完成了，代码大大减少、不依赖 Context，并且功能和原来一样 Provider至此，我们的大体结构已经搭建的差不多了，但是还有一点就是我们能不能将和 Context 相关的代码从所有业务组件中清除出去，这样一来就可以保证我们的业务组件都是干净的，所以我们来稍微的重构一下我们的 App 组件 在 App 组件当中之所以需要用到 Context，就是因为要把 store 存放到里面，好让子组件 connect 的时候能够取到 store，所以我们可以额外构建一个单独的组件专门来做这件事情，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 Context 了，我们把这个组件叫 Provider，因为它提供（provide）了 store 1234567891011121314151617181920export class Provider extends Component { static propTypes = { store: PropTypes.object, children: PropTypes.any } static childContextTypes = { store: PropTypes.object } getChildContext() { return { store: this.props.store } } render() { return &lt;div&gt;{this.props.children}&lt;/div&gt; }} Provider 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来，它还会把外界传给它的 props.store 放到 Context，这样子组件 connect 的时候都可以获取到，下面我们再来调整 App 组件，也就是删除 App 里面所有关于 Context 的代码，整理过的 App 如下所示，可以发现现在已经变得很干净了 12345678910111213// 删除 App 里面所有关于 context 的代码class App extends Component { render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) }}export default App 这样我们就把所有关于 Context 的代码从组件里面删除了，然后将之前在 App 组件当中生成 store 等一系列操作移动到我们的主文件当中，如下 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react'import ReactDOM from 'react-dom'import './index.css'import App from './App'import 'antd/dist/antd.css'import { Provider } from './Provider'function createStore(reducer) { let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; { state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) } dispatch({}) return { getState, dispatch, subscribe }}const themeReducer = (state, action) =&gt; { if (!state) return { themeColor: 'red' } switch (action.type) { case 'CHANGE_COLOR': return { ...state, themeColor: action.themeColor } default: return state }}const store = createStore(themeReducer)ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 至此，我们的整个流程就算是走通了 组件划分最后我们再来回过头看一下我们设计的组件，我们在之前的 Redux、Flux 和 React-Redux 三者之间的区别 章节当中曾经介绍过，React-Redux 将所有组件分成了两大类，UI 组件和容器组件，UI 组件基本只做一件事情，那就是根据 props 来进行渲染，而容器组件则是负责应用的逻辑、数据，把所有相关的 UI 组件组合起来，通过 props 控制它们 但是我们观察我们的 Header 组件，这个组件其实在执行 connect 之前它一直都是 UI 组件，就是因为 connect 了导致它和 Context 扯上了关系，导致它变成容器组件了，也使得这个组件没有了很好的复用性，所以我们需要来重构一下，我们在 src 目录下新建两个文件夹 components 和 containers 123├─ App │ ├─ components │ └─ containers 我们规定所有的 UI 组件都放在 components/ 目录下，所有的容器组件都放在 containers/ 目录下，所以我们根据这个规则来重构我们的目录，这里以 Header 组件为例，我们将 components/ 文件夹下的 Header 组件调整为 123456789101112import React, { Component } from 'react'import PropTypes from 'prop-types'export default class Header extends Component { static propTypes = { themeColor: PropTypes.string } render() { return &lt;h2 style={{ color: this.props.themeColor }}&gt;标题&lt;/h2&gt; }} 这样一来，重构后的 Header 是一个纯展示的 UI 组件，下面我们在对应的 container/ 文件夹下新建一个与其对应的容器组件，名字也为 Header 12345678910import { connect } from 'react-redux'import Header from '../components/Header'const mapStateToProps = (state) =&gt; { return { themeColor: state.themeColor }}export default connect(mapStateToProps)(Header) 它引入 components/ 下的 Header 组件，经过 connect 包裹后返回一个新的 Header，就相当于我们把 Header 组件划分为了两部分，src/components/Header.js 下的负责渲染，而 src/containers/Header.js 则是跟业务相关的，同理，我们在分别重构 ThemeSwitch 和 Content 组件，但是这里有一点需要注意的是，针对 Content 组件可以分为两种情况，即不复用和可复用，这里我们分情况来进行讨论 如果是不复用的情况下，将 Content 移至业务文件夹 container/ 下即可，最终的目录结构为 123456789src├── components│ ├── Header.js│ └── ThemeSwitch.js├── containers│ ├── Content.js│ ├── Header.js│ └── ThemeSwitch.js└── App.js 如果可复用，那么 Content 的子组件 ThemeSwitch 就一定要是 UI 组件，所以在这种情况下就不能直接使用 connect 了，所以涉及到的 ThemeSwitch 的数据、onSwitchColor 函数等就要通过它的父组件传递进来，而不是通过 connect 获得，这样一来组件的划分就变为了 123456789src├── components│ ├── Header.js│ ├── Content.js│ └── ThemeSwitch.js├── containers│ ├── Header.js│ └── Content.js└── App.js 这里我们为了简便，就直接采用了不复用的形式，但是我们可以发现，针对复用性的需求不同，我们划分组件的方式也有所不同，当然还有一点要注意，容器组件并不意味着完全不能复用，容器组件的复用性也是依赖场景的，在某些特定的应用场景下还是可以复用容器组件的，最终整合后的完整代码可见 组件划分 总结我们来简单的总结一下我们在上面做了哪些事情，我们知道 store 里面的内容是不可以随意修改的，而是通过 dispatch 才能变更里面的 state，所以我们尝试把 store 和 Context 结合起来使用，可以兼顾组件之间共享状态问题和共享状态可能被任意修改的问题 在我们设计的第一个版本当中，因为 store 和 Context 结合有诸多缺陷，有大量的重复逻辑和对 Context 的依赖性过强，所以我们尝试通过构建一个高阶组件 connect 函数的方式，把所有的重复逻辑和对 Context 的依赖放在里面 connect 函数里面，而其他组件则仅仅只负责渲染（UI 组件），让 connect 跟 Context 打交道，然后通过 props 把参数传给普通的组件 而每个组件需要的数据和需要触发的 action 都不一样，所以我们调整了 connect，让它可以接受两个参数 mapStateToProps 和 mapDispatchToProps，分别用于告诉 connect 这个组件需要什么数据和需要触发什么 action 最后为了把所有关于 Context 的代码完全从我们业务逻辑里面清除掉，我们构建了一个 Provider 组件，Provider 作为所有组件树的根节点，外界可以通过 props 给它提供 store，它会把 store 放到自己的 Context 里面，好让子组件 connect 的时候都能够获取到 最后的最后，我们将我们的组件重新的划分了一遍，分为了 UI 组件和容器组件，UI 组件基本只做一件事情，那就是根据 props 来进行渲染，而容器组件则是负责应用的逻辑、数据，把所有相关的 UI 组件组合起来，通过 props 控制它们 当然，我们实现的这版 React-Redux 也是存在着一定问题的，比如不相关的数据变化的时候其实所有组件都会重新渲染的，不过在这里我们就不详细展开了，想了解更多的话可以参考之前整理过的一篇系列文章 Virtual DOM 与 Diff 算法内容总结 来了解更多，但是通过上面的示例，我们知道了为什么要 connect，为什么要 mapStateToProps 和 mapDispatchToProps，以及什么是 Provider，这样在接触官方的 React-Redux 的时候就会变得上手十分简单","link":"/2020/10/23/React/13/"},{"title":"JavaScript 中的闭包","text":"之前我们曾经介绍过了 作用域与执行上下文栈 的相关内容，这一章我们就来看看与其联系十分密切的闭包 什么是闭包所谓闭包，官方的解释是 是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分 看起来有点绕，换个说法，简而言之，闭包就是 『闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在』 闭包就是就是函数的堆栈在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配 通常而言，如果在一个函数内返回了另外一个函数，这种情况下就会产生闭包 做为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别，闭包的差别在于局部变变量可以在函数执行结束后仍然被函数外的代码访问，这意味着函数必须返回一个指向闭包的引用，或将这个引用赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问 闭包产生的原因在本质上来说，闭包就是将函数内部和函数外部连接起来的一座桥梁，闭包可以用在许多地方，它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，在之前 作用域与执行上下文栈 一文当中我们已经介绍过执行上下文，这里我们再来简单的复习一下 ECMAscript 的脚本的函数运行时，每个函数关联都有一个执行上下文场景（Execution Context） ，这个执行上下文场景中包含三个部分 文法环境（The LexicalEnvironment） 变量环境（The VariableEnvironment） this 绑定 我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录（Enviroment Recode），和外部引用（指针），环境记录包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景，全局的上下文场景中此引用值为 null，这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景 而这也就是『闭包产生的原因』，我们都知道，在 ES5 中只存在两种作用域『全局作用域』和『函数作用域』，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是『作用域链』，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条，比如 123456789var a = 1function f1() { var a = 2 function f2() { var a = 3 console.log(a) }} 在这段代码中，f1 的作用域指向有全局作用域（window）和它本身，而 f2 的作用域指向全局作用域（window）、f1 和它本身，而且作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错，就这么简单一件事情 而闭包产生的本质就是，当前环境中存在指向父级作用域的引用 1234567891011function f1() { var a = 2 function f2() { console.log(a) } return f2}var x = f1()x() // 2 这里 x 会拿到父级作用域中的变量，输出 2，因为在当前环境中，含有对 f2 的引用，f2 恰恰引用了 window、f1 和 f2 的作用域，因此 f2 可以访问到 f1 的作用域的变量 看到这里我们可能会有一些疑问，那是不是只有返回函数才算是产生了闭包呢？让我们回到闭包的本质，我们需要做的只是让父级作用域的引用存在即可，因此我们可以调整上面的示例 123456789101112var f3function f1() { var a = 2 f3 = function () { console.log(a) }}f1()f3() 这里我们让 f1 执行，给 f3 赋值后，等于说现在 f3 拥有了 window、f1 和 f3 本身这几个作用域的访问权限，还是自底向上查找，最近是在 f1 中找到了 a，因此输出 2 在这里是外面的变量 f3 还存在着父级作用域的引用，因此产生了闭包，虽然形式变了，但是本质没有改变 闭包中 this 的指向浏览器中的顶级域，其实就是 window 对象，所谓的闭包中的 this 指向，通俗点说就是，谁调用这个函数（即 xx.fn() 中的 xx），谁就是这个函数（fn）的 this，JavaScript 中的 this 指向函数调用时的上下文，可以想像成每个函数在被调用时，动态注入了一个 this 对象，所以在非严格模式下内部的 this 指向 window 对象，严格模式下应为 undefined，其实，引入 this 的初衷就是想在原型继承的情况下，得到函数的调用者，如下实例 12345678910111213var obj = { method: function () { return this }}console.log(obj.method() === obj)var F = function () { }F.prototype = objvar instance = new Fconsole.log(instance.method() === instance) 如果函数没有指明调用者呢，那就让 this 指向全局对象吧 12345var global = thisconsole.log(global === window)var g = obj.methodconsole.log(g() === global) 不过针对与下面这种情况，如果想让 this 的指向指回去的话，可以使用 bind 方法 12var g = obj.method.bind(obj)g() // { method: ƒ } 再看一个实例 12345678910111213var name = 'window'var person = { name: '张三', age: 20, say: function () { return function () { return this.name } }}console.log(person.say()()) // window 当完成 person.say() 之后，这个函数就调用结束了，在这个函数调用结束之前 this 是指向 preson，但是在调用匿名函数的时候，this 就指向了 window，所以得到的结果是 window，针对于以上这种情况，我们可以把函数中的 this 用一个临时变量保存起来，就可以得到我们想要的结果 12345678910111213141516var name = 'window'var person = { name: '张三', age: 20, say: function () { // that 就指向 person（把 this 保存起来） var that = this return function () { return that.name } }}console.log(person.say()()) 此时 that 就是指向 person 的，所以调用 that.name 就是 person 中的 name 闭包的表现形式我们下面来简单的看看，在真实的场景当中，有哪些地方可以体现闭包的存在，主要有以下几种情况 首先是函数内部再次返回一个函数，这个也就是我们上面介绍的示例，就不过多提及了 作为函数参数传递，比如下面这个示例 1234567891011121314151617var a = 1function foo() { var a = 2 function baz() { console.log(a) } bar(baz)}function bar(fn) { // 这就是闭包 fn()}// 结果为 2，而不是1foo() 在定时器、事件监听、Ajax 请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包，比如下面这个示例，其中的闭包保存的仅仅是 window 和当前作用域 123456789// 定时器setTimeout(function timeHandler() { console.log('123')}, 100)// 事件监听$('#btn').click(function () { console.log('DOM Listener')}) IIFE（立即执行函数表达式）创建闭包，保存了全局作用域 window 和当前函数的作用域，因此可以全局的变量 123456var a = 2;(function IIFE() { // 输出2 console.log(a)})() 柯里化我们可以先从一道面试题看起，如下 123var result = add(1)(2)(3)console.log(result) // 要求输出的结果为 6 当然，没有什么特殊要求的话，很好实现，如下 12345678910111213// 一般形式function add(a) { return function (b) { return function (c) { return a + b + c } }}// 可以使用箭头函数进行简化const add = a =&gt; b =&gt; c =&gt; a + b + cadd(1)(2)(3) // 6 我们虽然实现了，但是可以发现，它的通用性并不是很好，比如我们像 add(1)(2)(3)(4) 这样传递四个参数，又或者现在需求有变化，变成了求 multiple(1)(2)(3) 结果的话，我们可能就需要去调整函数内部的结构来适应需求，这样一来上面这个方法的通用性就不太行了，所以我们下面将会设计一个更为通用的方法来实现它，这也就是所谓的『柯里化』的应用了 柯里化通常也称部分求值，其要求被传入函数所有参数都被明确的定义，因此当使用部分参数调用时，他会返回一个新的函数，在真正调用之前等待外部提供其余的参数，可以简单的理解为，在所有参数被提供之前，挂起或延迟函数的执行，我们就按照这个思路来实现一个版本 12345678910var curry = function (fn) { var _args = [] return function cb() { if (arguments.length === 0) { return fn.apply(this, _args) } Array.prototype.push.apply(_args, arguments) return cb }} 下面我们来定义一个 add 函数来测试一下 1234567891011121314var add = function () { var total = 0 for (var i = 0, c; c = arguments[i++];) { total += c } return total}var sum = curry(add)sum(1)(2)(3)(4)// 只有空白调用的时候才开始真正计算sum() // 10 也可以使用下面这种方式来进行调用 12345sum(1)sum(2, 3)sum(4)sum() // 10 另外，计算 multiple 也是可以的 12345678var multiple = function (a, b, c) { return a * b * c}var mult = curry(multiple)mult(1)(2)(3)mult() // 6 但是我们可以发现，有一点不算太完美的地方，就是我们每次需要空白调用的时候才会返回最后的计算结果，那么有没有可以自动计算出结果的方式呢？方法是有的，如下 123456789101112131415function curry(fn, args) { var length = fn.length, args = args || [] return function () { var _args = args.slice(0), i for (i = 0; i &lt; arguments.length; i++) { _args.push(arguments[i]) } // 在返回的时候借用 call 或者 apply 来达到自动调用的效果 if (_args.length &lt; length) { return curry.call(this, fn, _args) } else { return fn.apply(this, _args) } }} 我们可以来试一下上面的这个方法 12345678var multiple = function (a, b, c) { return a * b * c}var mult = curry(multiple)mult(1)(2)(3) // 6mult(2, 3)(4) // 24 最后我们再来看一个在网上比较常见的使用 ES6 的实现，十分简洁 1234567891011const curry = fn =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg))const sum = (a, b, c, d) =&gt; a + b + c + dconst currySum = curry(sum)currySum(1)(2)(3)(4) // 10currySum(1, 2)(3)(4) // 10currySum(1)(2, 3)(4) // 10 反柯里化下面我们再来简单的看一下反柯里化，从名字就可以得知，它就是柯里化操作的反向操作，类似于下面这样 1obj.func(arg1, arg2) =&gt; func(obj, arg1, arg2) 实现如下 123456789101112131415Function.prototype.uncurrying = function () { var that = this return function () { return Function.prototype.call.apply(that, arguments) }}function sayHi() { return 'hello ' + this.value + [].slice.call(arguments)}let sayHiuncurrying = sayHi.uncurrying()// hello worldsayHiuncurrying({ value: 'world' }, '!') 偏函数既然提到了柯里化，这里就顺带着介绍一下偏函数，那么什么是偏函数呢？偏函数，即固定函数的某一个或几个参数，返回一个新的函数来接收剩下的变量参数，比如下面这个例子 123456789function mul(a, b) { return a * b}var dobule = mul.bind(null, 2)dobule(2) // 4 ==&gt; 其实相当于执行了 mul(2, 2) dobule(3) // 6 ==&gt; 其实相当于执行了 mul(2, 3) dobule(4) // 8 ==&gt; 其实相当于执行了 mul(2, 4) 以上就是偏函数应用，我们创造一个新函数，让现有的一些参数值固定，从而使函数更加灵活，我们来看一下与柯里化之间的区别 『柯里化』是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数 『偏函数』则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数 那么问题来了，按照上面的示例所示，要实现偏函数应用，我们直接使用 bind 不就好了吗，但是了解过 bind 的原理就应该会知道，bind 是会改变 this 的指向的，所以，我们就来实现一个通用的偏函数，这里需要注意，this 的指向是不改变的 123456789101112131415// ES5 写法function partial(fn) { var args = [].slice.call(arguments, 1) return function () { var newArgs = args.concat([].slice.call(arguments)) return fn.apply(this, newArgs) }}// ES6 写法function partial(fn, ...args) { return function (...newArgs) { return fn.call(this, ...args, ...newArgs) }} 我们来稍微测试一下 123456789101112131415function mul(a) { return a * this.value}var value = 1var obj = { value: 2, mul: mul}var dobule1 = obj.mul.bind(obj, 2)var dobule2 = partial(obj.mul, 2)dobule1(1) // 4 ==&gt; 使用 bind 的时候 value 使用的是 obj 当中的dobule2(2) // 2 ==&gt; 使用 partial 的时候，value 使用的是全局当中的 value 一道经典的闭包面试题题目是这样的，要求为示例当中的三个 li 绑定点击事件，并输出对应的 index 12345&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 第一印象就是直接获取到这三个元素，然后每个元素绑定一个点击事件，如下 1234567var list = document.querySelector('li')for (var i = 0; i &lt; list.length; i++) { list[i].onclick = function () { alert(i) }} 很明显这样写并没有实现我们想要的结果，不管点击哪一个 li 都只打印了一个结果就是 3，那么这是什么原因呢？onclick 是一个事件，这个事件委托了并没有去触发，只有触发的时候才会调用回调函数，代码自上而下运行这时候 i 的值已经变为 3 了，所以每个点击事件的回调结果都是 3 我们来稍微调整一下，使用一个匿名函数将其包裹一下（也有其他解决方式，比如 let 等，但是我们这里主要介绍闭包的形式），并且在每次循环的时候将当前 i 的值传递给匿名函数 123456789var list = document.querySelector('li')for (var i = 0; i &lt; list.length; i++) { +function (j) { list[j].onclick = function () { alert(j) } }(i)} 这样的话点击不同的 li 就会打印对应的 index 值，简单来说就是改变 i 的作用域，保留它的值，因为之前的代码当中，i 的作用域是全局的，所以打印的结果都是 3，现在是作为实参传递到匿名函数当中，并调用，就变成形参写传递到了事件当中，这样就改变掉了其作用域，也就是将原来有的值保留了下来，所以结果就是打印对应的 index 值 上面的这种解决方式，也是之前一种比较常见的方式，但是问题来了，虽然可以解决这样的问题，但是它内部的原理究竟是什么样子的呢，为什么会形成这样的结果呢？这里就要用到我们之前介绍过的 执行上下文栈和变量对象 的相关知识了 我们将上面的例子稍微简化调整一下，让我们从另一个方向来看看它在运行过程中到底发生了什么，简化后的示例如下 1234567891011var data = []for (var i = 0; i &lt; 3; i++) { data[i] = function () { console.log(i) }}data[0]()data[1]()data[2]() 原理都是一样的，结果在上面我们已经知晓了，都是 3，这是因为当执行到 data[0] 函数之前，此时全局上下文的 VO 为 123456globalContext = { VO: { data: [...], i: 3 }} 当执行 data[0] 函数的时候，data[0] 函数的作用域链为 123data[0]Context = { Scope: [AO, globalContext.VO]} data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，此时的 i 为 3，所以打印的结果就是 3，data[1] 和 data[2] 是一样的道理，下面我们将其修改为闭包再来看看 12345678910111213var data = []for (var i = 0; i &lt; 3; i++) { data[i] = (function (i) { return function () { console.log(i) } })(i)}data[0]()data[1]()data[2]() 当执行到 data[0] 函数之前，此时全局上下文的 VO 为 123456globalContext = { VO: { data: [...], i: 3 }} 跟没改之前是一模一样的，但是当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变 123data[0]Context = { Scope: [AO, 匿名函数Context.AO globalContext.VO]} 此时匿名函数执行上下文的 AO 为 123456789匿名函数Context = { AO: { arguments: { 0: 0, length: 1 }, i: 0 }} data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，但是因为找到了，所以就不会再往 globalContext.VO 当中进行查找了，即使 globalContext.VO 也有 i 的值（值为 3），所以打印的结果就是 0，同理，data[1] 和 data[2] 也是一样的 闭包的实例前面我们大致了解了 JavaScript 中的闭包是什么，闭包在 JavaScript 是怎么实现的，下面我们来看一些例子来更加深入的理解闭包，先来看五个摘自 JavaScript Closures for Dummies 的案例 实例一：闭包中局部变量是引用而非拷贝123456789101112function say667() { // 局部变量 var num = 666 var sayAlert = function () { alert(num) } num++ return sayAlert}var sayAlert = say667()sayAlert() 因此执行结果应该弹出的 667 而非 666 实例二：多个函数绑定同一个闭包，因为他们定义在同一个函数内12345678910111213141516function setupSomeGlobals() { var num = 666 // 存储一些函数作为全局变量的引用 gAlertNumber = function () { alert(num) } gIncreaseNumber = function () { num++ } gSetNumber = function (x) { num = x }}setupSomeGlobals() // 为三个全局变量赋值gAlertNumber() gIncreaseNumber()gAlertNumber() gSetNumber(12)gAlertNumber() 输出的结果依次喂 666，667，12 实例三：当在一个循环中赋值函数时，这些函数将绑定同样的闭包1234567891011121314151617181920function buildList(list) { var result = [] for (var i = 0; i &lt; list.length; i++) { var item = 'item' + list[i] result.push(function () { alert(item + ' ' + list[i]) }) } return result}function testList() { var fnlist = buildList([1, 2, 3]) // 使用 j 防止混乱 for (var j = 0; j &lt; fnlist.length; j++) { fnlist[j]() }}testList() 因为这三个函数绑定了同一个闭包，而且 item 的值为最后计算的结果，所以会输出三次 item3 undefined 实例四：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后1234567891011function sayAlice() { var sayAlert = function () { alert(alice) } // 但是如果把 return 语句放到 var 上面，结果就是 undefined var alice = 'Hello Alice' return sayAlert}var helloAlice = sayAlice()helloAlice() 执行结果是弹出 'Hello Alice' 的窗口，即使局部变量声明在函数 sayAlert 之后，局部变量仍然可以被访问到 实例五：每次函数调用的时候创建一个新的闭包123456789101112131415161718function newClosure(someNum, someRef) { var num = someNum var anArray = [1, 2, 3] var ref = someRef return function (x) { num += x anArray.push(num) alert('num: ' + num + ' anArray ' + anArray.toString() + ' ref.someVar ' + ref.someVar) }}closure1 = newClosure(40, { someVar: 'closure 1' })closure2 = newClosure(1000, { someVar: 'closure 2' })closure1(5) // num: 45 anArray[1, 2, 3, 45] ref: 'someVar closure1'closure2(-10) // num: 990 anArray[1, 2, 3, 990] ref: 'someVar closure2' 下面我们再来看看一些在平时开发过程中遇到的坑 实例六：闭包引用的局部变量，不会自动清除123456789101112function f1() { var n = 999 nAdd = function () { n += 1 } function f2() { alert(n) } return f2}var result = f1()result() // 999nAdd()result() // 1000 在上述代码中，result 实际上就是闭包 f2 函数，它一共运行了两次，第一次的值是 999，第二次的值是 1000，这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除 原因在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1 ，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage-collection）回收 这段代码中另一个值得注意的地方，就是 nAdd = function () { n += 1 } 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量，其次，nAdd 的值是一个 『匿名函数』（anonymous-function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作 实例七：闭包中的 this12345678910111213141516171819202122232425262728// 第一种情况var name = 'The Window'var object = { name: 'My Object', getNameFunc: function () { return function () { return this.name } }}alert(object.getNameFunc()())// 第二种情况var name = 'The Window'var object = { name: 'My Object', getNameFunc: function () { var that = this return function () { return that.name } }}alert(object.getNameFunc()()) 第一个打印结果为 The window，因为第一个 this 为全局对象，所以 alert 处理的 name 为 The window 第二个打印结果为 My Object，因为第二个 that 为 Object 对象，所以 alert 处理的 name 为 My object，因为在调用前用 that 保存了 Object 自己的 this，所以在闭包内可以调用 实例八：闭包中的作用域12345678910111213141516171819202122// 第一种情况function foo(x) { var tmp = 3 function bar(y) { alert(x + y + (++tmp)) } bar(10)}foo(2)// 第二种情况function foo(x) { var tmp = 3 return function (y) { alert(x + y + (++tmp)) }}var bar = foo(2) // bar 现在是一个闭包bar(10) // 16bar(10) // 17 在第一种情况当中，不管执行多少次，输出当值都为 16，因为 bar 能访问 foo 的参数 x，也能访问 foo 的变量 tmp，但这还不是闭包，只有当你 return 的是内部 function 时，就是一个闭包（即这时才会产生一个闭包） 关于第二种情况，虽然 bar 不直接处于 foo 的内部作用域，但 bar 还是能访问 x 和 tmp，但是由于 tmp 仍存在于 bar 闭包的内部，所以它还是会自加 1，而且你每次调用 bar 时它都会自加 1 上面的 x 是一个字面值（值传递），和 JavaScript 里其他的字面值一样，当调用 foo 时，实参 x 的值被复制了一份，复制的那一份作为了 foo 的参数 x，那么问题来了，JavaScript 里处理 Object 时是用到引用传递的，那么，你调用 foo 时传递一个 Object，foo 函数 return 的闭包也会引用最初那个 Object，也就有了下面的第三种情况 1234567891011121314// 第三种情况function foo(x) { var tmp = 3 return function (y) { alert(x + y + tmp) x.memb = x.memb ? x.memb + 1 : 1 alert(x.memb) }}var age = new Number(2)var bar = foo(age) // bar 现在是一个引用了 age 的闭包bar(10) 不出我们意料，每次运行 bar(10)，x.memb 都会自加 1，但需要注意的是 x 每次都指向同一个 Object，运行两次 bar(10) 后，age.memb 会变成 2，这里还有一个不用 return 关键字的闭包例子 1234567function closureExample(objID, text, timedelay) { setTimeout(function () { document.getElementById(objID).innerHTML = text }, timedelay)}closureExample('myDiv', 'Closure is created', 500) 注意，外部函数不是必需的 通过访问外部变量，一个闭包可以维持（keep alive）这些变量，在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出，但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据，闭包经常用于创建含有隐藏数据的函数（但并不总是这样），看下面这段代码 12345678910111213141516171819202122var db = (function () { // 创建一个隐藏的 object, 这个 object 持有一些数据 // 从外部是不能访问这个 object 的 var data = {} // 创建一个函数, 这个函数提供一些访问 data 的数据的方法 return function (key, val) { if (val === undefined) { // get return data[key] } else { // set return data[key] = val } } // 我们可以调用这个匿名方法 // 返回这个内部函数，它是一个闭包})()db('x') // 返回 undefineddb('x', 1) // 设置 data['x'] 为 1db('x') // 返回 1 从上面的示例我们可以发现，我们不可能访问 data 这个对象本身，但是我们可以设置它的成员 实例九：下面两个函数有什么不同123456789101112131415161718192021// 示例一var scope = 'global scope'function checkscope() { var scope = 'local scope' function f() { return scope } return f()}checkscope()// 示例二var scope = 'global scope'function checkscope() { var scope = 'local scope' function f() { return scope } return f}checkscope()() 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？答案就是执行上下文栈的变化不一样，让我们分别来模拟两段代码的执行过程 第一段代码 1234ECStack.push(&lt;checkscope&gt; functionContext)ECStack.push(&lt;f&gt; functionContext)ECStack.pop()ECStack.pop() 第二段代码 1234ECStack.push(&lt;checkscope&gt; functionContext)ECStack.pop()ECStack.push(&lt;f&gt; functionContext)ECStack.pop() 关于两者更详细的不同，可以见 一道面试题引发的思考","link":"/2017/05/12/JavaScript/14/"},{"title":"JavaScript 中的深浅拷贝","text":"最后更新于 2020-02-22 深浅拷贝也算是一个老生常谈的话题了，它也是一些面试题当中的高频题目，所以今天就抽些时间来深入的了解一下 JavaScript 中的深浅拷贝，也算是记录记录，不过在此之前我们先来了解一下可能会与深浅拷贝所混淆的『赋值』概念 变量的赋值我们在之前的 JavaScript 中的数据类型 章节当中曾经提到过，在 JavaScript 中，变量包含两种不同的数据类型，即『基本类型』和『引用类型』，在将一个值赋给变量时，解析器必须确定这个值是基本类型还是引用类型 基本类型的值被直接存储在『栈』中，在变量定义时，栈就为其分配好了内存空间，由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 相对于具有不可变性的基本类型，我们习惯于把对象称为引用类型，引用类型的值实际存储在『堆内存』中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值 与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说我们不能直接操作对象的内存空间，所以在操作对象时，实际上是在操作对象的引用而不是实际的对象，所以变量的赋值行为可以分为『传值』与『传址』两种 给变量赋予基本数据类型的值，也就是『传值』，而给变量赋予引用数据类型的值，实际上是『传址』，基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较 12345678910var a = 123var b = 123var c = aa === b // truea === c // truea = 456a === b // falsea === c // false 引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较 1234567const a = [1, 2, 3]const b = ab.push(4)a // [1, 2, 3, 4]b // [1, 2, 3, 4]a === b // true 由于 a 和 b 都是引用类型，采用的是『址』传递，即 a 将地址传递给 b，那么 a 和 b 必然指向同一个地址（引用类型的地址存放在栈内存中），而这个地址都指向了堆内存中引用类型的值，当 b 改变了这个值的同时，因为 a 的地址也指向了这个值，故 a 的值也跟着变化 那么如果我们想让 b 的值在改变后不影响 a 的值的话，该如何解决呢？这也就引出了我们今天的主题『浅深拷贝』，下面我们就来看看如何解决这样的问题 什么是拷贝在展开之前，我们先来直观的感受一下『赋值』与『拷贝』的区别，比如下面这个示例 12345const a = [1, 2, 3]const b = ab[0] = 4b // [4, 2, 3] 这就是直接赋值的情况，不涉及任何拷贝，当我们改变 b 的时候，由于是同一个引用，所以 a 指向的值也会跟着改变，下面我们再来看看浅拷贝的情况，如下 123456const a = [1, 2, 3]const b = a.slice()b[0] = 4a // [1, 2, 3]b // [4, 2, 3] 当我们修改 b 的时候，a 的值并没有改变，这是因为这里的 b 是 a 浅拷贝后的结果，所以 b 和 a 现在引用的已经不是同一块空间了，而这也就是所谓的『浅拷贝』，但是别急着高兴，我们上面的操作是存在一个潜在问题的，我们将其简单的调整一下 12345const a = [1, 2, { val: 3 }]const b = a.slice()b[2].val = 4a // [1, 2, { val: 4 }] 我们发现了问题所在，为什么改变了 b 当中的第二个元素的 val 值，a 当中的 val 也跟着变了，上面不是说引用已经不是同一块空间了吗？这也就是浅拷贝的限制所在了，因为它只能拷贝一层对象，如果有对象的嵌套，那么浅拷贝将无能为力 但幸运的是，深拷贝就是为了解决这个问题而生的，它能解决对象嵌套的拷贝问题，实现彻底的拷贝，下面我们就先来看看它们两者之间的区别，然后在一步一步的来实现一个我们自己的『深拷贝』 深拷贝与浅拷贝我们先来明确一下深拷贝和浅拷贝的定义，其实两者的区别可以如下图所示 浅拷贝 简而言之，就是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象 深拷贝 将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象 话不多说，浅拷贝我们就不过多提及了，下面我们直接进入正题，来看看『深拷贝』到底该如何实现 入门版本如果我们的对象只是普通的对象，没有函数，Symbol，RegExp 等一系列特殊的对象的话，比较方便的方式就是使用下面这个方法 1JSON.parse(JSON.stringify()) 这种写法非常简单，而且可以应对大部分的应用场景，比如使用它来解决我们上面遇到的问题 123456const a = [1, 2, { val: 3 }]const b = JSON.parse(JSON.stringify(a))b[2].val = 4a // [1, 2, { val: 3 }]b // [1, 2, { val: 4 }] 但是它是有很大缺陷的，对于某些严格的场景来说，这个方法是有巨大的坑的，首先，无法解决循环引用的问题，比如下面这个示例 123const a = { val: 2 }a.target = a 我们使用上面的方式去拷贝 a 的话就会出现系统栈溢出的错误，因为出现了无限递归的情况，也就是说 JSON.stringify() 无法转换这样的结构 其次就是无法拷贝一些特殊的对象，诸如函数，Date，Set，Map 等，所以我们在某些要求比较严格的使用场景就需要另辟蹊径了 关于这两者更多内容可以参考我们之前整理过的 JSON.parse() &amp;&amp; JSON.stringify() 基础版本既然没有现成的 API 可用，那么我们就来尝试自己动手实现一个，如果只是浅拷贝的话，Object.assign()，我们上面用到的 slice() 或是 concat()，另外还有扩展运算符（...）等都可以帮助我们完成目标，但是它们当中的某些方法比较有局限性，比如说只能适用于数组，所以一个比较通用的浅拷贝通常是下面这样的 1234567const deepClone = (target) =&gt; { const cloneTarget = Array.isArray(target) ? [] : {} for (let prop in target) { cloneTarget[prop] = target[prop] } return cloneTarget} 简单来说就是创建一个新的对象，遍历需要拷贝的对象，将需要拷贝对象的属性依次添加到新对象上，返回即可 如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，所以针对上面的代码我们只需要稍微的调整一下就可以得到我们的『深拷贝』的基础版本，其中需要注意的有以下几点 如果是基本类型，无需继续拷贝，直接返回 如果是引用类型，创建一个新的对象，遍历需要拷贝的对象，将需要拷贝对象的属性执行『深拷贝』后依次添加到新对象上 很容易理解，如果有更深层次的对象可以继续递归直到属性为基本类型，这样我们就完成了一个最简单的深拷贝 12345678910111213const deepClone = (target) =&gt; { if (typeof target === 'object' &amp;&amp; target !== null) { const cloneTarget = Array.isArray(target) ? [] : {} for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop]) } } return cloneTarget } else { return target }} 下面来简单的测试下 123456789101112131415const target1 = { a: 1, b: undefined, c: { name: 2 }, d: [3, 4, 5], e: null}const target2 = deepClone(target1)target2.c.name = 4console.log(target1) // {a: 1, b: undefined, c: { name: 2 }, d: [3, 4, 5], e: null}console.log(target2) // {a: 1, b: undefined, c: { name: 4 }, d: [3, 4, 5], e: null} 现在基本功能已经基本实现了，但是之前遗留的几个问题，比如循环引用，特殊对象的拷贝等，我们都会在这个基础版本之上一步步来完善、优化我们的深拷贝代码 循环引用我们先来测试这样的一个示例，如下 12345678const target = { val: 1}target.target = target// ❌ Maximum call stack size exceededdeepClone(target) 很明显，因为递归进入死循环导致栈内存溢出了，而原因就是我们上面提到的对象循环引用的情况，即对象的属性间接或直接的引用了自身的情况，针对于这种循环引用的问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题 而这个存储空间，需要可以存储 key-value 形式的数据，且 key 可以是一个引用类型，所以我们可以选择 Map 这种数据结构（WeakMap 也可），具体流程如下 首先检查 Map 中有无拷贝过的对象 如果有，则直接返回 如果没有，则将当前对象作为 key，拷贝对象作为 value 进行存储 继续拷贝 这里我们将之前放在函数体内部的判断提取了出来，让函数主体更为简洁明了一些 12345678910111213141516171819const isObject = (target) =&gt; (typeof target === 'object' || typeof target === 'function') &amp;&amp; target !== nullconst deepClone = (target, map = new Map()) =&gt; { if (isObject(target)) { if (map.get(target)) { return map.get(target) } const cloneTarget = Array.isArray(target) ? [] : {} map.set(target, cloneTarget) for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map) } } return cloneTarget } else { return target }} 现在我们再来测试一下上面循环引用的示例 1234567891011const target = { val: 1}target.target = targetdeepClone(target)// {// val: 1,// target: [Circular]// } 现在可以看到，执行后已经没有报错了，并且 target 属性变为了一个 Circular 类型，即循环引用的意思，现在循环引用的问题已经解决了，下面我们再来看看特殊对象的处理需要如何操作 特殊对象的处理在上面的代码中，我们其实只考虑了普通的 object 和 array 两种数据类型，实际上引用类型的对象远远不止这两个，而对于特殊的对象，我们可以使用以下方式来进行鉴别 1const getType = obj =&gt; Object.prototype.toString.call(obj) 这一部分内容我们在之前的 类型判断 章节当中已经详细梳理过了，所以在这里我们就直接抽离出一些常用的数据类型以便后面使用，如下所示 12345678910const mapTag = '[object Map]'const setTag = '[object Set]'const boolTag = '[object Boolean]'const numberTag = '[object Number]'const stringTag = '[object String]'const symbolTag = '[object Symbol]'const dateTag = '[object Date]'const errorTag = '[object Error]'const regexpTag = '[object RegExp]'const funcTag = '[object Function]' 在上面的这些类型当中，我们可以简单的将它们分为两类 一类是可以继续遍历的类型 另一类是不可以继续遍历的类型 所以我们下面就分别来为它们做对应不同的拷贝处理 可继续遍历的类型上面我们提到过的 object、array 都属于可以继续遍历的类型，因为它们当中都还可以存储其他类型的数据，另外还有 Map，Set 等都是可以继续遍历的类型，但是这里需要注意的一点就是，我们在上面的实现当中，cloneTarget 是直接赋值给了 [] 或是 {}，这里存在的问题就是可能会造成原型的丢失 为了避免这个问题，我们在初始化的时候可以通过 target.constructor 的方式，然后在对其进行 new 操作，这是因为 {} 本质上就是 new Object() 的语法糖，另外我们还使用了原对象的构造方法，所以这样一来它就可以保留对象原型上的数据，而如果直接使用普通的 {}，那么原型必然是丢失了的（当然这种方式也是存在一些小问题的，我们会在后面来进行处理） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const isObject = (target) =&gt; (typeof target === 'object' || typeof target === 'function') &amp;&amp; target !== nullconst getType = obj =&gt; Object.prototype.toString.call(obj)const mapTag = '[object Map]'const setTag = '[object Set]'const canTraverse = { '[object Map]': true, '[object Set]': true, '[object Array]': true, '[object Object]': true, '[object Arguments]': true,}const deepClone = (target, map = new Map()) =&gt; { // 基本类型直接返回 if (!isObject(target)) { return target } // 初始化 let type = getType(target) let cloneTarget if (!canTraverse[type]) { // 处理不能继续遍历的对象，下面会进行完善 return } else { // 处理可以继续遍历的对象，保证对象的原型不丢失 let ctor = target.constructor cloneTarget = new ctor() } // 防止循环引用 if (map.get(target)) { return target } map.set(target, true) // 处理 Map if (type === mapTag) { target.forEach((item, key) =&gt; { cloneTarget.set(deepClone(key, map), deepClone(item, map)) }) } // 处理 Set if (type === setTag) { target.forEach(item =&gt; { cloneTarget.add(deepClone(item, map)) }) } // 处理数组和对象 for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map) } } return cloneTarget} 再来简单的测试一下 123456789101112131415161718192021const map = new Map()map.set('key', 'value')const set = new Set()set.add('key')set.add('value')const target = { a: 1, b: undefined, c: { name: 2 }, d: [3, 4, 5], e: null, map, set,}// {a: 1, b: undefined, c: { name: 2 }, d: [3, 4, 5], e: null, Map: { 'key' =&gt; 'value' }, Set: { 'key', 'value' }}deepClone(target) 没有问题，下面我们再来继续处理其他类型 不可继续遍历的类型针对于不可遍历的对象，不同的对象有不同的处理，下面我们来看看如何进行完善 1234567891011121314151617181920212223242526const cloneReg = (target) =&gt; { const { source, flags } = target return new target.constructor(source, flags)}const cloneFunc = (target) =&gt; { // 下面会详细介绍}const cloneOtherType = (target, tag) =&gt; { const Ctor = targe.constructor switch (tag) { case boolTag: case numberTag: case stringTag: case errorTag: case dateTag: return new Ctor(target) case regexpTag: return cloneReg(target) case funcTag: return cloneFunc(target) default: return new Ctor(target) }} 仔细观察的话可以发现，我们在这里少罗列了一种类型，那就是 Symbol 类型，不过不要着急，我们会在下面完善的时候一起来进行介绍 拷贝函数虽然函数也是对象，但是它过于特殊，所以这里我们就单独把它拿出来进行拆解，实际上函数拷贝是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我们可以参考 lodash 里的 _.clone(value) 方法的源码当中对于函数的处理，如下 12345const isFunc = typeof value == 'function'if (isFunc || !cloneableTags[tag]) { return object ? value : {}} 可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，话虽这么说，但是在这里我们还是简单的扩展一些，来看看到底如何完善函数的拷贝 在 JavaScript 中有两种函数，一种是普通函数，另一种是箭头函数，每个普通函数都是 Function 的实例，而箭头函数不是任何类的实例，并且每次调用都是不一样的引用，所以简单的归纳一下就是我们只需要处理普通函数的情况，而箭头函数的话就直接返回它本身就可以了 我们可以使用正则来处理普通函数，分别使用正则取出函数体和函数参数，然后使用 new Function([arg1[, arg2[, ...argN]]] functionBody) 构造函数重新构造一个新的函数 至于如何区分普通函数和箭头函数呢？我们可以通过 prototype 来进行区分，因为箭头函数是没有 prototype 的 1234567891011121314151617const cloneFunc = (func) =&gt; { // 箭头函数直接返回自身 if (!func.prototype) return func const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/ const funcString = func.toString() // 分别匹配 函数参数 和 函数体 const param = paramReg.exec(funcString) const body = bodyReg.exec(funcString) if (!body) return null if (param) { const paramArr = param[0].split(',') return new Function(...paramArr, body[0]) } else { return new Function(body[0]) }} 到现在，我们的深拷贝就差不多比较完善了，不过还存在一些小问题，我们接着往下看 布尔包装类我们在之前曾提到过，在初始化的时候，如果直接使用 {} 可能会造成原型的丢失问题，所以我们采用了 target.constructor 的方式，但是这样的方式对于布尔包装类会存在一些小问题，如下 12345const target = new Boolean(false)const Ctor = target.constructor// 结果为 Boolean {true} 而不是 falsenew Ctor(target) 对于这样的问题，我们可以单独针对 Boolean 类型的拷贝做最简单的修改，即调用它的 valueOf，也就是调整为下面这样 1new target.constructor(target.valueOf()) 但实际上，这种写法是不推荐的，因为在 ES6 后已经不再推荐使用这种对于基本类型直接使用 new 操作的语法了，所以 ES6 中的新类型 Symbol 是不能直接使用 new 的，而是需要通过 new Object(SymbelType) 来进行调用，所以我们可以来调整一下我们之前的写法，也顺路将我们之前遗留的 Symbol 类型统一进去 12345678910111213141516171819202122const cloneOtherType = (target, tag) =&gt; { const Ctor = target.constructor switch (tag) { case boolTag: return new Object(Boolean.prototype.valueOf.call(target)) case numberTag: return new Object(Number.prototype.valueOf.call(target)) case stringTag: return new Object(String.prototype.valueOf.call(target)) case symbolTag: return new Object(Symbol.prototype.valueOf.call(target)) case errorTag: case dateTag: return new Ctor(target) case regexpTag: return cloneFunc(target) case funcTag: return cloneFunc(target) default: return new Ctor(target) }} 这样一来，我们的深拷贝也算是比较完善了 完整代码最终完善后的代码汇总如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const getType = obj =&gt; Object.prototype.toString.call(obj)const isObject = (target) =&gt; (typeof target === 'object' || typeof target === 'function') &amp;&amp; target !== nullconst canTraverse = { '[object Map]': true, '[object Set]': true, '[object Array]': true, '[object Object]': true, '[object Arguments]': true,}const mapTag = '[object Map]'const setTag = '[object Set]'const boolTag = '[object Boolean]'const numberTag = '[object Number]'const stringTag = '[object String]'const symbolTag = '[object Symbol]'const dateTag = '[object Date]'const errorTag = '[object Error]'const regexpTag = '[object RegExp]'const funcTag = '[object Function]'const handleRegExp = (target) =&gt; { const { source, flags } = target return new target.constructor(source, flags)}const cloneFunc = (func) =&gt; { if (!func.prototype) return func const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/ const funcString = func.toString() const param = paramReg.exec(funcString) const body = bodyReg.exec(funcString) if (!body) return null if (param) { const paramArr = param[0].split(',') return new Function(...paramArr, body[0]) } else { return new Function(body[0]) }}const cloneOtherType = (target, tag) =&gt; { const Ctor = target.constructor switch (tag) { case boolTag: return new Object(Boolean.prototype.valueOf.call(target)) case numberTag: return new Object(Number.prototype.valueOf.call(target)) case stringTag: return new Object(String.prototype.valueOf.call(target)) case symbolTag: return new Object(Symbol.prototype.valueOf.call(target)) case errorTag: case dateTag: return new Ctor(target) case regexpTag: return cloneFunc(target) case funcTag: return cloneFunc(target) default: return new Ctor(target) }}const deepClone = (target, map = new Map()) =&gt; { if (!isObject(target)) return target let type = getType(target) let cloneTarget if (!canTraverse[type]) { return cloneOtherType(target, type) } else { let ctor = target.constructor cloneTarget = new ctor() } if (map.get(target)) return target map.set(target, true) if (type === mapTag) { target.forEach((item, key) =&gt; { cloneTarget.set(deepClone(key, map), deepClone(item, map)) }) } if (type === setTag) { target.forEach(item =&gt; { cloneTarget.add(deepClone(item, map)) }) } for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map) } } return cloneTarget} 最后我们再来简单的测试一下，如下 123456789101112131415161718192021222324252627282930313233const map = new Map()map.set('key', 'value')const set = new Set()set.add('key')set.add('value')const target = { a: 1, b: undefined, c: { name: 2 }, d: [3, 4, 5], e: null, map, set, bool: new Boolean(true), num: new Number(2), str: new String(2), symbol: Object(Symbol(1)), date: new Date(), reg: /\\d+/, error: new Error(), func1: () =&gt; { console.log('func1') }, func2: function (a, b) { return a + b }}deepClone(target) 结果如下 123456789101112131415161718{ a: 1, b: undefined, bool: [Boolean: true], c: { name: 2 }, d: [3, 4, 5], date: Mon Feb 22 2020 22:14:00 GMT+0800 (中国标准时间) {}, e: null, error: Error, func1: () =&gt; { console.log('func1') }, func2: [ƒ anonymous(a, b)], map: {'key' =&gt; 'value'} num: [Number: 2], reg: /\\d+/, set: {'key', 'value'} str: [String: '2'] ， symbol: [Symbol: Symbol(1)],} Vuex 当中的实现最后的最后，我们再来看看 Vuex 当中 deepCopy 的源码部分，与我们手动实现的版本可以做一个对比，加深印象，实现如下 12345678910111213141516171819function deepCopy(obj, cache = []) { if (obj === null || typeof obj !== 'object') { return obj } const hit = cache.filter(c =&gt; c.original === obj)[0] if (hit) { return hit.copy } const copy = Array.isArray(obj) ? [] : {} // 将 copy 首先放入 cache，因为我们需要在递归 deepCopy 的时候引用它 cache.push({ original: obj, copy }) Object.keys(obj).forEach(key =&gt; { copy[key] = deepCopy(obj[key], cache) }) return copy} 这里我们着重介绍这一部分 12345const hit = cache.filter(c =&gt; c.original === obj)[0]if (hit) { return hit.copy} 这一部分判断的作用主要是针对如果传入的对象与缓存的相等，则递归结束，这样可以防止循环，类似下面这种 12var a = { b: 1 }a.c = a 更多详细内容可以参考 MDN 上面的 TypeError: cyclic object value 当然你可能会发现，这里并没有针对 Map，Set，Date 等特殊对象来进行处理，因为针对于我们平常的开发任务来说，针对性的处理 {} 和 [] 就已经足够我们使用了，当然还是需要根据实际使用场景来选择最为适合的方式 参考 Lodash clone","link":"/2018/01/14/JavaScript/24/"},{"title":"跨域","text":"之所以会出现跨域问题，主要是因为 浏览器的同源策略 所引起的，简单来说就是 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制 受到同源限制 无法读取不同源的 Cookie、LocalStorage 和 IndexDB 无法获得不同源的 DOM 不能向不同源的服务器发送 Ajax 请求 不受同源限制 在浏览器中 &lt;script&gt;，&lt;img&gt;，&lt;iframe&gt;，&lt;link&gt; 等标签都可以跨域加载资源，而不受同源策略的限制 什么是跨域我们先来看看一个域名的组成，比如 1http://www.aaa.com:8080/script/index.js 一般由 协议（http://），子域名（www），主域名（aaa.com），端口号（8080），请求资源地址（script/index.js）组成 协议，网络协议遍及 OSI 通信模型（OSI 七层模型，常用协议有 TCP/IP、HTTP、FTP 协议等） 域名，Domain Name，网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置） 端口，是设备与外界通讯交流的出口，分为物理端口和虚拟端口（比如常见的 80 端口） 当协议，子域名，主域名，端口号中任意一个不相同的时候，都算作不同域，不同域之间相互请求资源，就算作跨域，比如 http://www.aaa.com/index.html 请求 http://bbb.com/index.php，JavaScript 出于安全方面的考虑，不允许跨域调用其他页面的对象，简单的理解就是因为 JavaScript 同源策略的限制，a.com 域名下的 JavaScript 无法操作 b.com 或是 c.a.com 域名下的对象 所谓同源策略，即同域名（IP），同端口，同协议 CORSCORS 全称 Cross-Origin Resource Sharing，是 W3C 的一个标准，它定义如何跨域访问资源，浏览器将 CORS 请求分成两类，简单请求（simple request）和非简单请求（not-so-simple request），如下 请求方法是以下三种方法之一，HEAD、GET、POST HTTP 的头信息不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type，只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 只要同时满足以下两大条件，就属于简单请求，不同时满足上面两个条件，就属于非简单请求 简单请求浏览器会带上 Origin 的请求头发送到服务器，服务器根据 Origin 判断是否许可，如果许可就会带上 CORS 相关响应头，如果不在许可范围内就不会带上 CORS 相关的响应头，浏览器再根据响应头中是否有相关的 CORS 响应头，来判断拦截响应 body 和抛出错误 无论你是否需要用 JavaScript 通过 CORS 跨域请求资源，你都要了解 CORS 的原理，最新的浏览器全面支持，在引用外域资源时，除了 JavaScript 和 CSS 外，都要验证 CORS，例如当你引用了某个第三方 CDN 上的字体文件时 1234@font-face { font-family: 'FontAwesome'; src: url('../fontawesome.ttf') format('truetype');} 如果该 CDN 服务商未正确设置 Access-Control-Allow-Origin，那么浏览器无法加载字体资源 非简单请求对于 PUT、DELETE 以及其他类型如 application/json 的 POST 请求，在发送 Ajax 请求之前，浏览器会先发送一个 OPTIONS 请求（带着 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等 CORS 相关的请求头的预检请求）到这个 URL 上，询问目标服务器是否接受 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的 Method 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的 Access-Control-Allow-Methods 头确实包含将要发送的 Ajax 请求的 Method，才会继续发送 Ajax，否则抛出一个错误（可见下方实例），由于以 POST、PUT 方式传送 JSON 格式的数据在 REST 中很常见，所以要跨域正确处理 POST 和 PUT 请求，服务器端必须正确响应 OPTIONS 请求，更多关于 CORS 的信息可以查阅 跨域资源共享 CORS 详解 处理跨域的方法处理跨域的方法有很多，比如之前比较常见的 JSONP，亦或者现在比较常用的 CORS，所以我们就在这里小小的总结了一下解决跨域的相关方法，下面我们就一个一个来看 CORS也算是目前使用较多的一种方式，针对于普通跨域请求（简单请求），只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，Origin 表示本域，也就是浏览器当前页面的域 当 JavaScript 向外域（如 sina.com）发起请求后，浏览器收到响应后，首先检查 Access-Control-Allow-Origin 是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript 将无法获取到响应的任何数据，假设本域是 my.com，外域是 sina.com，只要响应头 Access-Control-Allow-Origin 为 http://my.com，或者是 *，本次请求就可以成功，可见跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的 Access-Control-Allow-Origin，决定权始终在对方（服务器）手中 不过有一个需要注意的地方，那就是跨域请求默认不会携带 Cookie 信息，如果需要携带，可以采取如下操作 1'Access-Control-Allow-Credentials': true 或者在请求当中配置 1http.post(url, data, { withCredentials: true }) 如果是非简单请求，前台则需要添加额外的 Headers 来触发非简单请求，比如下面的示例，前台采用 Ajax 123456789101112131415var xhr = new XMLHttpRequest()xhr.withCredentials = truexhr.open('post', 'http://www.aaa.com', true)// 添加额外的 Headers 来触发非简单请求xhr.setRequestHeader('Content-Type', 'application/json')xhr.send()xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText) }} 后台采用 Node.js 123456789101112131415161718192021222324252627var http = require('http')var server = http.createServer()var qs = require('querystring')server.on('request', function (req, res) { var postData = '' req.addListener('data', function (chunk) { postData += chunk }) req.addListener('end', function () { postData = qs.parse(postData) // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送 Cookie 'Access-Control-Allow-Origin': 'http://www.aaa.com', // 允许访问的域（协议 + 域名 + 端口） 'Set-Cookie': 'x=123;Path=/;Domain=www.aaa.com;HttpOnly' // HttpOnly 的作用是让 JavaScript 无法读取 Cookie }) res.write(JSON.stringify(postData)) res.end() })})server.listen('8000') JSONPJSONP（JSON With Padding）是 JSON 的一种使用模式，可用于解决主流浏览器的跨域数据访问的问题，主要原理是借助 &lt;script&gt; 等标签的 src 属性可以请求不同域名下的资源，即 &lt;script&gt; 请求不受浏览器同源策略影响，实现过程主要通过网页客户端动态添加 &lt;script&gt; 标签内的 src 属性，向服务端发送请求（不受同源策略束缚），当服务器收到请求后，将数据放在一个指定名字的回调函数里（作为参数）传回来，前台代码如下示例 123456789101112var script = document.createElement('script')script.src = 'http://localhost:3000/jsonp?callback=_callback'// 插入标签document.body.appendChild(script)// 回调处理函数var _callback = function (obj) { for (key in obj) { console.log('key: ' + key + ' value: ' + obj[key]) }} 上面的 &lt;script&gt; 标签会向本地服务器发送请求，这个请求的后面带了个 callback 参数，是用来告诉服务器回调方法的方法名的，因为服务器收到请求后，会把相应数据写进回调函数的参数位置，后端响应代码如下 123456789app.get('/jsonp', (req, res) =&gt; { let callback = req.query.callback; let obj = { type: 'jsonp', name: 'weapon-x' }; res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.end(callback + '(' + JSON.stringify(obj) + ')');}) 这样浏览器通过 &lt;script&gt; 下载的资源就是上面的脚本了，当 &lt;script&gt; 下载完成就会立即执行，也就是说这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到 JSON 数据，但是有一个需要注意的地方，JSONP 只支持 GET 请求方式，因为本质上 &lt;script&gt; 加载资源就是 GET，但是如果我们需要发送 POST 请求那该怎么办呢？ iframe + form如果想要发送 POST 请求，可以采用这种方式，主要原理是利用 iframe 标签的跨域能力，我们先来看看前台代码 123456789101112131415161718192021222324252627282930313233343536373839404142const requestPost = ({ url, data }) =&gt; { // 首先创建一个用来发送数据的 iframe，并且将其隐藏 const iframe = document.createElement('iframe') iframe.name = 'iframePost' iframe.style.display = 'none' document.body.appendChild(iframe) // 获取元素 const form = document.createElement('form') const node = document.createElement('input') // 注册 iframe 的 load 事件处理程序，如果你需要在响应返回时执行一些操作的话 iframe.onload = function() { console.log('post success') } // 在指定的 iframe 中执行 form form.action = url form.target = iframe.name form.method = 'post' for (let name in data) { node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) } // 表单元素需要添加到主文档中 form.style.display = 'none' document.body.appendChild(form) form.submit() // 表单提交后，就可以删除这个表单，不影响下次的数据发送 document.body.removeChild(form)}// 使用方式requestPost({ url: 'http://localhost:3000', data: { msg: 'hello' }}) 后台来接收并处理数据 123456789101112// 处理成功失败返回格式的工具const { successBody } = require('./utli')class CrossDomain { static async iframePost(ctx) { let postData = ctx.request.body console.log(postData) ctx.body = successBody({ postData: postData }, 'success') }}module.exports = CrossDomain 这样一来我们就可以发送 POST 请求了 document.domain + iframe这种方法有些局限性，仅限主域相同，子域不同的跨域应用场景，实现原理就是让两个页面都通过 JavaScript 强制设置 document.domain 为同一域名，这样一来就实现了同域，这里有两种场景 第一种场景是在父页面调用内嵌的 iframe 当中的元素，如下 我们的父窗口是 http://www.aaa.com/a.html 子窗口（内嵌的 iframe）是 http://www.aaa.com/b.html 这时候如果想在 a 页面里获取 b 页面里的 DOM 进行操作，就会发现你不能获得 b 的 DOM，比如使用 document.getElementById('myIFrame').contentWindow.document 或者 window.parent.document.body 都获取不到，都将因为两个窗口不同源而报错，在这个时候只需要在 a 页面里和 b 页面里把 document.domain 设置成相同的值就可以在两个页面里操作 DOM 了 1234567891011121314&lt;!-- 父窗口当中内嵌子页面 --&gt;&lt;iframe id=\"myIFrame\" src=\"http://www.aaa.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com' var user = 'admin'&lt;/script&gt;&lt;!-- 子页面当中设置相同的 domain --&gt;&lt;script&gt; document.domain = 'domain.com' // 获取父窗口中变量 alert('get js data from parent ==&gt; ' + window.parent.user)&lt;/script&gt; 第二种场景是共享 Cookie 引起的问题 在 a 页面里写入了 document.cookie = 'test1=hello'，但是在 b 页面当中是获取不到这个 Cookie 的，Cookie 是服务器写入浏览器的一小段信息，只有『同源』的网页才能共享，但是两个网页一级域名相同，只是二级域名不同，在这种情况下浏览器允许通过设置 document.domain 来共享 Cookie 另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，这样的话，二级域名或者三级域名不用做任何设置，都可以读取这个 Cookie，但是这里有一些需要注意的地方 document.domain 也是有限制的，虽然可读写，但只能设置成自身或者是高一级的父域且主域必须相同，所以只能解决一级域名相同二级域名不同的跨域问题 document.domain 只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法跨域 window.name + iframewindow 对象有个 name 属性，该属性有个特征，即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置，并且可以支持非常长的 name 值（2MB），这里可以分为下面几种情况 第一种情况是在同一个浏览器标签页里打开了不同域名下的页面 比如先在浏览器的一个标签页里打开了 http://www.aaa.com/a.html 页面，你通过 location.href = http://www.bbb.com/b.html 在同一个浏览器标签页里打开了不同域名下的页面，这时候这两个页面可以使用 window.name 来传递参数，因为 window.name 指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个网页里访问值都是一样的 第二种情况和上面的 document.domain + iframe 当中的第一种场景类似，但是不同之处就是两个页面的一级域名也不相同，这时候 document.domain 就解决不了了 这个时候就可以使用 window.name 来解决，比如你在 b 页面里设定 window.name='hello'，你再返回到 a 页面，在 a 页面里访问 window.name，可以得到 hello 第三种情况比较少见，动态创建 iframe，利用 window.name 来传递数据，成功后再切换到同域代理页面，如下，这里分为三个页面 父窗口，http://www.aaa.com/a.html 中间代理页面，http://www.aaa.com/proxy.html，中间代理页，与 a.html 同域，内容为空即可 子窗口（内嵌的 iframe），http://www.bbb.com/b.html（一级域名也不相同） 12345678910111213141516171819202122232425262728293031var proxy = function (url, callback) { // 防止页面无限刷新 var state = 0 var iframe = document.createElement('iframe') // 加载跨域页面 iframe.src = url // onload 事件会触发 2 次，第 1 次加载跨域页，并留存数据于 window.name iframe.onload = function () { if (state === 0) { // 第 1 次 onload 成功后（跨域页），切换到同域代理页面（指向当前域），为防止错误，可以设置为空白页面 iframe.contentWindow.location = 'http://www.aaa.com/proxy.html' state = 1 } else if (state === 1) { // 第 2 次 onload 成功后（同域的 proxy.html），读取同域 window.name 中数据 callback(iframe.contentWindow.name) // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域的 iframe 访问） iframe.contentWindow.document.write('') iframe.contentWindow.close() document.body.removeChild(iframe) } } document.body.appendChild(iframe)}// 请求跨域 b 页面数据proxy('http://www.bbb.com/b.html', function (data) { alert(data)}) 使用的话，在 b 页面当中直接设置 window.name 即可 12// b 页面window.name = 'This is page b data!' 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域，这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作 location.hashlocation.hash 就是指 url 的 # 号后面的部分，这种情况一般使用在父窗口和 iframe 的子窗口之间通讯或者是 window.open 打开的子窗口之间的通讯，如果是两个不同域的页面 a 和 b 之间需要相互通信，则需要通过借助中间页 c 来实现，实现原理如下 1a.html（A 域） ==&gt; b.html（B 域） ==&gt; c.html（A 域） a 与 b 不同域只能通过 Hash 值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象，实例如下，三个测试页面如下 A 域下的 a.html，地址为 http://www.aaa.com/a.html B 域下的 b.html，地址为 http://www.bbb.com/b.html A 域下的 c.html，地址为 http://www.ccc.com/c.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- A 域下的 a.html（内嵌 B 域下的 b.html） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.bbb.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') // 向b.html传hash值 setTimeout(function () { iframe.src = iframe.src + '#user=zhangsan' }, 1000) // 开放给同域 c.html 使用的回调方法 function onCallback(res) { alert('data from c.html ==&gt; ' + res) }&lt;/script&gt;&lt;!-- B 域下的 b.html（内嵌 A 域下的 c.html） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.aaa.com/c.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') // 监听 a.html 传来的 hash 值，再传给 c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash }&lt;/script&gt;&lt;!-- A 域下的 c.html --&gt;&lt;script&gt; // 监听 b.html 传来的 hash 值 window.onhashchange = function () { // 再通过操作同域 a.html 当中提供的回调函数，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')) }&lt;/script&gt; postMessagepostMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨域数据传递 语法如下 1window.postMessage(message, targetOrigin, [transfer]) 有三个参数 data，向目标窗口发送的数据，任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify() 序列化 origin，协议 + 主机 + 端口号，也可以设置为 *，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为 '/' transfer，可选参数，是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权 另外消息的接收方必须有监听事件，否则发送消息时就会报错，如下所示 1The target origin provided ('http://localhost:3000') does not match the recipient window's origin ('http://localhost:3001'). 接收消息可以直接监听 window 对象的 message 事件即可 1window.addEventListener('message', callback) callback 接收到的 message 事件包含三个属性 data，从其他 window 中传递过来的数据 origin，调用 postMessage 时消息发送方窗口的 origin 需要注意的是，这个 origin 不能保证是该窗口的当前或未来 origin 因为 postMessage 被调用后可能被导航到不同的位置 source，对发送消息的窗口对象的引用，可以使用此来在具有不同 origin 的两个窗口之间建立双向通信 简单来说，就是一个页面发送数据，另一个页面接收数据，下面来看一个实例 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 父页面（内嵌一个 iframe，内容为页面 b） --&gt;&lt;iframe id=\"iframe\" src=\"http://www.bbb.com/index.html\" style=\"display:none\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe') iframe.onload = function () { var data = { name: 'zhangsan' } // 向 b 页面发送数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.bbb.com') } // 接受 b 页面返回的数据 window.addEventListener('message', function (e) { alert('data from page b ==&gt; ' + e.data) }, false)&lt;/script&gt;&lt;!-- 子页面 --&gt;&lt;script&gt; // 接收 a 页面的数据 window.addEventListener('message', function (e) { alert('data from page a ==&gt; ' + e.data) var data = JSON.parse(e.data) if (data) { data.age = 18 // 处理后再发回给 a 页面 window.parent.postMessage(JSON.stringify(data), 'http://www.aaa.com') } }, false)&lt;/script&gt; Nginx 代理基本原理是我们请求的时候还是使用的前端域名，但是 Nginx 会帮我们把这个请求转发到真正的后端域名上，这样就可以避免跨域问题，Nginx 配置如下 123456789101112server{ # 监听 3000 端口 listen 3000; # 域名是 localhost server_name localhost; # 凡是类似 localhost:3000/api 这样的请求，都会转发到真正的服务端地址 http://localhost:3001 location ^ ~ /api { proxy_pass http://localhost:3001; }} 在请求的时候，还是跟往常一样正常请求即可 123456789101112// 请求的时候直接使用 http://localhost:3000// Nginx 会帮我们进行监听fetch('http://localhost:3000', { method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ msg: 'hello' })}) Node.js 中间件代理跨域中间件实现跨域代理，原理大致与 Nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 Cookie 中域名，实现当前域的 Cookie 写入，方便接口登录认证，利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器 前台代码如下 12345678var xhr = new XMLHttpRequest()// 前端开关，浏览器是否读写 Cookiexhr.withCredentials = true// 访问 http-proxy-middleware 代理服务器xhr.open('get', 'http://www.aaa.com/login?user=zhangsan', true)xhr.send() 中间件服务器代码如下 123456789101112131415161718192021var express = require('express')var proxy = require('http-proxy-middleware')var app = express()app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.bbb.com', changeOrigin: true, // 修改响应头信息，实现跨域并允许带 Cookie onProxyRes: function (proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.aaa.com') res.header('Access-Control-Allow-Credentials', 'true') }, // 修改响应信息中的cookie域名 // 可以为 false，表示不修改 cookieDomainRewrite: 'www.aaa.com'}))app.listen(3000) 后台代码如下 123456789101112131415161718var http = require('http')var server = http.createServer()var qs = require('querystring')server.on('request', function (req, res) { var params = qs.parse(req.url.substring(2)) // 向前台写 Cookie // HttpOnly 表示脚本无法读取 res.writeHead(200, { 'Set-Cookie': 'x=123;Path=/;Domain=www.bbb.com;HttpOnly' }) res.write(JSON.stringify(params)) res.end()})server.listen('3000') 如果使用的是 Webpack 构建的项目，可以使用 webpack-dev-server 代理接口跨域，在开发环境下，由于渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无须设置 Headers 跨域信息了，webpack.config.js 部分配置如下 12345678910111213141516module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.bbb.com', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: 'www.aaa.com' // 可以为 false，表示不修改 }], noInfo: true }} WebSocket 协议跨域WebSocket protocol 是 HTML5 一种新的协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现，原生 WebSocket API 使用起来不太方便，我们可以选择使用 Socket.io，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容 前台代码如下 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=\"text\"&gt;&lt;/div&gt;&lt;script src=\"./socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.bbb.com'); // 连接成功处理 socket.on('connect', function () { // 监听服务端消息 socket.on('message', function (msg) { console.log('data from server: ==&gt; ' + msg) }) // 监听服务端关闭 socket.on('disconnect', function () { console.log('Server socket has closed.') }) }) document.getElementsByTagName('input')[0].onblur = function () { socket.send(this.value) };&lt;/script&gt; 后台代码如下 1234567891011121314151617181920212223242526var http = require('http')var socket = require('socket.io')// http 服务var server = http.createServer(function (req, res) { res.writeHead(200, { 'Content-type': 'text/html' }) res.end()})server.listen('3000')// 监听 socket 连接socket.listen(server).on('connection', function (client) { // 接收信息 client.on('message', function (msg) { client.send('hello：' + msg) console.log('data from client: ==&gt; ' + msg) }) // 断开处理 client.on('disconnect', function () { console.log('Client socket has closed.') })}) 总结处理跨域的方法有许多种，现在比较流行的还是使用 CORS 的方式，也就是服务端来进行设置，从而一劳永逸，不过多了解一些其他的方式也是不错的，还是那句老话，根据实际使用场景来进行选择","link":"/2018/04/26/JavaScript/33/"},{"title":"JavaScript 中 Promise 的实现","text":"之前重新梳理了一下 JavaScript 中的 Promise 的相关内容，也算是又温习了一遍 Promise 相关知识点，本章当中我们就来看看关于 Promise 的最后一部分内容，也就是 Promise 的内部实现原理 参考了网上各路大神的实现方式，发现虽然实现方式各有不同，但是原理都是十分类似的，所以下面就让我们站在巨人的肩膀上来实现一个我们自己版本的 Promise，尽量做到浅显易懂 基本结构我们先来看一个官方版本的 Promise 的简单使用方式，如下 1234567const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('result') }, 1000)})p1.then(res =&gt; console.log(res), err =&gt; console.log(err)) 观察上面这个示例我们可以发现，构造函数 Promise 必须接受一个函数作为参数，我们称该函数为 executor，executor 又包含 resolve 和 reject 两个参数，它们是两个函数，而内部的异步任务（这里是 setTimeout()）则会被放入对应任务队列，等待我们去调用 then() 来进行执行 所以我们可以明显的意识到这其实就是一个观察者（收集依赖 =&gt; 触发通知 =&gt; 取出依赖执行）模式，所以我们可以依据这个流程得出我们的 Promise 大致模样 12345678910111213141516171819202122232425262728293031class MyPromise { constructor(executor) { if (!isFunction(executor)) { throw new Error(`MyPromise must accept a function as a parameter`) } this._fulfilledQueues = [] // 成功回调函数队列 this._rejectedQueues = [] // 失败回调函数队列 try { executor(this._resolve.bind(this), this._reject.bind(this)) } catch (err) { this._reject(err) } } _resolve(val) { // 依次执行成功队列中的函数，并清空队列 while (this._fulfilledQueues.length) { const callback = this._fulfilledQueues.shift() callback(val) } } _reject(val) { // 依次执行成功队列中的函数，并清空队列 while (this._rejectedQueues.length) { const callback = this._rejectedQueues.shift() callback(val) } }} 这里的 isFunction 就是一个简单的判断参数是否为函数的方法，如下 1const isFunction = fn =&gt; typeof fn === 'function' 我们建立了两个回调队列，将每次 then 方法注册时的回调函数添加到数组中等待执行，之所以使用一个队列来储存回调，是因为我们知道 then 方法可以被同一个 Promise 调用多次，所以如果使用一个变量而非队列来储存回调，那么即使多次 p1.then() 也只会执行一次回调，其次当 resolve 或 reject 方法执行时，我们可以依次提取成功或失败任务队列当中的函数来进行执行，并清空队列，从而实现 then 方法的多次调用 但是我们在平常在使用 Promise 的时候，都知道它内部是含有多个状态的，所以下面我们再来看看如何给我们的 Promise 添加状态 Promises/A+ 规范我们都知道，Promise 对象存在以下三种状态 Pending（进行中） Fulfilled（已成功） Rejected（已失败） 之所以有这几种状态，是因为 ES6 中的 Promise 的实现需要遵循 Promises/A+ 规范，是规范对 Promise 的状态控制做了要求，规范当中涉及到的内容比较多，在这里我们只总结两条核心规则，如下 Promise 本质是一个状态机，且状态只能为以下三种，即 Pending（等待态）、Fulfilled（执行态）和 Rejected（拒绝态），状态的变更是单向的，只能从 Pending =&gt; Fulfilled 或者 Pending =&gt; Rejected，并且状态的变更不可逆 then 方法接收两个可选参数，分别对应状态改变时触发的回调，then 方法返回一个新的 Promise，并且可以被同一个 Promise 调用多次 如下图所示 所以根据规范，我们再来补充一下我们的 Promise 代码，添加状态和值，并添加状态改变的执行逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const isFunction = fn =&gt; typeof fn === 'function'const PENDING = 'PENDING'const FULFILLED = 'FULFILLED'const REJECTED = 'REJECTED'class MyPromise { constructor(executor) { if (!isFunction(executor)) { throw new Error(`MyPromise must accept a function as a parameter`) } this._status = PENDING // 当前状态 this._value = undefined // 回调返回的值 this._fulfilledQueues = [] // 成功回调函数队列 this._rejectedQueues = [] // 失败回调函数队列 try { executor(this._resolve.bind(this), this._reject.bind(this)) } catch (err) { this._reject(err) } } _resolve(val) { // 我们将上面的 _resolve 执行回调的操作封装成一个函数，放进 setTimeout 里，以兼容 executor 是同步代码的情况 const run = () =&gt; { if (this._status !== PENDING) return this._status = FULFILLED this._value = val while (this._fulfilledQueues.length) { const callback = this._fulfilledQueues.shift() callback(val) } } setTimeout(run) } _reject(err) { // 同理 const run = () =&gt; { if (this._status !== PENDING) return this._status = REJECTED this._value = err while (this._rejectedQueues.length) { const callback = this._rejectedQueues.shift() callback(val) } } setTimeout(run) }} 为了支持同步的 Promise，我们将之前同步的回调放到了一个 run 函数当中，并且采用了异步调用的方式，这样一来我们就实现了 Promise 状态和值的改变，下面我们再来看看 Promise 的核心方法 then 的实现 then 方法Promise 对象的 then 方法接受两个参数，一个成功的回调和一个失败的回调 1promise.then(onFulfilled, onRejected) 我们还是和上面一样，根据 Promises/A+ 规范来梳理一下 then 方法实现当中需要注意的地方，首先 onFulfilled 和 onRejected 都是可选参数，如果 onFulfilled 或 onRejected 不是函数，需要被忽略 onFulfilled 的特性 如果 onFulfilled 不是函数，忽略 当 Promise 状态变为成功时必须被调用，其第一个参数为 Promise 成功状态传入的值（resolve 执行时传入的值） 在 Promise 状态改变前其不可被调用 其调用次数不可超过一次 onRejected 的特性 如果 onRejected 不是函数，忽略 当 Promise 状态变为失败时必须被调用，其第一个参数为 Promise 失败状态传入的值（reject 执行时传入的值） 在 Promise 状态改变前其不可被调用 其调用次数不可超过一次 其次我们还需要注意多次调用的情况，因为 then 方法可以被同一个 Promise 对象调用多次，所以在这里需要注意 当 Promise 成功状态时，所有 onFulfilled 需按照其注册顺序依次回调 当 Promise 失败状态时，所有 onRejected 需按照其注册顺序依次回调 最后需要注意的就是 then 方法调用以后的返回值 1promise2 = promise1.then(onFulfilled, onRejected) 因为 then 方法必须返回一个新的 Promise 对象，所以 Promise 才可以支持链式调用 1promise1.then(onFulfilled1, onRejected1).then(onFulfilled2, onRejected2) 关于多次调用和返回值，因为这里涉及到了 Promise 的执行规则，也就是值的传递和错误捕获机制，所以这里我们借住规范来详细梳理一下，主要有以下几点 如果 onFulfilled 或者 onRejected 返回一个值 x，则运行下面的 Promise 解决过程（[[Resolve]](promise2, x)） 若 x 不为 Promise，则使 x 直接作为新返回的 Promise 对象的值，即新的 onFulfilled 或者 onRejected 函数的参数 若 x 为 Promise，这个时候后一个回调函数就会等待该 Promise 对象（即 x）的状态发生变化才会被调用，并且新的 Promise 状态和 x 的状态相同 其实简单来说就是 then 方法的返回值分为普通值和 Promise 对象两种情况，所以需要进行不同的处理，对比以下两个示例，我们就能很明显的发现其中的区别 1234567891011121314let promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve() }, 1000)})promise2 = promise1.then(res =&gt; { return '这里返回一个普通值'})promise2.then(res =&gt; { // `这里返回一个普通值` console.log(res)}) 123456789101112131415161718let promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve() }, 1000)})promise2 = promise1.then(res =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('这里返回一个 Promise') }, 2000) })})promise2.then(res =&gt; { // `这里返回一个 Promise` console.log(res)}) 如果 onFulfilled 或者 onRejected 抛出一个异常 e，则 promise2 必须变为失败（Rejected），并返回失败的值 e，例如 12345678910111213141516let promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('success') }, 1000)})promise2 = promise1.then(res =&gt; { throw new Error('这里抛出一个异常 e')})promise2.then(res =&gt; { console.log(res)}, err =&gt; { // `这里抛出一个异常 e` console.log(err)}) 如果 onFulfilled 不是函数且 promise1 状态为成功（Fulfilled），promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，例如 1234567891011121314let promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('success') }, 1000)})promise2 = promise1.then('这里的 onFulfilled 本来是一个函数，但现在不是')promise2.then(res =&gt; { // success console.log(res)}, err =&gt; { console.log(err)}) 针对于这种情况，简单来说就是 then 方法接收的参数如果不是函数，那么我们应该忽略它，如果没有忽略的话，当 then 方法回调不为函数的时候将会抛出异常，导致链式调用中断 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），promise2 必须变为失败（Rejected）并返回 promise1 失败的值，例如 1234567891011121314let promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('fail') }, 1000)})promise2 = promise1.then(res =&gt; res, '这里的 onRejected 本来是一个函数，但现在不是')promise2.then(res =&gt; { console.log(res)}, err =&gt; { // fail console.log(err)}) 其实梳理下来我们可以发现，上面的一些处理方式，其实都是为了解决状态分别为 resolve/reject 下的不同情况，因为在有些时候 resolve/reject 可能在 then() 之前就被执行（比如 Promise.resolve().then()），如果这个时候我们还把 then() 回调 push 到 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为 fulfilled 或 rejected 的情况，我们需要单独来进行处理，所以下面我们就来看看到底该如何实现 在了解了以上总结的一些规则以后，我们就可以得出 then 方法的大概雏形，首先 then 方法接受两个函数作为参数，然后返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中 123456789101112131415161718192021then(onFulfilled, onRejected) { const { _value, _status } = this switch (_status) { // 当状态为 PENDING 时，将 then 方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(onFulfilled) this._rejectedQueues.push(onRejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: onFulfilled(_value) break case REJECTED: onRejected(_value) break } return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { // ... })} 这个时候我们就需要考虑一下这个返回的对象了，首先返回的新的 Promise 对象肯定是包含两个函数的，也就是成功时执行的函数和失败时执行的函数，但是我们什么时候改变状态呢？改变为哪种状态呢？ 根据上面 then 方法当中的规则，我们知道返回的新的 Promise 对象的状态依赖于当前 then 方法回调函数执行的情况以及返回值，例如 then 方法的参数是否为一个函数、回调函数执行是否出错、返回值是否为 Promise 对象等等，也就是说，在这里我们就不能简单的针对于成功或者失败的状态而去直接调用传递进来的 onFulfilled() 或者 onRejected() 方法了，而是需要根据当前状态的不同，进行不同的处理 如下，我们将对应的 onFulfilled() 和 onRejected() 包裹一层，也就是下面的 fulfilled 和 rejected 方法，在其中我们针对当前状态的不同来进行不同的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849then(onFulfilled, onRejected) { const { _value, _status } = this return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { let fulfilled = value =&gt; { // 成功时执行的函数 try { if (!isFunction(onFulfilled)) { // 如果不是函数，直接在成功回调当中返回当前值 onFulfilledNext(value) } else { let res = onFulfilled(value) // 成功回调返回的值 if (res instanceof MyPromise) { // 如果返回的是 MyPromise 对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) } else { onFulfilledNext(res) // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数 } } } catch (err) { // 如果函数执行出错，新的 Promise 对象的状态为失败 onRejectedNext(err) } } let rejected = error =&gt; { // 失败时执行的函数，逻辑和上面是一样的 try { if (!isFunction(onRejected)) { onRejectedNext(error) } else { let res = onRejected(error) if (res instanceof MyPromise) { res.then(onFulfilledNext, onRejectedNext) } else { onFulfilledNext(res) } } } catch (err) { onRejectedNext(err) } } switch (_status) { case PENDING: // 当状态为 PENDING 时，将 then 方法回调函数加入执行队列等待执行 this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break case FULFILLED: // 当状态已经改变时，立即执行对应的回调函数 fulfilled(_value) break case REJECTED: rejected(_value) break } })} 最后我们再来考虑处理一种特殊情况，那就是如果 _resolve 方法传入的参数为一个 Promise 对象，并且此时该 Promise 对象状态决定当前 Promise 对象的状态，也就是下面这个示例当中所示 12345678const p1 = new Promise(function (resolve, reject) { // ...})const p2 = new Promise(function (resolve, reject) { // ... resolve(p1)}) 上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，即一个异步操作的结果是返回另一个异步操作，这时 p1 的状态就会传递给 p2，也就是说 p1 的状态决定了 p2 的状态，也就是 如果 p1 的状态是 Pending，那么 p2 的回调函数就会等待 p1 的状态改变 如果 p1 的状态已经是 Fulfilled 或者 Rejected，那么 p2 的回调函数将会立刻执行 所以下面我们就来修改我们开头部分的 _resolve 方法以便支持这样的特性，我们将 _resolve 当中单纯的执行成功队列中的函数的方式拆分了一下，分为了 runFulfilled 和 runRejected 两种情况，然后根据传递进 _resolve 方法的参数不同来分别赋予不同的状态和执行逻辑 12345678910111213141516171819202122232425262728293031323334353637_resolve(val) { const run = () =&gt; { if (this._status !== PENDING) return // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; { while (this._fulfilledQueues.length) { const callback = this._fulfilledQueues.shift() callback(value) } } // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; { while (this._rejectedQueues.length) { const callback = this._rejectedQueues.shift() callback(error) } } // 如果 resolve 的参数为 Promise 对象，则必须等待该 Promise 对象状态改变后，当前 Promsie 的状态才会改变 // 且状态取决于参数 Promsie 对象的状态 if (val instanceof MyPromise) { val.then(value =&gt; { this._value = value this._status = FULFILLED runFulfilled(value) }, err =&gt; { this._value = err this._status = REJECTED runRejected(err) }) } else { this._value = val this._status = FULFILLED runFulfilled(val) } } setTimeout(run, 0)} 至此，我们已经实现了 Promise 的主要功能，但是原生的 Promise 还提供了一些额外方法，下面我们来看看这些附加方法如何实现 catch()我们在之前的 JavaScript 中的 Promise 章节当中的曾经提到过，实际上 catch() 只是 promise.then(undefined, onRejected) 方法的一个别名而已，但是需要注意的是 catch() 方法也返回一个 Promise，也就是说 catch 之后，我们还是可以继续是使用 then 方法 1234// 其实就是执行 then 的第二个回调catch (onRejected) { return this.then(undefined, onRejected)} resolve()Promise.resolve(value) 方法返回一个以给定值解析后的 Promise 对象 如果 value 是个 Thenable 对象，返回的 Promise 会跟随这个 Thenable 的对象，采用它的最终状态（关于 Thenable 对象可以参考 JavaScript 中的 Promise） 如果传入的 value 本身就是 Promise 对象，那么 Promise.resolve 将不做任何修改、原封不动地返回这个 Promise 对象 其他情况则直接返回以该值为成功状态的 Promise 对象 12345static resolve(value) { // 如果参数是 MyPromise 实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value))} reject()与 Promise.resolve() 不同的是，Promise.reject() 方法的参数会原封不动地作为 reject 的理由，变成后续方法的参数 123static reject(value) { return new MyPromise((resolve, reject) =&gt; reject(value))} all()Promise.all(promises) 返回一个 Promise 对象 如果传入的参数是一个空的可迭代对象，那么此 Promise 对象回调完成（resolve），只有此情况是同步执行的，其它都是异步返回的 如果传入的参数不包含任何 Promise，则返回一个异步完成 所有的 Promise 都完成时或参数中不包含 Promise 时回调完成 如果参数中有一个 Promise 失败，那么 Promise.all 返回的 Promise 对象失败，失败原因是第一个失败 Promise 的结果 在任何情况下，Promise.all 返回的 Promise 的完成状态的结果都是一个数组 123456789101112131415161718static all(list) { return new MyPromise((resolve, reject) =&gt; { let values = [] let count = 0 for (let [i, p] of list.entries()) { // 数组参数如果不是 MyPromise 实例，先调用 MyPromise.resolve this.resolve(p).then(res =&gt; { values[i] = res count++ // 所有状态都变成 fulfilled 时返回的 MyPromise 状态就变成 fulfilled if (count === list.length) resolve(values) }, err =&gt; { // 有一个被 rejected 时返回的 MyPromise 状态就变成 rejected reject(err) }) } })} race()Promise.race() 函数返回一个 Promise，它将与第一个传递的 Promise 相同的完成方式被完成，它可以是完成（resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个，如果传的参数数组是空，则返回的 Promise 将永远等待 123456789101112static race(list) { return new MyPromise((resolve, reject) =&gt; { for (let p of list) { // 只要有一个实例率先改变状态，新的 MyPromise 的状态就跟着改变 this.resolve(p).then(res =&gt; { resolve(res) }, err =&gt; { reject(err) }) } })} finally()finally() 方法返回一个 Promise，在 Promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数，在 finally 之后，我们还可以继续调用 then 方法，并且会将值原封不动的传递给后面的 then 方法 123456finally (callback) { return this.then( value =&gt; MyPromise.resolve(callback()).then(() =&gt; value), reason =&gt; MyPromise.resolve(callback()).then(() =&gt; { throw reason }) )} 这里针对 MyPromise.resolve(callback()) 我们详细说明一下，这个写法其实涉及到一个 finally() 的使用细节，即 finally() 如果 return 了一个 reject 状态的 Promise，将会改变当前 Promise 的状态，这个 MyPromise.resolve() 就用于改变 Promise 状态，在 finally() 没有返回 reject 状态的 Promise 或 throw 错误的情况下，去掉 MyPromise.resolve 也是一样的 比如下面这个例子 123456789var p = Promise.resolve('ok') .finally(() =&gt; { return Promise.reject('这里只有返回被拒绝的 promise 或者 throw 一个错误，才会影响当前 finally 返回的新 promise 的决议') }) .then(value =&gt; { console.log('成功', value) }, (err) =&gt; { console.log('失败', err) }) finally() 对自身返回的 Promise 的决议影响有限，它可以将上一个 resolve 改为 reject，也可以将上一个 reject 改为另一个 reject，但不能把上一个 reject 改为 resolve，更多使用细节可以参考 Promise.prototype.finally() 完整代码以上，我们就实现了一个完整的 Promsie，更为完善的实现可以参考 es6-promise 这个版本，也算是 Promise 的众多实现中较为完善的一个例子，下面来看看我们汇总后的代码，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182const isFunction = fn =&gt; typeof fn === 'function'const PENDING = 'PENDING'const FULFILLED = 'FULFILLED'const REJECTED = 'REJECTED'class MyPromise { constructor(executor) { if (!isFunction(executor)) { throw new Error('MyPromise must accept a function as a parameter') } this._status = PENDING // 当前状态 this._value = undefined // 回调返回的值 this._fulfilledQueues = [] // 成功回调函数队列 this._rejectedQueues = [] // 失败回调函数队列 try { executor(this._resolve.bind(this), this._reject.bind(this)) } catch (err) { this._reject(err) } } _resolve(val) { // 我们把 _resolve 执行回调的操作封装成一个函数，放进 setTimeout 里，以兼容 executor 是同步代码的情况 const run = () =&gt; { if (this._status !== PENDING) return // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; { while (this._fulfilledQueues.length) { const callback = this._fulfilledQueues.shift() callback(value) } } // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; { while (this._rejectedQueues.length) { const callback = this._rejectedQueues.shift() callback(error) } } // 如果 resolve 的参数为 Promise 对象，则必须等待该 Promise 对象状态改变后，当前 Promsie 的状态才会改变，且状态取决于参数 Promsie 对象的状态 if (val instanceof MyPromise) { val.then(value =&gt; { this._value = value this._status = FULFILLED runFulfilled(value) }, err =&gt; { this._value = err this._status = REJECTED runRejected(err) }) } else { this._value = val this._status = FULFILLED runFulfilled(val) } } setTimeout(run, 0) } _reject(err) { // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; { if (this._status !== PENDING) return this._status = REJECTED this._value = err while (this._rejectedQueues.length) { const callback = this._rejectedQueues.shift() callback(err) } } setTimeout(run, 0) } then(onFulfilled, onRejected) { const { _value, _status } = this return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { let fulfilled = value =&gt; { // 成功时执行的函数 try { if (!isFunction(onFulfilled)) { // 如果不是函数，直接在成功回调当中返回当前值 onFulfilledNext(value) } else { let res = onFulfilled(value) // 成功回调返回的值 if (res instanceof MyPromise) { // 如果返回的是 MyPromise 对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) } else { onFulfilledNext(res) // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数 } } } catch (err) { // 如果函数执行出错，新的 Promise 对象的状态为失败 onRejectedNext(err) } } let rejected = error =&gt; { // 失败时执行的函数，逻辑和上面是一样的 try { if (!isFunction(onRejected)) { onRejectedNext(error) } else { let res = onRejected(error) if (res instanceof MyPromise) { res.then(onFulfilledNext, onRejectedNext) } else { onFulfilledNext(res) } } } catch (err) { onRejectedNext(err) } } switch (_status) { // 当状态为 PENDING 时，将 then 方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break } }) } catch(onRejected) { // 其实就是执行 then 的第二个回调 return this.then(undefined, onRejected) } static resolve(value) { // 如果参数是 MyPromise 实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value)) } static reject(value) { return new MyPromise((resolve, reject) =&gt; reject(value)) } static all(list) { return new MyPromise((resolve, reject) =&gt; { let values = [] let count = 0 for (let [i, p] of list.entries()) { // 数组参数如果不是 MyPromise 实例，先调用 MyPromise.resolve this.resolve(p).then(res =&gt; { values[i] = res count++ // 所有状态都变成 fulfilled 时返回的 MyPromise 状态就变成 fulfilled if (count === list.length) resolve(values) }, err =&gt; { // 有一个被 rejected 时返回的 MyPromise 状态就变成 rejected reject(err) }) } }) } static race(list) { return new MyPromise((resolve, reject) =&gt; { for (let p of list) { // 只要有一个实例率先改变状态，新的 MyPromise 的状态就跟着改变 this.resolve(p).then(res =&gt; { resolve(res) }, err =&gt; { reject(err) }) } }) } finally(callback) { return this.then( //执行回调,并returnvalue传递给后面的then value =&gt; MyPromise.resolve(callback()).then(() =&gt; value), reason =&gt; MyPromise.resolve(callback()).then(() =&gt; { throw reason }) ) }} 最后我们来简单的测试一下 1234567891011121314151617181920212223// 定义一个 Promiseconst p1 = new MyPromise((resolve, reject) =&gt; { resolve(1)})// 链式调用p1.then(res =&gt; { console.log(res) return 2}).then('123').then(res =&gt; { // `123` 会被忽略 console.log(res) // 返回一个新的 Promise return new MyPromise((resolve, reject) =&gt; { resolve(3) })}).then(res =&gt; { console.log(res) // 抛出错误 throw new Error('reject测试')}).then(() =&gt; { }, err =&gt; { console.log(err)}) 输出结果如下 1234// 1 // 2 // 3 // Error: reject 测试 参考 Promise/async/Generator 实现原理解析 剖析 Promise Promise 最简实现 Promise Promise的源码实现（完美符合Promise/A+规范） es6-promise","link":"/2020/11/15/JavaScript/55/"},{"title":"排序算法","text":"之前我们介绍过了在平常经常会遇到的 查找算法，今天我们就在来看看另一类比较常见而且非常重要的算法，那就是『排序算法』，排序算法在所有的算法当中应该算是应用最为广泛的一类算法 基本概念我们先来看官方定义 假设含有 n 个记录的序列为 { r1, r2 ... rn }，其相应的关键字分别为 { k1, k2 ... kn }，需确定 1, 2 ... n 的一种排列 p1, p2 ... pn，使其相应的关键字满足 kp1 &lt;= kp2 &lt;= ... &lt;= kpn 非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列 { rp1, rp2 ... rpn }，这样的操作就称为排序 其实简单来说，在排序问题中，通常将数据元素称为记录，显然我们输入的是一个记录集合，排序后输出的也是一个记录集合，所以我们可以将排序看成是线性表的一种操作，排序的依据是关键字之间的大小关系，那么对同一记录集合，针对不同的关键字进行排序，可以得到不同序列 排序的稳定性假设 ki = kj（1 &lt;= i &lt;= n, 1 &lt;= j &lt;= n, i != j），且在排序前的序列中 ri 领先于 rj（即 i &lt; j） 如果排序后 ri 仍领先于 rj，则称所用的排序方法是稳定的 反之，若可能使得排序后的序列中 rj 领先 ri，则称所用的排序方法是不稳定的 排序算法性能下面我们来看看影响排序算法性能的几个要素，主要有下面三个 时间性能，其实内排序主要进行的就是比较和移动，而高效率的内排序算法，应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数 辅助空间，优秀的排序算法是不需要太多的辅助空间的 算法的复杂性，这里不是指算法的时间复杂度，而是算法本身是否复杂 根据排序过程中涉及的存储器不同，可以将排序方法分为两大类，一类是内部排序，指的是待排序的几率存放在计算机随机存储器中进行的排序过程，另一类的外部排序，指的是排序中要对外存储器进行访问的排序过程（比如与硬盘进行数据交换等） 常见的『快速排序』、『归并排序』、『堆排序』、『冒泡排序』等属于『比较排序』，在排序的最终结果里，元素之间的次序依赖于它们之间的比较，每个数都必须和其他数进行比较，才能确定自己的位置 在冒泡排序之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 O(n²)，在归并排序、快速排序 之类的排序中，问题规模通过分治法消减为 logn 次，所以时间复杂度平均 O(nlogn) 比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序，可以说，比较排序适用于一切需要排序的情况 计数排序、基数排序、桶排序 则属于非比较排序，非比较排序是通过确定每个元素之前，应该有多少个元素来排序，针对数组 arr，计算 arr[i] 之前有多少个元素，则唯一确定了 arr[i] 在排序后数组中的位置 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决，算法时间复杂度 O(n)，非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定的要求，本章我们将会介绍十大经典排序算法，它们之间的区别如下图 其实总结来说，应该根据场合来进行选择使用，因为没有最好的算法，只有最适合的算法，下面我们就一个一个慢慢来进行了解 冒泡排序冒泡排序算法的原理如下 比较相邻的元素，如果第一个比第二个大，就交换它们两个 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，在这一点，最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 一句话总结就是，『在未排序列中，选出最值放入已排序列』 我们下面就可以对照着原理来尝试进行实现，如下 1234567891011121314151617// 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换// 对所有元素均重复以上步骤，直至最后一个元素function sort(arr) { var temp, l = arr.length - 1 for (var i = 0; i &lt; l; i++) { // 外循环为排序趟数，len 个数进行 len - 1 趟 for (var j = 0; j &lt; l - i; j++) { // 内循环为每趟比较的次数，第 i 趟比较 len - i 次 if (arr[j] &gt; arr[j + 1]) { // 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 这里需要注意的一点就是在于内层循环，第 i 趟只需要比较 len - i 次即可，但是针对于上面这种算法，如果我们细心观察的话可以发现，是还存在可以优化的空间，因为当数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到 arr.length - 1 次，因而后面的比较没有意义的 所以我们可以设置一个标志位，flag，如果发生了交换 flag 设置为 true，如果没有交换就设置为 false，这样当一轮比较结束后如果 flag 仍为 false，那么我们就可以知道这一轮是没有发生交换的，说明数据的顺序已经排好，没有必要继续进行下去 123456789101112131415161718function sort(arr) { var temp, flag // flag 为是否交换的标志 for (var i = 0; i &lt; arr.length - 1; i++) { flag = false // 每次遍历标志位都要先置为 false，才能判断后面的元素是否发生了交换 for (var j = arr.length - 1; j &gt; i; j--) { // 选出该趟排序的最大值往后移动 if (arr[j - 1] &gt; arr[j]) { temp = arr[j - 1] arr[j - 1] = arr[j] arr[j] = temp flag = true // 只要有发生了交换，flag 就置为 true } } if (!flag) break // 判断标志位是否为 false，如果为 false，说明后面的元素已经有序，就直接 return } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 对于这种使用 flag 的方式，比较适用于序列当中有部分是已经是排序完成的，比如 arr = [1, 0, 2, 3, 4, 5, 6, 7] 这样的序列 选择排序选择排序可以算是表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n^2) 的时间复杂度，所以用到它的时候，数据规模越小越好，唯一的好处可能就是不占用额外的内存空间了吧，下面我们来看看它的具体实现原理 简单来说就是，对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量 k 来记住它的位置，以此类推，等到循环结束的时候，我们就可以找到了最小的那个数的下标了 然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟它交换一下值，这样就找到整个数组中最小的数了 然后找到数组中第二小的数，让它跟数组中第二个元素交换一下值，以此类推 一句话总结就是，『在未排序列中，选出最值放入已排序列』，也就是下图这样 下面我们来看代码如何实现 12345678910111213141516171819function sort(arr) { var min, temp, l = arr.length for (var i = 0; i &lt; l - 1; i++) { min = i for (var j = i + 1; j &lt; l; j++) { if (arr[j] &lt; arr[min]) { min = j } } if (min != i) { // 第 i 个数与最小的数 arr[i] 交换 temp = arr[i] arr[i] = arr[min] arr[min] = temp } } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 插入排序插入排序（Insertion sort）是一种简单直观且稳定的排序算法，如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法插入排序法，插入排序的基本思想是，每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止 如果用现实当中的例子来看的话，就类似与我们的斗地主，在摸排阶段手里的牌都按照从小到大排序，如果每摸一张牌，我们就把它插入合适的位置，使得它比后面位置的牌小，比前面位置的牌大或者相等，这样的一种排序方法就是插入排序，下面我们来看一下插入排序的实现原理 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复执行步骤二到五 一句话总结就是『将未排序列和已排序列做比较』，所以我们可以考虑使用双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，与已排序的元素进行比较，小于则交换位置，大于则位置不动，也就是下图这样 下面我们来看代码如何实现 12345678910111213function sort(arr) { var temp for (var i = 1; i &lt; arr.length; i++) { for (var j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) { temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 希尔排序希尔排序是『插入排序』的一种，又称『缩小增量排序』（Diminishing Increment Sort），是『直接插入排序』算法的一种更高效的改进版本，希尔排序的原理是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止，希尔排序是基于『插入排序』的以下两点性质而提出改进方法的 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 可以如下图所示，假设我们的初始化关键字如下 然后我们将其先分为两组，然后分别对当前数组进行『插入排序』，如下所示 我们以 49 和 13 为起始，对比它们两者直接的大小，小的放左边，大的放右边，然后在比较 38 和 27，以此类推 在第一趟结束以后，结果是下面这样的 然后我们再将之前的数组再次分割，也就是下面这样 这次我们就以 13，55，38，76 为起始，依次比对，接下来就是 27，04，65，往后在以此类推 第二趟结束以后，结果是下面这样的 以此类推 最终结果如下 下面我们来看看如何用代码进行实现，其实我们的代码就是在『插入排序』的基础上来进行调整就可以来 123456789101112131415function sort(arr) { var temp, l = arr.length for (var gap = Math.floor(l / 2); gap &gt; 0; gap = Math.floor(gap / 2)) { for (var i = gap; i &lt; l; i++) { for (var j = i - gap; j &gt;= 0 &amp;&amp; arr [j] &gt; arr[gap + j]; j -= gap) { temp = arr[j] arr[j] = arr[gap + j] arr[gap + j] = temp } } } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 可以发现，我们的主体逻辑没有改变，而是仅仅只添加来一个 gap 变量来进行分组，最主要的变化就是之前的外层循环的判断条件由 i = 1 变成了 i = gap，内层循环的判断条件由 var j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j-- 变成了 var j = i - gap; j &gt;= 0 &amp;&amp; arr [j] &gt; arr[gap + j]; j -= gap 归并排序和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度，代价是需要额外的内存空间，简单来说就是将两个或者两个以上有序表组成一个新的有序表，这个操作就称之为归并，也就是『先递归来分解数列，再合并数列』（分治思想的典型应用） 归并排序（Merge Sort）就是利用归并的思想实现的排序方法，它的原理是假设初始序列有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 ⌈n / 2⌉ 个长度为 2 或 1 的有序子序列，再两两归并，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为二路归并排序，也就是下图这样的逻辑 简单来说就是分为三个步骤 将一个数组拆成 A、B 两个小组，两个小组继续拆，直到每个小组只有一个元素为止 按照拆分过程逐步合并小组，由于各小组初始只有一个元素，可以看做小组内部是有序的，合并小组可以被看做是合并两个有序数组的过程 对左右两个小数列重复第二步，直至各区间只有一个数 我们以数组 [42, 20, 17, 13, 28, 14, 23, 15] 为例，进行归并排序，模拟排序过程如下 第一步，拆分数组，一共需要拆分三次（logN） 第一次拆成 [42, 20, 17, 13] 和 [28, 14, 23, 15] 第二次拆成 [42, 20]，[17, 13]，[28, 14]，[23, 15] 第三次拆成 [42]，[20]，[17]，[13]，[28]，[14]，[23]，[15] 第二步，逐步归并数组，采用合并两个有序数组的方法，每一步其算法复杂度基本接近于 O(n) 第一次归并为 [20, 42]，[13, 17]，[14, 28]，[15, 23] 第二次归并为 [13, 17, 20, 42] 和 [14, 15, 23, 28] 第三次归并为 [13, 14, 15, 17, 20, 23, 28, 42] 如下图演示 下面我们来看代码如何实现 123456789101112131415161718192021222324252627282930313233343536373839function mergeSort(arr) { console.log(arr) if (arr.length === 1) return arr var mid = Math.floor(arr.length / 2) var left = arr.slice(0, mid) var right = arr.slice(mid) // 合并左右两部分 return merger(mergeSort(left), mergeSort(right))}// 实现归并，并将最后的结果存放进数组 c 当中function merger(a, b) { var n = a &amp;&amp; a.length var m = b &amp;&amp; b.length var c = [] var i = 0, j = 0 while (i &lt; n &amp;&amp; j &lt; m) { if (a[i] &lt; b[j]) { c.push(a[i++]) } else { c.push(b[j++]) } } // 如果存放完毕以后还有剩余的元素，就追加进数组 while (i &lt; n) { c.push(a[i++]) } while (j &lt; m) { c.push(b[j++]) } console.log('将数组 ', a, '和 ',b ,'合并为 ',c) return c}mergeSort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 快速排序关于这个算法的实现方式，网上有很多争议，让我们先抛开争议，先从最为基本的实现方式开始看起，看看这些争议具体体现在什么地方，它的具体实现思路为 数列中挑出一个元素，称为基准（基准选择开头，结尾或者中间数都可以） 准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器 递归处理两个容器的元素，并将处理后的数据与基数按大小合并成一个数组，返回 快速排序本质是通过分治策略通过基准值数组拆分成两部分，一部分永远比基准值小，另外一部分永远比基准值大，这时候在继续在拆分的部分中取基准值继续将已经拆分的部分再次拆分成两部分，直到不可在继续拆分下去，这个时候数组的顺序就已经完成了排序操作，所以我们可以得出我们的第一版代码，如下 12345678910111213141516function sort(arr) { if (arr.length &lt;= 1) return arr var pivot = arr[0] var left = [] var right = [] for (var i = 1; i &lt; arr.length; i++) { if (arr[i] &lt;= pivot) { left.push(arr[i]) } else { right.push(arr[i]) } } return sort(left).concat(pivot).concat(sort(right))}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 运行以后可以发现，是可以达到排序的目的的，我们选择基数为参照，划分数组，分而治之，结果很美好，但是仔细观察后可以发现，它其实是存在着一定问题的，我们慢慢来看 我们发现在函数内定义了额外的两个数组用于存放临时数据，随着递归的次数增多，会定义并存放越来越多的临时数据从而占用了更多的存储空间（增加了空间复杂度），而且如果是比较极端的情况，比如序列是一个从大到小反向排列的序列，而我们选择的基准点又刚好是序列的第一位，那么它的性能就可想而知了，所以这里我们就可以采用一种名为『原地分区』的算法来进行优化，那么什么是原地分区呢？ 正如其名，原地分区的算法是借由移动小于等于 pivot 的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面，在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值，它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到，由于算法只使用交换，因此最后的数列与原先的数列拥有一样的元素，也不会产生临时数组，从而增加空间复杂度 我们用一个示例来说明它的具体操作流程，比如我们要排序的序列是 [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]，这里我们选取的基准值为 6（基准值是左侧的话则右边先行，如果选取的是最后一位，则左边先行），在定义对两个循环当中的 i 和 j 分别指向 6 和 8 分别从序列的两端开始进行查找，先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们（这里注意，是 j 先开始行动） 开始执行查找，j 找到 5，而 i 找到 7，此时 i &lt; j，进行交换，序列变成了 [6, 1, 2, 5, 9, 3, 4, 7, 10, 8]，第一次交换结束 接下来 j 继续开始行动，它找到了 4，而 i 找到了 9，此时 i &lt; j，继续执行互换，变成了 [6, 1, 2, 5, 4, 3, 9, 7, 10, 8]，此时交换结束 j 继续行动，发现了 3，而 i 在寻找的过程中和 j 相遇了，此时 i 不小于 j 了，这也说明我们此次的查找过程已经结束了，所以我们将基准值 6 和 3 进行互换，这时就变成了 [3, 1, 2, 5, 4, 6, 9, 7, 10, 8] 此时，以基准数 6 为分界点，此时我们已经将原来的序列，以 6 为分界点拆分成了两个序列，6 左边的数都小于等于 6，而 6 右边的数都大于等于 6，接下来，我们只需要继续按照刚才的方法分别对这两个序列来进行处理，也就是我们的 [3, 1, 2, 5, 4] 和 [9, 7, 10, 8]，以此类推，就可以得到我们最终的结果，也就是下面这样的 其实简单来说就是，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了，下面我们来看看具体的代码是如何实现的 12345678910111213141516171819202122232425function sort(arr, left, right) { if (left &gt;= right) return arr // 退出递归的条件 var temp, i = left, j = right, pivot = arr[left] while (i &lt; j) { while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) { // 从右边起，寻找比基数小的数 j-- } while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) { // 从左边起，寻找比基数大的数 i++ } if (i &lt; j) { // 如果 i &lt; j 就一直执行我们的查找过程 temp = arr[i] arr[i] = arr[j] arr[j] = temp } } arr[left] = arr[i] // 此时 i &gt;= j 了，说明我们的第一次的查找过程已经结束了，所以交换基准值 arr[i] = pivot sort(arr, left, i - 1) // 对应处理基准值左侧的数据 sort(arr, i + 1, right) // 对应处理基准值右侧的数据 return arr}var arr = [2, 3, 5, 6, 4, 7, 8, 1, 9, 0]sort(arr, 0, arr.length - 1) 堆排序堆排序是指利用堆这种数据结构所设计的一种排序算法，堆是一个近似完全二叉树的结构，并同时满足堆积的性质，即在堆的数据结构中，堆中的最大值（或者最小值）总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点） 堆排序是对『选择排序』算法的改进版本，堆当中的每个结点的值，都大于或者等于其左右孩子结点的值，称之为『大顶堆』，反正称之为『小顶堆』，每个结点的值都小于或者等于其左右孩子的结点，所以我们可以简单的总结一下堆的要点 根结点一定是堆中所有结点最大或者最小者，如果按照层序遍历的方式给结点从 1 开始编号（这里需要注意，『堆的排序下标是从 1 开始的』），则结点之间满足如下关系 满足 ki &gt;= k2i &amp;&amp; ki &gt;= k2i + 1 就是大顶堆的情况 满足 ki &lt;= k2i &amp;&amp; ki &lt;= k2i + 1 就是小顶堆的情况 以上满足条件 1 &lt;= i &lt;= ⌊n / 2⌋（向下取整） 下标 i 与 2i 和 2i + 1 是双亲和子女关系 如果我们想把大顶堆和小顶堆用层序遍历存入数组，则一定满足上面的表达式 堆排序算法的实现原理如下图所示 我们可以以上图当中的二叉树为例，来简单梳理一下其中的步骤，总共分为三步 将待排序的序列构造成一个大顶堆，此时整个二叉树的最大值就是堆顶的根结点，将其与堆数组的末尾元素交换，此时末尾元素就是最大值了 然后将剩余的 n - 1 个序列重新构造成一个新的大顶堆，这样就会得到 n 个元素中的此大值 重复步骤二，直到堆中元素个数为 1（或其对应数组的长度为 1），排序完成 下面我们来看代码是如何实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 交换两个节点function swap(A, i, j) { let temp = A[i] A[i] = A[j] A[j] = temp}// 将 i 结点以下的堆整理为大顶堆function heapAdjust(A, i, length) { // 当前父节点 let temp = A[i] // j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整 // 这里需要注意，因为 i 是双亲结点，所以对于二叉树来说， 2 * i 表示的是它的左孩子，2 * i + 1 表示的是右孩子 // 2 * j 表示指向下一个双亲结点 for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) { // 将 A[i] 取出，整个过程相当于找到 A[i] 应处于的位置 // 也就是待调整的双亲 temp = A[i] // 因为此时 j 是指向双亲的右孩子，所以如果右孩子大于左孩子的话 // 小于 length 是确定 j + 1 不是最后一个结点 // 简单来说就是，如果右孩子大于左孩子，j 就指向右孩子 // 如果左孩子大于右孩子的话，j 还是它自己 if (j + 1 &lt; length &amp;&amp; A[j] &lt; A[j + 1]) { // 指向较大的元素，也就是找到两个孩子中较大的一个，再与父节点比较 j++ } if (temp &lt; A[j]) { // 如果父节点小于子节点就执行交换，否则跳出 swap(A, i, j) // 交换后，temp 的下标变为 j i = j } else { break } }}// 堆排序function heapSort(A) { for (let i = Math.floor(A.length / 2 - 1); i &gt;= 0; i--) { // 初始化大顶堆，从第一个非叶子结点开始 heapAdjust(A, i, A.length) // 这里传递的 i 就表示的是双亲结点 } for (let i = Math.floor(A.length - 1); i &gt; 0; i--) { // 排序，每一次 for 循环找出一个当前最大值，数组长度减一 swap(A, 0, i) // 根节点与最后一个节点交换 heapAdjust(A, 0, i) // 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数，为 i，即比较到最后一个结点前一个即可 }}const arr = [2, 3, 5, 6, 4, 7, 8, 1, 9, 0]heapSort(arr)console.log(arr) 计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，计数排序是一种稳定的排序算法，计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数，然后根据数组 C 来将 A 中的元素排到正确的位置，它只能对整数进行排序，它的原理是这样的 找出待排序的数组中最大和最小的元素 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 对所有的计数累加（即从 C 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组，将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1 也就是下图所示 下面是代码实现 123456789101112131415161718function sort(arr, maxValue) { var bucket = new Array(maxValue + 1), sortedIndex = 0 for (var i = 0; i &lt; arr.length; i++) { if (!bucket[arr[i]]) { bucket[arr[i]] = 0 } bucket[arr[i]]++ } for (var j = 0; j &lt; maxValue + 1; j++) { while (bucket[j] &gt; 0) { arr[sortedIndex++] = j bucket[j]-- } } return arr}sort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0], 9) 桶排序桶排序是『计数排序』的升级版，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定，它的工作原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序），主要分为以下几个步骤 设置固定数量的空桶 把数据放到对应的桶中 对每个不为空的桶中数据进行排序 拼接不为空的桶中数据，得到结果 也就是下图所示 下面我们来看代码如何实现 12345678910111213141516171819202122232425262728// 这里使用之前的插入排序function insertSort(arr) { var temp for (var i = 1; i &lt; arr.length; i++) { for (var j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) { temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } return arr}function bucketSort(arr, maxValue) { const DEFAULT_BUCKET_SIZE = 5 // 设置桶的默认数量 const buckets = Array.from({ length: DEFAULT_BUCKET_SIZE }, () =&gt; []) // 创建桶 for (let i = 0; i &lt; arr.length; i++) { // 把元素放入对应桶子 const idx = ~~(arr[i] / maxValue) // 计算需要放入桶子序号（取整） buckets[idx].push(arr[i]) } for (let i = 0; i &lt; buckets.length; i++) { // 对每个桶子进行排序 insertSort(buckets[i]) // 此处选取插入排序, 空间消耗少，元素少常数时间消耗短，也可以使用其他的方式 } return [].concat(...buckets) // 把每个桶子数据合并}const arr = [2, 3, 5, 6, 4, 7, 8, 1, 9, 0]bucketSort(arr, 9) 基数排序基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，它的原理是按照低位先排序，然后收集，再按照高位排序，然后再收集，依次类推，直到最高位，有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前，具体流程如下 取得数组中的最大数，并取得位数 arr 为原始数组，从最低位开始取每个位组成 radix 数组 对 radix 进行计数排序（利用计数排序适用于小范围数的特点） 如下图所示 看上去可能不太好理解，所以我们用一个示例来进行了解，比如说现在有一个这样的无序数组和一个桶（buckets） 123const arr = [10, 200, 13, 12, 7, 88, 91, 24]const buckets = Array.from({ length: 10 }, () =&gt; []) 我们第一步就是取原数组的每个元素的个位，也就是下面这样 12// const arr = [10, 200, 13, 12, 7, 88, 91, 24][0, 0, 3, 2, 7, 8, 1, 4] 然后根据个位值的大小放到对应的桶中，其实这一步也可以理解为根据『个位值的大小』进行第一次排序，把个位数组的每个元素对应到桶的索引（也就是『计数排序』的思路），通过此步骤，目前桶就变成了 1buckets = [[10, 200], [91], [12], [13], [24], [], [], [7], [88]] 在按照桶的索引进行取值，通过此步 就已经完成了原数组的个位排序 1arr = [10, 200, 91, 12, 13, 24, 7, 88] 那接下来就是按照十位进行排序，取原数组的每个元素的十位 12// arr = [10, 200, 91, 12, 13, 24, 7, 88]，如果某个元素没有该位就默认为 0[1, 0, 9, 1, 1, 2, 0, 8] 和上面一样，根据十位值的大小放到对应的桶中，这时桶就变成了 1buckets = [[200, 7], [10, 12, 13], [24], [], [], [], [], [], [88], [91]] 跟之前一样，按照桶的索引进行取值，通过此步就已经完成了原数组的十位排序 1arr = [200, 7, 10, 12, 13, 24, 88, 91] 重复以上通过同样步骤来处理百位，按照百位进行排序，并取原数组的每个元素的百位，最后就完成了基数排序 12345678// 按照百位进行排序[2, 0, 0, 0, 0, 0, 0, 0, 0, 0]// 取原数组的每个元素的百位[[7, 10, 12, 13, 24, 88, 91], [], [200] ... ]// 完成排序[7, 10, 12, 13, 24, 88, 91, 200] 以上就是整个流程，其实简单来说，就是在计数排序的基础之上进行的的步骤分解，下面我们来看看如何用代码进行实现 123456789101112131415161718192021function radixSort(arr) { const max = Math.max(...arr) // 取最大值 最大值的位数就是要循环遍历的次数 const buckets = Array.from({ length: 10 }, () =&gt; []) // 定义一个桶 let m = 1 // 定义当前要遍历的位数 个位 十位 百位 while (m &lt; max) { // m &lt; 最大值，下方 m 要 m *= 10 -&gt; 每次遍历增加一位，保证遍历完所有可能的位数 arr.forEach(number =&gt; { // 放入桶 const digit = ~~((number % (m * 10)) / m) // digit 表示某位数的值，也就是计算出某个数字的某位数的值 buckets[digit].push(number) // 把该位数的值放到桶 buckets 中，通过索引确定顺序 类比计数排序 }) let ind = 0 // 从桶 buckets 中取值，完成此步后 就完成了一次位数排序 buckets.forEach(bucket =&gt; { while (bucket.length &gt; 0) { arr[ind++] = bucket.shift() // shift 从头部取值，保证按照队列先入先出 } }) m *= 10 // 每次最外层 while 循环后 m 要乘等 10，也就是要判断下一位 比如当前是个位 下次就要判断十位 } return arr}radixSort([2, 3, 5, 6, 4, 7, 8, 1, 9, 0]) 关于 digit 的获取这里多说一句，这里指的是计算出某个数字的某位数的值，比如说一个数字 521，那么我们如何分别拿到 1，2，5 呢？首先 ~~ 表示的是向下取整（也可以使用 Math.floor()），m 首次是 1 以后每次乘等 10 所以取个位 1，首先取模，521 % 10 = 1，然后除以 m，也就得到了 1 / 1 = 1，最后向下取整为 1 所以取十位 2，首先取模，521 % 100 = 21，然后除以 m，也就得到了 21 / 10 = 2.1，最后向下取整为 2 所以取百位 5，首先取模，521 % 1000 = 521，然后除以 m，也就得到了 521 / 100 = 5.21，最后向下取整为 5","link":"/2020/07/02/Essay/30/"},{"title":"Cookie、Session、Token 与 JWT","text":"最后更新于 2020-04-12 最近在复习相关内容，打算从头的整理一下 Cookie、Session、Token 与 JWT 相关内容，彻底弄清它们的含义以及它们之间的区别，主要内容包括以下这些 认证（Authentication） 授权（Authorization） 凭证（Credentials） 什么是 Cookie 什么是 Session 什么是 Token 什么是 JWT Cookie 和 Session 的区别 Token 和 Session 的区别 Token 和 JWT 的区别 常见的加密算法 常见问题 下面就让我们一个一个来进行了解，先从几个基本概念开始看起 认证（Authentication）关于认证，通俗地讲就是验证当前用户的身份，证明你是你自己（比如你每天上下班打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功），而互联网中的认证则包括 用户名密码登录 邮箱发送登录链接 手机号接收验证码 只要你能收到邮箱/验证码，就默认你是账号的主人 授权（Authorization）关于授权，简单来说就是用户授予第三方应用访问该用户某些资源的权限，比如你在安装手机应用的时候，App 会询问是否允许授予权限（访问相册、地理位置等权限），又或者你在访问微信小程序时，在登录的时候，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息等），实现授权的方式一般有 Cookie、Session、Token、OAuth 凭证（Credentials）实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份，在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件，通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证 而在互联网应用中，一般网站会有两种模式，游客模式和登录模式，在游客模式下，你可以正常浏览网站上面的文章，一旦想要实现某些交互操作等（比如评论），就需要登录或者注册账号，当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（Token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能 什么是 Cookie在看完了几个基本概念以后，我们就正式的来了解一下什么是 Cookie，众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，那么我们如何能把一个用户的状态和数据关联起来呢？ 比如在某个页面中，你进行了登录操作，而当你跳转到商品页时，服务端如何知道你是已经登录的状态呢？所以在这种情况下就产生了 Cookie 这门技术来解决这个问题，Cookie 是 HTTP 协议的一部分，它的处理分为如下几步 客户端发送 HTTP 请求到服务器 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段 浏览器收到响应后保存下 Cookie 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器 这里有几个需要注意的地方，首先 Cookie 是存储在客户端的，其次 Cookie 是不可跨域的，每个 Cookie 都会绑定单一的域名，无法在别的域名下获取使用，但是一级域名和二级域名之间是允许共享使用的（依靠的是 domain） 其次 Cookie 主要用于以下三个方面 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 下面我们来看看一些 Cookie 当中比较重要的参数 Name/Value键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型（如果值为 Unicode 字符，需要为字符编码，如果值为二进制数据，则需要使用 BASE64 编码），所以我们在用 JavaScript 操作 Cookie 的时候需要注意对 Value 进行编码处理 ExpiresExpires 用于设置 Cookie 的过期时间，比如 1Set-Cookie: id=b7fGcj3fWa; Expires=Wed, 21 Oct 2017 07:28:00 GMT; 当 Expires 属性缺省时，表示是会话性 Cookie，当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效，需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样 与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookie 会保存在用户的硬盘中，直至过期或者清除 Cookie，这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端 Max-AgeMax-Age 用于设置在 Cookie 失效之前需要经过的秒数，比如 1Set-Cookie: id=b7fGcj3fWa; Max-Age=604800 Max-Age 可以为正数、负数、甚至是 0，具体区别如下 如果 max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中 当 max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该 Cookie 当 max-Age 为 0 时，则会立即删除这个 Cookie 假如 Expires 和 Max-Age 都存在，则 Max-Age 优先级更高 DomainDomain 指定了 Cookie 可以送达的主机名，假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名），比如某个站点首页设置的 Domain 是 .test.com，这样无论是 a.test.com 还是 b.test.com 都可以使用 Cookie 但是这里需要注意的是，不能跨域设置 Cookie，比如 a 域名下的页面把 Domain 设置成 b 是无效的 1Set-Cookie: qwerty=219ffwef9w0f; Domain=b.com; Path=/; Expires=Wed, 30 Aug 2017 00:00:00 GMT PathPath 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部，比如设置 Path=/docs，/docs/Web/ 下的资源会带 Cookie 首部，/test 则不会携带 Cookie 首部 Domain 和 Path 标识共同定义了 Cookie 的作用域，即 Cookie 应该发送给哪些 URL Secure标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，默认为 false，当值为 true 时，Cookie 在 HTTP 中是无效，在 HTTPS 中才有效 使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改 HTTPOnly如果给某个 Cookie 设置了 httpOnly 属性，则无法通过 JavaScript 脚本读取到该 Cookie 的信息，但还是能通过 Application 中手动修改 Cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 SameSite这里我们重点来看看这个属性，因为在二月份发布的 Chrome 80 的版本中已经默认屏蔽掉了第三方的 Cookie，这样一来就导致了许多问题，我们先来看看这个属性的作用，其实简单来说就是『SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）』 SameSite 可以有下面三种值 Strict，仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致 Lax，允许部分第三方请求携带 Cookie None，无论是否跨站都会发送 Cookie 之前默认是 None 的，而 Chrome 80 后默认是 Lax 跨域和跨站首先要理解的一点就是『跨站』和『跨域』是不同的，同站（same-site）与跨站（cross-site）和第一方（first-party）与第三方（third-party）是等价的，但是与浏览器同源策略（SOP）中的同源（same-origin）与跨域（cross-origin）是完全不同的概念 同源策略作为浏览器的安全基石，其『同源』判断是比较严格的，相对而言，Cookie 中的『同站』判断就比较宽松，只要两个 URL 的 eTLD + 1 相同即可，不需要考虑协议和端口，其中 eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如 .com、.co.uk、.github.io 等，其中的 eTLD + 1 则表示，有效顶级域名加上二级域名，例如 test.com 等 举几个例子来说的话就是 www.taobao.com 和 www.baidu.com 是跨站，www.a.taobao.com 和 www.b.taobao.com 是同站，a.github.io 和 b.github.io 是跨站（注意是跨站） 改变接下来我们来看下从 None 改成 Lax 到底影响了哪些地方的 Cookies 的发送？见下表 请求类型 实例 以前 Strict Lax None 链接 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 发送 Cookie 不发送 发送 Cookie 发送 Cookie 预加载 &lt;link rel=&quot;prerender&quot; href=&quot;&quot; /&gt; 发送 Cookie 不发送 发送 Cookie 发送 Cookie GET 表单 &lt;form method=&quot;GET&quot; action=&quot;&quot;&gt; 发送 Cookie 不发送 发送 Cookie 发送 Cookie POST 表单 &lt;form method=&quot;POST&quot; action=&quot;&quot;&gt; 发送 Cookie 不发送 不发送 发送 Cookie iframe &lt;iframe src=&quot;&quot;&gt;&lt;/iframe&gt; 发送 Cookie 不发送 不发送 发送 Cookie Ajax $.get() 发送 Cookie 不发送 不发送 发送 Cookie Image &lt;img src=&quot;&quot; /&gt; 发送 Cookie 不发送 不发送 发送 Cookie 从上图可以看出，对大部分 Web 应用而言，POST 表单，iframe，Ajax，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送，主要原因如下 iframe 嵌入的 Web 应用有很多是跨站的，都会受到影响 Ajax 可能会影响部分前端取值的行为和结果 Image 一般都存放在 CDN 上，大部分情况不需要 Cookie，故影响有限，但如果引用了需要鉴权的图片，可能会受到影响 问题我们再看看会出现什么的问题？举几个例子 通过接口获取的登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的禁止第三方 Cookie 功能导致而给与错误的提示 一些站点上使用 iframe 嵌入的部分，没有了 Cookie，都会受到影响 一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响 一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域设置一个 Cookie，请求中带上这个 Cookie 之后，短时间内不再弹安全验证码，在 Chrome 80 以上如果因为 Samesite 的原因请求没办法带上这个 Cookie，则会出现一直弹出验证码进行安全验证 某些请求了跨域的接口，因为没有 Cookie，接口不会返回数据 解决方法解决方案就是设置 SameSite 为 none，以 Adobe 网站为例 www.adobe.com/sea/，查看请求可以看到 SameSite 是为 none 的，如下图 这里也有两点我们需要注意的地方 HTTP 接口不支持 SameSite=none 如果想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送 需要 UA 检测，部分浏览器不能加 SameSite=none iOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性 实例我们下面来看一个实际的使用示例，即 express 中的 Cookie 是如何使用的，这里需要注意的是 express 在 4.x 版本之后，Session 的管理和 Cookies 等许多模块都不再直接包含在 express 中，而是需要单独添加相应模块，在 express 在 4.x 版本中操作 Cookie 可以使用 cookie-parser 模块 12345678910111213141516171819202122var express = require('express')var cookieParser = require('cookie-parser')var app = express()app.listen(3000)// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 Cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 Cookie 可选参数app.use(cookieParser())app.get('/', function (req, res) { // 如果请求中的 Cookie 存在 isVisit, 则输出 Cookie // 否则，设置 Cookie 字段 isVisit, 并设置过期时间为1分钟 if (req.cookies.isVisit) { console.log(req.cookies) res.send('再次欢迎访问') } else { res.cookie('isVisit', 1, { maxAge: 60 * 1000 }) res.send('欢迎第一次访问') }}) 什么是 SessionCookie 虽然很方便，但是使用 Cookie 有一个很大的弊端，那就是 Cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 Cookie 中了，而且如果 Cookie 中数据字段太多会影响传输效率，为了解决这些问题，就产生了 Session，Session 是另一种记录服务器和客户端会话状态的机制，Session 是基于 Cookie 实现的，Session 中的数据是保留在服务器端的，流程可以如下图所示 Session 的运作通过一个 SessionId 来进行，SessionId 通常是存放在客户端的 Cookie 中（比如在 express 中，默认是 connect.sid 这个字段），当请求到来时，服务端检查 Cookie 中保存的 SessionId 并通过这个 SessionId 与服务器端的 SessionData 关联起来，进行数据的保存和修改 这意思就是说，当你浏览一个网页时，服务端随机产生一个字符串，然后存在你 Cookie 中的 connect.sid 字段中，当你下次访问时，Cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据，由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造 Session 可以存放在内存、Cookie 本身、Redis 等缓存，又或者可以放置于数据库中，如果是线上环境，缓存的方案比较常见，如果是存在数据库的话，查询效率相比前三者都太低，不太推荐，而 Cookie-Session 有安全性问题，下面我们就来看看几种存储 Session 方式之间的区别以及一些实际使用的示例 在内存中存储 Session在 express 当中操作 Session 要用到 express-session 这个模块，主要的方法就是 session(options)，其中 options 中包含可选参数，主要有下面这些 name，保存 Session 的字段名称，默认为 connect.sid store，Session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等，express 生态中都有相应模块的支持 secret，通过设置的 secret 字符串，来计算 Hash 值并放在 Cookie 中，使产生的 signedCookie 防篡改 Cookie，设置存放 SessionId 的 Cookie 的相关选项，默认为（default: { path: '/', HTTPOnly: true, secure: false, maxAge: null }） genid，产生一个新的 SessionId 时，所使用的函数， 默认使用 uid2 这个 npm 包 rolling，每个请求都重新设置一个 Cookie，默认为 false resave，即使 Session 没有被修改，也保存 Session 值，默认为 true express-session 默认使用内存来存 Session，对于开发调试来说很方便 123456789101112131415161718192021222324var express = require('express')var session = require('express-session')var app = express()app.listen(5000)// 按照上面的解释，设置 Session 的可选参数app.use(session({ secret: 'recommand 128 bytes random string', // 建议使用 128 个字符的随机字符串 cookie: { maxAge: 60 * 1000 }}))app.get('/', function (req, res) { // 检查 Session 中的 isVisit 字段 // 如果存在则增加一次，否则为 Session 设置 isVisit 字段，并初始化为 1 if (req.session.isVisit) { req.session.isVisit++ res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来此页面&lt;/p&gt;') } else { req.session.isVisit = 1 res.send('欢迎第一次来这里') console.log(req.session) }}) 在 Redis 中存储 SessionSession 存放在内存中不方便进程间共享，因此可以使用 Redis 等缓存来存储 Session，假设你的机器是四核的，你使用了四个进程在跑同一个服务，当用户访问进程一时，他被设置了一些数据当做 Session 存在内存中，而下一次访问时，他被负载均衡到了进程二，则此时进程二的内存中没有他的信息，认为他是个新用户，这就会导致用户在服务中的状态不一致 所以在这种情况下我们可以考虑使用 Redis 作为缓存，可以使用 connect-redis 模块来得到 Redis 连接实例，然后在 Session 中设置存储方式为该实例 123456789101112131415161718192021222324var express = require('express')var session = require('express-session')var redisStore = require('connect-redis')(session)var app = express()app.listen(5000)app.use(session({ // 假如你不想使用 Redis 而想要使用 memcached 的话，代码改动也不会超过 5 行 // 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 Session 的 store 使用 // 比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法，编写自己的 store 也很简单 store: new redisStore(), secret: 'somesecrettoken'}))app.get('/', function (req, res) { if (req.session.isVisit) { req.session.isVisit++ res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来到此页面&lt;/p&gt;') } else { req.session.isVisit = 1 res.send('欢迎第一次来这里') }}) 我们可以运行 redis-cli 查看结果，如图可以看到 Redis 中缓存结果 各种存储的利弊上面我们说到，Session 的 store 有四个常用选项 内存，其实在开发环境存内存就可以，一般的小程序为了省事，如果不涉及状态共享的问题，用内存 Session 也没问题，但内存 Session 除了省事之外，没有别的好处 Cookie，Cookie-Session 我们下面会提到，先说说利弊，用 Cookie-Session 的话，是不用担心状态共享问题的，因为 Session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息，它的弊端是增大了数据量传输，利端是方便 缓存，缓存方式是最常为常用用的方式，不仅速度快，而且又能共享状态，相比 Cookie-Session 来说，当 SessionData 比较大的时候，可以节省网络传输，也是推荐使用的方式 数据库，关于数据库 Session 除非你很熟悉这一块，知道自己要什么，否则还是使用缓存吧 signedCookieCookie 虽然很方便，但是使用 Cookie 有一个很大的弊端，即 Cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，比如我们现在有一个网站，使用 Cookie 来记录登录的用户凭证，相应的 Cookie 长这样， dotcom_user=zhangsan，它说明现在的用户是 zhangsan 这个用户，如果我在浏览器中装个插件，把它改成 dotcom_user=lisi，服务器一读取，就会误认为我是 lisi，然后我就可以进行 lisi 才能进行的操作了 现在我们有一些数据，不想存在 Session 中，想存在 Cookie 中，怎么保证不被篡改呢？答案很简单，签个名，假设我们的服务器有个秘密字符串，是 this_is_my_secret，然后我们就可以为用户 Cookie 的 dotcom_user 字段设置了个值 zhangsan，Cookie 本应是 1{ 'dotcom_user': 'zhangsan' } 而如果我们签个名，比如把 dotcom_user 的值跟我们的秘密字符串做个 SHA1 1sha1('this_is_my_secret' + 'zhangsan') === '59ea8588929a887ff79757a5f3fe8ae57f5df104' 然后把 Cookie 变成这样 1234{ 'dotcom_user': 'zhangsan', 'dotcom_user.sig': '59ea8588929a887ff79757a5f3fe8ae57f5df104',} 这样一来，用户就没法伪造信息了，一旦它更改了 Cookie 中的信息，则服务器会发现 Hash 校验的不一致，毕竟他不懂我们的秘密字符串是什么，而暴力破解哈希值的成本太高 Cookie-SessionCookie-Session 的实现跟 signedCookies 差不多，不过 Cookie-Session 建议不要轻易使用，有受到回放攻击的危险，回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 Session 中，Session 保存在 Cookie 中，他先复制下现在的这段 Cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了，而他现在可以将之前复制下的那段 Cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分 如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 Cookie-Session，而验证所需的信息，一定不能存在 Cookie 中，这么一来，避免了这种攻击后，使用 Cookie-Session 的好处就荡然无存了，如果为了避免攻击而引入了缓存使用的话，那不如把 Cookie-Session 也一起放进缓存中 什么是 TokenAcesss Token 简单来说就是访问资源接口（API）时所需要的资源凭证，Token 是由 uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）等几部分组成，它的特点是服务端无状态化、可扩展性好，支持移动端设备，相对而言比较安全，又支持跨程序调用，Token 的身份验证流程可以如下图所示 它的流程大致是下面这样的 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端 客户端收到 Token 以后，会把它存储起来，比如放在 Cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 下面是一些使用 Token 的注意事项 每一次请求都需要携带 Token，需要把 Token 放到 HTTP 的 Header 里 基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据，用解析 Token 的计算时间换取 Session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 Token 完全由应用管理，所以它可以避开同源策略 Token 和 Session 的区别 Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息，而 Token 是令牌，访问资源接口（API）时所需要的资源凭证，Token 使服务端无状态化，不会存储会话信息 Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了，如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionId 的不可预测性，暂且认为是安全的，而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是认证和授权，认证是针对用户，授权是针对 App，其目的是让某 App 有权利访问某用户的信息，这里的 Token 是唯一的，不可以转移到其它 App上，也不可以转到其它用户上，Session 只提供一种简单的认证，即只要有此 SessionId ，即认为有此 User 的全部权利，是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App，所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token ，如果永远只是自己的网站，自己的 App，用什么就无所谓了 什么是 JWTJSON Web Token（简称 JWT）是一种认证授权机制，也是目前最流行的跨域认证解决方案，JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519），JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，比如用在用户登录上，可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名，因为数字签名的存在，这些传递的信息是可信的 我们这里只是简单介绍，更为关于 JWT 的内容可以参考 JSON Web Token 入门教程，JWT 的原理是下面这样的 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT 客户端将 Token 保存到本地（通常使用 localStorage，也可以使用 Cookie） 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样的 1Authorization: Bearer &lt;token&gt; 一些注意事项 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制 Token 和 JWT 的区别相同点如下 都是访问资源的令牌 都可以记录用户的信息 都是使服务端无状态化 都是只有验证成功后，客户端才能访问服务端上受保护的资源 区别如下 Token，服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效 JWT，将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据 常见的加密算法我们在之前的存储 Session 部分提到了一种加密方式 SHA1 其实是一种哈希算法，下面我们就来看看一些常见的加密算法，见下图 哈希算法（Hash Algorithm）又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字指纹的方法，哈希算法将数据重新打乱混合，重新创建一个哈希值，哈希算法主要用来保障数据真实性（即完整性），即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实，哈希算法通常有以下几个特点 正像快速，原始数据可以快速计算出哈希值 逆向困难，通过哈希值基本不可能推导出原始数据 输入敏感，原始数据只要有一点变动，得到的哈希值差别很大 冲突避免，很难找到不同的原始数据得到相同的哈希值 但是也有一些需要注意的地方 上面提到的一些算法不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改可以使用 RSA 公钥私钥方案，再配合哈希值 哈希算法主要用来防止计算机传输过程中的错误 常见问题下面我们来看一些比较常见的问题 使用 Cookie 时需要考虑的问题 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性 不要存储敏感数据，比如用户密码，账户余额 使用 httpOnly 在一定程度上提高安全性 尽量减少 Cookie 的体积，能存储的数据量不能超过 4kb 设置正确的 domain 和 path，减少数据传输 Cookie 无法跨域 一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie 使用 Session 时需要考虑的问题 将 Session 存储在服务器里面，当用户同时在线量比较多时，这些 Session 会占据较多的内存，需要在服务端定期的去清理过期的 Session 当网站采用集群部署的时候，会遇到多台 Web 服务器之间如何做 Session 共享的问题，因为 Session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 Session 的服务器，那么该服务器就无法拿到之前已经放入到 Session 中的登录凭证之类的信息了 当多个应用要共享 Session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 Cookie 跨域的处理 SessionId 是存储在 Cookie 中的，假如浏览器禁止 Cookie 或不支持 Cookie 怎么办？ 一般会把 SessionId 跟在 URL 参数后面即重写 URL，所以 Session 不一定非得需要靠 Cookie 实现 移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token 使用 Token 时需要考虑的问题 如果你认为用数据库来存储 Token 会导致查询时间太长，可以选择放在内存当中，比如 Redis 很适合你对 Token 查询的需求 Token 完全由应用管理，所以它可以避开同源策略 Token 可以避免 CSRF 攻击（因为不需要 Cookie 了） 移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token 使用 JWT 时需要考虑的问题 因为 JWT 并不依赖 Cookie，所以可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） JWT 默认是不加密，但也是可以加密的，生成原始 Token 以后，可以用密钥再加密一次 JWT 不仅可以用于认证，也可以用于交换信息，有效使用 JWT，可以降低服务器查询数据库的次数 JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展，但这也是 JWT 最大的缺点，由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限，也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限，为了减少盗用，JWT的有效期应该设置得比较短，对于一些比较重要的权限，使用时应该再次对用户进行认证 JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输 使用加密算法时需要考虑的问题 永远使用哈希算法来处理密码，不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的 绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1，只使用强密码哈希算法 绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样，如果你需要忘记密码的功能，可以随机生成一个新的一次性的（这点很重要）密码，然后把这个密码发送给用户 只要关闭浏览器 Session 就消失了吗不会，因为对 Session 来说，除非程序通知服务器删除一个 Session，否则服务器会一直保留，程序一般都是在用户做退出操作的时候发个指令去删除 Session，然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 Session 机制都使用会话 Cookie 来保存 SessionId 而关闭浏览器后这个 SessionId 就消失了，再次连接服务器时也就无法找到原来的 Session，如果服务器设置的 Cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 SessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 Session，恰恰是由于关闭浏览器不会导致 Session 被删除，迫使服务器为 Session 设置了一个失效时间，当距离客户端上一次使用 Session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 Session 删除以节省存储空间 参考 Using HTTP cookies Set-Cookie 一文彻底搞懂 Cookie、Session、Token 到底是什么 详解 Cookie，Session，Token","link":"/2017/11/26/HTTP/02/"},{"title":"Node.js 中的 Stream（流）","text":"本章我们来看 Node.js 当中一个比较重要的概念，那就是 Stream，也就是所谓的流，那么什么是 Stream 呢？ 什么是 StreamStream 的概念最早来源于 Unix 系统，其可以将一个大型系统拆分成一些小的组件，然后将这些小的组件可以很好地运行，TCP/IP 协议中的 TCP 协议也用到了 Stream 的思想，进而可以进行流量控制、差错控制，在 unix 中通过 | 来表示流，而在 Node.js 中则是通过 pipe() 方法，Stream 可以认为数据就像管道一样，多次不断地被传递下去，而不是一次性全部传递给下游 Node.js 中的流在 Node.js API 文档 中可以看到下面一段话 12345A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter 简单来说 Stream 是 Node.js 中一个非常重要的概念，被大量对象实现，尤其是 Node.js 中的 I/O 操作 Stream 是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如 _read、_write、_transform) Stream 是 EventEmitter 的子类，实际上 Stream 的数据传递内部依然是通过事件（data）来实现的 流的分类在 Node.js 中有四种类型的流，它们分别是 readable、writeable、Duplex 和 transform readable，可读流，表示数据能够被消费，例如可以通过 fs.createReadStream() 方法创建可读流 writeable，可写流，表示数据能被写，例如可以通过 fs.createWriteStream() 方法创建可写流 duplex，即表示既是 Readable 流也是 Writable 流，如 TCP Socket transform，它也是 Duplex 流，能够用来修改或转换数据，例如 zlib.createGzip 方法用来使用 gzip 压缩数据（你可以认为 transform 流是一个函数，它的输入是 Writable 流，输出是 Readable 流） 使用情景 类 需要重写的方法 只读 Readable _read 只写 Writable _write 双工 Duplex _read，_write 操作被写入数据，然后读出结果 Transform _transform，_flush 此外所有的流都是 EventEmitter 的实例，它们能够监听或触发事件，用于控制读取和写入数据，Readable 与 Writable 流支持的常见的事件和方法如下图所示 下面我们就一个一个来分类介绍 Readable可读流（Readable Streams）是对提供数据的源头（source）的抽象，可读流事实上工作在下面两种模式之一 flowing 和 paused 在 flowing 模式下，可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用 在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段 那如何触发这两种模式呢 paused mode，调用 pause 方法（没有 pipe 方法）、移除 data 事件和释放所有 pipe flowing mode，注册事件 data、调用 resume 方法、调用 pipe 方法 如下所示 12345678910111213141516171819202122232425262728// data 事件触发 flowing modeReadable.prototype.on = function (ev, fn) { // ... if (ev === 'data' &amp;&amp; false !== this._readableState.flowing) { this.resume() } // ...}// resume 触发 flowing modeReadable.prototype.resume = function () { var state = this._readableState if (!state.flowing) { debug('resume') state.flowing = true resume(this, state) } return this}// pipe 方法触发 flowing 模式Readable.prototype.resume = function () { if (!state.flowing) { this.resume() }} 简单来说，两种模式取决于一个 flowing 字段 123true ==&gt; flowing modefalse ==&gt; paused mode 上面三种方式最后均是通过 resume 方法，将 state.flowing = true，可读流的两种操作模式是一种简单抽象，它抽象了在可读流实现（Readable stream implementation）内部发生的复杂的状态管理过程，在任意时刻，任意可读流应确切处于下面三种状态之一 12345readable._readableState.flowing = nullreadable._readableState.flowing = falsereadable._readableState.flowing = true 若 readable._readableState.flowing 为 null，由于不存在数据消费者，可读流将不会产生数据，如果监听 data 事件，调用 readable.pipe() 方法，或者调用 readable.resume() 方法，readable._readableState.flowing 的值将会变为 true，这时，随着数据生成，可读流开始频繁触发事件 调用 readable.pause() 方法，readable.unpipe() 方法，或者接收背压（关于背压的概念我们会在下面进行介绍），将导致 readable._readableState.flowing 值变为 false，这将暂停事件流，但不会暂停数据生成，当 readable._readableState.flowing 值为 false 时， 数据可能堆积到流的内部缓存中 需要注意的是，应该选择其中『一种』来消费数据，而『不应该』在单个流使用多种方法来消费数据，对于大多数用户，建议使用 readable.pipe() 方法来消费流数据，因为它是最简单的一种实现，如果要精细地控制数据传递和产生的过程，可以使用 EventEmitter 和 readable.pause()/readable.resume() 提供的 API paused mode在 paused mode 下，需要手动地读取数据，并且可以直接指定读取数据的长度 123456789var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)console.log(r.read(1).toString()) // hconsole.log(r.read(3).toString()) // ell 还可以通过监听事件 readable，触发时手工读取 chunk 数据 12345678910111213var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)r.on('readable', function() { var chunk = r.read() console.log(chunk.toString())})// helloworld 需要注意的是，一旦注册了 readable 事件，必须手工读取 read 数据，否则数据就会流失，看看内部实现 123456789101112131415161718192021222324252627function emitReadable_(stream) { debug('emit readable') stream.emit('readable') flow(stream)}function flow(stream) { var state = stream._readableState debug('flow', state.flowing) if (state.flowing) { do { var chunk = stream.read() } while (null !== chunk &amp;&amp; state.flowing) }}Readable.prototype.read = function (n) { // ... var res = fromList(n, state) if (!util.isNull(ret)) { this.emit('data', ret) } // ...} flow 方法直接 read 数据，将得到的数据通过事件 data 交付出去，然而此处没有注册 data 事件监控，因此，得到的 chunk 数据并没有交付给任何对象，这样数据就白白流失了，所以在触发 emit('readable') 时，需要提前 read 数据 flowing mode通过注册 data、pipe、resume 可以自动获取所需要的数据，比如通过事件 data 的方式 12345678910111213var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)r.on('data', function (chunk) { console.log(chunk.toString())})// hello // world 或者通过 pipe 的方式 12345678910var Read = require('stream').Readablevar r = new Read()r.push('hello')r.push('world')r.push(null)r.pipe(process.stdout)// helloworld 以上两种 mode 总体如下 readable 与 data 事件read() 是 Readable 流的基石，无论流处于什么模式，只要是涉及读取数据最终都会转到 read() 上面来，它的主要功能是 读取缓冲区数据并返回给消费者，并按需发射各种事件 按需调用 _read()，_read() 会从底层汲取数据，并填充缓冲区 它的流程大致如下 务必记住 read() 是『同步』的，因此它并不是直接从底层数据那里读取数据，而是从缓冲区读取数据，而缓冲区的数据则是由 _read() 负责补充 _read() 可以是同步或者异步，Node.js 内部的实现经常会调用 read(0)，因为参数是 0 所以不会破坏缓冲区中的数据和状态，但可以触发 _read() 来从底层汲取数据并填充缓冲区，_read() 是流实现者需要重写的函数，它从底层汲取数据并填充缓冲区（flowing 模式不会填充而是直接发送给消费者），它的大致流程如下 注意在 addChunk() 后会根据情况发射 readable 或者 data 事件，然后依次调用 1read() ==&gt; _read(0) ==&gt; ... ==&gt; addChunk() 从而形成一个循环，因为一旦调用了 _read() 之后，流就会默默在底层读取数据，直到数据都消耗完为止 readable 事件文档上关于 readable 事件的描述如下 事实上，readable 事件表明流有了新的动态，要么是有了新的数据，要么是到了流的尾部，对于前者 stream.read() 将返回可用的数据，而对于后者 stream.read() 将返回 null 由此我们可以知道 readable 事件意味着 流有了新的数据（注意，这里只说明有了新数据，至于新数据如何读取是调用者自己的事情） 流到达了尾部 来看下面这个示例 1234567// 可以将 size 设为 1 或 undefined 来进行测试const size = 1const rs = require('fs').createReadStream('./test.js')rs.on('readable', () =&gt; { console.log(rs.read(size))}) 总之，readable 只是负责通知用户流有了新的动态，事件发生的时候是否读取数据，如何读取数据则是调用者的事情（如果一直不读取事件，则数据会存在于缓冲区中），例如可以给 readable 注册一个回调函数，该回调函数调用无参的 read()，它会读取并清空缓冲区的全部数据，这样就使得每次 readable 发生的时候都可以读取到最新的数据 readable 的触发时机readable 在以下几种情况会被触发 在 onEofChunk 中，且 _read() 从底层汲取的数据为空，这个场景意味着流中的数据已经全部消耗完 在 addChunk() 中，且 _read() 从底层汲取的数据不为空且处于 pause 模式，这个场景意味着流中有新数据 在 read(n) 中，且 n 为 0 是的某些情况下 通过 on() 为 readable 添加监听器，如果此时缓冲区有数据则会触发，这个场景意味着流中已经有数据可供 read() 直接调用 data 事件data 事件的意义则明确很多，文档上关于 data 事件的描述如下 The ‘data’ event is emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer. 与 readable 不同的是，data 事件代表的意义清晰单一，流将数据交付给消费者时触发，并且会将对应的数据通过回调传递给用户 data 的触发时机从源码来看，有两个地方会触发 data 事件 在 read() 中，如果缓冲区此时有数据可以返回给调用者，这种情况只会在调用 pipe() 时候发生，如果 readable() 被暂停过并重新启动，此时缓冲区内残留的数据会通过 read() 读出然后借助 data 事件传递出去 在 addChunk() 中，此时 _read() 从底层汲取的数据不为空，且满足以下条件 处于 flowing 模式 缓冲区为空 处于异步调用模式 在这种情况下，数据直接就交付给消费者了，并没有在缓冲区缓存，而文档中的说法是 当流转换到 flowing 模式时会触发该事件，调用 readable.pipe()， readable.resume() 方法，或为 data 事件添加回调可以将流转换到 flowing 模式， data 事件也会在调用 readable.read() 方法并有数据返回时触发 似乎两者不太一致？其实本质上调用 readable.pipe()、readable.resume() 或为 data 事件添加回调，最终都会依次调用 1read() ==&gt; _read() ==&gt; addChunk() 然后最终才进行发射 data 事件，结合 _read() 的流程图，可以发现，通过 on() 为 readable 和 data 事件添加监听器后，程序就开始循环汲取底层数据直至消耗完为止 如果同时监听 readable 和 data 事件如下示例 1234const rs = require('fs').createReadStream('./test.js')rs.on('readable', () =&gt; console.log('readable 触发'))rs.on('data', console.log) 运行结果如下 12&lt;Buffer 63 6f 6e 73 74 20 72 73 20 3d 20 72 65 71 75 69 72 65 28 27 66 73 27 29 2e 63 72 65 61 74 65 52 65 61 64 53 74 72 65 61 6d 28 27 2e 2f 74 65 73 74 2e ... &gt;readable 触发 从上面的流程图我们知道，在 addChunk() 中当有新数据到来的时候，redable 和 data 都有可能触发，那究竟触发哪个？让我们来看看 addChunk() 的源码 123456789101112131415161718192021function addChunk(stream, state, chunk, addToFront) { // 如果处于 flowing 模式，且缓冲区为空，且为异步调用时候，触发 data 事件 if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) { state.awaitDrain = 0 stream.emit('data', chunk) } else { // 更新缓冲区已有数据数量 state.length += state.objectMode ? 1 : chunk.length if (addToFront) // 插入缓冲区头部 state.buffer.unshift(chunk) else // 插入缓冲区尾部 state.buffer.push(chunk) if (state.needReadable) // 触发 readable 事件 emitReadable(stream) } maybeReadMore(stream, state)} 由于为 data 事件添加回调会使得流进入 flowing 模式，因此我们的例子中，有新数据时只会发射 data 事件，而 readable 事件则流结束的时候发射一次 Writable所有 Writable 流都实现了 stream.Writable 类定义的接口，尽管特定的 Writable 流的实现可能略有差别，所有的 Writable streams 都可以按一种基本模式进行使用，如下 12345const myStream = getWritableStreamSomehow()myStream.write('some data')myStream.write('some more data')myStream.end('done writing data') 本质上 只是需要实现的是 _write(data, enc, next) 方法 1234567891011121314151617181920212223const Writable = require('stream').Writableconst writable = Writable()// 实现 _write 方法// 这是将数据写入底层的逻辑writable._write = function (data, enc, next) { // 将流中的数据写入底层 process.stdout.write(data.toString().toUpperCase()) // 写入完成时，调用 next() 方法通知流传入下一个数据 process.nextTick(next)}// 所有数据均已写入底层writable.on('finish', () =&gt; process.stdout.write('DONE'))// 将一个数据写入流中writable.write('a' + '\\n')writable.write('b' + '\\n')writable.write('c' + '\\n')// 再无数据写入流时，需要调用 end() 方法writable.end() 上游通过调用 writable.write(data) 将数据写入可写流中，write() 方法会调用 _write() 将 data 写入底层，在 _write 方法中，当数据成功写入底层后，必须调用 next([err]) 告诉流开始处理下一个数据 next 的调用既可以是同步的，也可以是异步的，上游必须调用 writable.end(data) 来结束可写流，data 是可选的，此后，不能再调用 write 新增数据，在 end 方法调用后，当所有底层的写操作均完成时，会触发 finish 事件 Readable Stream 与 Writeable Stream二者的关系 Readable Stream 是提供数据的 Stream，外部来源的数据均会存储到内部的 Buffer 数组内缓存起来 writeable Stream 是消费数据的 Stream，从 readable stream 中获取数据，然后对得到的 chunk 块数据进行处理，至于如何处理，就依赖于具体实现（也就是 _write 的实现） 首先看看 Readdable Stream 与 writeable stream 二者之间的流动关系 pipe 的流程stream 内部是从 readable stream 流到 writeable stream，有两种处理方法 pipe 连接两个 stream123456789101112131415161718var Read = require('stream').Readablevar Write = require('stream').Writablevar r = new Read()var w = new Write()r.push('hello')r.push('world')r.push(null)w._write = function(chunk, ev, cb) { console.log(chunk.toString()) cb()}r.pipe(w)// hello// world pipe 是一种最简单直接的方法连接两个 stream，内部实现了数据传递的整个过程，在开发的时候不需要关注内部数据的流动 1234567891011121314151617181920Readable.prototype.pipe = function (dest, pipeOpts) { var src = this // ... src.on('data', ondata) function ondata(chunk) { var ret = dest.write(chunk) if (false === ret) { debug('false write response, pause', src._readableState.awaitDrain) src._readableState.awaitDrain++ src.pause() } } // ...} 附一张 pipe() 的流程图 事件 data + 事件 drain 联合实现1234567891011121314151617181920212223242526var Read = require('stream').Readablevar Write = require('stream').Writablevar r = new Read()var w = new Write()r.push('hello')r.push('world')r.push(null)w._write = function(chunk, ev, cb) { console.log(chunk.toString()) cb()}r.on('data', function(chunk) { if (!w.write(chunk)) { r.pause() }})w.on('drain', function() { r.resume()})// hello// world DuplexDuplex 实际上就是继承了 Readable 和 Writable 的一类流，所以，一个 Duplex 对象既可当成可读流来使用（需要实现 _read 方法），也可当成可写流来使用（需要实现 _write 方法） 12345678910111213141516171819202122232425262728var Duplex = require('stream').Duplexvar duplex = Duplex()// 可读端底层读取逻辑duplex._read = function () { this._readNum = this._readNum || 0 if (this._readNum &gt; 1) { this.push(null) } else { this.push(' ' + (this._readNum++)) }}// 可写端底层写逻辑duplex._write = function (buf, enc, next) { // a, b process.stdout.write('_write ' + buf.toString() + '\\n') next()}// 0, 1duplex.on('data', data =&gt; console.log('ondata', data.toString()))duplex.write('a')duplex.write('b')duplex.end() 上面的代码中实现了 _read 方法，所以可以监听 data 事件来消耗 Duplex 产生的数据，同时，又实现了 _write 方法，可作为下游去消耗数据，因为它既可读又可写，所以它有两端，可写端和可读端，可写端的接口与 Writable 一致，作为下游来使用，可读端的接口与 Readable 一致，作为上游来使用，下面是另外一个示例，读取从 A 到 Z 的字母 123456789101112131415161718192021const { Duplex } = require('stream')const inoutStream = new Duplex({ write(chunk, encoding, callback) { console.log(chunk.toString()) callback() }, read() { this.push(String.fromCharCode(this.currentCharCode++)) if (this.currentCharCode &gt; 90) { this.push(null) } }})inoutStream.currentCharCode = 65process.stdin.pipe(inoutStream).pipe(process.stdout)inoutStream.end() 我们将可读的 stdin 流传输到 duplex stream 当中以使用 callback()，然后将 duplex stream 本身传输到可写的 stdout 流以查看我们的输出结果 TransformTranform 继承自 Duplex，并已经实现了 _read 和 _write 方法，我们只需要实现将两者结合起来的 transform 方法即可，它具有 write 方法，我们可以使用它来推送数据 下面是一个简单的 transform stream 示例，它会将你的输入结果转换为大写 12345678910const { Transform } = require('stream')const upperCaseTr = new Transform({ transform(chunk, encoding, callback) { this.push(chunk.toString().toUpperCase()) callback() }})process.stdin.pipe(upperCaseTr).pipe(process.stdout) 内置的 transform streamNode.js 有一些内置的 transform stream，比如 zlib 和 crypto，下面是一个使用 zlib.createGzip() 方法结合 fs 的 readable/writable 流实现的一个文件压缩示例 1234567const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(file + '.gz')) 上述示例可以将传递进来的文件进行 gzip 压缩，下面我们来稍微扩展一下，比如我们希望用户在运行时可以看到进度结果，并且在完成的时侯看到已经完成的提示 123456789const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]fs.createReadStream(file) .pipe(zlib.createGzip()) .on('data', () =&gt; process.stdout.write('.')) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')) 在上面示例当中，我们也可以不使用 on 去监听其中的数据事件，而只需创建一个 transform stream 来追踪进度，然后将 .on() 方法替换为另一个 .pipe() 即可 123456789101112131415161718const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]const { Transform } = require('stream')const reportProgress = new Transform({ transform(chunk, encoding, callback) { process.stdout.write('.') callback(null, chunk) }})fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(reportProgress) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')) 注意上面示例当中的 callback() 方法的第二个参数，这样写是为了优先推送数据，在或者，我们需要在 gzip 压缩之前或之后对文件进行加密，和上面的示例一样，我们只需要按照我们想要的顺序添加另外一个 transform stream 即可 1234567891011121314151617181920const crypto = require('crypto')const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]const { Transform } = require('stream')const reportProgress = new Transform({ transform(chunk, encoding, callback) { process.stdout.write('.') callback(null, chunk) }})fs.createReadStream(file) .pipe(zlib.createGzip()) .pipe(crypto.createCipher('aes192', 'a_secret')) .pipe(reportProgress) .pipe(fs.createWriteStream(file + '.zz')) .on('finish', () =&gt; console.log('Done')) 当然，为了解压上面我们压缩过的内容，我们只需要以相反的顺序执行 crypto 和 zlib 即可 123456fs.createReadStream(file) .pipe(crypto.createDecipher('aes192', 'a_secret')) .pipe(zlib.createGunzip()) .pipe(reportProgress) .pipe(fs.createWriteStream(file.slice(0, -3))) .on('finish', () =&gt; console.log('Done')) 自定义流自定义流的实现很简单，只要实现相应的内部待实现方法就可以了，具体来说 readable stream，实现 _read 方法来解决数据的获取问题 writeable stream，实现 _write 方法来解决数据的去向问题 tranform stream，实现 _tranform 方法来解决数据存放在 Buffer 前的转换工作 代码如下 1234567891011121314151617181920212223242526// 自定义 readable stream 的实现var Stream = require('stream')var Read = Stream.Readablevar util = require('util')util.inherits(MyReadStream, Read)function MyReadStream(data, opt) { Read.call(this, opt) this.data = data || []}MyReadStream.prototype._read = function () { var _this = this this.data.forEach(function (d) { _this.push(d) }) this.push(null)}var data = ['aa', 'bb', 'cc']var r = new MyReadStream(data)r.on('data', function (chunk) { console.log(chunk.toString())}) 背压我们在上面介绍可读流（Readable Streams）的时候，提及了一个背压的概念，下面我们就来看看到底什么是背压，本小结内容主要是参考 Backpressuring in Streams 这个文章整合而成 数据流中的积压问题通常在数据处理的时候我们会遇到一个普遍的问题，那就是背压，意思是在数据传输过程中有一大堆数据在缓存之后积压着，每次当数据到达结尾又遇到复杂的运算，又或者无论什么原因它比预期的慢，这样累积下来，从源头来的数据就会变得很庞大，像一个塞子一样堵塞住 为解决这个问题，必须存在一种适当的代理机制，确保流从一个源流入另外一个的时候是平滑顺畅的，不同的社区组织针对他们各自的问题单独做了解决，好例子比如 Unix 的管道和 TCP 的 Socket，在 Node.js 中，流（stream）已经是被采纳的解决方案 数据太多，速度太快有太多的例子证明有时 Readable 传输给 Writable 的速度远大于它接受和处理的速度，如果发生了这种情况，消费者开始为后面的消费而将数据列队形式积压起来，写入队列的时间越来越长，也正因为如此，更多的数据不得不保存在内存中知道整个流程全部处理完毕，写入磁盘的速度远比从磁盘读取数据慢得多，因此当我们试图压缩一个文件并写入磁盘时，积压的问题也就出现了，因为写磁盘的速度不能跟上读磁盘的速度 12// 数据将会在读入侧堆积，这样写入侧才能和数据流的读入速度保持同步inp.pipe(gzip).pipe(outputFile) 这就是为什么说积压机制很重要，如果积压机制不存在，进程将用完你全部的系统内存，从而对其它进程产生显著影响，它独占系统大量资源直到任务完成为止，这最终将会导致一些问题 明显使得其它进程处理变慢 太多繁重的垃圾回收 内存耗尽 pipe 的背压平衡机制假设现在有一对 Readable 和 Writable，要求编程实现从 Readable 里面读取数据然后写到 Writable 中，那么面临的问题很有可能就是如果两者对数据的产生/消费速度不一致，那么需要手动协调两者速度使得任务可以完成，思路可能这样 Readable 进入 flowing 模式，然后进入步骤 2 听 data 事件，一旦有数据到达则进入步骤 2，如果捕捉到 end 事件就结束任务 数据写入到 Writable，如果返回 true 进入步骤 1，否则进入步骤 3 Readable 进入 pause 模式，并等待 Writable 发射 drain 事件 果 Writable 发射了 drain 事件，则返回步骤 1 而事实上 pipe() 的过程和上述很相似，它的源码如下 123456789101112131415161718192021222324252627282930313233343536373839Readable.prototype.pipe = function (dest, pipeOpts) { // ... var ondrain = pipeOnDrain(src) // 当写操作返回 false 的时候，正常情况下必然会在稍后触发一个 drain 事件 dest.on('drain', ondrain) src.on('data', ondata) function ondata(chunk) { var ret = dest.write(chunk) // 如果写操作的返回值为 false，则暂停 readable 流 if (ret === false) { if (((state.pipesCount === 1 &amp;&amp; state.pipes === dest) || (state.pipesCount &gt; 1 &amp;&amp; state.pipes.indexOf(dest) !== -1)) &amp;&amp; !cleanedUp) { state.awaitDrain++ } src.pause() } } // ... return dest}function pipeOnDrain(src) { return function () { var state = src._readableState if (state.awaitDrain) state.awaitDrain-- if (state.awaitDrain === 0 &amp;&amp; EE.listenerCount(src, 'data')) { // 将流重新设为 flowing 模式 state.flowing = true // 将缓冲区中残留的数据读取并重新触发 data 事件 flow(src) } }} 通过上面的代码我们可以看到 当向 dest 写入数据返回 false 时，马上调用 src.pause() 暂停流，src.pause() 将暂停事件流，但不会暂停数据生成 也就是说 src 此时依然汲取底层数据填充缓冲区，只是暂停发射 data 事件，等到缓冲区的数据量超过警戒线才会停止汲取 因为写入数据返回 false，因此在稍后的某个时候 dest 必然会发射 drain 事件 当 drain 事件发生后，src 再次进入 flowing 模式自动产生数据，同时将缓冲区中的残留数据写入 dest .pipe() 的生命周期为了对积压有一个更好的理解，这里有一副 Readable 流正通过 piped 流入 Writable 流的整个生命周期图 1234567891011121314151617181920212223242526272829303132333435363738394041 +===================+ x--&gt; Piping functions +--&gt; src.pipe(dest) | x are set up during |===================| x the .pipe method. | Event callbacks | +===============+ x |-------------------| | Your Data | x They exist outside | .on('close', cb) | +=======+=======+ x the data flow, but | .on('data', cb) | | x importantly attach | .on('drain', cb) | | x events, and their | .on('unpipe', cb) |+---------v---------+ x respective callbacks. | .on('error', cb) || Readable Stream +----+ | .on('finish', cb) |+-^-------^-------^-+ | | .on('end', cb) | ^ | ^ | +-------------------+ | | | | | ^ | | ^ ^ ^ | +-------------------+ +=================+ ^ | ^ +----&gt; Writable Stream +---------&gt; .write(chunk) | | | | +-------------------+ +=======+=========+ | | | | | ^ | +------------------v---------+ ^ | +-&gt; if (!chunk) | Is this chunk too big? | ^ | | emit.end() | Is the queue busy? | | | +-&gt; else +-------+----------------+---+ | ^ | emit.write() | | | ^ ^ +--v---+ +---v---+ | | ^-----------------------------------&lt; No | | Yes | ^ | +------+ +---v---+ ^ | | | ^ emit.pause() +=================+ | | ^---------------^-----------------------+ return false &lt;-----+---+ | +=================+ | | | ^ when queue is empty +============+ | ^------------^-----------------------&lt; Buffering | | | |============| | +&gt; emit.drain() | ^Buffer^ | | +&gt; emit.resume() +------------+ | | ^Buffer^ | | +------------+ add chunk to queue | | &lt;---^---------------------&lt; +============+ 注意，如果你创建一些管道准备把一些流串联起来从而操纵数据，你应该实现 Transform 流，在这种情况下，从 Readable 流中的输出进入 Transform，并且会被管道输送进入 Writable 1Readable.pipe(Transformable).pipe(Writable) 积压将被自动应用，但是同时请注意输入和输出 Transform 的水准值，可以手动控制，并且会影响到积压系统，如果想要了解更多，可以参考 通过源码解析 Node.js 中导流（pipe）的实现 这篇文章 总结在 Node.js 中有四种类型的流，它们是 readable、writeable、duplex 和 transform readable，可读流，表示数据能够被消费，是对提供数据的源头（source）的抽象，工作在下面两种模式之一 在 flowing 模式下，可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用 通过注册 data、pipe、resume 可以自动获取所需要的数据，比如通过事件 data 的方式 在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段 在 paused mode 下，需要手动地读取数据，并且可以直接指定读取数据的长度 还可以通过监听事件 readable，触发时手工读取 chunk 数据 一旦注册了 readable 事件，必须手工读取 read 数据，否则数据就会流失 如何触发 paused mode，调用 pause 方法（没有 pipe 方法）、移除 data 事件和释放所有 pipe flowing mode，注册事件 data、调用 resume 方法、调用 pipe 方法 writeable，可写流，表示数据能被写，所有 Writable 流都实现了 stream.Writable 类定义的接口 本质上 只是需要实现的是 _write(data, enc, next) 方法 在 _write 方法中，当数据成功写入底层后，必须调用 next([err]) 告诉流开始处理下一个数据 next 的调用既可以是同步的，也可以是异步的 上游必须调用 writable.end(data) 来结束可写流，data 是可选的，此后，不能再调用 write 新增数据 在 end 方法调用后，当所有底层的写操作均完成时，会触发 finish 事件 duplex，实际上就是继承了 Readable 和 Writable 的一类流 一个 duplex 对象既可当成可读流来使用（需要实现 _read 方法），也可当成可写流来使用（需要实现 _write 方法） transform，它也是 duplex 流，能够用来修改或转换数据，例如 zlib.createGzip 方法用来使用 gzip 压缩数据（内置的 transform stream） 你可以认为 transform 流是一个函数，它的输入是 Writable 流，输出是 Readable 流 Tranform 继承自 duplex，并已经实现了 _read 和 _write 方法 只需要实现将两者结合起来的 transform 方法即可，它具有 write 方法，我们可以使用它来推送数据 推荐一下这篇文章 Node Stream，干货很多 参考 stream-handbook Node.js Stream - 基础篇 Node.js Stream - 进阶篇 Node.js Stream - 实战篇 streamify-your-node-program Node.js 中文网 Node.js Streams: Everything you need to know stream-handbook streamify-your-node-program","link":"/2019/10/09/Node/01/"},{"title":"Virtual DOM 与 Diff 算法内容总结","text":"之前我们借住 HcySunYang/vue-design 分了三部分分别介绍了 Virtual DOM 与 diff 算法相关内容，如下 什么是 Virtual DOM？ 渲染器 渲染器的核心 Diff 算法 本章是在之前的基础之上，将分散的代码汇总一下，做一下整体上的梳理，也算是一个小小的总结 使用 VNode 来描述真实 DOM在第一部分当中，我们主要介绍了如何使用 VNode 来描述真实的 DOM，其主要分为五类，分别是 html/svg 元素、组件、纯文本、Fragment 以及 Portal，然后我们使用了 flags 来作为 VNode 的标识，使用位运算符来标记上面五类不同的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// flags.jsconst VNodeFlags = { // html 标签 ELEMENT_HTML: 1, // SVG 标签 ELEMENT_SVG: 1 &lt;&lt; 1, // 普通有状态组件 COMPONENT_STATEFUL_NORMAL: 1 &lt;&lt; 2, // 需要被keepAlive的有状态组件 COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE: 1 &lt;&lt; 3, // 已经被keepAlive的有状态组件 COMPONENT_STATEFUL_KEPT_ALIVE: 1 &lt;&lt; 4, // 函数式组件 COMPONENT_FUNCTIONAL: 1 &lt;&lt; 5, // 纯文本 TEXT: 1 &lt;&lt; 6, // Fragment FRAGMENT: 1 &lt;&lt; 7, // Portal PORTAL: 1 &lt;&lt; 8}// html 和 svg 都是标签元素，可以用 ELEMENT 表示VNodeFlags.ELEMENT = VNodeFlags.ELEMENT_HTML | VNodeFlags.ELEMENT_SVG// 普通有状态组件、需要被 keepAlive 的有状态组件、已经被 keepAlice 的有状态组件都是有状态组件，统一用 COMPONENT_STATEFUL 表示VNodeFlags.COMPONENT_STATEFUL = VNodeFlags.COMPONENT_STATEFUL_NORMAL | VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE | VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE // 有状态组件 和 函数式组件都是组件，用 COMPONENT 表示VNodeFlags.COMPONENT = VNodeFlags.COMPONENT_STATEFUL | VNodeFlags.COMPONENT_FUNCTIONALconst ChildrenFlags = { // 未知的 children 类型 UNKNOWN_CHILDREN: 0, // 没有 children NO_CHILDREN: 1, // children 是单个 VNode SINGLE_VNODE: 1 &lt;&lt; 1, // children 是多个拥有 key 的 VNode KEYED_VNODES: 1 &lt;&lt; 2, // children 是多个没有 key 的 VNode NONE_KEYED_VNODES: 1 &lt;&lt; 3}ChildrenFlags.MULTIPLE_VNODES = ChildrenFlags.KEYED_VNODES | ChildrenFlags.NONE_KEYED_VNODESexport { VNodeFlags, ChildrenFlags } 辅助创建 VNode 的 h 函数当我们拥有了 VNode 以后，接下来就需要一个辅助我们创建 VNode 的 h 函数，利用它来生成我们的 VNode 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// h.jsimport { VNodeFlags, ChildrenFlags } from './flags'export const Fragment = Symbol()export const Portal = Symbol()export function h(tag, data = null, children = null) { // 确定 flags let flags = null if (typeof tag === 'string') { flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML } else if (tag === Fragment) { flags = VNodeFlags.FRAGMENT } else if (tag === Portal) { flags = VNodeFlags.PORTAL tag = data &amp;&amp; data.target } else { // 兼容 Vue2 的对象式组件 if (tag !== null &amp;&amp; typeof tag === 'object') { flags = tag.functional ? VNodeFlags.COMPONENT_FUNCTIONAL // 函数式组件 : VNodeFlags.COMPONENT_STATEFUL_NORMAL // 有状态组件 } else if (typeof tag === 'function') { // Vue3 的类组件 flags = tag.prototype &amp;&amp; tag.prototype.render ? VNodeFlags.COMPONENT_STATEFUL_NORMAL // 有状态组件 : VNodeFlags.COMPONENT_FUNCTIONAL // 函数式组件 } } // 确定 childFlags let childFlags = null if (Array.isArray(children)) { const { length } = children if (length === 0) { // 没有 children childFlags = ChildrenFlags.NO_CHILDREN } else if (length === 1) { // 单个子节点 childFlags = ChildrenFlags.SINGLE_VNODE children = children[0] } else { // 多个子节点，且子节点使用key childFlags = ChildrenFlags.KEYED_VNODES children = normalizeVNodes(children) } } else if (children == null) { // 没有子节点 childFlags = ChildrenFlags.NO_CHILDREN } else if (children._isVNode) { // 单个子节点 childFlags = ChildrenFlags.SINGLE_VNODE } else { // 其他情况都作为文本节点处理，即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode childFlags = ChildrenFlags.SINGLE_VNODE children = createTextVNode(children + '') } // 返回 VNode 对象 return { _isVNode: true, flags, tag, data, key: data &amp;&amp; data.key ? data.key : null, children, childFlags, el: null }}function normalizeVNodes(children) { const newChildren = [] // 遍历 children for (let i = 0; i &lt; children.length; i++) { const child = children[i] if (child.key == null) { // 如果原来的 VNode 没有key，则使用竖线(|)与该VNode在数组中的索引拼接而成的字符串作为key child.key = '|' + i } newChildren.push(child) } // 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES return newChildren}export function createTextVNode(text) { return { _isVNode: true, // flags 是 VNodeFlags.TEXT flags: VNodeFlags.TEXT, tag: null, data: null, // 纯文本类型的 VNode，其 children 属性存储的是与之相符的文本内容 children: text, // 文本节点没有子节点 childFlags: ChildrenFlags.NO_CHILDREN }} 渲染器在我们在拥有了 VNode 对象以后，就可以利用渲染器来将其渲染到页面当中了，渲染器的工作流程分为两个阶段 mount 和 patch 如果旧的 VNode 存在，则会使用新的 VNode 与旧的 VNode 进行对比，试图以最小的资源开销完成 DOM 的更新，这个过程就叫 patch 如果旧的 VNode 不存在，则直接将新的 VNode 挂载成全新的 DOM，这个过程叫做 mount 同样的，挂载过程也需要分类来进行处理，一一对应着我们 VNode 对象当中的五大类，在挂载完成以后，我们就需要考虑对其的更新操作，所以这时候就需要用上 patch 函数，同样对应着对象当中的五大类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504// render.jsimport { VNodeFlags, ChildrenFlags } from './flags'import { createTextVNode } from './h'export default function render(vnode, container) { const prevVNode = container.vnode if (prevVNode == null) { if (vnode) { // 没有旧的 VNode，使用 `mount` 函数挂载全新的 VNode mount(vnode, container) // 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了 container.vnode = vnode } } else { if (vnode) { // 有旧的 VNode，则调用 `patch` 函数打补丁 patch(prevVNode, vnode, container) // 更新 container.vnode container.vnode = vnode } else { // 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。 container.removeChild(prevVNode.el) container.vnode = null } }}function mount(vnode, container, isSVG, refNode) { const { flags } = vnode if (flags &amp; VNodeFlags.ELEMENT) { // 挂载普通标签 mountElement(vnode, container, isSVG, refNode) } else if (flags &amp; VNodeFlags.COMPONENT) { // 挂载组件 mountComponent(vnode, container, isSVG) } else if (flags &amp; VNodeFlags.TEXT) { // 挂载纯文本 mountText(vnode, container) } else if (flags &amp; VNodeFlags.FRAGMENT) { // 挂载 Fragment mountFragment(vnode, container, isSVG) } else if (flags &amp; VNodeFlags.PORTAL) { // 挂载 Portal mountPortal(vnode, container, isSVG) }}function mountElement(vnode, container, isSVG, refNode) { isSVG = isSVG || vnode.flags &amp; VNodeFlags.ELEMENT_SVG const el = isSVG ? document.createElementNS('http://www.w3.org/2000/svg', vnode.tag) : document.createElement(vnode.tag) vnode.el = el const data = vnode.data if (data) { for (let key in data) { patchData(el, key, null, data[key]) } } const childFlags = vnode.childFlags const children = vnode.children if (childFlags !== ChildrenFlags.NO_CHILDREN) { if (childFlags &amp; ChildrenFlags.SINGLE_VNODE) { mount(children, el, isSVG) } else if (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) { for (let i = 0; i &lt; children.length; i++) { mount(children[i], el, isSVG) } } } refNode ? container.insertBefore(el, refNode) : container.appendChild(el)}function mountText(vnode, container) { const el = document.createTextNode(vnode.children) vnode.el = el container.appendChild(el)}function mountFragment(vnode, container, isSVG) { // 拿到 children 和 childFlags const { children, childFlags } = vnode switch (childFlags) { case ChildrenFlags.SINGLE_VNODE: // 如果是单个子节点，则直接调用 mount mount(children, container, isSVG) break case ChildrenFlags.NO_CHILDREN: // 如果没有子节点，等价于挂载空片段，会创建一个空的文本节点占位 const placeholder = createTextVNode('') mountText(placeholder, container) break default: // 多个子节点，遍历挂载之 for (let i = 0; i &lt; children.length; i++) { mount(children[i], container, isSVG) } }}function mountPortal(vnode, container) { const { tag, children, childFlags } = vnode // 获取挂载点 const target = typeof tag === 'string' ? document.querySelector(tag) : tag if (childFlags &amp; ChildrenFlags.SINGLE_VNODE) { // 将 children 挂在到 target 上，而非 container mount(children, target) } else if (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) { for (let i = 0; i &lt; children.length; i++) { // 将 children 挂在到 target 上，而非 container mount(children[i], target) } } // 占位的空文本节点 const placeholder = createTextVNode('') // 将该节点挂载到 container 中 mountText(placeholder, container, null) // el 属性引用该节点 vnode.el = placeholder.el}function mountComponent(vnode, container, isSVG) { if (vnode.flags &amp; VNodeFlags.COMPONENT_STATEFUL) { mountStatefulComponent(vnode, container, isSVG) } else { mountFunctionalComponent(vnode, container, isSVG) }}function mountStatefulComponent(vnode, container, isSVG) { // 创建组件实例 const instance = (vnode.children = new vnode.tag()) // 初始化 props instance.$props = vnode.data instance._update = function () { if (instance._mounted) { // 更新 // 1、拿到旧的 VNode const prevVNode = instance.$vnode // 2、重渲染新的 VNode const nextVNode = (instance.$vnode = instance.render()) // 3、patch 更新 patch(prevVNode, nextVNode, prevVNode.el.parentNode) // 4、更新 vnode.el 和 $el instance.$el = vnode.el = instance.$vnode.el } else { // 1、渲染VNode instance.$vnode = instance.render() // 2、挂载 mount(instance.$vnode, container, isSVG) // 3、组件已挂载的标识 instance._mounted = true // 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素 instance.$el = vnode.el = instance.$vnode.el // 5、调用 mounted 钩子 instance.mounted &amp;&amp; instance.mounted() } } instance._update()}function mountFunctionalComponent(vnode, container, isSVG) { vnode.handle = { prev: null, next: vnode, container, update: () =&gt; { if (vnode.handle.prev) { // 更新 // prevVNode 是旧的组件VNode，nextVNode 是新的组件VNode const prevVNode = vnode.handle.prev const nextVNode = vnode.handle.next // prevTree 是组件产出的旧的 VNode const prevTree = prevVNode.children // nextTree 是组件产出的新的 VNode const props = nextVNode.data const nextTree = (nextVNode.children = nextVNode.tag(props)) // 调用 patch 函数更新 patch(prevTree, nextTree, vnode.handle.container) } else { // 获取 props const props = vnode.data // 获取 VNode const $vnode = (vnode.children = vnode.tag(props)) // 挂载 mount($vnode, container, isSVG) // el 元素引用该组件的根元素 vnode.el = $vnode.el } } } // 立即调用 vnode.handle.update 完成初次挂载 vnode.handle.update()}function patch(prevVNode, nextVNode, container) { const nextFlags = nextVNode.flags const prevFlags = prevVNode.flags if (prevFlags !== nextFlags) { replaceVNode(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.ELEMENT) { patchElement(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.COMPONENT) { patchComponent(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.TEXT) { patchText(prevVNode, nextVNode) } else if (nextFlags &amp; VNodeFlags.FRAGMENT) { patchFragment(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.PORTAL) { patchPortal(prevVNode, nextVNode) }}function replaceVNode(prevVNode, nextVNode, container) { container.removeChild(prevVNode.el) if (prevVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) { const instance = prevVNode.children instance.unmounted &amp;&amp; instance.unmounted() } mount(nextVNode, container)}function patchElement(prevVNode, nextVNode, container) { // 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数使用新的 VNode 替换旧的 VNode if (prevVNode.tag !== nextVNode.tag) { replaceVNode(prevVNode, nextVNode, container) return } // 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素 const el = (nextVNode.el = prevVNode.el) const prevData = prevVNode.data const nextData = nextVNode.data if (nextData) { for (let key in nextData) { const prevValue = prevData[key] const nextValue = nextData[key] patchData(el, key, prevValue, nextValue) } } if (prevData) { for (let key in prevData) { const prevValue = prevData[key] if (prevValue &amp;&amp; !nextData.hasOwnProperty(key)) { patchData(el, key, prevValue, null) } } } // 调用 patchChildren 函数递归的更新子节点 patchChildren( prevVNode.childFlags, // 旧的 VNode 子节点的类型 nextVNode.childFlags, // 新的 VNode 子节点的类型 prevVNode.children, // 旧的 VNode 子节点 nextVNode.children, // 新的 VNode 子节点 el // 当前标签元素，即这些子节点的父节点 )}function patchChildren( prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // 旧的 children 是单个子节点，会执行该 case 语句块 case ChildrenFlags.SINGLE_VNODE: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: // 新的 children 也是单个子节点时，会执行该 case 语句块 patch(prevChildren, nextChildren, container) break case ChildrenFlags.NO_CHILDREN: // 新的 children 中没有子节点时，会执行该 case 语句块 container.removeChild(prevChildren.el) break default: // 但新的 children 中有多个子节点时，会执行该 case 语句块 container.removeChild(prevChildren.el) for (let i = 0; i &lt; nextChildren.length; i++) { mount(nextChildren[i], container) } break } break // 旧的 children 中没有子节点时，会执行该 case 语句块 case ChildrenFlags.NO_CHILDREN: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: // 新的 children 是单个子节点时，会执行该 case 语句块 mount(nextChildren, container) break case ChildrenFlags.NO_CHILDREN: // 新的 children 中没有子节点时，会执行该 case 语句块 break default: // 但新的 children 中有多个子节点时，会执行该 case 语句块 for (let i = 0; i &lt; nextChildren.length; i++) { mount(nextChildren[i], container) } break } break // 旧的 children 中有多个子节点时，会执行该 case 语句块 default: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: for (let i = 0; i &lt; prevChildren.length; i++) { container.removeChild(prevChildren[i].el) } mount(nextChildren, container) break case ChildrenFlags.NO_CHILDREN: for (let i = 0; i &lt; prevChildren.length; i++) { container.removeChild(prevChildren[i].el) } break default: // 但新的 children 中有多个子节点时，会执行该 case 语句块 let lastIndex = 0 for (let i = 0; i &lt; nextChildren.length; i++) { const nextVNode = nextChildren[i] let j = 0, find = false for (j; j &lt; prevChildren.length; j++) { const prevVNode = prevChildren[j] if (nextVNode.key === prevVNode.key) { find = true patch(prevVNode, nextVNode, container) if (j &lt; lastIndex) { // 需要移动 const refNode = nextChildren[i - 1].el.nextSibling container.insertBefore(prevVNode.el, refNode) break } else { // 更新 lastIndex lastIndex = j } } } if (!find) { // 挂载新节点 const refNode = i - 1 &lt; 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling mount(nextVNode, container, false, refNode) } } // 移除已经不存在的节点 for (let i = 0; i &lt; prevChildren.length; i++) { const prevVNode = prevChildren[i] const has = nextChildren.find( nextVNode =&gt; nextVNode.key === prevVNode.key ) if (!has) { // 移除 container.removeChild(prevVNode.el) } } break } break }}function patchText(prevVNode, nextVNode) { // 拿到文本节点 el，同时让 nextVNode.el 指向该文本节点 const el = (nextVNode.el = prevVNode.el) // 只有当新旧文本内容不一致时才有必要更新 if (nextVNode.children !== prevVNode.children) { el.nodeValue = nextVNode.children }}function patchFragment(prevVNode, nextVNode, container) { // 直接调用 patchChildren 函数更新 新旧片段的子节点即可 patchChildren( prevVNode.childFlags, // 旧片段的子节点类型 nextVNode.childFlags, // 新片段的子节点类型 prevVNode.children, // 旧片段的子节点 nextVNode.children, // 新片段的子节点 container ) switch (nextVNode.childFlags) { case ChildrenFlags.SINGLE_VNODE: nextVNode.el = nextVNode.children.el break case ChildrenFlags.NO_CHILDREN: nextVNode.el = prevVNode.el break default: nextVNode.el = nextVNode.children[0].el }}function patchPortal(prevVNode, nextVNode) { patchChildren( prevVNode.childFlags, nextVNode.childFlags, prevVNode.children, nextVNode.children, prevVNode.tag // 注意 container 是旧的 container ) // 让 nextVNode.el 指向 prevVNode.el nextVNode.el = prevVNode.el // 如果新旧容器不同，才需要搬运 if (nextVNode.tag !== prevVNode.tag) { // 获取新的容器元素，即挂载目标 const container = typeof nextVNode.tag === 'string' ? document.querySelector(nextVNode.tag) : nextVNode.tag switch (nextVNode.childFlags) { case ChildrenFlags.SINGLE_VNODE: // 如果新的 Portal 是单个子节点，就把该节点搬运到新容器中 container.appendChild(nextVNode.children.el) break case ChildrenFlags.NO_CHILDREN: // 新的 Portal 没有子节点，不需要搬运 break default: // 如果新的 Portal 是多个子节点，遍历逐个将它们搬运到新容器中 for (let i = 0; i &lt; nextVNode.children.length; i++) { container.appendChild(nextVNode.children[i].el) } break } }}function patchComponent(prevVNode, nextVNode, container) { if (nextVNode.tag !== prevVNode.tag) { replaceVNode(prevVNode, nextVNode, container) } else if (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) { // 获取组件实例 const instance = (nextVNode.children = prevVNode.children) // 更新 props instance.$props = nextVNode.data // 更新组件 instance._update() } else { // 更新函数式组件 const handle = (nextVNode.handle = prevVNode.handle) handle.prev = prevVNode handle.next = nextVNode handle.container = container handle.update() }}function patchData(el, key, prevValue, nextValue) { const domPropsRE = /\\W|^(?:value|checked|selected|muted)$/ switch (key) { case 'style': for (let k in nextValue) { el.style[k] = nextValue[k] } for (let k in prevValue) { if (!nextValue.hasOwnProperty(k)) { el.style[k] = '' } } break case 'class': el.className = nextValue break default: if (key[0] === 'o' &amp;&amp; key[1] === 'n') { // 事件 // 移除旧事件 if (prevValue) { el.removeEventListener(key.slice(2), prevValue) } // 添加新事件 if (nextValue) { el.addEventListener(key.slice(2), nextValue) } } else if (domPropsRE.test(key)) { // 当做 DOM Prop 处理 el[key] = nextValue } else { // 当做 Attr 处理 el.setAttribute(key, nextValue) } break }} 核心 Diff 算法只有当新旧子节点的类型都是多个子节点时，核心 diff 算法才派得上用场，如下图所示 在 diff 算法一章，我们主要介绍了三种不同的算法，下面我们一个一个来进行回顾 这里需要注意，采用不同的算法只需要替换 patchChildren 函数当中的新旧 children 中都有多个子节点的情况下的分支判断即可 React 所采用 Diff 算法React 当中所采用的方式是利用 key 来尽可能的复用 DOM 元素，然后在遍历当中使用『最大索引值』的概念来确定需要移动的元素，接着在内层循环当中采用标记变量的方式来确定是否需要挂载新的元素，最后在外层循环结束之后，再遍历一次旧的节点，如果在新节点当中找不到相对应的，则删除掉对应节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function patchChildren(prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // ... 省略（见上方） // 只有当新旧子节点的类型都是多个子节点时，核心 Diff 算法才派得上用场 default: switch (nextChildFlags) { // ... 省略（见上方） /** * react 所采用 diff 算法 */ default: let lastIndex = 0 for (let i = 0; i &lt; nextChildren.length; i++) { const nextVNode = nextChildren[i] let j = 0, find = false for (j; j &lt; prevChildren.length; j++) { const prevVNode = prevChildren[j] if (nextVNode.key === prevVNode.key) { find = true patch(prevVNode, nextVNode, container) if (j &lt; lastIndex) { // 需要移动 const refNode = nextChildren[i - 1].el.nextSibling container.insertBefore(prevVNode.el, refNode) break } else { // 更新 lastIndex lastIndex = j } } } if (!find) { // 挂载新节点 const refNode = i - 1 &lt; 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling mount(nextVNode, container, false, refNode) } } // 移除已经不存在的节点 for (let i = 0; i &lt; prevChildren.length; i++) { const prevVNode = prevChildren[i] const has = nextChildren.find( nextVNode =&gt; nextVNode.key === prevVNode.key ) if (!has) { // 移除 container.removeChild(prevVNode.el) } } break } break }} Vue2 所采用 Diff 算法Vue2 所采用的是『双端比较』的算法，借鉴于开源项目 snabbdom，原理是使用四个变量分别存储新旧两个端点的位置索引，在结合四个位置索引所指向的 VNode，依次从两端开始进行比较，根据四次比较当中的各种情况进行不同的处理方式，对于经过四次比较依然没有找到可复用的节点的非理想情况，则采用再次遍历旧的节点的方式分情况进行处理 如果寻找到与第一个新节点当中拥有相同 key 值的元素，就会将其更新，并且将该节点置为 undefined，后续过程则会跳过这个状态 如果没有寻找到，这说明是一个全新的节点，挂载即可，为了避免遗漏，会在循环完毕之后再次进行判断，如果还存在没有被处理的全新节点，则一样会被挂载 同样的，在循环完毕后会进行判断有没有多余的元素，如果存在则说明有元素需要被移除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function patchChildren(prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // ... 省略（见上方） // 只有当新旧子节点的类型都是多个子节点时，核心 Diff 算法才派得上用场 default: switch (nextChildFlags) { // ... 省略（见上方） /** * vue2 所采用 diff 算法 */ default: // 当新的 children 中有多个子节点时，会执行该 case 语句块 let oldStartIdx = 0 let oldEndIdx = prevChildren.length - 1 let newStartIdx = 0 let newEndIdx = nextChildren.length - 1 let oldStartVNode = prevChildren[oldStartIdx] let oldEndVNode = prevChildren[oldEndIdx] let newStartVNode = nextChildren[newStartIdx] let newEndVNode = nextChildren[newEndIdx] while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (!oldStartVNode) { oldStartVNode = prevChildren[++oldStartIdx] } else if (!oldEndVNode) { oldEndVNode = prevChildren[--oldEndIdx] } else if (oldStartVNode.key === newStartVNode.key) { patch(oldStartVNode, newStartVNode, container) oldStartVNode = prevChildren[++oldStartIdx] newStartVNode = nextChildren[++newStartIdx] } else if (oldEndVNode.key === newEndVNode.key) { patch(oldEndVNode, newEndVNode, container) oldEndVNode = prevChildren[--oldEndIdx] newEndVNode = nextChildren[--newEndIdx] } else if (oldStartVNode.key === newEndVNode.key) { patch(oldStartVNode, newEndVNode, container) container.insertBefore( oldStartVNode.el, oldEndVNode.el.nextSibling ) oldStartVNode = prevChildren[++oldStartIdx] newEndVNode = nextChildren[--newEndIdx] } else if (oldEndVNode.key === newStartVNode.key) { patch(oldEndVNode, newStartVNode, container) container.insertBefore(oldEndVNode.el, oldStartVNode.el) oldEndVNode = prevChildren[--oldEndIdx] newStartVNode = nextChildren[++newStartIdx] } else { const idxInOld = prevChildren.findIndex( node =&gt; node.key === newStartVNode.key ) if (idxInOld &gt;= 0) { const vnodeToMove = prevChildren[idxInOld] patch(vnodeToMove, newStartVNode, container) prevChildren[idxInOld] = undefined container.insertBefore(vnodeToMove.el, oldStartVNode.el) } else { // 新节点 mount(newStartVNode, container, false, oldStartVNode.el) } newStartVNode = nextChildren[++newStartIdx] } } if (oldEndIdx &lt; oldStartIdx) { // 添加新节点 for (let i = newStartIdx; i &lt;= newEndIdx; i++) { mount(nextChildren[i], container, false, oldStartVNode.el) } } else if (newEndIdx &lt; newStartIdx) { // 移除操作 for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) { container.removeChild(prevChildren[i].el) } } break } break }} inferno 所采用 Diff 算法也是在 Vue3 中将采用的一种算法，原理是在进行 diff 算法之前，先进行一次预处理，剔除掉相同的前置和后置元素，原理是建立一个索引，指向新旧子节点中的第一个节点，并逐步向后遍历，直到遇到两个拥有不同 key 值的节点为止，然后根据索引之间的关系来进行对应的单独处理 对于判断是否需要进行 DOM 移动，采用了构造一个数组来记录新子节点在经过预处理之后剩余未处理节点的数量 采用构建索引表（为了将时间复杂度由 O(n^2) 降为 O(n)）的方式对新旧子节点中具有相同 key 值的节点进行更新，来确定是否需要移动操作 最后利用最长递增子序列的方式来进行 DOM 的移动操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function patchChildren(prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // ... 省略（见上方） // 只有当新旧子节点的类型都是多个子节点时，核心 Diff 算法才派得上用场 default: switch (nextChildFlags) { // ... 省略（见上方） /** * inferno 所采用 diff 算法 */ default: // 更新相同的前缀节点 let j = 0 let prevVNode = prevChildren[j] let nextVNode = nextChildren[j] let prevEnd = prevChildren.length - 1 let nextEnd = nextChildren.length - 1 outer: { while (prevVNode.key === nextVNode.key) { patch(prevVNode, nextVNode, container) j++ if (j &gt; prevEnd || j &gt; nextEnd) { break outer } prevVNode = prevChildren[j] nextVNode = nextChildren[j] } // 更新相同的后缀节点 prevVNode = prevChildren[prevEnd] nextVNode = nextChildren[nextEnd] while (prevVNode.key === nextVNode.key) { patch(prevVNode, nextVNode, container) prevEnd-- nextEnd-- if (j &gt; prevEnd || j &gt; nextEnd) { break outer } prevVNode = prevChildren[prevEnd] nextVNode = nextChildren[nextEnd] } } if (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) { // j -&gt; nextEnd 之间的节点应该被添加 const nextPos = nextEnd + 1 const refNode = nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null while (j &lt;= nextEnd) { mount(nextChildren[j++], container, false, refNode) } } else if (j &gt; nextEnd) { while (j &lt;= prevEnd) { container.removeChild(prevChildren[j++].el) } } else { // 构造 source 数组 const nextLeft = nextEnd - j + 1 // 新 children 中剩余未处理节点的数量 const source = [] for (let i = 0; i &lt; nextLeft; i++) { source.push(-1) } const prevStart = j const nextStart = j let moved = false let pos = 0 // 构建索引表 const keyIndex = {} for (let i = nextStart; i &lt;= nextEnd; i++) { keyIndex[nextChildren[i].key] = i } let patched = 0 // 遍历旧 children 的剩余未处理节点 for (let i = prevStart; i &lt;= prevEnd; i++) { prevVNode = prevChildren[i] if (patched &lt; nextLeft) { // 通过索引表快速找到新 children 中具有相同 key 的节点的位置 const k = keyIndex[prevVNode.key] if (typeof k !== 'undefined') { nextVNode = nextChildren[k] // patch 更新 patch(prevVNode, nextVNode, container) patched++ // 更新 source 数组 source[k - nextStart] = i // 判断是否需要移动 if (k &lt; pos) { moved = true } else { pos = k } } else { // 没找到，说明旧节点在新 children 中已经不存在了，应该移除 container.removeChild(prevVNode.el) } } else { // 多余的节点，应该移除 container.removeChild(prevVNode.el) } } if (moved) { const seq = lis(source) // j 指向最长递增子序列的最后一个值 let j = seq.length - 1 // 从后向前遍历新 children 中的剩余未处理节点 for (let i = nextLeft - 1; i &gt;= 0; i--) { if (source[i] === -1) { // 作为全新的节点挂载 // 该节点在新 children 中的真实位置索引 const pos = i + nextStart const nextVNode = nextChildren[pos] // 该节点下一个节点的位置索引 const nextPos = pos + 1 // 挂载 mount( nextVNode, container, false, nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null ) } else if (i !== seq[j]) { // 说明该节点需要移动 // 该节点在新 children 中的真实位置索引 const pos = i + nextStart const nextVNode = nextChildren[pos] // 该节点下一个节点的位置索引 const nextPos = pos + 1 // 移动 container.insertBefore( nextVNode.el, nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null ) } else { // 当 i === seq[j] 时，说明该位置的节点不需要移动 // 并让 j 指向下一个位置 j-- } } } } break } break }}","link":"/2019/12/23/React/09/"},{"title":"React 查漏补缺","text":"本章主要用于记录一些 React 相关知识点，因为最近在复习 React 相关内容，发现版本迭代了许多，废弃了很多 API，也添加了一些新的方法（比如生命周期钩子等），所以就简单的在这里汇总整理一下，也算是查漏补缺 回调函数中的 this通常，我们在 React 当中的事件处理是下面这样 12345678910111213141516171819class Toggle extends React.Component { constructor(props) { super(props) this.state = { isToggleOn: true } // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this) } handleClick() { this.setState(state =&gt; ({ isToggleOn: !state.isToggleOn })) } render() { return &lt;button onClick={this.handleClick}&gt;{this.state.isToggleOn ? 'ON' : 'OFF'}&lt;/button&gt; }} 我们之所以要在构造函数当中进行显式的 this 绑定，这是因为在 JavaScript 中，Class 的方法默认不会绑定 this，如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined，如果不想显式的执行绑定操作的话，我们经常还会采用下面这种方式，即使用箭头函数的方式 12345678910class LoggingButton extends React.Component { handleClick() { console.log('this is:', this) } render() { // 此语法确保 `handleClick` 内的 `this` 已被绑定 return &lt;button onClick={() =&gt; this.handleClick()}&gt;Click me&lt;/button&gt; }} 此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数，在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染，所以建议使用下面这种方式来进行绑定，即使用 Class fields 语法 12345678910class LoggingButton extends React.Component { // 确保 `handleClick` 内的 `this` 已被绑定 handleClick = () =&gt; { console.log('this is:', this) } render() { return &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt; }} 事件处理程序参数传递在循环中，通常我们会为事件处理函数传递额外的参数，例如 id 是你要删除那一行的 id，以下两种方式都可以向事件处理函数传递参数 12345&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;// or&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt; 在这两种情况下，React 的事件对象 e 会被作为第二个参数传递，如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递 组件通信的几种方式 我们先来看看需要组件之进行通信的几种情况 父组件向子组件通信 子组件向父组件通信 跨级组件通信 没有嵌套关系组件之间的通信 父组件向子组件通信通常通过 props 向子组件传递需要的信息 12345678910111213141516// ChildChild.propTypes = { name: PropTypes.string.isRequired,}export default function Child({ name }) { return &lt;h1&gt;Hello, {name}&lt;/h1&gt;}// Parentexport default class Parent extends Component { render() { return &lt;Child name=\"zhangsan\" /&gt; }} 子组件向父组件通信主要是利用回调函数的方式，另外也可以利用自定义事件机制，这个我们会在下面一起来进行介绍，这里我们主要来看回调函数的方式 123456789101112131415161718192021222324252627282930313233343536373839404142// Listexport default class List extends Component { static propTypes = { hideConponent: PropTypes.func.isRequired } render() { return ( &lt;div&gt; List &lt;button onClick={this.props.hideConponent}&gt;隐藏 List&lt;/button&gt; &lt;/div&gt; ) }}// Appexport default class App extends Component { constructor(...args) { super(...args) this.state = { isShowList: false } } showConponent = () =&gt; { this.setState({ isShowList: true, }) } hideConponent = () =&gt; { this.setState({ isShowList: false, }) } render() { return ( &lt;div&gt; &lt;button onClick={this.showConponent}&gt;显示 Lists 组件&lt;/button&gt; { this.state.isShowList ? &lt;List hideConponent={this.hideConponent} /&gt; : null } &lt;/div&gt; ) }} 观察一下实现方法，可以发现它与传统回调函数的实现方法一样，而且 setState 一般与回调函数均会成对出现，因为回调函数即是转换内部状态的函数传统 另外我们也可以使用 onRef，原理与上面的方式是一致的 1234567891011121314151617181920212223242526272829303132333435363738// Childexport default class Child extends React.Component { state = { name: '初始值' } componentDidMount() { this.props.onRef(this, this.state.name) } click = () =&gt; { this.setState({ name: '改变后的值' }) }; render() { return ( &lt;div&gt; &lt;div&gt; &lt;div&gt;{this.state.name}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) }}// Appclass App extends Component { handleParentClick = (ref) =&gt; { console.log(ref.state.name) ref.click() } render() { return &lt;Child onRef={this.handleParentClick} /&gt; }} 跨级组件通信有两种实现方式 层层组件传递 props 例如 A 组件和 B 组件之间要进行通信，先找到 A 和 B 公共的父组件，A 先向 C 组件通信，C 组件通过 props 和 B 组件通信，此时 C 组件起的就是中间件的作用 使用 Context Context是一个全局变量，像是一个大容器，在任何地方都可以访问到，我们可以把要通信的信息放在 Context 上，然后在其他组件中可以随意取到 但是 React 官方不建议使用大量 Context，尽管他可以减少逐层传递，但是当组件结构复杂的时候，我们并不知道 Context是从哪里传过来的 而且 Context是一个全局变量，全局变量正是导致应用走向混乱的罪魁祸首 这里我们主要来看看 Context 的使用方式，比如下面这个示例，其中 ListItem 是 List 的子组件，List 是 App 的子组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ListItemexport default class ListItem extends Component { // 子组件声明自己要使用 context，并且 contextTypes 是必写的 static contextTypes = { color: PropTypes.string, } static propTypes = { value: PropTypes.string, } render() { const { value } = this.props return ( &lt;li style={{ background: this.context.color }}&gt; &lt;span&gt;{value}&lt;/span&gt; &lt;/li&gt; ) }}// Listexport default class List extends Component { // 父组件声明自己支持 context static childContextTypes = { color: PropTypes.string, } static propTypes = { list: PropTypes.array, } // 提供一个函数，用来返回相应的 context 对象 getChildContext() { return { color: 'red', } } render() { const { list } = this.props return ( &lt;div&gt; &lt;ul&gt; { list.map((entry, index) =&gt; &lt;ListItem key={`list-${index}`} value={entry.text} /&gt;) } &lt;/ul&gt; &lt;/div&gt; ) }} 1234567891011// Appconst list = [ { text: '题目一', }, { text: '题目二', },]export default class App extends Component { render() { return &lt;List list={list} /&gt; }} 没有嵌套关系的组件通信如果在业务逻辑不是十分复杂的情况下推荐使用自定义事件机制，这里以常用的 发布/订阅 模式举例，借用 Node.js 当中的 Events 模块的浏览器版实现，比如我们要实现这样一个功能，点击 List2 中的一个按钮，改变 List1 中的信息显示，其中 List1 和 List2 没有任何嵌套关系，App 是他们的父组件 我们首先需要安装 events 包 1$ npm install events --save 然后我们新建一个 events.js 1234// events.jsimport { EventEmitter } from 'events'export default new EventEmitter() 接下来进行使用即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// List1export default class List extends Component { constructor(props) { super(props) this.state = { message: 'List1', } } componentDidMount() { // 组件装载完成以后声明一个自定义事件 this.eventEmitter = emitter.addListener('changeMessage', (message) =&gt; { this.setState({ message, }) }) } componentWillUnmount() { // 组件卸载的时候取消订阅 emitter.removeListener(this.eventEmitter) } render() { return &lt;div&gt;{this.state.message}&lt;/div&gt; }}// List2export default class List2 extends Component { handleClick = (message) =&gt; { emitter.emit('changeMessage', message) } render() { return &lt;div&gt;&lt;button onClick={this.handleClick.bind(this, 'List2')}&gt;点击我改变 List1 组件中显示信息&lt;/button&gt;&lt;/div&gt; }}// APPexport default class App extends Component { render() { return ( &lt;div&gt; &lt;List1 /&gt; &lt;List2 /&gt; &lt;/div&gt; ) }} 自定义事件是典型的发布订阅模式，通过向事件对象上添加监听器和触发事件来实现组件之间的通信 总结 父组件向子组件通信使用 props 子组件向父组件通信使用回调函数或者自定义事件 跨级组件通信使用层层组件传递 props 的方式或是 Context 没有嵌套关系组件之间的通信推荐使用自定义事件 但是在进行组件通信的时候，主要还是看业务的具体需求来选择最为合适的，当业务逻辑复杂到一定程度，可以考虑引入 Mobx 或 Redux 等状态管理工具 对比我们在上面介绍了一些比较常见的处安置方式，但是 React 当中的传参方式并不只有这些，下表列举了一些在 React 当中可以使用的传参方式，我们可以对比一下它们之间的优缺点，然后根据实际场景选择使用 方法 优点 缺点 props 不需要引入外部插件 兄弟组件通讯需要建立共同父级组件，较为麻烦 Provider，Consumer 和 Context 不需要引入外部插件，跨多级组件或者兄弟组件通讯利器 状态数据状态追踪麻烦 EventEmitter 可支持兄弟，父子组件通讯 要引入外部插件 路由传参 可支持兄弟组件传值，页面简单数据传递非常方便 父子组件通讯无能为力 onRef 可以在获取整个子组件实例，使用简单 兄弟组件通讯麻烦，官方不建议使用 ref 同 onRef 同 onRef Redux 建立了全局的状态管理器，兄弟父子通讯都可解决 引入了外部插件 Mobx 建立了全局的状态管理器，兄弟父子通讯都可解决 引入了外部插件 Flux 建立了全局的状态管理器，兄弟父子通讯都可解决 引入了外部插件 Hook 16.x 新的属性，可支持兄弟，父子组件通讯 需要结合 Context 一起使用 slot 支持父向子传标签 下面我们来看看 Redux，Mobx 和 Flux 三者之间简单的对比，详细内容可以参考 Redux、Flux 和 React-Redux 三者之间的区别 Redux 核心模块 action，reducer，store store 和更改逻辑是分开的，并且只有一个 store 没有调度器的概念，而且容器组件是有联系的 状态是不可改变的，更多的是遵循函数式编程思想 Mobx 核心模块 action，reducer，Derivation 有多个 store 设计更多偏向于面向对象编程和响应式编程，通常将状态包装成可观察对象，一旦状态对象变更，就能自动获得更新 Flux 核心模块 store，Reduce，Container 有多个 store React.lazyReact.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件），在使用之前 1import OtherComponent from './OtherComponent' 而使用之后 1const OtherComponent = React.lazy(() =&gt; import('./OtherComponent')) 不过更为常见的方式是搭配 React.Suspense 使用 12345678910111213import React, { Suspense } from 'react'const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; )} React.lazy() 接收一个函数作为参数，该函数需要返回一个 Promise 对象，reslove 后返回一个模块，模块的默认导出对象作为渲染的 React 组件，例如 1234567import React from 'react'function OtherComponent() { return &lt;h1&gt;Hello World&lt;/h1&gt;}export default OtherComponent 如何支持有名导出的模块使用 React.lazy() 加载的模块，如果其中的 React 组件不是默认导出话，可能会报以下错误 123Warning: React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports. 这是因为 React.lazy() 目前只支持默认导出（Default Export），不支持有名导出（Named Exports），假如在 OtherComponent 中导出了多个组件，如下 12345678910111213import React, { Component } from 'react'export class AComponent extends Component { render() { return &lt;div&gt;Hello&lt;/div&gt; }}export class BComponent extends Component { render() { return &lt;div&gt;World&lt;/div&gt; }} 我们在 OtherComponent 组件当中分别导出了 AComponent 和 BComponent 两个组件，在不修改 OtherComponent 的前提下，可以这样写 123456789101112131415161718192021222324const OtherComponent = React.lazy(() =&gt; { return new Promise((resolve, reject) =&gt; { import('./OtherComponent').then(module =&gt; { resolve({ // 这里可以根据需求加载 `AComponent` 或是 `BComponent` default: module.AComponent }) }).catch(err =&gt; { reject(err) }) })})export default class Test extends Component { render() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; ) }} 搭配 Webpack 实现代码分割借助 Webpack 的 Code Splitting 功能，使用动态 import() 引入的模块会被自动拆分为异步加载的 chunk，如果希望自定义 chunk 的文件名，可以在 import() 中加入 Webpack 特定的注释，如下 123const OtherComponent = React.lazy( () =&gt; import(/* webpackChunkName: 'Other-Component' */ './OtherComponent')) 例如如下代码 123456789101112131415const AComponent = React.lazy(() =&gt; import(/* webpackChunkName: 'A-component' */ './AComponent'))const BComponent = React.lazy(() =&gt; import(/* webpackChunkName: 'B-component' */ './BComponent'))export default class Test extends Component { render() { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;AComponent /&gt; &lt;BComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; ) }} 运行后可以在控制台的 Network 选项当中发现 A-component.chunk.js 和 B-component.chunk.js setState() 是同步还是异步我们从一个简单的例子开始看起，如下 1234567891011121314class App extends Component { state = { val: 0 } increment = () =&gt; { this.setState({ val: this.state.val + 1 }) // 需要注意的是这里的值仍为 0 console.log(this.state.val) } render() { return &lt;div onClick={this.increment}&gt;{`Counter is ${this.state.val}`}&lt;/div&gt; }} 运行以后我们可以发现，输出的值仍为 0，所以在本节当中，我们就来简单的探讨一下这个问题，其实在 React 中，setState() 的使用场景一般有以下这些 合成事件中 setState() 生命周期函数中的 setState() 原生事件中的 setState() setTimeout 中的 setState() setState() 中的批量更新 所以下面我们就分别来看看这些不同情况下的结果 合成事件中 setState()在 JSX 中常见的 onClick()、onChange() 这些其实本质上都是合成事件，也就是属于 React 来进行管辖的范围，就比如上面的例子，我们可以知道它的结果为 0 生命周期函数中的 setState()1234567891011121314class App extends Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) // 需要注意的是这里的值仍为 0 console.log(this.state.val) } render() { return &lt;div&gt;{`Counter is ${this.state.val}`}&lt;/div&gt; }} 其实还是和合成事件一样，当 componentDidmount() 执行的时候，React 内部并没有更新，这就导致在 componentDidmount() 中调用完 setState() 以后去 console.log() 拿到的结果还是更新之前的值 原生事件中的 setState()123456789101112131415161718class App extends Component { state = { val: 0 } changeValue = () =&gt; { this.setState({ val: this.state.val + 1 }) // 需要注意的是这里的值为 1 console.log(this.state.val) } componentDidMount() { document.body.addEventListener('click', this.changeValue, false) } render() { return &lt;div&gt;{`Counter is ${this.state.val}`}&lt;/div&gt; }} 原生事件是指非 React 合成事件，比如上面的 addEventListener()，它相较于合成事件，会直接触发点击事件，所以当你在原生事件中 setState() 后，能同步拿到更新后的 state 值 setTimeout 中的 setState()12345678910111213141516class App extends Component { state = { val: 0 } componentDidMount() { setTimeout(_ =&gt; { this.setState({ val: this.state.val + 1 }) // 需要注意的是这里的值为 1 console.log(this.state.val) }, 0) } render() { return &lt;div&gt;{`Counter is ${this.state.val}`}&lt;/div&gt; }} 在 setTimeout() 中去使用 setState() 并不算是一个单独的场景，它是随着外层所决定的，因为你可以在合成事件中使用 setTimeout()，可以在钩子函数中使用 setTimeout()，也可以在原生事件中使用 setTimeout()，但是不管是哪个场景下，基于 EventLoop 的模型下， 在 setTimeout() 当中去 setState() 总能拿到最新的 state 值 setState 中的批量更新123456789101112131415class App extends Component { state = { val: 0 } batchUpdates = () =&gt; { this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) // 需要注意的是这里的值仍为 1 } render() { return &lt;div onClick={this.batchUpdates}&gt;{`Counter is ${this.state.val}`}&lt;/div&gt; }} 在调用 setState() 的时候 React 内部会创建一个更新队列，通过 firstUpdate/lastUpdate/lastUpdate.next 等方式去维护一个更新队列，在最终的 performWork 当中，相同的 key 会被覆盖，所以只会对最后一次的 setState() 进行更新，而如果我们使用一些别的方式，如下 1234567891011121314151617181920212223class App extends React.Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) this.setState({ val: this.state.val + 1 }) console.log(this.state.val) setTimeout(_ =&gt; { this.setState({ val: this.state.val + 1 }) console.log(this.state.val); this.setState({ val: this.state.val + 1 }) console.log(this.state.val) }, 0) } render() { return &lt;div&gt;{this.state.val}&lt;/div&gt; }} 结合上面分析的，钩子函数中的 setState() 无法立即拿到更新后的值，所以前两次都是输出 0，当执行到 setTimeout() 里的时候，前面两个 state 的值已经被更新，由于 setState() 批量更新的策略， this.state.val 只对最后一次的生效，为 1，而在 setTimeout() 中 setState() 是可以同步拿到更新结果，所以 setTimeout() 中的两次输出 2，3，最终结果就为 0，0，2，3 总结简单来说，有时表现出异步，有时表现出同步 setState() 只在合成事件和钩子函数当中可以理解为异步的，在原生事件和 setTimeout() 中都是同步的 setState() 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的异步，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果（这个可以参考官方文档当中的 State 的更新可能是异步的） setState() 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout() 中不会批量更新，在异步中如果对同一个值进行多次 setState()，setState() 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState() 多个不同的值，在更新时会对其进行合并批量更新 如果使用一种比较好的记忆方式来进行概括的话，就是 React 管得到的就是异步，管不到的就是同步 最后我们在简单的提及一个使用 setState() 的小技巧，那就是它还可以接收第二个参数，作用是在 state 值改变后进行调用 12345this.setState( { count: 3 }, () =&gt; { // ... }) 监听数据变化在 React 的 16.x 之前的版本我们可以使用 componentWillReceiveProps()（当然现在还暂未移除，不过调整成了 UNSAFE_componentWillReceiveProps()） 12345componentWillReceiveProps(nextProps){ if (this.props.visible !== nextProps.visible) { // props 值改变做的事 }} 但是有一点需要注意的就是，有些时候 componentWillReceiveProps() 在 props 值未变化也会触发，因为在生命周期的第一次 render() 后不会被调用，但是会在之后的每次 render() 中被调用（当父组件再次传送 props） 在 React 的 16.x 以后的版本当中我们可以使用 getDerivedStateFromProps() 这个静态方法 123456789101112131415161718192021222324252627export default class App extends React.Component { state = { countOne: 1, changeFlag: '' } clickOne = () =&gt; { let { countOne } = this.state this.setState({ countOne: countOne + 1 }) } static getDerivedStateFromProps(nextProps) { console.log(`变化执行`) return { changeFlag: 'state 值变化执行' } } render() { const { countOne, changeFlag } = this.state return ( &lt;div&gt; &lt;div&gt; &lt;Button type=\"primary\" onClick={this.clickOne}&gt;点击加 1&lt;/Button&gt;&lt;span&gt;countOne 值为{countOne}&lt;/span&gt; &lt;div&gt;{changeFlag}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) }} 使用 React Hook 来检查网络连接状态我们都知道，在 JavaScript 当中有一个 Navigator 对象，它包含当前浏览器的状态和特性，比如定位、userAgent 和一些其他的属性，其中就包括当前是否处于网络连接状态，这里我们需要获取的就是 onLine 这个属性（这里需要注意它是驼峰命名的形式），下面我们就来看看如何在 Hook 中来使用 显然我们的首要任务是需要一些状态来跟踪记录我们是否在线的状态以及把它从我们的自定义 Hook 中 return 出来，如下 1234function useNetwork() { const [isOnline, setOnline] = useState(window.navigator.onLine) return isOnline} 当组件正常挂载时这样做没有问题，但是如果当用户在渲染完成之后掉线我们该怎么做呢？所幸的是，我们可以监听两个事件，触发时以更新状态，为了达到这个效果我们需要使用 useEffect Hook 12345678function useNetwork() { const [isOnline, setNetwork] = useState(window.navigator.onLine) useEffect(() =&gt; { window.addEventListener('offline', _ =&gt; setNetwork(window.navigator.onLine)) window.addEventListener('online', _ =&gt; setNetwork(window.navigator.onLine)) }) return isOnline} 如你所见我们监听了两个事件，offline 和 online（这里就不是驼峰命名的形式了），当事件触发的时候会随之更新状态，但是我们都知道在处理 useEffect 的时候应该 return 一个清理函数，这样 React 就可以帮助我们移除事件的监听，所以我们就不能直接在 addEventListener 当中使用箭头函数的方式了，而是应该传递同一个函数，这样 React 才能明确是哪一个监听器应该被移除，下面是我们最终版本的代码 123456789101112131415function useNetwork() { const [isOnline, setNetwork] = useState(window.navigator.onLine) const updateNetwork = () =&gt; { setNetwork(window.navigator.onLine) } useEffect(() =&gt; { window.addEventListener('offline', updateNetwork) window.addEventListener('online', updateNetwork) return () =&gt; { window.removeEventListener('offline', updateNetwork) window.removeEventListener('online', updateNetwork) } }) return isOnline} 如何确保一个对象仅被创建一次比如一个常见的使用场景就是创建初始 state 需要花费大量的计算的时候，比如下面这个示例 12345function Table(props) { // ⚠️ createRows() 每次渲染都会被调用 const [rows, setRows] = useState(createRows(props.count)) // ...} 为了避免重新创建被忽略的初始 state，我们可以传一个函数给 useState 12345function Table(props) { // ✅ createRows() 只会被调用一次 const [rows, setRows] = useState(() =&gt; createRows(props.count)) // ...} 这样一来 React 只会在首次渲染时调用这个函数，但是有时候我们也可能想要避免重新创建 useRef() 的初始值，比如下面这个例子 12345function Image(props) { // ⚠️ IntersectionObserver 在每次渲染都会被创建 const ref = useRef(new IntersectionObserver(onIntersect)) // ...} 但是 useRef 不会像 useState 那样可以接受一个特殊的函数重载，所以针对这种情况，我们可以编写自己的函数来创建并将其设为惰性的 1234567891011121314function Image(props) { const ref = useRef(null) // ✅ IntersectionObserver 只会被惰性创建一次 function getObserver() { if (ref.current === null) { ref.current = new IntersectionObserver(onIntersect) } return ref.current } // 当需要时，调用 getObserver() // ...} 这样一来我们就避免了在一个对象被首次真正需要之前就先创建了它 路由传参的几种方式params12345&lt;Route path='/path/:name' component={Search} /&gt;&lt;link to=\"/path/2\"&gt;&lt;/Link&gt;this.props.history.push({pathname: '/path/' + name}) 读取参数使用 this.props.match.params.name query12345&lt;Route path='/query' component={Search} /&gt;&lt;Link to={{pathname: '/query', query: { name: 'zhangsan' }}}&gt;this.props.history.push({pathname: '/query', query: { name: 'zhangsan' }}) 读取参数使用 this.props.location.query.name state12345&lt;Route path='/sort ' component={Search} /&gt;&lt;Link to={{pathname: '/sort', state: { name: 'zhangsan' }}}&gt; this.props.history.push({pathname: '/sort', state: { name: 'zhangsan' }}) 读取参数使用 this.props.location.query.state search12345&lt;Route path='/web/search' component={Search} /&gt;&lt;link to=\"web/search?id=123\"&gt;&lt;/Link&gt;this.props.history.push({ pathname: `/web/search?id=${row.id}` }) 读取参数使用 this.props.location.search，但是需要注意这种方式在 react-router-dom^4.2.2 下存在一些问题，即传参跳转页面会空白，刷新才会加载出来 优缺点 params 在 HashRouter 和 BrowserRouter 路由中刷新页面参数都不会丢失 state 在 BrowserRouter 中刷新页面参数不会丢失，在 HashRouter 路由中刷新页面会丢失 query 在 HashRouter 和 BrowserRouter 路由中刷新页面参数都会丢失 query 和 state 都可以传递对象 require.context()这一个是 Webpack 当中的 API，但是因为 React 工程是基于 Webpack 打包的，所以在 React 当中也可以使用，它的功能是创建我们自己的 context，该函数接受三个参数，一个要搜索的目录，一个标记表示是否还搜索其子目录，以及一个匹配文件的正则表达式，语法如下 1require.context(directory, useSubdirectories = true, regExp = /^\\.\\/.*$/, mode = 'sync') 两个简单的示例 12345// 创建一个 context，其中文件来自 test 目录，request 以 `.test.js` 结尾require.context('./test', false, /\\.test\\.js$/)// 创建一个 context，其中所有文件都来自父文件夹及其所有子级文件夹，request 以 `.stories.js` 结尾require.context('../', true, /\\.stories\\.js$/) 此外，一个 context module 会导出一个（require）函数，此函数可以接收一个参数 request，另外导出的函数也有三个属性 resolve，keys 和 id resolve 是一个函数，它返回 request 被解析后得到的模块 id keys 也是一个函数，它返回一个数组，由所有可能被此 context module 处理的请求组成 如果我们想引入一个文件夹下面的所有文件，或者引入能匹配一个正则表达式的所有文件，这个功能就会很有帮助 123456function importAll(r) { r.keys().forEach(r)}importAll(require.context('../components/', true, /\\.js$/))const cache = {} 123456function importAll(r) { r.keys().forEach(key =&gt; cache[key] = r(key))}// 在构建时，所有被 `require` 的模块都会被填充到 `cache` 对象中importAll(require.context('../components/', true, /\\.js$/)) ReactDOM.createPortal()ReactDOM.createPortal() 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的方案，也就是说组件的 render() 函数返回的元素会被挂载在它的父级组件上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react'import ReactDOM from 'react-dom'import { Button } from 'antd'const modalRoot = document.bodyclass Modal extends React.Component { constructor(props) { super(props) this.el = document.createElement('div') this.el.style.width = '200px' this.el.style.height = '200px' this.el.style.backgroundColor = 'green' this.el.style.position = 'absolute' this.el.style.top = '200px' this.el.style.left = '400px' } componentDidMount() { modalRoot.appendChild(this.el) } componentWillUnmount() { modalRoot.removeChild(this.el) } render() { return ReactDOM.createPortal(this.props.children, this.el) }}function Child() { return &lt;div className=\"modal\"&gt;这个是通过 ReactDOM.createPortal 创建的内容&lt;/div&gt;}export default class App extends React.Component { constructor(props) { super(props) this.state = { clicks: 0 } this.handleClick = this.handleClick.bind(this) } handleClick() { this.setState(prevState =&gt; ({ clicks: prevState.clicks + 1 })) } render() { return ( &lt;div&gt; &lt;Button onClick={this.handleClick}&gt;点击&lt;/Button&gt; &lt;p&gt;点击次数为 {this.state.clicks}&lt;/p&gt; &lt;Modal&gt; &lt;Child /&gt; &lt;/Modal&gt; &lt;/div&gt; ) }} 取消请求在 React 中如果当前正在发出请求的组件从页面上卸载了，理想情况下这个请求也应该取消掉，那么如何把请求的取消和页面的卸载关联在一起呢？在这种情况下可以考虑利用 useEffect 的清理函数搭配 Ajax 或是 Fetch 的取消请求 API（使用方式可以参考我们之前整理过的 终止请求） 所以有了这两个方式以后，我们就可以结合 React 来封装一个 useFetch 的自定义 Hook 1234567891011121314151617181920export function useFetch = (config, deps) =&gt; { const abortController = new AbortController() const [loading, setLoading] = useState(false) const [result, setResult] = useState() useEffect(() =&gt; { setLoading(true) fetch({ ...config, signal: abortController.signal }).then(res =&gt; setResult(res)) .finally(_ =&gt; setLoading(false)) }, deps) useEffect(() =&gt; { return () =&gt; abortController.abort() }, []) return { result, loading }} 如上，如果在此时路由发生切换或是 Tab 发生切换等场景下，被卸载掉的组件发出的请求也会被中断 深比较依赖我们通常在使用 useEffect 的时候需要传入所依赖的 Hook，最理想的状况是所有依赖都在真正发生变化的时候才去改变自身的引用地址，但是有些依赖可能在每次渲染都会重新生成一个引用，但是内部的值却没变，这可能会让 useEffect 对于依赖的『浅比较』没法正常工作，也就是我们有时候会遇到的无限循环问题 123456789const getDep = () =&gt; { return { foo: 'bar', }}useEffect(() =&gt; { // ❌ 无限循环}, [getDep()]) 在上面的示例当中，由于 getDeps 函数返回的对象每次执行都是一个全新的引用，所以会导致触发无限更新的问题，这里有一个比较取巧的解决方式，那就是把依赖转为字符串 1234567891011const getDep = () =&gt; { return { foo: 'bar', }}const dep = JSON.stringify(getDeps())useEffect(() =&gt; { // ✅}, [dep]) 这样一来对比的就是字符串 { foo: 'bar' } 的值，而不再是对象的引用，所以只有在值真正发生变化时才会触发更新，当然最好还是采用社区提供的解决方案 useDeepCompareEffect，它选用深比较策略，对于对象依赖来说，它会逐个对比 key 和 value，但是在性能上会有所牺牲，useDeepCompareEffect 大致原理如下 1234567891011import { isEqual } from 'lodash'export function useDeepCompareEffect(fn, deps) { const trigger = useRef(0) const prevDeps = useRef(deps) if (!isEqual(prevDeps.current, deps)) { trigger.current++ } prevDeps.current = deps return useEffect(fn, [trigger.current])} 真正传入 useEffect 用以更新的是 trigger 这个数字值，使用 useRef 来保留上一次传入的依赖，每次都利用 lodash 的 isEqual 方法对本次依赖和旧依赖进行深比较，如果发生变化，则让 trigger 的值增加 另外我们也可以采用 fast-deep-equal 这个库，根据官方的 benchmark 对比，它比 lodash 的效率高七倍左右","link":"/2020/10/11/React/11/"},{"title":"React 中的 HOC","text":"我们在之前的 React 中的 Mixin 章节当中介绍了一些 Mixin 的基本原理和它存在的一些问题，而且在之前我们也提到过，React 现在已经不再推荐使用 Mixin 来解决代码复用问题，因为 Mixin 带来的危害比他产生的价值还要巨大，推荐我们使用高阶组件来替代它，所以在本章当中我们就来深入的了解一下什么是高阶组件，它的实现方式和应用场景以及存在的一些问题 使用 HOC 的动机我们在之前的文章当中提到过使用 Mixin 所带来的风险，在这里我们在简单的总结一下 Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的 Mixin 中的方法可能会相互冲突 Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而 HOC 的出现可以解决这些问题 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处，高阶组件的增加不会为原组件增加负担 不过在深入高阶组件之前，让我们先来看看装饰器模式和高阶函数的相关内容，了解这两者的内容以后有助于我们更好的理解高阶组件 装饰器模式之所以先介绍装饰器模式，这是因为 React 当中的高阶组件其实就是装饰器模式的一种实现，所谓装饰器模式（Decorator Pattern），它允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装，与继承相比，装饰者是一种更轻便灵活的做法 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，这里需要注意的是，它是不会改变原本类的，这一点很关键 JavaScript 当中的装饰器装饰器是 ES7 中的一个新语法，正如其字面意思而言，它可以对类、方法、属性进行修饰，从而进行一些相关功能定制，简而言之就是对对象进行包装，返回一个新的对象描述（descriptor），这个概念其实和 React 中的高阶组件也类似，我们来看下面这个示例，假设我们现在要对一个函数 log，打印出它的执行记录，如果不使用装饰器是下面这样的 1234567891011const log = (fn) =&gt; { return (...arguments) =&gt; { console.info(`${arguments.join(',')}`) fn(...arguments) }}const plus = (a, b) =&gt; a + bconst logPlus = log(plus)logPlus(1, 2) // 1, 2 而如果使用装饰器则是下面这样的 12345678910111213141516171819const log = (target, name, descriptor) =&gt; { var oldValue = descriptor.value descriptor.value = function () { console.log(arguments) return oldValue.apply(this, arguments) } return descriptor}class Math { @log plus(a, b) { return a + b }}const math = new Math()math.add(1, 2) // 1, 2 从上面的代码可以看出，如果有的时候我们并不需要关心函数的内部实现，仅仅是想调用它的话，装饰器能够带来比较好的可读性，使用起来也是非常的方便 装饰器原理其实简单来说，JavaScript 当中的装饰器本质也是一个函数，利用的是 JavaScript 中 Object 的 descriptor，这个函数会接收三个参数 123456789101112131415161718192021222324252627/** * 装饰器函数 * @param {Object} target 被装饰器的类的原型 * @param {string} name 被装饰的类、属性、方法的名字 * @param {Object} descriptor 被装饰的类、属性、方法的描述 */function Decorator(target, name, descriptor) { // 以此可以获取实例化的时候此属性的默认值 let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this) // 返回一个新的描述对象作为被修饰对象的描述，或者直接修改也可以 return { enumerable: true, configurable: true, get() { return v }, set(c) { v = c }, }}// USEclass Fudao { @Decorator title = '标题'} 当然装饰器也可以接受参数，其实就是将外部包装一个函数，而函数可以带参数 123456789101112131415161718192021222324252627/** * 装饰器函数 * @param {Object} target 被装饰器的类的原型 * @param {string} name 被装饰的类、属性、方法的名字 * @param {Object} descriptor 被装饰的类、属性、方法的描述*/function Decorator(type) { return (target, name, descriptor) =&gt; { let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this) return { enumerable: true, configurable: true, get() { return v + type }, set(c) { v = c }, } }}// USEclass Fudao { @Decorator('string') title = '标题'} 常见的装饰器这里我们通过 core-decorators 这个库来简单介绍几个比较常用的装饰器，比如 autobind 修饰器可以让方法中的 this 对象绑定原始对象，使得 this 始终指向绑定的对象 12345678910111213import { autobind } from 'core-decorators'class Person { @autobind getPerson() { return this }}let person = new Person()let getPerson = person.getPersongetPerson() === person // true 而 readonly 修饰器使得属性或方法不可写 123456789import { readonly } from 'core-decorators'class Fudao { @readonly title = '标题'}var fudao = new Fudao()fudao.title = '新的标题' 高阶函数关于高阶函数的定义，维基 上的定义是，高阶函数是至少满足下列一个条件的函数 接受一个或多个函数作为输入 输出一个函数 比如下面这个示例，就是一个简单的高阶函数 123const add = (x, y, f) =&gt; f(x) + f(y)add(-5, 6, Math.abs) 当我们在调用的时候，参数 x，y 和 f 分别接收 -5，6 和 Math.abs，根据函数定义，我们可以推导计算过程为 12345x ==&gt; -5y ==&gt; 6f ==&gt; Math.absf(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11 所以上面代码执行后的结果为 11，在简单了解了装饰器模式和高阶函数的基本概念以后，下面就让我们正式的来看看高阶组件的相关内容 高阶组件那么，什么是高阶组件呢？类比高阶函数的定义，高阶组件就是接受一个组件作为参数并返回一个新组件的函数，这里需要注意高阶组件是一个函数，并不是组件，这一点一定要注意 更通俗地描述为，高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用，下面我们先来实现一个简单的高阶组件（函数）看看它是如何工作的，它接受一个 React 组件，包裹后然后返回 1234567891011121314export default function withHeader(WrappedComponent) { return class HOC extends Component { render() { return ( &lt;div&gt; &lt;div className=\"demo-header\"&gt; 我是标题 &lt;/div&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt; ) } }} 上面的代码就是一个 HOC 的简单应用，函数接收一个组件作为参数，并返回一个新组件，我们在其他组件里就可以来引用这个高阶组件，用来强化它 123456@withHeaderexport default class Demo extends Component { render() { return &lt;div&gt;我是一个普通组件&lt;/div&gt; }} 在这里我们使用了上面介绍到的装饰器模式来让写法变得更为优雅，当然下面这种写法也是可以的 1const EnhanceDemo = withHeader(Demo) 如下图所示，我们可以发现 Demo 组件已经被 HOC 组件包裹起来了，符合了高阶组件的预期，即组件是层层包裹起来的，如同洋葱一样 但是随之带来的问题是，如果这个高阶组件被使用了多次，那么在调试的时候，将会看到一大堆 HOC，所以这个时候需要做一点小优化，就是在高阶组件包裹后，应当保留其原有名称，我们改写一下上述的高阶组件代码，增加了 getDisplayName 函数以及静态属性 displayName 12345678910111213141516171819function getDisplayName(component) { return component.displayName || component.name || 'Component'}export default function (WrappedComponent) { return class HOC extends Component { static displayName = `HOC(${getDisplayName(WrappedComponent)})` render() { return ( &lt;div&gt; &lt;div className=\"demo-header\"&gt; 我是标题 &lt;/div&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt; ) } }} 此时我们再去观察就会如下图所示，可以发现此时原本组件的名称也会正确的显示了 由此可以看出，高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用，但是我们仔细观察上方的示例可以发现，此时这个高阶组件的作用仅仅只是展示了标题名称，但是为了更好的抽象，此标题应当可以被参数化，如下方式调用 123456789// 如果传入参数，则传入的参数将作为组件的标题呈现@withHeader('Demo')export default class Demo extends Component { render() { return ( //... ) }} 所以我们来简单的调整一下 withHeader，让它接受一个参数，然后返回一个高阶组件（函数） 12345678910111213141516export default function (title) { return function (WrappedComponent) { return class HOC extends Component { render() { return ( &lt;div&gt; &lt;div className=\"demo-header\"&gt; { title ? title : '我是标题' } &lt;/div&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt; ) } } }} 也使用 ES6 写法来进行简化 123456789101112export default (title) =&gt; (WrappedComponent) =&gt; class HOC extends Component { render() { return ( &lt;div&gt; &lt;div className=\"demo-header\"&gt; { title ? title : '我是标题' } &lt;/div&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt; ) }} 组合多个高阶组件我们在上面使用高阶组件为 React 组件添加一个显示标题的功能，但是如果需要同时增加多个功能的话需要如何处理呢？这种场景非常常见，例如我们既需要增加一个组件标题，又需要在此组件未加载完成时显示 Loading，即下面这种情况 12345@withHeader@withLoadingclass Demo extends Component {} 针对于这种情况，我们可以使用 compose 来简化上述过程，这样也能体现函数式编程的思想 123456const enhance = compose(withHeader, withLoading)@enhanceclass Demo extends Component {} 这里我们简单的介绍一下 compose，compose 可以帮助我们组合任意个（包括 0 个）高阶函数，例如 compose(a, b, c) 返回一个新的函数 d，函数 d 依然接受一个函数作为入参，只不过在内部会依次调用 c, b, a，从表现层对使用者保持透明 基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更 compose 函数里的参数个数便可，更多详细内容可以参考 Redux-Compose 在简单介绍了高阶组件的基本用法之后，下面我们就来深入的了解一下 React 中的高阶组件，比如它的实现方式，实际应用以及注意事项等内容 高阶组件的实现方式React 中的高阶组件主要有两种形式，即属性代理和反向继承，它们的区别如下 属性代理（props proxy），即高阶组件通过被包裹的 React 组件来操作 props 反向继承（inheritance inversion），即高阶组件继承于被包裹的 React 组件 两者的区别可以看继承的组件，一般属性代理继承的都是 React.Component，而反向继承通常继承的是传入的组件 WrappedComponent 属性代理属性代理是最常见的高阶组件的使用方式，函数返回一个我们自己定义的组件，然后在 render 中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染 12345678910111213141516171819import React, { Component } from 'React'// 高阶组件定义const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component { render() { return &lt;WrappedComponent {...this.props} /&gt; } }// 普通的组件class WrappedComponent extends Component { render() { //.... }}// 高阶组件使用export default HOC(WrappedComponent) 我们可以看见函数 HOC 返回了新的组件（WrapperComponent），这个组件原封不动的返回作为参数的组件（也就是被包裹的组件 WrappedComponent），并将传给它的参数（props）全部传递给被包裹的组件（WrappedComponent） 其实简单来说，属性代理其实就是一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件，又因为属性代理类型的高阶组件返回的其实是一个标准的 React.Component 组件，相对比于原生组件来说，它可以增强下列一些额外操作 可操作所有传入的 props 可操作组件的生命周期 可操作组件的 static 方法 获取 refs 反向继承反向继承其实就是一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法 由于继承了原组件，能通过 this 访问到原组件的生命周期，props，state，render 等，相比属性代理它能操作更多的属性（有点类似于 Render Props 的感觉） 123456const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { return super.render() } } 其实我们仔细观察可以发现，其实属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是 React.Component，反向继承中继承的是传入的组件 WrappedComponent，它相对比于原生组件来说，可以增强下列一些额外操作 可操作所有传入的 props 可操作组件的生命周期 可操作组件的 static 方法 获取 refs 可操作 state 可以渲染劫持 高阶组件的功能实现我们在上面介绍了高阶组件的两种实现方式，也就是属性代理和反向继承，下面我们就来看看利用这两种方式可以实现哪些额外功能 组合渲染最容易想到的莫过于组合渲染，即可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果，通过属性代理实现方式如下 1234567891011const HOC = (WrappedComponent) =&gt; class extends Component { render() { return ( &lt;div&gt; &lt;div className=\"title\"&gt;{this.props.title}&lt;/div&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt; ) } } 通过反向继承实现方式如下 1234567891011const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { return ( &lt;div&gt; &lt;div className=\"title\"&gt;{this.props.title}&lt;/div&gt; {super.render()} &lt;/div&gt; ) } } 条件渲染这个也是一个比较常见的使用场景，根据特定的属性决定原组件是否渲染，通过属性代理实现方式如下 1234567const HOC = (WrappedComponent) =&gt; class extends Component { render() { if (this.props.visible === false) return null return &lt;WrappedComponent {...props} /&gt; } } 通过反向继承实现方式如下 12345678910const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { if (this.props.visible === false) { return null } else { return super.render() } } } 操作 props我们也可以对传入组件的 props 进行增加、修改、删除或者根据特定的 props 进行特殊的操作，通过属性代理实现方式如下 12345678910const HOC = (WrappedComponent) =&gt; class extends Component { render() { const newProps = { ...this.props, user: 'zhangsan' } return &lt;WrappedComponent {...newProps} /&gt; } } 获取 refs有的时候我们需要访问 DOM 元素（比如使用第三方 DOM 操作库等）的时候就会用到组件的 ref 属性，它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上，ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是 组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例 组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null 那么我们如何在高阶组件中获取到 WrappedComponent 组件的实例呢？答案就是可以通过 WrappedComponent 组件的 ref 属性，该属性会在组件 componentDidMount 的时候执行 ref 的回调函数并传入该组件的实例 123456789const HOC = (WrappedComponent) =&gt; class extends React.Component { executeInstanceMethod = (wrappedComponentInstance) =&gt; { wrappedComponentInstance.someMethod() } render() { return &lt;WrappedComponent {...this.props} ref={this.executeInstanceMethod} /&gt; } } 这里需要注意的是，不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例 其实简单来说，就是调用高阶组件的时候并不能获取到原组件的真实 ref，需要我们手动的来进行传递，这里主要涉及到 React.forwardRef 这个 API，关于这点我们在下面的高阶组件的注意事项章节当中会详细来进行介绍，也可以参考官方文档当中的 Refs 转发 来了解更多 状态管理将原组件的状态提取到 HOC 中进行管理，如下面的代码，我们将 Input 的 value 提取到 HOC 中进行管理，使它变成受控组件，同时不影响它使用 onChange 方法进行一些其他操作，依然是通过属性代理的方式来进行实现 1234567891011121314151617181920212223242526272829303132const proxyHoc = (WrappedComponent) =&gt; class extends Component { constructor(props) { super(props) this.state = { value: '' } } onChange = (event) =&gt; { const { onChange } = this.props this.setState({ value: event.target.value, }, () =&gt; { if (typeof onChange === 'function') { onChange(event) } }) } render() { const newProps = { value: this.state.value, onChange: this.onChange, } return &lt;WrappedComponent {...this.props} {...newProps} /&gt; } }class HOC extends Component { render() { return &lt;input {...this.props}&gt;&lt;/input&gt; }}export default proxyHoc(HOC) 操作 state 这里需要注意，不推荐直接修改或添加原组件的 state，因为这样有可能和组件内部的操作构成冲突 上面的例子我们通过属性代理的方式利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的 state，而通过反向继承，我们可以直接操作原组件的 state，下面是通过反向继承实现 123456789101112const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { console.log('props', this.props) console.log('state', this.state) return ( &lt;div className=\"debuging\"&gt; {super.render()} &lt;/div&gt; ) } } 上面的 HOC 在 render 中将 props 和 state 打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码，想象一下，只需要在我们想要调试的组件上加上 @debug 就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码 渲染劫持高阶组件可以在 render 函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持，实际上上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件 render 函数产生的 React 元素，下面是通过反向继承的实现方式 12345678910111213const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { const tree = super.render() let newProps = {} if (tree &amp;&amp; tree.type === 'input') { newProps = { value: `渲染被劫持了` } } const props = Object.assign({}, tree.props, newProps) const newTree = React.cloneElement(tree, props, tree.props.children) return newTree } } 这里需要注意我们在上面提及的是增强而不是更改，因为 render 函数内实际上是调用 React.creatElement 产生的 React 元素，如下图所示 虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们可以通过 getOwnPropertyDescriptors() 方法来看一下它的配置项 可以发现，所有的 writable 属性均被配置为了 false，即所有属性是不可变的，虽然不能直接修改，但是我们可以借助 cloneElement 方法来在原组件的基础上增强一个新组件，因为 React.cloneElement() 方法几乎相当于下面这样 1&lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt; 这里我们简单介绍一下 React.cloneElement() 方法，它的基本语法为 1React.cloneElement(element, [props], [...children]) React.cloneElement() 克隆并返回一个新的 React 元素，使用 element 作为起点，生成的元素将会拥有原始元素 props 与新 props 的浅合并，新的子级会替换现有的子级，来自原始元素的 key 和 ref 将会保留 但是关于反向继承有一个重要的点，那就是反向继承不能保证完整的子组件树被解析，关于这一点我们会在下面的高阶组件存在的问题当中来详细介绍 高阶组件存在的问题这里我们主要介绍下面三点 静态方法丢失当我们应用 HOC 去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性 12345678// 定义静态方法WrappedComponent.staticMethod = function () { }// 使用高阶组件const EnhancedComponent = HigherOrderComponent(WrappedComponent)// 增强型组件没有静态方法typeof EnhancedComponent.staticMethod === 'undefined' // true 但是我们可以在HOC当中手动的拷贝它们 12345678function HigherOrderComponent(WrappedComponent) { class Enhance extends React.Component { } // 必须得知道要拷贝的方法 Enhance.staticMethod = WrappedComponent.staticMethod return Enhance} 但是如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，不过我们可以使用 hoist-non-react-statics 这个库来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法 123456789import hoistNonReactStatic from 'hoist-non-react-statics'function HigherOrderComponent(WrappedComponent) { class Enhance extends React.Component { } hoistNonReactStatic(Enhance, WrappedComponent) return Enhance} refs 属性不能透传一般来说高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref，与其他属性不同的地方在于 React 对其进行了特殊的处理，如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件 但是很多情况下我们需要用到原组件的 ref，又因为高阶组件并不能像透传 props 那样将 refs 透传，所以我们可以用一个回调函数来完成 ref 的传递 123456789101112131415161718const HOC = (WrappedComponent) =&gt; class extends Component { getWrappedRef = () =&gt; this.wrappedRef render() { return &lt;WrappedComponent ref={ref =&gt; { this.wrappedRef = ref }} {...this.props} /&gt; } }@HOCclass Input extends Component { render() { return &lt;input&gt;&lt;/input&gt; }}class App extends Component { render() { return &lt;Input ref={ref =&gt; { this.inpitRef = ref.getWrappedRef() }} &gt;&lt;/Input&gt; }} React 在 16.3 的版本当中提供了一个 forwardRef API 来帮助我们进行 refs 传递，这样我们在高阶组件上获取的 ref 就是原组件的 ref 了，而不需要再手动传递，更多内容可以参考 Refs 转发 1234567891011function forwardRef(WrappedComponent) { class HOC extends Component { render() { const { forwardedRef, ...props } = this.props return &lt;WrappedComponent ref={forwardedRef} {...props} /&gt; } } return React.forwardRef((props, ref) =&gt; { return &lt;HOC forwardedRef={ref} {...props} /&gt; })} 反向继承不能保证完整的子组件树被解析关于这一点可能不太好理解，但是我们可以借住 React Components, Elements, and Instances 这篇文章来进行了解，在文章当中主要明确了以下两点内容 元素（element）是一个是用 DOM 节点或者组件来描述屏幕显示的纯对象，元素可以在属性（props.children）中包含其他的元素，一旦创建就不会改变，我们通过 JSX 和 React.createClass 创建的都是元素 组件（component）可以接受属性（props）作为输入，然后返回一个元素树（element tree）作为输出，有多种实现方式，比如 Class 或者函数（Function） 所以，反向继承不能保证完整的子组件树被解析的意思就是，如果解析的元素树中包含了组件（函数类型或者 Class类型），就不能再操作组件的子组件了，这就是所谓的不能完全解析，比如 1234567891011121314151617181920212223242526272829303132333435import React, { Component } from 'react'const MyFuncComponent = (props) =&gt; { return &lt;div&gt;Hello World&lt;/div&gt;}class MyClassComponent extends Component { render() { return &lt;div&gt;Hello World&lt;/div&gt; }}class WrappedComponent extends Component { render() { return ( &lt;div&gt; &lt;div&gt; &lt;span&gt;Hello World&lt;/span&gt; &lt;/div&gt; &lt;MyFuncComponent /&gt; &lt;MyClassComponent /&gt; &lt;/div&gt; ) }}const HOC = (WrappedComponent) =&gt; class extends WrappedComponent { render() { const elementsTree = super.render() return elementsTree } }export default HOC(WrappedComponent) 运行结果如下 通过观察控制台当中的页面结构可以发现，div 下的 span 是可以被完全被解析的，但是 MyFuncComponent 和 MyClassComponent 都是组件类型的，其子组件就不能被完全解析了 高阶组件的约定高阶组件带给我们极大方便的同时，我们也要遵循一些约定 props 保持一致高阶组件在为子组件添加特性的同时，要尽量保持原有组件的 props 不受影响，也就是说传入的组件和返回的组件在 props 上尽量保持一致 不要改变原始组件不要在高阶组件内以任何方式修改一个组件的原型，比如下面的代码 12345678910const HOC = (WrappedComponent) =&gt;function withLogging(WrappedComponent) { WrappedComponent.prototype.componentWillReceiveProps = function (nextProps) { console.log('Current props', this.props) console.log('Next props', nextProps) } return WrappedComponent}const EnhancedComponent = withLogging(SomeComponent) 可以发现，我们在高阶组件的内部对 WrappedComponent 进行了修改，一旦对原组件进行了修改，那么就失去了组件复用的意义，所以在这种情况下最好使用纯函数（相同的输入总有相同的输出）来返回新的组件 123456789101112const HOC = (WrappedComponent) =&gt; class extends React.Component { componentWillReceiveProps() { console.log('Current props', this.props) console.log('Next props', nextProps) } render() { // 透传参数，而不要去修改它 return &lt;WrappedComponent {...this.props} /&gt; } } 这样优化之后的 withLogging 是一个纯函数，并不会修改 WrappedComponent 组件，所以不需要担心有什么副作用，进而达到组件复用的目的 透传不相关 props 属性给被包裹的组件使用高阶组件，我们可以代理所有的 props，但往往特定的 HOC 只会用到其中的一个或几个 props，我们需要把其他不相关的 props 透传给原组件，如下面的代码 12345678const HOC = (WrappedComponent) =&gt; class extends Component { render() { const { visible, ...props } = this.props if (visible === false) return null return &lt;WrappedComponent {...props} /&gt; } } 这里我们只使用 visible 属性来控制组件的显示可隐藏，然后把其他的 props 全部透传下去 不要在 render() 方法中使用高阶组件React Diff 算法的原则是 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在 render 方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载 123456789class SomeComponent extends React.Component { render() { // 调用高阶函数的时候每次都会返回一个新的组件 const EnchancedComponent = enhance(WrappedComponent) // 每次 render 的时候，都会使子对象树完全被卸载和重新 // 重新加载一个组件会引起原有组件的状态和它的所有子组件丢失 return &lt;EnchancedComponent /&gt; }} 使用 compose 组合高阶组件12// 不要这么使用const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent)) 针对于上面这种情况，我们可以使用一个 compose 函数组合这些高阶组件，lodash/redux/ramda 等第三方库都提供了类似 compose 功能的函数 123const enhance = compose(withRouter, connect(commentSelector))const EnhancedComponent = enhance(WrappedComponent) 因为按照约定实现的高阶组件其实就是一个纯函数，如果多个函数的参数一样（在这里 withRouter 函数和 connect(commentSelector) 所返回的函数所需的参数都是 WrappedComponent），所以就可以通过 compose 方法来组合这些函数 关于 compose 相关内容我们在上方的组合多个高阶组件的章节中已经简单介绍过了，更多详细内容可以参考 Redux-Compose 来了解更多 包装显示名字以便于调试高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的，为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果 123456789const getDisplayName = WrappedComponent =&gt; WrappedComponent.displayName || WrappedComponent.name || 'Component'function HigherOrderComponent(WrappedComponent) { class HigherOrderComponent extends React.Component { /* ... */ } HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(WrappedComponent)})` return HigherOrderComponent} 实际上有一些第三方类库，比如 recompose 等已经帮我们实现了类似的功能，如下 123456789import getDisplayName from 'recompose/getDisplayName'HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(BaseComponent)})`// orimport wrapDisplayName from 'recompose/wrapDisplayName'HigherOrderComponent.displayName = wrapDisplayName(BaseComponent, 'HigherOrderComponent') 高阶组件的应用场景最后我们来看一下如何在业务场景中使用高阶组件 权限控制利用高阶组件的条件渲染特性可以对页面进行权限控制，权限控制一般分为两个维度，页面级别和页面元素级别，这里以页面级别为例，首先是我们的高阶组件 1234567891011121314151617181920function withAdminAuth(WrappedComponent) { return class extends React.Component { state = { isAdmin: false, } async componentDidMount() { const currentRole = await getCurrentUserRole() this.setState({ isAdmin: currentRole === 'Admin', }) } render() { if (this.state.isAdmin) { return &lt;WrappedComponent {...this.props} /&gt; } else { return &lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;/div&gt; } } }} 然后是两个页面 PageA 和 PageB 12345678910111213class PageA extends React.Component { constructor(props) { super(props) } componentDidMount() { // fetching data } render() { // render page with data }}export default withAdminAuth(PageA) 12345678910111213class PageB extends React.Component { constructor(props) { super(props) } componentDidMount() { // fetching data } render() { // render page with data }}export default withAdminAuth(PageB) 使用高阶组件对代码进行复用之后，可以发现是非常方便就可以进行拓展的，但是如果后续需求有所调整，比如某个组件需只要 VIP 权限就可以访问了，那该如何处理呢？当然你可以新写一个高阶组件 withVIPAuth 来进行使用 但是在这里我们可以采用一种更为高效的方式，那就是在高阶组件之上再抽象一层，所以我们就无需去实现各种 withXXXAuth 高阶组件，我们要做的就是实现一个返回高阶组件的函数，把变的部分（比如这里的 Admin、VIP 等）抽离出来，保留不变的部分，具体实现如下 1234567891011121314151617181920const withAuth = role =&gt; WrappedComponent =&gt; { return class extends React.Component { state = { permission: false } async componentDidMount() { const currentRole = await getCurrentUserRole() this.setState({ permission: currentRole === role }) } render() { if (this.state.permission) { return &lt;WrappedComponent {...this.props} /&gt; } else { return &lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;/div&gt; } } }} 可以发现经过对高阶组件再进行了一层抽象后，前面的 withAdminAuth 可以写成 withAuth('Admin') 了，如果此时需要 VIP 权限的话，只需在 withAuth 函数中传入 'VIP' 就可以了，可以发现其实是和 React-Redux 的 connect 方法的使用方式非常像，关于这部分更为详细的内容可以参考我们之前手动实现的 connect 方法 组件渲染性能追踪借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录 1234567891011121314151617181920212223242526272829class Home extends React.Component { render() { return &lt;h1&gt;Hello World.&lt;/h1&gt; }}function withTiming(WrappedComponent) { return class extends WrappedComponent { constructor(props) { super(props) this.start = 0 this.end = 0 } UNSAFE_componentWillMount() { super.UNSAFE_componentWillMount &amp;&amp; super.UNSAFE_componentWillMount() this.start = Date.now() } componentDidMount() { super.componentDidMount &amp;&amp; super.componentDidMount() this.end = Date.now() console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`) } render() { return super.render() } }}export default withTiming(Home) 如下，withTiming 是利用反向继承实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间 页面复用假设我们有两个页面 pageA 和 pageB 分别渲染两个分类的电影列表，普通写法可能是这样 1234567891011121314151617181920class PageA extends React.Component { state = { movies: [], } // ... async componentDidMount() { const movies = await fetchMoviesByType('science-fiction') this.setState({ movies, }) } render() { return &lt;MovieList movies={this.state.movies} /&gt; }}export default PageA 1234567891011121314151617181920class PageB extends React.Component { state = { movies: [], } // ... async componentDidMount() { const movies = await fetchMoviesByType('action') this.setState({ movies, }) } render() { return &lt;MovieList movies={this.state.movies} /&gt; }}export default PageB 页面少的时候可能没什么问题，但是假如随着业务的进展，需要上线的越来越多类型的电影，就会写很多的重复代码，所以我们需要重构一下 12345678910111213141516171819202122232425const withFetching = fetching =&gt; WrappedComponent =&gt; { return class extends React.Component { state = { data: [], } async componentDidMount() { const data = await fetching() this.setState({ data, }) } render() { return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt; } }}// A 组件export default withFetching(fetching('science-fiction'))(MovieList)// B 组件export default withFetching(fetching('action'))(MovieList)// C 组件export default withFetching(fetching('some-other-type'))(MovieList) 重构完以后可以发现，其实 withFetching 和前面的 withAuth 函数类似，我们只是把变的部分（fetching(type)）抽离到外部传入，从而实现页面的复用 高阶组件的缺陷虽然高阶组件解决了很多我们在之前 Mixin 章节当中介绍到过的一些问题，但是它依然还是存在一些缺陷的 HOC 需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难 HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突 但是不用担心，我们在接下来会介绍一种更为简单，也是现在更为流行的的解决方式，那就是 Hook，使用它可以帮助我们同时解决 Mixin 和 HOC 带来的问题 参考 React 进阶之高阶组件 ES6 中优雅的 mixin 式继承 装饰者模式的应用和 ES6 装饰器 使用高阶组件优化你的代码 React 高阶组件(HOC)入门指南","link":"/2020/10/25/React/15/"},{"title":"深入 useEffect","text":"我们在之前的章节当中已经整体的梳理一遍 React 当中的几种状态逻辑复用的方式，从 Mixin 到 HOC，再到最后的 Hook，虽然 Hook 算是比较新的内容，但是它也已经渐渐开始变得普及起来 所以在本章当中，我们就来深入的了解一下 Hook 当中的 useEffect，主要参考的是官方 FAQ 当中的 如果我的 effect 的依赖频繁变化，我该怎么办？，更多详细内容可以参考文档 遇到的问题首先先来看看我们在使用 useEffect 过程当中会遇到的一些问题，不过不用担心，这里涉及的问题我们都会在后面详细来进行介绍，涉及到的问题主要有以下几点 如何用 useEffect 模拟 componentDidMount？ 如何在 useEffect 里请求数据？[] 又是什么？ 是否应该把函数当做 effect 的依赖？ 为什么有时候会出现无限重复请求的问题？ 为什么有时候在 effect 里拿到的是旧的 state 或 prop？ 如何用 useEffect 模拟 componentDidMount？如果我们想要模拟生命周期，虽然可以使用 useEffect(fn, [])，但它们并不完全相等，和 componentDidMount 不一样，useEffect 会捕获 props 和 state，所以即便在回调函数里，我们拿到的还是初始的 props 和 state，如果我们想要得到最新的值，可以使用 ref 来进行操作，不过通常会有更简单的实现方式，所以并不一定要用 ref，关于这一点我们会在下面详细来进行介绍 但是我们需要注意的是 effect 的运行方式和 componentDidMount 以及其他生命周期是不同的，effect 更倾向于数据同步，而不是响应生命周期事件 如何在 useEffect 里请求数据？[] 又是什么？如何请求数据相关内容可以参考 How to fetch data with React Hooks 这篇文章，十分详细，而 [] 表示 effect 没有使用任何 React 数据流里的值，因此该 effect 仅被调用一次是安全的 但是 [] 同样也是一类常见问题的来源，就是我们以为没使用数据流里的值但其实使用了，所以我们需要采用一些策略（useReducer/useCallback 等）来移除这些 effect 依赖，而不是错误地忽略它们 是否应该把函数当做 effect 的依赖？一般建议把不依赖 props 和 state 的函数提到相关组件外面，并且把那些仅被 effect 使用的函数放到 effect 里面，这样做了以后，如果我们的 effect 还是需要用到组件内的函数（包括通过 props 传进来的函数），可以在定义它们的地方用 useCallback 包一层，为什么要这样做呢？ 因为这些函数可以访问到 props 和 state，因此它们会参与到数据流中，更多相关内容可以参考官方提供的 FAQ 为什么有时候会出现无限重复请求的问题？这个通常发生于我们在 effect 里做数据请求并且没有设置 effect 依赖参数的情况，如果没有设置依赖，effect 会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect，这样就形成了无限循环，但是也可能是因为我们设置的依赖总是在改变 我们可以通过一个一个移除的方式排查出哪个依赖导致了问题，但是移除所使用的依赖（或者盲目地使用 []）通常是一种错误的解决方式，举个例子，比如某个函数可能会导致这个问题，我们可以把它们放到 effect 里，或者提到组件外面，或者用 useCallback 包一层，或者使用 useMemo 等方式都可以避免重复生成对象 为什么有时候在 effect 里拿到的是旧的 state 或 prop？effect 拿到的总是定义它的那次渲染中的 props 和 state（这个我们会在下面看到），之所以这样涉及是能够避免 一些问题，对于某些场景来说，我们可以明确地使用可变的 ref 来保存一些值，更多相关内容可以参考官方的 FAQ 我们在上面简单的介绍了在使用 useEffect 过程当中会遇到的一些问题，以及简单的处理方式，下面我们就来深入的了解一下 useEffect，看看这些问题出现的根本原因以及如何更为优雅的来解决它们，让我们先从渲染开始看起 渲染我们先从一个简单是示例开始看起，也就是官方文档当中那个计时器的示例，我们稍微的调整一下，如下 123456789function App() { const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;点击了 {count} 次&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt;点击&lt;/button&gt; &lt;/div&gt; )} 这里我们注意来看 {count} 当中的内容，这里的 count 并不是是 React 帮我们监听状态的变化并而自动更新的，它仅仅只是一个用于显示的数字，我们的组件在第一次渲染的时候，从 useState() 拿到 count 的初始值 0，当我们调用 setCount(1) 的时候，React 会再次渲染组件，这一次 count 是 1 当我们更新状态的时候，React 会重新渲染组件，每一次渲染都能拿到独立的 count 状态，这个状态值是函数中的一个常量，所以下面的这行代码没有做任何特殊的数据绑定 1&lt;p&gt;点击了 {count} 次&lt;/p&gt; 它仅仅只是在渲染输出中插入了 count 这个数字，这个数字由 React 提供，当我们调用 setCount 的时候，React 会带着一个不同的 count 值再次调用组件，然后 React 会更新 DOM 以保持和渲染输出一致 这里关键的点在于任意一次渲染中的 count 常量都不会随着时间改变，渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的 count 值独立于其他渲染（关于这个过程更深入的探讨可以参考 React as a UI Runtime） 所以在这里我们可以发现，其实 React 当中的每一次渲染都有它自己的 props 和 state，有了这个了解以后我们接着往下看，那么事件处理函数呢？是否也是一样的呢？我们将上面的示例稍微调整一下，我们添加一个显示点击数的事件 1234567891011121314151617function App() { const [count, setCount] = useState(0) function handleAlertClick() { setTimeout(() =&gt; { alert(count) }, 3000) } return ( &lt;div&gt; &lt;p&gt;点击了 {count} 次&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt;点击&lt;/button&gt; &lt;button onClick={handleAlertClick}&gt;显示点击数&lt;/button&gt; &lt;/div&gt; )} 如果我们首先将 count 增加到 3，然后在点击显示点击数的按钮，等待 3 秒以后可以发现结果是我们所设想的 3，但是如果我们先将 count 增加到 3，然后点击一下显示点击数的按钮，并且在定时器回调触发之前将 count 点击增加到 5，那么此时弹出的结果会是多少呢？是 5 还是 3 呢？ 答案是 3，也就是这个值是我们点击时候的状态，所以在这里我们也可以发现，除开 props 和 state，每一次渲染也都有它自己的事件处理函数（How Are Function Components Different from Classes 这篇文章当中探讨了具体原因），但它究竟是如何工作的呢？ 我们发现 count 在每一次函数调用中都是一个常量值，也就是说我们的组件函数每次渲染都会被调用，但是每一次调用中 count 值都是常量，并且它被赋予了当前渲染中的状态值，但是这并不是 React 所特有的，普通的函数也有类似的行为 123456789101112131415function sayHi(person) { const name = person.name setTimeout(() =&gt; { alert(`Hi, ${name}`) }, 3000)}let someone = { name: 'zhangsan' }sayHi(someone)someone = { name: 'lisi' }sayHi(someone)someone = { name: 'wangwu' }sayHi(someone) 在上面这个例子中，外层的 someone 会被赋值很多次（就像在 React 中，当前的组件状态会改变一样），然后在 sayHi 函数中，局部常量 name 会和某次调用中的 person 关联，因为这个常量是局部的，所以每一次调用都是相互独立的，结果就是当定时器回调触发的时候，每一个 alert 都会弹出它拥有的 name 这就解释了我们的事件处理函数如何捕获了点击时候的 count 值，这是因为每一次渲染都有一个新版本的 handleAlertClick，每一个版本的 handleAlertClick 都记住它自己的 count，我们用伪代码表示如下 1234567891011121314151617181920212223242526272829function App() { // ... function handleAlertClick() { setTimeout(() =&gt; { alert(0) }, 3000) } &lt;button onClick={handleAlertClick} /&gt; // The one with 0 inside}function App() { // ... function handleAlertClick() { setTimeout(() =&gt; { alert(1) }, 3000) } &lt;button onClick={handleAlertClick} /&gt; // The one with 1 inside}function App() { // ... function handleAlertClick() { setTimeout(() =&gt; { alert(2) }, 3000) } &lt;button onClick={handleAlertClick} /&gt; // The one with 2 inside} 在任意一次渲染中，props 和 state 是始终保持不变的，如果 props 和 state 在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数），它们都属于一次特定的渲染，即便是事件处理中的异步函数调用所得到的的也是这次渲染中的 count 值 Effect我们在上面探讨了 props/state 以及事件处理函数，那么 effect 呢？其实 effect 并没有什么两样，我们还是以上面的示例为例，如下 1234567891011121314function App() { const [count, setCount] = useState(0) useEffect(() =&gt; { document.title = `${count}` }) return ( &lt;div&gt; &lt;p&gt;点击了 {count} 次&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt;点击&lt;/button&gt; &lt;/div&gt; )} 结果可以发现，两处的 count 的值是同步修改的，那么我们可能会有些疑惑，那就是 effect 是如何读取到最新的 count 状态值的呢？其实这并不是 count 的值每次在 effect 当中发生了改变，而是 effect 函数本身在每一次渲染中都不相同，每一个 effect 版本当中的 count 值都来自于它属于的那次渲染，我们用伪代码表示如下 1234567891011121314151617function App() { useEffect(() =&gt; { document.title = `${0}` })}function App() { useEffect(() =&gt; { document.title = `${1}` })}function App() { useEffect(() =&gt; { document.title = `${2}` })} React 会记住提供的 effect 函数，并且会在每次更改作用于 DOM 并让浏览器绘制屏幕后去调用它，所以虽然我们说的是一个 effect（这里指更新 document 的 title 的操作），但其实每次渲染都是一个不同的函数，并且每个 effect 函数获取到的 props 和 state 都来自于它属于的那次特定渲染，概念上我们可以想象 effect 是渲染结果的一部分，它属于某个特定的渲染，就像事件处理函数一样 所以在这里我们也可以发现，即每次渲染也都有它自己的 effect，但是如果我们将上面的示例调整为下面这样，结果又会是如何呢？ 12345678910111213141516function App() { const [count, setCount] = useState(0) useEffect(() =&gt; { setTimeout(() =&gt; { console.log(`${count}`) }, 3000) }) return ( &lt;div&gt; &lt;p&gt;点击了 {count} 次&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt;点击&lt;/button&gt; &lt;/div&gt; )} 如果我们点击了很多次并且在 effect 里设置了延时，那么输出的结果会是什么呢？结果可能会出乎我们的意料，我们可能认为是某一个固定的值，但是运行后却可以发现，它会按顺序的输出每一次点击所对应的值，至于原因，也正是我们之前提及过的，因为每一个 effect 都属于某次特定的渲染，这里我们就不得不和 Class 当中的 this.state 来进行简单的对比了，如下 12345componentDidUpdate() { setTimeout(() =&gt; { console.log(`${this.state.count}`) }, 3000)} 如果调整成生命周期的模式，运行以后可以发现，this.state.count 总是指向最新的 count 值，而不是属于某次特定渲染的值，如果我们在定时器回调结束之前点击了 5 次，那么我们可以看到 5 次输出结果，并且每次输出打印的结果都是 5 到目前为止，综合我们上面所有的发现，可以明确地得出，即每一个组件内的函数（包括事件处理函数，effect，定时器或者 API 调用等等）都会捕获某次渲染中定义的 props 和 state，所以下面的两个例子是相等的 12345678910111213141516function App(props) { useEffect(() =&gt; { setTimeout(() =&gt; { console.log(props.counter) }, 1000) })}function App(props) { const counter = props.counter useEffect(() =&gt; { setTimeout(() =&gt; { console.log(counter) }, 1000) })} 也就是说，在组件内什么时候去读取 props 或者 state 是无关紧要的，因为它们不会改变，在单次渲染的范围内，props 和 state 始终保持不变，当然有时候我们可能想在 effect 的回调函数里读取最新的值而不是捕获的值，最简单的实现方法是使用 refs（可以参考 How Are Function Components Different from Classes） 不过不推荐去进行这样的操作，因为需要从过去渲染中的函数里读取未来的 props 和 state，但是有时候可能也需要这样做 12345678910111213function App() { const [count, setCount] = useState(0) const latestCount = useRef(count) useEffect(() =&gt; { // Set the mutable latest value latestCount.current = count setTimeout(() =&gt; { // Read the mutable latest value console.log(`${latestCount.current}`) }, 3000) })} 这样操作以后，我们可以发现点击 5 次以后，会输出 5 次最后操作的值，与我们上面 this.state.count 的计算结果是一致的，所以可以发现，在 Class 组件中 React 正是这样去修改 this.state 的，不像捕获的 props 和 state，我们没法保证在任意一个回调函数中读取的 latestCount.current 是不变的 Effect 中的清理在 官方文档 当中曾经提及，有些 effect 可能需要有一个清理步骤，本质上它的目的是消除副作用，比如取消订阅，我们在之前也提到过，每一个组件内的函数（包括事件处理函数，effect，定时器或者 API 调用等等）都会捕获某次渲染中定义的 props 和 state 有了这些概念以后，我们来思考下面的代码 123456useEffect(() =&gt; { ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange) return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange) }}) 我们假设第一次渲染的时候 props 是 {id: 10}，第二次渲染的时候是 {id: 20}，我们可能会认为清理操作也是按顺序执行的，也就是首先清除了 {id: 10} 的 effect，然后渲染了 {id: 20} 的 UI，最后再次执行了 {id: 20} 的 effect，但是事实并不是这样 React 只会在 浏览器绘制 后运行 effect，这会使我们的应用更为流畅，因为大多数 effect 并不会阻塞屏幕的更新，effect 的清除同样被延迟了，上一次的 effect 会在重新渲染后被清除，也就是说首先会渲染 {id: 20} 的 UI，然后浏览器进行绘制，所以我们在屏幕上可以看到 {id: 20} 的 UI，最后才会按顺序依次去执行清除 {id: 10} 的 effect 和 {id: 20} 的 effect 这里可能有一点会让人疑惑的地方，那就是如果清除上一次的 effect 是发生在 props 变成 {id: 20} 之后，那它为什么还能获取到旧的 {id: 10} 呢？答案显而易见，effect 的清除并不会读取最新的 props，它只能读取到定义它的那次渲染中的 props 值，也就是我们之前提到过的，它的伪代码会是下面这样的 12345678910111213141516171819202122232425// First render, props are {id: 10}function App() { // Effect from first render useEffect(() =&gt; { ChatAPI.subscribeToFriendStatus(10, handleStatusChange) // Cleanup for effect from first render return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange) } }) // ...}// Next render, props are {id: 20}function App() { // Effect from second render useEffect(() =&gt; { ChatAPI.subscribeToFriendStatus(20, handleStatusChange) // Cleanup for effect from second render return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange) } }) // ...} 也就是说，第一次渲染中 effect 的清除函数其实只能看到 {id: 10} 这个 props，这也正是为什么 React 能做到在绘制后立即处理 effect，并且在默认情况下会使我们的应用运行更为流畅 同步比如我们有下面这样一个组件 123function App({ name }) { return &lt;h1 className=\"Greeting\"&gt;Hello, {name}&lt;/h1&gt;} 我们首先渲染 &lt;Greeting name=&quot;zhangsan&quot; /&gt;，然后渲染 &lt;Greeting name=&quot;lisi&quot; /&gt;，和我们直接渲染 &lt;Greeting name=&quot;lisi&quot; /&gt; 其实并没有什么区别，因为在这两种情况中，我们最后看到的结果都是 Hello, lisi React 会根据我们当前的 props 和 state 同步到 DOM，所以我们应该以相同的方式去思考 effect，只不过 useEffect 可以使我们能够根据 props 和 state 同步 React tree 之外的东西而已 123456function App({ name }) { useEffect(() =&gt; { document.title = 'Hello, ' + name }) return &lt;h1 className=\"Greeting\"&gt;Hello, {name}&lt;/h1&gt;} 这与我们所熟知的 mount/update/unmount 等生命周期是有一定区别的，不过如果在每一次渲染后都去运行所有的 effect 可能并不高效（并且在某些场景下，它可能会导致无限循环），所以我们该怎么解决这个问题呢？在这种情况下，我们就需要告诉 React 去比对我们的 Effect 我们都知道，React 的 diff 算法只会更新 DOM 真正发生改变的部分，而不是每次渲染都大动干戈，所以我们也可以使用这种类似的方式来处理 effect，比如下面这个示例 12345678910111213141516function App({ name }) { const [counter, setCounter] = useState(0) useEffect(() =&gt; { document.title = 'Hello, ' + name }) return ( &lt;h1 className=\"Greeting\"&gt; Hello, {name} &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt; Increment &lt;/button&gt; &lt;/h1&gt; )} 我们的 effect 并没有使用 counter 这个状态，所以我们的 effect 只会同步 name 属性给 document.title，但是 name 并没有变，所以在每一次 counter 改变后重新给 document.title 赋值并不是理想的做法，所以在这种情况下我们可以提供给 useEffect 一个依赖数组参数（deps） 123useEffect(() =&gt; { document.title = 'Hello, ' + name}, [name]) 如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步，所以 React 会自动跳过这次 effect，但是需要注意，即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过 effect 的运行，要同步所有 但是在平时我们可能经常会遇到下面这样的用法，也就是我们只是想在挂载的时候运行它一次而已，所以我们只传递一个 [] 123456789function App() { async function fetchData() { // ... } useEffect(() =&gt; { fetchData() }, [])} 这样虽然在某些情况下可以解决问题，但是在官方的建议当中，如果我们设置了依赖项，effect 中用到的所有组件内的值都要包含在依赖中，这包括 props，state，函数，组件内的任何东西 有时候虽然我们也是这样操作的，但是却会遇到无限请求的问题，解决的方法当然不是移除依赖项，而是我们应该先尝试更好地理解这个问题，下面就让我们来深入的了解一下 effect 中的依赖项 依赖项我们有没有考虑过，如果设置了错误的依赖会怎么样呢？我们都知道，如果依赖项包含了所有 effect 中使用到的值，React 就能知道何时需要运行它 123useEffect(() =&gt; { document.title = 'Hello, ' + name}, [name]) 但是如果我们将 [] 设为 effect 的依赖的话呢？可以发现，新的 effect 函数是不会运行的 123useEffect(() =&gt; { document.title = 'Hello, ' + name}, []) 在这个例子当中，问题看起来显而易见，我们设置的依赖是 []，依赖没有变，所以不会再次运行 effect，也就是说运行了一次以后就停下来了，但是我们再来看看下面这个示例，情况就有些不太一样了 123456789101112function App() { const [count, setCount] = useState(0) useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(count + 1) }, 1000) return () =&gt; clearInterval(id) }, []) return &lt;h1&gt;{count}&lt;/h1&gt;} 针对于这个示例，我们依然设置依赖为 []，因为直觉上我们就只想让其运行一次 effect，也就是帮助我们开启定时器即可，但是运行后的结果可能会出乎我们的意料，这个例子只会递增一次以后就停止了，因为在第一次渲染中，count 是 0，因此 setCount(count + 1) 在第一次渲染中等价于 setCount(0 + 1)，但是同时我们设置了 [] 依赖，effect 不会再重新运行，所以其实它后面每一秒调用的都是 setCount(0 + 1) 其实仔细观察是可以发现我们的 effect 是依赖 count 的（但是我们仅仅只传递了一个 []），又因为 React 会对比依赖，而我们的依赖没有变，所以就不会再次运行 effect，也就是说会跳过后面的 effect，针对于上面这种情况，我们很容易的可以想到，我们直接在依赖中包含所有 effect 中用到的组件内的值不就可以了吗，我们来试试 123456useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(count + 1) }, 1000) return () =&gt; clearInterval(id)}, [count]) 问题的确是解决了，因为现在依赖数组正确了，但是我们仔细观察，却发现它可能不是太理想，因为现在每次 count 修改以后都会重新运行 effect，也就类似于下面这种情况 123456789101112131415161718192021// First render, state is 0function App() { // Effect from first render useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(0 + 1) }, 1000) return () =&gt; clearInterval(id) }, [0])}// Second render, state is 1function App() { // Effect from second render useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(1 + 1) }, 1000) return () =&gt; clearInterval(id) }, [1])} 问题虽然解决了，但是可以发现我们的依赖是在一直发生着变化的，这就导致 effect 也会重新运行，也就是说我们的定时器会在每一次 count 改变后清除和重新设定，这明显这不是我们想要的结果，所以下面我们就来看看另外一种解决方案，也就是修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更，我们不再传递 [] 这种错误的依赖，而是修改 effect，让它的依赖变得更少 为了实现这个目的，我们需要问自己一个问题，那就是我们为什么要用 count 呢？可以看到我们只在 setCount 调用中用到了 count，在这个场景中，我们其实并不需要在 effect 中使用 count，之所以依赖它是因为我们在之前的 effect 中写了 setCount(count + 1)，所以 count 成为了一个必需的依赖，但是其实我们真正想要的只是把 count 转换为 count + 1，然后返回给 React 而已，所以我们需要做的仅仅只是告知 React，让其去递增状态，而不用管它现在具体是什么值 在这种情况之下，我们就可以采用 Class 组件当中 setState() 的使用方式，因为在使用 setState() 的过程当中我们已经知晓，当我们想要根据前一个状态更新状态的时候，我们可以使用它的函数形式，这里当然也可以这么使用，如下 123456useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(c =&gt; c + 1) }, 1000) return () =&gt; clearInterval(id)}, []) 现在我们将更新值的方式调整成了 setCount(c =&gt; c + 1)，同时也将依赖数组设置为了 []，再次运行后可以发现，程序可以正常运行，此时我们已经移除了依赖，我们的 effect 也就不再读取渲染中的 count 值了，而依赖为 []，它没有变化，所以不会再次运行 effect，尽管 effect 只运行了一次，但是在第一次渲染中的定时器回调函数可以完美地在每次触发的时候给 React 发送 c =&gt; c + 1 更新指令，它也不再需要知道当前的 count 值了，因为 React 已经知道了 然而，即使是 setCount(c =&gt; c + 1) 也并不完美，它看起来有点怪，并且非常受限于它能做的事，如果我们有两个互相依赖的状态，或者我们想基于一个 prop 来计算下一次的 state，它并不能做到，但是幸运的是，setCount(c =&gt; c + 1) 有一个更强大的模式，那就是 useReducer useReducer我们来修改上面的例子让它包含两个状态 count 和 step，我们的定时器会每次在 count 上增加一个 step 值 123456789101112131415161718function App() { const [count, setCount] = useState(0) const [step, setStep] = useState(1) useEffect(() =&gt; { const id = setInterval(() =&gt; { setCount(c =&gt; c + step) }, 1000) return () =&gt; clearInterval(id) }, [step]) return ( &lt;&gt; &lt;h1&gt;{count}&lt;/h1&gt; &lt;input value={step} onChange={e =&gt; setStep(Number(e.target.value))} /&gt; &lt;/&gt; )} 这个例子目前的行为是修改 step 后会重启定时器，因为它是依赖项之一，也就是清除上一次的 effect 然后重新运行新的 effect，但是如果我们不想在 step 改变后重启定时器，我们该如何从 effect 中移除对 step 的依赖呢？ 当我们想更新一个状态的时候，并且这个状态更新依赖于另一个状态的值，这个时候我们就可以考虑使用 useReducer 去替换它们，reducer 可以让我们把组件内发生了什么（actions）和状态如何响应并更新分开表述，所以我们用一个 dispatch 依赖去替换 effect 的 step 依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const initialState = { count: 0, step: 1,}function reducer(state, action) { const { count, step } = state switch (action.type) { case 'tick': return { ...state, count: count + step } case 'step': return { ...state, step: action.step } default: return state }}function App() { const [state, dispatch] = useReducer(reducer, initialState) const { count, step } = state useEffect(() =&gt; { const id = setInterval(() =&gt; { dispatch({ type: 'tick' }) }, 1000) return () =&gt; clearInterval(id) }, [dispatch]) return ( &lt;&gt; &lt;h1&gt;{count}&lt;/h1&gt; &lt;input value={step} onChange={e =&gt; { dispatch({ type: 'step', step: Number(e.target.value) }) }} /&gt; &lt;/&gt; )} 因为 React 会保证 dispatch 在组件的声明周期内保持不变，所以在上面例子中我们也就不再需要重新订阅定时器 但是这里有一点需要注意的就是，我们可以从依赖中去除 dispatch，setState 和 useRef 包裹的值因为 React 会确保它们是静态的，不过我们设置了它们作为依赖也没什么问题（也就是说上面的 [dispatch] 可以简写为 []） 在上面的示例当中，相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么，这使得我们的 effect 和 step 状态解耦，我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么，更新的逻辑全都交由 reducer 去统一处理 在上面我们已经知道如何移除 effect 的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态，但假如我们需要依赖 props 去计算下一个状态，该如何处理呢？办法当然是有的，那就是把 reducer 函数放到组件内去读取 props 1234567891011121314151617181920212223242526272829303132function Counter({ step }) { const [count, dispatch] = useReducer(reducer, 0) function reducer(state, action) { switch (action.type) { case 'tick': return state + step default: return state } } useEffect(() =&gt; { const id = setInterval(() =&gt; { dispatch({ type: 'tick' }) }, 1000) return () =&gt; clearInterval(id) }, [dispatch]) return &lt;h1&gt;{count}&lt;/h1&gt;}function App() { const [step, setStep] = useState(1) return ( &lt;&gt; &lt;Counter step={step} /&gt; &lt;input value={step} onChange={e =&gt; setStep(Number(e.target.value))} /&gt; &lt;/&gt; )} 这种模式会使一些优化失效，所以我们应该避免滥用它，不过如果有需要完全可以在 reducer 里面访问 props，但是可能会疑惑，为什么在之前渲染中调用的 reducer 可以获取到最新的 props 呢？答案是当我们在 dispatch 的时候，React 只是记住了 action，它会在下一次渲染中再次调用 reducer，在那个时候，新的 props 就可以被访问到，而且 reducer 调用也不是在 effect 里的 函数一个典型的误解是认为函数不应该成为依赖，比如下面这个示例 1234567891011121314function App() { const [data, setData] = useState({}) async function fetchData() { const result = await axios('...') setData(result.data) } useEffect(() =&gt; { fetchData() }, []) // ...} 上面的代码虽然可以正常工作，但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行，如果我们的代码做下面这样的分离 12345678910111213141516function App() { function getFetchUrl() { return '...' } async function fetchData() { const result = await axios(getFetchUrl()) setData(result.data) } useEffect(() =&gt; { fetchData() }, []) // ...} 如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的 effect 的依赖，我们的 effect 就不会同步 props 和 state 带来的变更，这当然不是我们想要的，幸运的是，对于这个问题有一个更为简单的解决方案，那就是如果某些函数仅在 effect 中调用，我们可以把它们的定义移到 effect 中 1234567891011121314151617function App() { // ... useEffect(() =&gt; { function getFetchUrl() { return '...' } async function fetchData() { const result = await axios(getFetchUrl()) setData(result.data) } fetchData() }, []) // ...} 这样一来，我们不再需要去考虑这些间接依赖，因为在我们的 effect 中确实没有再使用组件范围内的任何东西，但是有时候我们可能不想把函数移入 effect 里，比如组件内有几个 effect 使用了相同的函数，我们不想在每个 effect 里复制黏贴一遍这个逻辑，也或许这个函数是一个 prop，比如下面这个示例，它就有两个 effect 会调用 getFetchUrl 的示例 1234567891011121314151617function App() { function getFetchUrl(query) { return '...' + query } useEffect(() =&gt; { const url = getFetchUrl('react') // ... }, []) // 缺少依赖 getFetchUrl useEffect(() =&gt; { const url = getFetchUrl('redux') // ... }, []) // 缺少依赖 getFetchUrl // ...} 可以发现，我们的两个 effect 都依赖 getFetchUrl，但是如果我们将 getFetchUrl 添加到依赖数组当中，因为它每次渲染的内容都不同，所以我们的依赖数组会变得无用，一个可能的解决办法是把 getFetchUrl 从依赖中去掉，但是这并不是很好的解决方式，这会使我们后面对数据流的改变很难被发现从而忘记去处理，这会导致类似于我们之前的定时器不更新值的问题 相反的，我们有两个更简单的解决办法，第一个就是，如果一个函数没有使用组件内的任何值，我们应该把它提到组件外面去定义，然后就可以自由地在 effect 中使用 1234567891011121314151617function getFetchUrl(query) { return '...' + query}function App() { useEffect(() =&gt; { const url = getFetchUrl('react') // ... }, []) useEffect(() =&gt; { const url = getFetchUrl('redux') // ... }, []) // ...} 这样一来我们就不需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响，另外一种方式就是将其包装成 useCallback Hook 1234567891011121314151617function App() { const getFetchUrl = useCallback((query) =&gt; { return '...' + query }, []) useEffect(() =&gt; { const url = getFetchUrl('react') // ... }, [getFetchUrl]) useEffect(() =&gt; { const url = getFetchUrl('redux') // ... }, [getFetchUrl]) // ...} useCallback 本质上是添加了一层依赖检查，它以另一种方式解决了问题，也就是我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖，这样一来如果 query 保持不变，getFetchUrl 也会保持不变，我们的 effect 也不会重新运行，但是如果 query 修改了，getFetchUrl 也会随之改变，因此会重新请求数据 同样的，对于通过属性从父组件传入的函数这个方法也适用 12345678910111213141516function Parent() { const [query, setQuery] = useState('test') const fetchData = useCallback(() =&gt; { const url = '...' + query // ... }, [query]) return &lt;Child fetchData={fetchData} /&gt;}function Child({ fetchData }) { let [data, setData] = useState(null) useEffect(() =&gt; { fetchData().then(setData) }, [fetchData]) // ...} 因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据，使用 useCallback，函数完全可以参与到数据流中，我们可以说如果一个函数的输入改变了，这个函数就改变了，如果没有，函数也不会改变 类似的，useMemo 可以让我们对复杂对象做类似的事情 12345function App() { const [color, setColor] = useState('pink') const style = useMemo(() =&gt; ({ color }), [color]) return &lt;Child style={style} /&gt;} 但是到处使用 useCallback 是件挺笨拙的事，当我们需要将函数传递下去并且函数会在子组件的 effect 中被调用的时候，useCallback 是很好的技巧，但总的来说 Hook 本身能更好地避免 传递回调函数 竞态下面是一个典型的在 Class 组件里发请求的例子 12345678910111213class App extends Component { state = { article: null } componentDidMount() { this.fetchData(this.props.id) } async fetchData(id) { const article = await API.fetchArticle(id) this.setState({ article }) } // ...} 仔细观察可能已经发现，上面的代码埋伏了一些问题，它并没有处理更新的情况，所以通常的解决方法是下面这样的 123456789101112131415161718class App extends Component { state = { article: null } componentDidMount() { this.fetchData(this.props.id) } componentDidUpdate(prevProps) { if (prevProps.id !== this.props.id) { this.fetchData(this.props.id) } } async fetchData(id) { const article = await API.fetchArticle(id) this.setState({ article }) } // ...} 这显然好多了！但依旧有问题，有问题的原因是请求结果返回的顺序不能保证一致，比如我们先请求 {id: 10}，然后更新到 {id: 20}，但 {id: 20} 的请求更先返回，请求更早但返回更晚的情况会错误地覆盖状态值，这被叫做竞态，这在混合了 async/await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props 和 state 可能会在 async 函数调用过程中发生改变） effect 并没有神奇地解决这个问题，尽管它会警告我们让我们直接传了一个 async 函数给 effect，但是如果我们使用的异步方式支持取消，那我们就可以直接在清除函数中取消异步请求，或者最简单的权宜之计是用一个布尔值来跟踪它 12345678910111213141516171819202122function App({ id }) { const [article, setArticle] = useState(null) useEffect(() =&gt; { let didCancel = false async function fetchData() { const article = await API.fetchArticle(id) if (!didCancel) { setArticle(article) } } fetchData() return () =&gt; { didCancel = true } }, [id]) // ...} 关于如何处理错误和加载状态，以及抽离逻辑到自定义的 Hook 可以参考 在 React Hooks 中如何请求数据？ 来了解更多 参考 官方文档 A Complete Guide to useEffect 从依赖项列表中省略函数是否安全？ React as a UI Runtime How Are Function Components Different from Classes 浏览器绘制 传递回调函数 在 React Hooks 中如何请求数据？ Build a CRUD App in React with Hooks","link":"/2020/11/07/React/17/"},{"title":"JavaScript 中的数据类型","text":"最后更新于 2020-11-25 最近打算重新的梳理一下 JavaScript 中数据类型的相关内容，主要分为三部分『数据类型』，『类型转换』和『类型判断』，也算是做一个整合汇总，方便以后进行查阅或是复习，下面我们就先从『数据类型』开始看起 数据类型在当下的 ECMAScript 标准 当中，总共定义了八种数据类型，分为『基本类型』和『引用类型』两大类，当然也有『原始类型』和『对象类型』的叫法，但是本文当中统一称为『基本类型』和『引用类型』，知道它们是同一个东西即可 『基本类型』包括 Null，只包含一个值 null Undefined，只包含一个值 undefined Boolean，包含两个值，true 和 false Number，整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String，一串表示文本值的字符序列 Symbol，一种实例是唯一且不可改变的数据类型 BigInt，ES10 当中加入，现已被最新 Chrome 支持 『引用类型』包括 Object，常用的 Object，Array、Function 等都属于特殊的对象 基本类型像 String，Number，Boolean 等这些我们平常经常使用的，这里我们就不多做提及了，关于 Symbol 的相关内容我们在之前已经梳理过了，而引用类型我们会在下面详细来进行介绍，所以这里我们就只简单的看看 Null，Undefined 和 BigInt Null在基本类型中，有两个类型 Null 和 Undefined，它们都有且仅有一个值，null 和 undefined，并且它们都代表无和空，我们一般这样来区分它们 表示被赋值过的对象，刻意把一个对象赋值为 null，故意表示其为空，不应有值，所以对象的某个属性值为 null 是正常的，并且 null 转换为数值时值为 0 Undefined表示『缺少值』，即此处应有一个值，但还没有定义，如果一个对象的某个属性值为 undefined 是不正常的，例如 obj.name = undefined，但是建议不要这样使用，应该直接 delete obj.name，并且 undefined 转为数值时为 NaN JavaScript 是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只有在运行期才知道），这就是 undefined 的意义所在 BigIntBigInt 主要是用于解决使用 number 类型的限制，比如无法精确表示的非常大的整数等，因为在 JavaScript 当中缺少显式整数类型，所以它无法精确表示的非常大的整数，而会自动的四舍五入，比如 1239007199254740992 === 9007199254740993 // trueconsole.log(9999999999999999) // 10000000000000000 其实在之前，JavaScript 也提供了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 常量来表示最大（最小）安全整数，但是在进行计算的时候也存在一定的误差，如下 1234567const minInt = Number.MIN_SAFE_INTEGERconsole.log(minInt) // -9007199254740991// 注意两者结果的对比console.log(minInt - 5) // -9007199254740996console.log(minInt - 4) // -9007199254740996 所以在这种情况之下，我们就可以考虑来使用 BigInt，使用了 BigInt 以后就可以在标准的 JavaScript 当中执行对大整数的算术运算，而不会有精度损失的风险，下面我们来看看如何进行使用，如果要创建 BigInt，只需在整数的末尾追加 n 即可，如下 12console.log(9007199254740995n) // 9007199254740995nconsole.log(9007199254740995) // 9007199254740996 或者，可以调用 BigInt() 构造函数来进行实现 1BigInt('9007199254740995') // 9007199254740995n 但是需要注意的是，不能使用严格相等运算符将 BigInt 与常规数字进行比较，因为它们的类型不同 1234console.log(10n === 10) // falseconsole.log(typeof 10n) // bigintconsole.log(typeof 10) // number 相反，可以使用等号运算符，它在处理操作数之前执行隐式类型转换 1console.log(10n == 10) // true 最后我们就简单的总结一下在使用 BigInt 过程当中一些值得警惕的点，其它更多内容在这里也就不具体展开了，感兴趣的话可以自行查阅相关内容，主要以下这几点 BigInt 不支持一元加号运算符，这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常 因为隐式类型转换可能丢失信息，所以不允许在 BigInt 和 Number 之间进行混合操作，当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示 12// TypeError10 + 10n 不能将 BigInt 传递给 Web API 和内置的 JavaScript 函数，这些函数需要一个 Number 类型的数字，尝试这样做会报 TypeError 错误 12// TypeErrorMath.max(2n, 4n, 6n) 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，换句话说只要不是 0n，BigInt 就被视为 truthy 的值 12345// 条件判断为 falseif (0n) { }// 条件为 trueif (3n) { } 元素都为 BigInt 的数组可以进行 sort BigInt 可以正常地进行位运算，如 |、&amp;、&lt;&lt;、&gt;&gt; 和 ^ 最后需要注意浏览器的兼容性，目前兼容性并不怎么好，只有 Chrome、Firefox、Opera 这些主流实现，要正式成为规范，其实还有很长的路要走 不可变性我们在上面所提到的基本类型，在 ECMAScript 标准中，它们被定义为 primitive values，即原始值，代表值本身是不可被改变的，以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的 123456789var str = 'foo'str.slice(1)str.substr(1)str.trim(1)str.toLowerCase(1)str[0] = 1console.log(str) // foo 在上面的代码中我们对 str 调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变 str，这就印证了字符串的不可变性，但是如果我们像下面这样操作的话 12345var str = 'foo'str += 'bar'console.log(str) // foobar 我们发现 str 的值被改变了，但是我们在上面又提到它不是不可变的吗？其实不然，我们从内存上来理解，我们都知道，在 JavaScript 中，每一个变量在内存中都需要一个空间来存储，而内存空间又被分为两种，即『栈内存』与『堆内存』 其中『栈内存』的特点是 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 JavaScript 中的基本类型的值被直接存储在『栈』中，在变量定义时，栈就为其分配好了内存空间，由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 而在上面的代码中，我们执行了 str += 'bar' 的操作，实际上是在栈中又开辟了一块内存空间用于存储 'foobar'，然后将变量 str 指向这块空间，所以这并不违背不可变性的特点 引用类型而『堆内存』的特点是 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 相对于上面具有不可变性的基本类型，我们习惯于把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值 1234567var obj1 = { name: 'foo' }var obj2 = { age: 18 }var obj3 = function () { }var obj4 = [1, 2, 3, 4, 5, 6, 7, 8, 9] 当然，引用类型就不再具有『不可变性』了，所以我们可以轻易的改变它们 1234567obj1.name = 'foo'obj2.age = 18obj4.length = 0console.log(obj1) // { name: 'foo' }console.log(obj2) // { age: 18 }console.log(obj4) // [] 以数组为例，它的很多方法都可以改变它自身 pop()，删除数组最后一个元素，如果数组为空，则不改变数组，返回 undefined，改变原数组，返回被删除的元素 push()，向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()，把数组的第一个元素删除，若空数组，不进行任何操作，返回 undefined，改变原数组，返回第一个元素的值 unshift()，向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()，颠倒数组中元素的顺序，改变原数组，返回该数组 sort()，对数组元素进行排序，改变原数组，返回该数组 splice()，从数组中添加或是删除项目，改变原数组，返回被删除的元素 数据如何存储我们在上面的探讨过程当中，其实漏掉了一种情况，那就是闭包的情况，根据我们之前所说的，如果变量存在『栈』中，那函数调用完『栈顶空间销毁』，闭包变量不就没了吗？ 所以在这里我们就需要注意了『闭包变量其实存在堆内存中的』，具体而言，我们之前提到的『基本类型』都存储在栈中，而所有的『引用类型』存放在堆中，值得注意的是，对于『赋值』操作，基本类型的数据直接完整地复制变量值，而引用类型的数据则是复制引用地址，也因此会有下面这样的情况 12345let obj1 = { a: 1 }let obj2 = obj1obj2.a = 2obj1.a // 2 之所以会这样，是因为 obj1 和 obj2 是同一份堆空间的地址，改变 obj2，等于改变了共同的堆内存，这时候通过 obj1 来获取这块内存的值当然会改变，关于这部分内容我们会在下面详细来进行介绍，现在我们先来看另外一个问题，那就是为什么不全部使用栈来保存呢？ 首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能，举个例子 123456789function f(a) { console.log(a)}function func(a) { f(a)}func(1) 假设我们使用 ESP 指针来保存当前的执行状态，在系统栈中会产生如下的过程 调用 func，将 func 函数的上下文压栈，ESP 指向栈顶 执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移 执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收 执行完 func，ESP 下移，func 对应的空间被回收 也就如下图所示 因此可以发现，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大，不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，关于垃圾回收这部分内容，我们会在 V8 引擎机制 一节当中来详细进行介绍 下面我们通过几个操作来详细看看基本类型和引用类型的区别 复制当我们把一个变量的值复制到另一个变量上时，基本类型和引用类型的表现是不一样的，先来看看基本类型 12345var name = 'foo'var name2 = namename2 = 'bar'console.log(name) // foo 我们可以设想内存中有一个变量 name，它的值为 foo，我们从变量 name 复制出一个变量 name2，此时在内存中创建了一个块新的空间用于存储 foo，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响，下面我们再来看看复制一个引用类型 12345var obj = { name: 'foo' }var obj2 = objobj2.name = 'bar'console.log(obj.name) // bar 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的 obj2 实际上和 obj 指向的堆中同一个对象，因此我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因 比较当我们在对两个变量进行比较时，不同类型的变量的表现是不同的 1234567var name = 'foo'var name2 = 'foo'console.log(name === name2) // truevar obj = { name: 'foo' }var obj2 = { name: 'foo' }console.log(obj === obj2) // false 对于基本类型，比较时会直接比较它们的值，如果值相等，即返回 true，对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为 false 值传递和引用传递先来看一个例子 1234567891011121314151617var a = 2var b = a // b 是 a 的值的一个副本b++a // 2b // 3// ==&gt;var c = [1, 2, 3]var d = cd.push(4)c // [1, 2, 3, 4]d // [1, 2, 3, 4] 上例中的 2 是一个标量基本类型值，所以变量 a 持有该值的一个副本，b 持有它的另一个复本，所以 b 更改时，a 的值保持不变，而 c 和 d 则分别指向同一个复合值 [1, 2, 3] 的两个不同引用，请注意，c 和 d 仅仅是指向值 [1, 2, 3]，并非持有，所以它们更改的是同一个值（比如调用 push() 方法），随后它们都指向了更改后的新值 [1, 2, 3, 4] 简单值（即标量基本类型值，scalar primitive），总是通过值复制的方式来赋值（传递），包括 number，boolean，string，undefined，null 和 ES6 中的 Symbol 和 BigInt 复合值（compound value），对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值（传递） 由上可知，由于引用指向的是值本身而非变量，所以一个引用无法更改另外一个引用的指向 1234567891011var a = [1, 2, 3]var b = aa // [1, 2, 3]b // [1, 2, 3]// ==&gt;b = [4, 5, 6]a // [1, 2, 3]b // [4, 5, 6] 从上面例子可以看出 b = [4, 5, 6] 并不影响 a 指向 [1, 2, 3]，下面我们就来分别看看它们两者之间的区别 引用类型值的传递我们首先需要明确一点，即 其实严格来说，在 JavaScript 中没有『引用传递』，比较严谨的说法是，如果传递的参数是一个值，是按值传递，如果传递的是一个对象，则传递的是一个对象的引用，JavaScript 不允许直接访问内存中的位置，不能直接操作对象的内存空间，实际上操作的是对象的引用，所以引用类型的值是按引用访问的 准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址 但是函数的参数就经常让人产生这样的疑惑，比如看下面这个例子 123456789101112131415function foo (x) { x.push(4) x // [1, 2, 3, 4] // ==&gt; x = [4, 5, 6] x.push(7) x // [4, 5, 6, 7]}var a = [1, 2, 3]foo(a)a // [1, 2, 3, 4] 我们向函数传递 a 的时候，实际是将引用 a 的一个复本赋值给 x，而 a 仍然指向 [1, 2, 3]，在函数中我们可以通过引用 x 来更改数组的值（如上，数组在 push(4) 后变为了 [1, 2, 3, 4]） 但 x = [4, 5, 6] 并不影响 a 的指向，所以 a 仍然指向 [1, 2, 3, 4]，我们不能通过引用 x 来更改引用 a 的指向，只能更改 a 和 x 共同指向的值，如果要将 a 的值变为 [4, 5, 6, 7]，那么就必须更改 x 指向的数组，而不是为 x 赋值一个新的数组 123456789101112131415function foo (x) { x.push(4) x // [1, 2, 3, 4] // ==&gt; x.length = 0 x.push(4, 5, 6, 7) x // [4, 5, 6, 7]}var a = [1, 2, 3]foo(a)a // [4, 5, 6, 7] 这样一来，在不创建新数组，而只是更改了当前的数组的情况下，a 的指向就变成了 [4, 5, 6, 7]，所以这里也就有一个小技巧，那就是如何引用一个对象，但是不改变原有对象的值，解决方法就是在一个函数中去引用，所以简单总结就是 对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值 对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象 基本类型值的传递相反，如果要将标量基本类型值传递到函数内并进行更改，这时候就需要将该值封装到一个复合值（对象，数组等）中，然后通过引用复制的方式传递 1234567891011function foo (wrap) { wrap.a = 22}var obj = { a: 2}foo(obj) obj.a // 22 这里的 obj 是一个封装了标量基本类型值 a 的封装对象，obj 引用的一个复本作为参数 wrap 被传递到 foo() 中，这样我们就可以通过 wrap 来访问该对象并更改它的属性，函数执行结束后 obj.a 的值就变为了 22，与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值 12345678910function foo (x) { x = x + 1 x // 3}var a = 2var b = new Number(a) // Objeact(a) 也是一样foo(b)b // 2，而不是 3 这是因为标量基本类型的值是不可更改的（字符串和布尔也是如此），如果一个数字对象的标量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象，x = x + 1 中，x 中的标量基本类型值 2 从数字对象中拆封（提取）出来以后，x 就从引用变成了数字对象，它的值为 2 + 1 等于 3，然而函数外的 b 仍然指向原来那个值为 2 的数字对象 包装类型最后我们再来简单的了解一下包装类型，为了便于操作基本类型值，ECMAScript 还提供了几个特殊的引用类型，它们是基本类型的包装类型 Boolean Number String 但是我们需要注意包装类型和基本类型的区别 12345true === new Boolean(true) // false123 === new Number(123) // false'foo' === new String('foo') // falseconsole.log(typeof new String('foo')) // objectconsole.log(typeof 'foo') // string 引用类型和包装类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法 1234var name = 'foo'name.color = 'red'console.log(name.color) // undefined 既然提到了包装类型，那就不得不提我们经常听闻的两个相关操作，即装箱和拆箱 装箱转换，把基本类型转换为对应的包装类型 拆箱操作，把引用类型转换为基本类型 既然基本类型不能扩展属性和方法，那么我们是如何使用基本类型调用方法的呢？其实每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码 12var name = 'foo'var name2 = name.substring(2) 实际上发生了以下几个过程 创建一个 String 的包装类型实例 在实例上调用 substring 方法 销毁实例 也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的我们使用 Number 和 Boolean 类型时，也会发生这个过程，而这个过程也就是我们下面将要介绍的类型转换的过程 类型转换从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循 ECMAScript 规范规定的抽象操作 [ToPrimitive]，大致有以下几个步骤 如果存在 Symbol.toPrimitive() 方法，优先调用再返回 其次检查该值是否有 valueOf() 的方法，如果有并且返回基本类型值，就使用该值进行强制类型转换为这个原始值 如果没有，则调用 toString 方法，如果 toString 方法返回的是原始值（如果存在），则对象转换为这个原始值 如果 valueOf 和 toString 方法均没有返回原始值，则抛出 TypeError 异常 123456789101112131415161718192021222324252627282930313233const obj = { valueOf: () =&gt; { console.log('valueOf') return 123 }, toString: () =&gt; { console.log('toString') return 'foo' },}const obj2 = { [Symbol.toPrimitive]: () =&gt; { console.log('toPrimitive') return 123 },}const obj3 = { valueOf: () =&gt; { console.log('valueOf') return {} }, toString: () =&gt; { console.log('toString') return {} },}console.log(obj - 1) // valueOf 122console.log(`${obj}`) // toString fooconsole.log(obj2 - 1) // valueOf 122console.log(obj3 - 1) // valueOf/toString TypeError 当然除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作，我们可以直接调用包装类型的 valueOf 或 toString，实现拆箱操作 1234var num = new Number('123')console.log(typeof num.valueOf()) // numberconsole.log(typeof num.toString()) // string 因为 JavaScript 是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换，类型转换分为两种 『隐式转换』即程序自动进行的类型转换 『强制转换』即我们手动进行的类型转换 强制转换我们就不再过多提及了，下面我们就来简单的梳理一下类型转换规则和来看一些让人头疼的隐式转换场景 类型转换规则我们在上面我们只是简单的提及了 toPrimitive 原则，其实这其中还包含着其它一些内容，具体我们可以参考 ECMAScript 规范当中的 类型转换与测试，梳理下来以后是下面这样的 字符串 和 数字 之间的比较（字符串 x ==&gt; ToNumber(x)） 如果 type(x) 是数字，type(y) 是字符串，则返回 x == ToNumber(y) 的结果 如果 type(x) 是字符串，type(y) 是数字，则返回 ToNumber(x) == y 的结果 其它类型 和 布尔类型 之间的比较（布尔 x ==&gt; ToNumber(x)） 如果 type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果 如果 type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果 null 和 undefined 之间的比较 如果 x 是 null，y 是 undefined，则结果为 true 如果 x 是 undefined，y 是 null，则结果为 true 对象 和 非对象 之间的比较（对象 ==&gt; ToPrimitive(obj)） 如果 type(x) 是字符串或数字，type(y) 是对象，则返回 x == ToPrimitive(y) 的结果 如果 type(x) 是对象，type(y) 是字符串或数字，则返回 ToPrimitive(x) == y 的结果 上述规则转换成我们比较好理解的方式可以参考下表 转换前类型 转换前值 转换后（Boolean） 转换后（Number） 转换后（String） Boolean ture - 1 'true' Boolean false - 0 'false' Number 123 true - '123' Number Infinity true - 'Infinity' Number 0 false - '0' Number NaN false - 'NaN' String '' false 0 - String '123' true 123 - String '123foo' true NaN - String 'foo' true NaN - Symbol Symbol() true TypeError TypeError Null null false 0 'null' Undefined undefined false NaN 'undefined' Function function(){} true NaN 'function(){}' Object {} true NaN [object Object] Array [] true 0 '' Array ['foo'] true NaN 'foo' Array ['123', 'foo'] true NaN '123, foo' 下面我们再来看几个实际场景当中的隐式转换 if 语句和逻辑语句在 if 语句和逻辑语句中，如果只有单个变量，会先将变量转换为 Boolean 值，只有下面几种情况会转换成 false，其余被转换成 true null undefined '' NaN 0 false 数学运算符我们在对各种非 Number 类型运用数学运算符时，会先将非 Number 类型转换为 Number 类型 12341 - true // 01 - null // 11 * undefined // NaN2 * ['5'] // 10 但是需要注意 + 是个例外，执行 + 操作符时 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型 当一侧为 Number 类型，另一侧为基本类型，则将基本类型转换为 Number 类型 当一侧为 Number 类型，另一侧为引用类型，将引用类型和 Number 类型转换成字符串后拼接 1234123 + '123' // 规则一 123123123 + null // 规则二 123123 + true // 规则二 124123 + {} // 规则三 123[object Object] ==使用 == 时，若两侧类型相同，则比较结果和 === 相同，否则会发生隐式转换，使用 == 时发生的转换可以分为几种不同的情况（这里我们只考虑两侧类型不同） NaNNaN 和其它任何类型比较永远返回 false（包括和它自己） 1NaN == NaN // false BooleanBoolean 和其它任何类型比较，Boolean 首先被转换为 Number 类型 1234true == 1 // true true == '2' // falsetrue == ['1'] // truetrue == ['2'] // false 但是这里需要注意一个可能会弄混淆的地方，那就是 undefined、null 和 Boolean 比较，虽然 undefined、null 和 false 都很容易被想象成假值，但是它们比较结果是 false，原因是 false 首先被转换成 0 12undefined == false // falsenull == false // false String 和 NumberString 和 Number 比较，先将 String 转换为 Number 类型 12123 == '123' // true'' == 0 // true Null 和 Undefined除了 null == undefined 比较结果是 true 以外，null、undefined 和其它任何结果的比较值都为 false 1234567null == undefined // truenull == '' // falsenull == 0 // falsenull == false // falseundefined == '' // falseundefined == 0 // falseundefined == false // false 基本类型和引用类型当基本类型和引用类型做比较时，引用类型会依照 ToPrimitive 规则转换为基本类型，这个我们在上面已经介绍过了 12'[object Object]' == {} // true'1, 2, 3' == [1, 2, 3] // true [] == ![]这个涉及到的转换就比较多了，这里我们简单的梳理一下，它的流程如下 1234567[] == ![] // 因为 ! 优先级较高，[] 转布尔值是 true，所以就变成了 [] == false[] == false // 当 == 号两边其中一个是布尔值的话，先把它转换为数字，也就成了 [] == 0[] == 0 // 对象和非对象之间的比较，针对对象执行 ToPrimitive() 操作[] == 0 // [].valueOf() 返回还是对象自身[] == 0 // [].toString() 返回 '''' == 0 // '' 会转成数字为 00 == 0 // true 另外再看下面这两个比较特殊的 12[null] == false // true[undefined] == false // true 根据数组的 ToPrimitive 规则，数组元素为 null 或 undefined 时，该元素被当做空字符串处理，所以 [null]、[undefined] 都会被转换为 0 所以，我们在上面总结了这么多，还是始终推荐使用 === 来判断两个值是否相等，最后我们再以一道有意思的面试题来进行收尾这个部分的内容，题目是如何让 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 的结果返回 true，这里我们就可以根据上面的拆箱转换，以及 == 的隐式转换得到最终的结果 12345678const a = { value: [3, 2, 1], valueOf: function () { return this.value.pop() }}a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true 类型判断我们在上面梳理了数据类型与类型转换的相关内容，下面我们再来看看类型判断的相关内容，我们就先从使用最为广泛的 typeof 开始看起 typeoftypeof 操作符可以准确判断一个变量是否为下面几个基本类型 12345typeof 'foo' // stringtypeof 123 // numbertypeof true // booleantypeof Symbol() // symboltypeof undefined // undefined 也可以用它来判断函数类型 1typeof function(){} // function 但是 typeof 也是存在一些局限性的，尤其是当我们使用 typeof 来判断引用类型时显得更为乏力 12345678typeof [] // objecttypeof { } // objecttypeof new Date() // objecttypeof /^\\w$/ // object// 两个特殊的情况typeof NaN // numbertypeof null // object instanceof而使用 instanceof 操作符就可以帮助我们判断引用类型具体是什么类型的对象 123[] instanceof Array // truenew Date() instanceof Date // truenew RegExp() instanceof RegExp // true instanceof 的一个有意思的特征是它不仅检测构造这个对象的构造器，还检测原型链，原型链包含了很多信息，包括定义对象所采用的继承模式，这里我们先来回顾下原型链的几条规则 所有引用类型都具有对象特性，即可以自由扩展属性 所有引用类型都具有一个 __proto__（隐式原型）属性，是一个普通对象 所有的函数都具有 prototype（显式原型）属性，也是一个普通对象 所有引用类型 __proto__ 值指向它构造函数的 prototype 当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去它的 __proto__ 中去找 我们在上面示例当中的 [] instanceof Array 实际上是判断 Array.prototype 是否在 [] 的原型链上，所以使用 instanceof 来检测数据类型，不会很准确，这不是它设计的初衷 12[] instanceof Object // true(function () { }) instanceof Object // true 另外，使用 instanceof 也不能检测基本数据类型，所以 instanceof 并不是一个很好的选择 toString我们在上面拆箱操作中提到了 toString 函数，我们可以调用它实现从引用类型的转换，因为每一个引用类型都有 toString 方法，默认情况下，toString() 方法被每个 Object 对象继承，如果此方法在自定义对象中未被覆盖，toString() 返回 '[object type]'，其中 type 是对象的类型，比如下面这个示例 1({}).toString() // [object Object] 关于 toString 方法的内部原理，我们可以根据 ECMAScript 规范 15.2.4.2 Object.prototype.toString() 来进行了解，根据规范可知，当 toString 方法被调用的时候，下面的步骤会被执行 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为 ToObject(this) 的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 '[object'，class 和 ']' 三个部分组成的字符串 但是这里需要注意的是，那就是我们在上面提到的『如果此方法在自定义对象中未被覆盖，toString 才会达到预想的效果』，事实上大部分引用类型比如 Array、Date、RegExp 等都重写了 toString 方法，所以在这种情况下，我们可以直接调用 Object 原型上未被覆盖的 toString() 方法，使用 call 来改变 this 指向来达到我们想要的效果 调用 结果 Object.prototype.toString.call(true) [object Boolean] Object.prototype.toString.call(123) [object Number] Object.prototype.toString.call('foo') [object String] Object.prototype.toString.call(null) [object Null] Object.prototype.toString.call(undefined) [object Undefined] Object.prototype.toString.call(Symbol()) [object Symbol] Object.prototype.toString.call({}) [object Object] Object.prototype.toString.call(function(){}) [object Function] Object.prototype.toString.call([]) [object Array] Object.prototype.toString.call(new Error()) [object Error] Object.prototype.toString.call(new ReaExp()) [object RegExp] Object.prototype.toString.call(new Date()) [object Date] Object.prototype.toString.call(Math) [object Math] Object.prototype.toString.call(JSON) [object JSON] Object.prototype.toString.call(window) [object global] Object.prototype.toString.call(arguments) [object Arguments] Object.is()ES6 中对象的扩展里面添加了一个 Object.is 方法，用于比较两个值是否严格相等，内部计算方式与 === 行为基本一致，但是还是存在一定的区别的，比如下面这几个示例 1234567891011121314NaN == NaN // false 但是我们期待它返回 trueNaN === NaN // false 但是我们期待它返回 true+0 == -0 // true 但是我们期待它返回 false+0 === -0 // true 但是我们期待它返回 falseObject.is(NaN, NaN) // trueObject.is(+0, -0) // false// 特例Object.is(0, -0) // falseObject.is(0, +0) // trueObject.is(-0, -0) // trueObject.is(NaN, 0 / 0) // true 可以发现，Object.is() 判断两个值是否相同跟我们的主观感受一致，即两个值是一样的，它们就应该相等（特例除外），所以这里需要我们注意它与 === 之间的区别 那么问题来了，我们如何才能在不支持这个方法的 ES5 中来进行实现呢？其实简单来说，我们还是可以直接使用 === 来实现，只不过需要单独处理一下上面提到的两种特殊情况即可，实现如下 1234567891011if (!Object.is) { Object.is = function (x, y) { if (x === y) { // 针对 +0 不等于 -0 return x !== 0 || 1 / x === 1 / y } else { // 针对 NaN 等于 NaN return x !== x &amp;&amp; y !== y } }} 这样就使得 Object.is() 总是返回我们需要的结果，它在下面六种情况下，都会返回 true 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN 都是除零和 NaN 外的其它同一个数字 可以看出 Object.is 可以对基本数据类型做出非常精确的比较，但是对于引用数据类型是没办法直接比较的 jQuery这里我们稍微扩展一点，来看看 jQuery 源码中是如何进行类型判断的 12345678910111213141516171819var class2type = {}jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) { class2type['[object ' + name + ']'] = name.toLowerCase() })type: function(obj) { if (obj == null) { return obj + '' } return typeof obj === 'object' || typeof obj === 'function' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj}isFunction: function(obj) { return jQuery.type(obj) === 'function'} 基本类型直接使用 typeof，引用类型使用 Object.prototype.toString.call 取得类型，借助一个 class2type 对象将字符串多余的代码过滤掉，例如 [object Function] 将得到 array，然后在后面的类型判断，如 isFunction 直接可以使用 jQuery.type(obj) === 'function' 这样的判断 空对象检测最后我们来看一种比较特殊的情况，那就是空对象检测，通常而言一般有下面几种方式 for-in一般最为常见的思路就是使用 for-in 遍历属性，为真则为非空数组，否则为空数组 1234567// 如果不为空，则会执行到这一步，返回 truefor (var i in obj) { return true}// 如果为空，返回 falsereturn false JSON.stringify()通过 JSON 自带的 stringify() 方法来判断，JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串，所以一般可以直接与 {} 来进行比较 1234567if (JSON.stringify(data) === '{}') { // 如果为空，返回 false return false}// 如果不为空，则会执行到这一步，返回 truereturn true Object.keys()ES6 新增的 Object.keys() 方法会返回所有可枚举属性，不包括原型中属性和 Symbol 属性，如果我们的对象为空，它会返回一个空数组 123var a = {}Object.keys(a) // [] isEmptyObject()jQuery 当中提供了 isEmptyObject() 方法用来判断空对象，但是其本质也是通过 for-in 循环来进行判断的，源码如下 1234567isEmptyObject: function(obj) { var name for (name in obj) { return false } return true} 这里有个需要注意的地方，就是我们在上面提及的这几个方法均不能检测出非枚举属性，比如如下示例 12345678910111213141516171819var obj = {}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'})for (var i in obj) { console.log(i)}JSON.stringify(obj) === '{}' // trueObject.keys(obj) // []$.isEmptyObject(obj) // true 所以我们还需要寻找一些其它方法来进行解决，接着往下看 Object.getOwnPropertyNames()该方法会返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组 123456789let obj = {}Object.getOwnPropertyNames(obj) // []// ES5 版本当中参数不是基本类型会引起错误Object.getOwnPropertyNames('foo') // TypeError: 'foo' is not an object// ES6 版本当中非对象参数会被强制转换为对象Object.getOwnPropertyNames('foo') // ['length', '0', '1', '2'] 利用这个方法可以检测出非枚举属性 12345678910var obj = {}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'})Object.getOwnPropertyNames(obj) // ['key'] Reflect.ownKeys(obj)这个是个无敌的方法，返回所有的自身属性，不管是否可枚举，不管是不是 Symbol，一律返回 123456789101112131415var test = Symbol()var obj = { [test]: 123}Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: '123'})Object.getOwnPropertyNames(obj) // ['key']Object.keys(obj) // []Reflect.ownKeys(obj) // ['key', Symbol()] 所以简单的总结一下，判断一个变量是不是空对象的比较完善的方法 12345678910111213obj !== null&amp;&amp; typeof obj === 'object'&amp;&amp; !Array.isArray(obj)&amp;&amp; (Object.getOwnPropertyNames(obj).length === 0)&amp;&amp; (Object.getOwnPropertySymbols(obj).length === 0)// or(Object.prototype.toString.call(obj) === '[object Object]')&amp;&amp; (Object.getOwnPropertyNames(obj).length === 0)&amp;&amp; (Object.getOwnPropertySymbols(obj).length === 0)// or(String(obj) === '[object Object]') &amp;&amp; (Reflect.ownKeys(obj).length === 0)","link":"/2018/03/17/JavaScript/25/"},{"title":"JavaScript 中的 Promise","text":"最后更新于 2020-11-14 最近在回过头来看之前整理过的 Promise 相关内容，发现有许多不完善或是遗漏的地方，所以打算抽些时间重新的梳理一下 Promise 相关内容，从什么是 Promise 开始，到它的各种使用方式，最后我们再来手动模拟实现一个 Promise 了解一下它的运行过程（整理完发现内容较多，所以另起篇幅，见 Promise 的实现），下面就让我们先从为什么要使用 Promise 开始看起 为什么要使用 Promise我们在接触一个新东西的时候，都应该先了解一下我们为什么要使用它，关于 Promise 这个东西，官方的说法是，Promise 是一个对象，它代表了一个异步操作的最终完成或者失败，我们先来看一个示例，示例很简单，就是读取当前目录下的 1.txt 这个文件，然后在控制台输出这个文件内容 12345var fs = require('fs')fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data)}) 看起来很简单，然后我们现在再进一步，读取两个文件，然后在控制台分别输出这两个文件内容 12345678var fs = require('fs')fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data) fs.readFile('2.txt', 'utf8', function (err, data) { console.log(data) })}) 要是读取更多的文件呢？ 1234567891011var fs = require('fs')fs.readFile('1.txt', 'utf8', function (err, data) { fs.readFile('2.txt', 'utf8', function (err, data) { fs.readFile('3.txt', 'utf8', function (err, data) { fs.readFile('4.txt', 'utf8', function (err, data) { // ... }) }) })}) 通过上面这个简单的示例我们可以发现，在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓回调地狱，而 Promise 将回调嵌套改为链式调用，增加了可读性和可维护性，下面我们就来看看如何使用 Promise 来改写上面的示例 Promise那么什么是 Promise 呢？首先它是一个对象，它和 JavaScript 普通的对象没什么区别，同时它也是一种规范，跟异步操作约定了统一的接口，表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的，可以总结为以下这些特点 只有三种状态，未完成，完成（fulfilled）和失败（rejected） 状态可以由未完成转换成完成，或者未完成转换成失败 状态转换只发生一次 状态转换完成后就是外部『不可变』的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 Promise 状态转换的情况） 下面我们就来看看如何使用 Promise 来改写我们之前的读取文件的示例 12345678910111213141516171819var fs = require('fs')function readFile() { return new Promise(function (resolve, reject) { fs.readFile('1.txt', 'utf-8', function (err, data) { if (err) { reject(err) } else { resolve(data) } }) })}readFile().then(function (data) { console.log(data)}).catch(function (err) { console.log(err)}) 我们将其封装成了一个 readFile() 的函数，在内部我们返回了一个新的 Promise，这样在调用了之后就可以使用 then 方法来接收它的成功和失败的回调，是不是看上去清爽很多，这也是 Promise 最为基本的使用方式了，下面我们就来稍微的深入一些，来看看 Promise 提供的各种方法以及如何进行错误处理的 Promise.resolve()一般情况下我们都会使用 new Promise() 来创建 Promise 对象，但是除此之外我们也可以使用其他方法，比如静态方法 Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式，比如 Promise.resolve(42) 可以认为是以下代码的语法糖 123new Promise(function (resolve) { resolve(42)}) 在这段代码中的 resolve(42) 会让这个 Promise 对象立即进入确定（即 resolved）状态，并将 42 传递给后面 then 里所指定的 onFulfilled 函数，方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用 123Promise.resolve(42).then(function (value) { console.log(value)}) 而 Promise.resolve 方法另一个作用就是将 Thenable 对象转换为 Promise 对象，而所谓的 Thenable 对象，简单来说就是一个非常类似 Promise 的东西，就像类数组一样，Thenable 指的是一个具有 .then 方法的对象，最简单的例子就是 $.ajax()，因为它的返回值是 jqXHR Object 对象，这个对象具有 .then 方法，在这种情况下我们就可以使用 Promise.resolve 来将其转换为一个 Promise 对象 123456// 返回 Promise 对象var promise = Promise.resolve($.ajax(url))promise.then(function (value) { console.log(value)}) 但是这里有一个需要注意的地方，jqXHR Object 对象虽然继承了来自 Deferred Object 的方法和属性，但是 Deferred Object 并没有遵循 Promises/A+ 或 ES6 Promises 标准，所以即使看上去这个对象转换成了一个 Promise 对象，但是会出现缺失部分信息的问题，这个问题的根源在于 jQuery 的 Deferred Object 的 then 方法机制与 Promise 不同，所以我们应该注意，即使一个对象具有 .then 方法，也不一定就能作为 ES6 Promises 对象使用 针对于以上内容，我们简单的总结一下就是，可以认为 Promise.resolve 方法的作用就是将传递给它的参数填充（Fulfilled）到 Promise 对象后并返回这个 Promise 对象，此外 Promise 的很多处理内部也是使用了 Promise.resolve 算法将值转换为 Promise 对象后再进行处理的 Promise.reject()Promise.reject(error) 是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式，比如 Promise.reject(new Error('出错了')) 就是下面代码的语法糖形式 123new Promise(function (resolve, reject) { reject(new Error('出错了'))}) 这段代码的功能是调用该 Promise 对象通过 then 指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数 123Promise.reject(new Error('出错了')).catch(function (error) { console.error(error)}) 它和 Promise.resolve(value) 的不同之处在于 Promise 内调用的函数是 reject 而不是 resolve，一般使用较少，不过在编写测试或是问题排查的情况下还是可以用得上的 then()我们在前面的章节里大致已经了解了 Promise 基本的实例方法 then 和 catch 的使用方式，想必我们也都已经知道了 .then().catch() 这种链式方法的写法了，其实在 Promise 里可以将任意个方法连在一起作为一个执行链 1234567aPromise.then(function taskA(value) { // Task A}).then(function taskB(vaue) { // Task B}).catch(function onRejected(error) { console.log(error)}) 如果把在 then 中注册的每个回调函数称为 Task 的话，那么我们就可以通过 Promise 执行链方式来编写能以 Task A ==&gt; Task B 这种流程进行处理的逻辑了，我们先来看看下面这个示例 1234567891011121314151617181920212223function taskA() { console.log(`Task A`)}function taskB() { console.log(`Task B`)}function onRejected(error) { console.log(`Catch Error: A or B`, error)}function finalTask() { console.log(`Final Task`)}var promise = Promise.resolve()promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask) 上述代码的执行流程，如果用一张图来描述一下的话，像下面的图那样 可以发现，虽然我们没有为 then 方法指定第二个参数（onRejected），但是我们会发现 Task A 和 Task B 都有指向 onRejected 的线出来，这些线的意思是在 Task A 或 Task B 的处理中，在下面的情况下就会调用 onRejected 方法 发生异常的时候 返回了一个 Rejected 状态的 Promise 对象 我们在 Promise 中的处理习惯上都会采用 try-catch 的风格，当发生异常的时候，会被 catch 捕获并被由在此函数注册的回调函数进行错误处理，但是大多数情况下我们对于异常处理策略是通过返回一个 Rejected 状态的 Promise 对象来实现的，这种方法不通过使用 throw 就能在 Promise 执行链中对 onRejected 进行调用，但是针对上面的示例还有一点需要注意的，那就是由于在 onRejected 和 Final Task 后面没有 catch 处理了，因此在这两个 Task 中如果出现异常的话将不会被捕获 下面我们再来看一个具体的关于 Task A ==&gt; onRejected 的例子 1234567891011121314151617181920212223242526function taskA() { console.log(`Task A`) throw new Error(`throw Error @ Task A`)}function taskB() { // 不会被调用 console.log(`Task B`)}function onRejected(error) { // =&gt; `throw Error @ Task A` console.log(error)}function finalTask() { console.log(`Final Task`)}var promise = Promise.resolve()promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask) 运行流程如下所示 运行以后可以发现，Task B 是不会被调用的，在本例中我们在 Task A 中使用了 throw 方法故意制造了一个异常，但在实际中想主动进行 onRejected 调用的时候，应该返回一个 Rejected 状态的 Promise 对象，关于这种两种方式的异同，我们会在下面进行介绍 我们仔细观察之前的示例可以发现，其实我们中间的 Task 都是相互独立的，只是被简单调用而已，但是这时候如果 Task A 想给 Task B 传递一个参数我们该怎么办呢？答案非常简单，那就是在 Task A 中 return 一个返回值，这样就会在 Task B 执行的时候传递给它 1234567891011121314151617181920212223function doubleUp(value) { return value * 2}function increment(value) { return value + 1}function output(value) { // =&gt; (1 + 1) * 2 console.log(value)}var promise = Promise.resolve(1)promise .then(increment) .then(doubleUp) .then(output) .catch(function (error) { // 如果执行链中出现异常会被调用 console.error(error) }) 运行流程如下所示 每个方法中 return 的值不仅只局限于字符串或者数值类型，也可以是对象或者 Promise 对象等复杂类型，return 的值会由 Promise.resolve() 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的 Promise 对象，也就是说 then 不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个新的 Promise 对象 从代码来看的话，可能会以为 .then().catch() 的方式像是针对最初的 Promise 对象进行了一连串的执行链调用，然而实际上不管是 then 还是 catch 都会返回了一个新的 Promise 对象，下面我们就来看看如何确认这两个方法返回的到底是不是新的 Promise 对象 1234567891011121314var aPromise = new Promise(function (resolve) { resolve(100)})var thenPromise = aPromise.then(function (value) { console.log(value)})var catchPromise = thenPromise.catch(function (error) { console.error(error)})console.log(aPromise !== thenPromise) // =&gt; trueconsole.log(thenPromise !== catchPromise) // =&gt; true === 是严格相等比较运算符，我们可以看出这三个对象都是互不相同的，这也就证明了 then 和 catch 都返回了和调用者不同的 Promise 对象，也就是如下图所示 如果我们知道了 then 方法每次都会创建并返回一个新的 Promise 对象的话，那么我们就应该不难理解下面代码中对 then 的使用方式上的差别了 123456789101112131415161718192021222324252627282930313233// 第一种情况，对同一个 Promise 对象同时调用 `then` 方法var aPromise = new Promise(function (resolve) { resolve(100)})aPromise.then(function (value) { return value * 2})aPromise.then(function (value) { return value * 2})aPromise.then(function (value) { // =&gt; 100 console.log(value)})// VS// 第二种情况，对 `then` 进行链式调用var bPromise = new Promise(function (resolve) { resolve(100)})bPromise.then(function (value) { return value * 2}).then(function (value) { return value * 2}).then(function (value) { // =&gt; 100 * 2 * 2 console.log(value)}) 通过对比，我们可以发现两种方式的结果是不一样的 第一种方式当中并没有使用 Promise 的执行链形式，这在 Promise 中是应该极力避免的写法，这种写法中的 then 调用几乎是在同时开始执行的，而且传给每个 then 方法的 value 值都是 100 第二种写法则采用了执行链的方式将多个 then 方法调用串连在了一起，各函数也会严格按照 resolve =&gt; then =&gt; then =&gt; then 的顺序执行，并且传给每个 then 方法的 value 的值都是前一个 Promise 对象通过 return 返回的值 但是我们需要注意下面这种使用方式 12345678function badAsyncCall() { var promise = Promise.resolve() promise.then(function () { // 任意处理 return newVar }) return promise} 这种写法有很多问题，首先在 .then() 中产生的异常不会被外部捕获，此外也不能得到 then 的返回值（即使它有返回值），这是因为每次 .then() 的调用都会返回一个新创建的 Promise 对象，因此我们需要像上述方式二那样，采用链式调用的方式，修改后的代码如下所示 1234567function anAsyncCall() { var promise = Promise.resolve() return promise.then(function () { // 任意处理 return newVar })} 有了上面的知识点铺垫以后，我们就可以来解决我们在实际使用场景当中所遇到的问题，比如在接口返回的数据量非常大的时候，并且如果集中在其中某一个接口来处理的话过于庞大，这时我们可以考虑在多个 then 方法中依次访问处理逻辑并执行 1234567891011121314151617181920212223242526272829303132333435// 后端返回的数据let result = { aList: [ //... ], bList: [ //... ], cList: [ //... ], //...}function getInfo() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(result) }, 500) })}getInfo().then(res =&gt; { let { aList } = res // 使用 aList 进行操作 console.log(aList) // 为下一个 then 方法返回 res return res}).then(res =&gt; { let { bList } = res // 同理 console.log(bList) return res}).then(res =&gt; { let { cList } = res // 同理 console.log(cList) return res}) catch()我们在上面的 then() 章节当中已经简单地使用了 catch() 方法，实际上 catch() 只是 promise.then(undefined, onRejected) 方法的一个别名而已，也就是说这个方法用来注册当 Promise 对象状态变为 Rejected 时的回调函数，但是也有一些我们需要注意的地方，如下 12345var promise = Promise.reject(new Error(`message`))promise.catch(function (error) { console.error(error)}) 如上代码在 IE8 及以下版本则会出现 identifier not found 的语法错误，这是因为 IE8 及以下版本都是基于 ECMAScript 3 来实现的，因此不能将 catch 作为属性来使用，也就不能编写类似 promise.catch() 的代码，在这种情况下我们就可以采用 中括号标记法 12345var promise = Promise.reject(new Error(`message`))promise['catch'](function (error) { console.error(error)}) 或者我们不单纯的使用 catch，而是使用 then 也是可以避免这个问题的 12345var promise = Promise.reject(new Error(`message`))promise.then(undefined, function (error) { console.error(error)}) 由于 catch 标识符可能会导致问题出现，因此一些类库也采用了 caught 作为函数名，而函数要完成的工作是一样的，而且很多压缩工具自带了将 promise.catch 转换为 promise['catch'] 的功能，所以可能不经意之间也能帮我们解决这个问题 then() 和 catch()在之前的章节当中，我们提到过 .catch 也可以理解为 promise.then(undefined, onRejected)，所以在本节当中我们就来具体的看一看 .then 和 catch 有什么异同，先来看下面这个示例 12345678910111213141516171819202122function throwError(value) { throw new Error(value)}// 第一种情况，onRejected 不会被调用function badMain(onRejected) { return Promise.resolve(42).then(throwError, onRejected)}// 第二种情况，有异常发生时 onRejected 会被调用function goodMain(onRejected) { return Promise.resolve(42).then(throwError).catch(onRejected)}// 运行示例badMain(function () { console.log(`BAD`)})goodMain(function () { console.log(`GOOD`)}) 在上面的代码中，badMain 是一个不太好的实现方式（但也不是说它有多坏），goodMain 则是一个能非常好的进行错误处理的版本，为什么说 badMain 不好呢？因为虽然我们在 .then 的第二个参数中指定了用来错误处理的函数，但实际上它却不能捕获第一个参数 onFulfilled 指定的函数（本例为 throwError）里面出现的错误，也就是说这时候即使 throwError 抛出了异常，onRejected 指定的函数也不会被调用 与此相对的是，goodMain 的代码则遵循了 throwError ==&gt; onRejected 的调用流程，这时候 throwError 中出现异常的话，在会被执行链中的下一个方法，即 .catch 所捕获，进行相应的错误处理，.then 方法中的 onRejected 参数所指定的回调函数，实际上针对的是其 Promise 对象或者之前的 Promise 对象，而不是针对 .then 方法里面指定的第一个参数，即 onFulfilled 所指向的对象，这也是 then 和 catch 表现不同的原因 这种情况下 then 是针对 Promise.resolve(42) 的处理，在 onFulfilled 中发生异常，在同一个 then 方法中指定的 onRejected 也不能捕获该异常，在这个 then 中发生的异常，只有在该执行链后面出现的 catch 方法才能捕获，当然，由于 .catch 方法是 .then 的别名，我们使用 .then 也能完成同样的工作，只不过使用 .catch 的话意图更明确，更容易理解 1Promise.resolve(42).then(throwError).then(null, onRejected) Promise 的构造函数，以及被 then 调用执行的函数基本上都可以认为是在 try-catch 代码块中执行的，所以在这些代码中即使使用 throw，程序本身也不会因为异常而终止，但是如果在 Promise 中使用 throw 语句的话，会被 try-catch 住，最终 Promise 对象也变为 Rejected 状态 12345678var promise = new Promise(function (resolve, reject) { throw new Error(`message`)})promise.catch(function (error) { // =&gt; `message` console.error(error)}) 以上代码虽然可以正常运行，但是如果想把 Promise 对象状态设置为 Rejected 状态的话，使用 reject 方法则更显得合理，所以上面的代码可以改写为下面这样 12345678var promise = new Promise(function (resolve, reject) { reject(new Error(`message`))})promise.catch(function (error) { // =&gt; `message` console.error(error)}) 其实我们也可以这么来考虑，在出错的时候我们并没有调用 throw 方法，而是使用了 reject，那么给 reject 方法传递一个 Error 类型的对象也就很好理解了，在 Promise 构造函数中，有一个用来指定 reject 方法的参数，建议使用这个参数而不是依靠 throw 将 Promise 对象的状态设置为 Rejected 状态 那么如果像下面那样想在 then 中进行 reject 的话该怎么办呢？ 1234567891011var promise = Promise.resolve()promise.then(function (value) { setTimeout(function () { // 经过一段时间后还没处理完的话就进行 reject - 2 }, 1000) // 比较耗时的处理 - 1 somethingHardWork()}).catch(function (error) { // 超时错误 - 3}) 上面的超时处理，需要在 then 中进行 reject 方法调用，但是传递给当前的回调函数的参数只有前面的 Promise 对象，在这种情况下该怎么办呢？ 在这里我们再次回忆下 then 的工作原理，在 then 中注册的回调函数可以通过 return 返回一个值，这个返回值会传给后面的 then 或 catch 中的回调函数，而且 return 的返回值类型不光是简单的字面值，还可以是复杂的对象类型，比如 Promise 对象等 这时候，如果返回的是 Promise 对象的话，那么根据这个 Promise 对象的状态，在下一个 then 中注册的回调函数中的 onFulfilled 和 onRejected 的哪一个会被调用也是能确定的 12345678var promise = Promise.resolve()promise.then(function () { var retPromise = new Promise(function (resolve, reject) { // resolve or reject 的状态决定 onFulfilled or onRejected 的哪个方法会被调用 }) return retPromise}).then(onFulfilled, onRejected) 比如上面这个示例，后面的 then 调用哪个回调函数是由 Promise 对象的状态来决定的，也就是说这个 retPromise 对象状态为 Rejected 的时候，会调用后面 then 中的 onRejected 方法，这样就实现了即使在 then 中不使用 throw 也能进行 reject 处理了 123456789var onRejected = console.error.bind(console)var promise = Promise.resolve()promise.then(function () { var retPromise = new Promise(function (resolve, reject) { reject(new Error(`this promise is rejected`)) }) return retPromise}).catch(onRejected) 使用 Promise.reject 的话还能再将代码进行简化 123456var onRejected = console.error.bind(console)var promise = Promise.resolve()promise.then(function () { return Promise.reject(new Error(`this promise is rejected`))}).catch(onRejected) Promise.all()Promise.all 实际上是一个 Promise，接收一个 Promise 数组（或一个可迭代的对象）做为参数，然后当其中所有的 Promise 都变为 resolved 状态，或其中一个变为 rejected 状态，便会执行回调函数，来看下面代码 12345Promise.all([promise1, promise2, promise3]) .then(result =&gt; { console.log(result) }) .catch(error =&gt; console.log(`Error in promises ${error}`)) 你可以看到，我们将一个数组传递给了 Promise.all，并且当三个 Promise 都转为 resolved 状态时，Promise.all 完成并在控制台输出，再来看看下面这个示例，经过给定时间会执行 resolve 123456789101112131415const timeOut = (t) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(`Completed in ${t}`) }, t) })}// Resolve 一个正常的 PromisetimeOut(1000) .then(result =&gt; console.log(result)) // Completed in 1000// 使用 Promise.allPromise.all([timeOut(1000), timeOut(2000)]) .then(result =&gt; console.log(result)) // [`Completed in 1000`, `Completed in 2000`] 在上面的示例中，Promise.all 在 2000ms 之后 resolved，并且在控制台上输出结果数组，但是我们可以发现，输出的 Promise 的顺序是固定的，也就是说每个 Promise 的结果（resolve 或 reject 时传递的参数值）和传递给 Promise.all 的 Promise 数组的顺序是一致的 以上就是 Promise.all 的基本用法，下面我们来看一些在实际项目中的应用，比如同步多个异步请求，在实际的项目中，页面通常需要将多个异步请求发送到后台，然后等到后台结果返回后，再开始渲染页面，有时候我们可能会这样进行处理 1234567891011121314151617181920212223242526272829303132333435363738function getAList() { return new Promise((resolve, reject) =&gt; { // 假设我们向服务器发出异步请求 setTimeout(function () { resolve('AList') }, 300) })}function getBList() { return new Promise((resolve, reject) =&gt; { // 假设我们向服务器发出异步请求 setTimeout(function () { resolve('BList') }, 500) })}function getCList() { return new Promise((resolve, reject) =&gt; { // 假设我们向服务器发出异步请求 setTimeout(function () { resolve('CList') }, 700) })}getAList().then(function (data) { // 渲染数据})getBList().then(function (data) { // 渲染数据})getCList().then(function (data) { // 渲染数据}) 上面的代码确实有效，但是有两个缺陷 每次我们从服务端请求数据时，我们都需要编写一个单独的函数来处理数据，这将导致代码冗余，并且不便于将来的升级和扩展 每个请求花费的时间不同，导致函数会异步渲染三次页面，会使用户感觉页面卡顿 现在我们可以使用 Promise.all 来优化我们的代码 123456789101112131415161718192021function getAList() { // ...}function getBList() { // ...}function getCList() { // ...}function initLoad() { Promise.all([getAList(), getBList(), getCList()]).then(res =&gt; { // 渲染数据 }).catch(err =&gt; { // ... })}initLoad() 这样代码看上去就清爽了不少，在所有请求完成后，我们在统一处理数据，但是如果有异常的话，该如何处理呢？在上面的示例中，我们可以按照下面的方式来进行异常处理 12345Promise.all([p1, p2]).then(res =&gt; { // ...}).catch(error =&gt; { // 异常处理}) 众所周知，Promise.all 的机制是，只要做为参数的 Promise 数组中的任何一个 Promise 抛出异常时，无论其他 Promise 成功或失败，整个 Promise.all 函数都会进入 catch 方法，但实际上，我们经常希望即使一个或多个 Promise 抛出异常，我们仍希望 Promise.all 继续正常执行，例如在上面的例子中，即使在 getAList() 中发生异常，只要在 getBList() 或 getCList() 中没有发生异常，我们仍然希望该程序继续执行，为了满足这个需求，我们可以使用一个技巧来增强 Promise.all 的功能 123Promise.all([p1.catch(error =&gt; error), p2.catch(error =&gt; error)]).then(res =&gt; { // ...}) 这样一来，即使一个 Promise 发生异常，也不会中断 Promise.all 中其它 Promise 的执行，应用到前面的示例，结果是这样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function getAList() { return new Promise((resolve, reject) =&gt; { setTimeout(function () { // 假设这里 reject 一个异常 reject(new Error('error')) }, 300) })}function getBList() { // ...}function getCList() { // ...}function initLoad() { Promise.all([ getAList().catch(err =&gt; err), getBList().catch(err =&gt; err), getCList().catch(err =&gt; err) ]).then(res =&gt; { if (res[0] instanceof Error) { // 处理异常 } else { // 渲染数据 } if (res[1] instanceof Error) { // 处理异常 } else { // 渲染数据 } if (res[2] instanceof Error) { // 处理异常 } else { // 渲染数据 } })}initLoad() Promise.race()Promise.race 的参数与 Promise.all 相同，可以是一个 Promise 数组或一个可迭代的对象，Promise.race() 方法返回一个 Promise 对象，一旦迭代器中的某个 Promise 为 fulfilled 或 rejected 状态，就会返回结果或者错误信息，我们来看下面这个定时功能的示例 当我们从后端服务器异步请求资源时，通常会限制时间，如果在指定时间内未接收到任何数据，则将引发异常，所幸 Promise.race 可以帮我们解决这个问题 12345678910111213141516171819202122232425262728293031function requestImg() { var p = new Promise(function (resolve, reject) { var img = new Image() img.onload = function () { resolve(img) } img.src = '...' }) return p}// 定时功能的延迟函数function timeout() { var p = new Promise(function (resolve, reject) { setTimeout(function () { reject(`Picture request timeout`) }, 5000) }) return p}Promise .race([requestImg(), timeout()]) .then(function (results) { // 该资源请求在指定时间内完成 console.log(results) }) .catch(function (reason) { // 该资源请求被在指定时间内没有完成 console.log(reason) }) Promises.finally()在上面我们介绍了 Promise.all() 和 Promise.race()，下面我们再来考虑另外一种情况，那就是如何让一个函数无论 Promise 对象成功和失败都能被调用呢？ 在这种情况下，就要用到 Promises.finally() 这个方法了，Promises.finally() 方法返回一个 Promise，在 Promise 执行结束时，无论结果是 fulfilled 或者是 rejected，在执行 then() 和 catch() 后，都会执行 finally 指定的回调函数，这为指定执行完 Promise 后，无论结果是 fulfilled 还是 rejected 都需要执行的代码提供了一种方式，避免同样的语句需要在 then() 和 catch() 中各写一次的情况 12345678910111213Promise.resolve('success').then(result =&gt; { console.log('then: ', result) return Promise.resolve(result)}).catch(err =&gt; { console.error('catch: ', err) return Promise.reject(err)}).finally(result =&gt; { console.info('finally: ', result)})// then: success// finally: undefined// Promise {&lt;resolved&gt;: 'success'} 经典示例在上面我们介绍了 Promise 的基本概念和一些 API 的用法，下面我们就来通过一些实际案例加深一下对于 Promise 的理解 红绿灯问题一个经典的题目，黄灯一秒亮一次，绿灯两秒亮一次，红灯三秒亮一次，如何让三个灯不断交替重复亮灯？三个亮灯函数已经存在 1234567891011function red() { console.log('red')}function green() { console.log('green')}function yellow() { console.log('yellow')} 这种情况，我们可以考虑使用 Promise 来实现 1234567891011121314151617181920var light = function (time, cb) { cb() return new Promise(resolve =&gt; { setTimeout(resolve, time) })}function step() { Promise.resolve().then(_ =&gt; { return light(3000, red) }).then(_ =&gt; { return light(2000, green) }).then(_ =&gt; { return light(1000, yellow) }).then(_ =&gt; { step() })}step() Promise 和 setTimeout最后我们再来看看平常可能会经常遇到的一类问题，那就是 Promise 和 setTimeout 的执行先后顺序的问题，先来看下面这个示例 123456789setTimeout(function () { console.log(1)}, 0)new Promise(function (resolve) { resolve()}).then(function () { console.log(2)}) 执行结果依次为 2 和 1，至于为什么会这样，简单来说就是 Promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行，所以 Promise 的执行顺序是高于 setTimeout 的，至于原因，则是因为在 ES6 当中，有一个新的概念建立在『事件循环队列』之上，叫做『任务队列』 简单的理解就是，它是挂在事件循环队列的每个 Tick 之后的一个队列，在事件循环的每个 Tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 Tick 的任务队列末尾添加一个项目（任务） 一个任务可能引起更多任务被添加到同一个队列末尾，所以理论上说，任务循环可能无限循环（一个任务总是添加另一个任务，以此类推）进而导致程序的无限循环，无法转移到下一个事件循环 Tick，从概念上看，这和代码中的无限循环（类似 while(true)）的体验几乎是一样的 有了以上的了解以后，我们再来看看下面这个稍微复杂点的的综合案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 一for (var i = 0 i &lt; 5 i++) { console.log(i)}// 二for (var i = 0 i &lt; 5 i++) { setTimeout(function () { console.log(i) }, 1000 * i)}// 三for (var i = 0 i &lt; 5 i++) { (function (i) { setTimeout(function () { console.log(i) }, 1000 * i) })(i)}// 四for (let i = 0 i &lt; 5 i++) { setTimeout(function () { console.log(i) }, 1000 * i)}// 五for (var i = 0 i &lt; 5 i++) { (function () { setTimeout(function () { console.log(i) }, 1000 * i) })(i)}// 六for (var i = 0 i &lt; 5 i++) { setTimeout((function (i) { console.log(i) })(i), i * 1000)}// 七setTimeout(function () { console.log(1)}, 0)new Promise(function executor(resolve) { console.log(2) for (var i = 0 i &lt; 10000 i++) { i == 9999 &amp;&amp; resolve() } console.log(3)}).then(function () { console.log(4)})console.log(5)// 八setTimeout(function () { console.log(1)}, 0)new Promise(function executor(resolve) { console.log(2) for (var i = 0 i &lt; 10000 i++) { i == 9999 &amp;&amp; resolve() } setTimeout(function() { console.log(6) }, 0) console.log(3)}).then(function () { console.log(4)})console.log(5) 最基本的，输出 0 ~ 4 setTimeout 会延迟执行，那么执行到 console.log 的时候，其实 i 已经变成 5 了，所以结果为 5 个 5（每一秒输出一个 5） 三当中使用了闭包，而四当中将 var 变成了 let，结果同样是 0 到 4 去掉 function() 中的 i，内部就没有对 i 保持引用，结果还是 5 个 5 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 0 ~ 4 而不会延迟 最后两个有些复杂，但是原理是类似的，我们来简单剖析一下 都被改写成了 Promise，但是首先需要明确的是，Promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行，首先是一个 setTimeout，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 1，然后是一个 Promise，里面的函数是会立即执行的，所以首先输出 2 和 3 这里需要注意的是，Promise 的 then 应当会放到当前 Tick 的最后，但是还是在当前 Tick 中（而不是下一次事件循环），所以会先输出 5 然后才会输出 4，最后轮到下一个 Tick 才会输出 1，所以结果为 2 3 5 4 1，至于最后一个，和第七个的原理是一样的，结果为 2 3 5 4 1 6 关于 Promise 和 setTimeout 两者间具体的差异可以参考之前整理过的 JavaScript 并发模型 来了解更多 参考 JavaScript Promise 迷你书 Promise 使用 Promise","link":"/2018/03/19/JavaScript/26/"},{"title":"JavaScript 中的事件轮询机制","text":"最后更新于 2019-12-28 最近打算重新复习一下 JavaScript 中的事件轮询机制，而且刚好在之前也介绍过 Node.js 中的事件轮询机制，它与 JavaScript 中的事件轮询机制是有所区别的，所以在这里打算重新的梳理一下，也算是将之前博客当中关于事件轮询的相关内容做一个汇总，方便以后更为方便的复习和查看，下面我们就先从一些前置知识点开始看起 JavaScript 中的栈和堆我们都知道，JavaScript 的一大特点就是单线程，这意味着在任何时候只能有一段代码执行，JavaScript 主线程在运行时，会建立一个执行同步代码的『栈』和执行异步代码的『队列』，在深入展开之前，我们先来简单的了解一下 JavaScript 中堆和栈的相关概念，关于 栈 和 堆 我们需要区分数据结构和内存中各自『堆栈』的含义，数据结构中的堆和栈是两种不同的数据项按序排列的数据结构，但是在这里我们主要介绍的是内存中的堆区与栈区 内存中的堆区与栈区在 C 语言中，各个区别如下 栈区是分配局部变量的空间 堆区是地址向上增长的用于分配我们申请的内存空间 另外还有静态区是分配静态变量、全局变量空间的 只读区是分配常量和程序代码空间的 一个简单的例子 123456789101112int a = 0; // 全局初始化区char *p1; // 全局未初始化区main() { int b; // 栈 char s[] = \"abc\"; // 栈 char *p2; // 栈 char *p3 = \"123\"; // 在常量区，p3 在栈上 static int c = 0; // 全局（静态）初始化区 p1 = (char *)malloc(10); // 堆 p2 = (char *)malloc(20); // 堆} 而 JavaScript 是高级语言，底层依靠 C/C++ 来编译实现，其变量划分为基本数据类型和引用数据类型 基本数据类型（undefined/null/boolean/string/number/BigInt/Symbol）在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较 引用数据类型（Object/Array/Function/Error/Date）大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的（和 C 语言的指针类似） 对于引用类型的变量，栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存在栈内存中，但是内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中 这样一来，当查询引用类型的变量的时候，就会先从栈中读取堆内存地址，然后在根据地址取出对应的值，显而易见的是，JavaScript 中所有引用类型创建实例的时候，都是显式或者隐式的 new 出对应类型的实例，实际上就是对应 C 语言的 malloc() 分配内存函数 栈和队列的区别 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的 队列先进先出，栈先进后出 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除，有一个比较好的记忆方式 队列相当我们去银行柜台排队，大家依次鱼贯而行，先进去排队的最先出来 栈比较像我们在家中洗碗，最后洗好的碗叠在最上面的，而下次拿的时候是最先拿到最后叠上去的碗 栈和堆的区别 栈区（Stack），由编译器自动分配释放，存放函数的参数值，局部变量的值等 堆区（Heap），一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 堆（数据结构），堆可以被看成是一棵树，如堆排序 栈（数据结构），一种先进后出的数据结构 进程和线程我们都知道 JavaScript 属于单线程，程序按顺序执行，本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中最终交由浏览器来执行，那么浏览器又是如何来执行的呢？在此之前，我们需要先来了解一下什么是进程和线程 进程学术上说，进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体，我们这里将进程比喻为工厂的车间，它代表 CPU 所能处理的单个任务，任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态 线程在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位，任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离 后来随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了，于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，这里把线程比喻一个车间的工人，即一个车间可以允许由多个工人协同完成一个任务 进程和线程的区别 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号） 调度和切换，线程上下文切换比进程上下文切换要快得多 多进程与多线程多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰 而多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务 这里我们只是简单的了解一下栈，堆，进程和线程的基本知识，更多相关内容可以参考我们之前整理过的 浏览器的渲染机制 这篇文章来了解更多，所以这里我们也就不过多提及了，下面我们就来正式的看看 EventLoop 的相关内容 EventLoop我们从一张图开始看起，如下 JavaScript 执行引擎的主线程运行的时候，产生堆（Heap）和栈（Stack），程序中代码依次进入栈中等待执行，若执行时遇到异步方法，该异步方法会被添加到用于回调的队列（Queue）中，即 JavaScript 执行引擎的主线程拥有一个执行栈（或者堆）和一个任务队列，其中 栈（Stack），函数调用会形成了一个堆栈帧 堆（Heap），对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域 队列（Queue），一个 JavaScript 运行时包含了一个待处理的消息队列 每一个消息都与一个函数相关联 当栈为空时，则从队列中取出一个消息进行处理 这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧） 当栈再次为空的时候，也就意味着该消息处理结束 所以我们梳理出整个执行流程大致模样，如下 所有同步任务都在主线程上执行，形成一个执行栈（并发模型的 Stack），同步的执行流程可以参考我们之前整理过的 JavaScript 的同步执行过程 主线程之外，还存在一个任务队列（并发模型的 Queue），只要异步任务有了运行结果，就在任务队列中放置一个事件 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件和那些对应的异步任务，于是等待结束状态，进入执行栈开始执行 主线程不断重复上面的第三步，也就是只要主线程空了，就会去读取任务队列 因为主线程从任务队列中读取事件的过程是循环不断的，因此这种运行机制又称为 EventLoop（事件循环），简单总结就是，主线程运行的时候，产生堆（Heap）和栈（Stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件（click，load，done），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些事件所对应的回调函数 任务队列我们在之前提到过，事件循环是通过 任务队列 的机制来进行协调的，在一个 EventLoop 中可以有一个或者多个任务队列（Task Queue），一个任务队列便是一系列有序任务（Task）的集合，每个任务都有一个任务源（Task Source），源自同一个任务源的 Task 必须放到同一个任务队列，从不同源来的则被添加到不同队列 在事件循环中，每进行一次循环操作称为 Tick，每一次 Tick 的 任务处理模型 是比较复杂的，但关键步骤如下 在此次 Tick 中选择最先进入队列的任务（Oldest Task），如果有则执行（一次） 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue 更新 render 主线程重复执行上述步骤 我们仔细查阅规范可知，异步任务可分为 Task 和 Microtask 两类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 EventLoop 将它们依次压入执行栈中执行（也就是如上面章节中的图片所示那样） 在网上比较常见的说法是分为是分为宏任务（Macrotask）和微任务（Microtask）两个概念，但规范中并没有提到 Macrotask，因而一个比较合理的解释是 Task 即为其它文章中的 Macrotask，另外在 ES2015 规范中将 Microtask 又称为 Job 但是在这里我们为了统一，干脆就称为宏任务（Macrotask）和微任务（Microtask），知道它们各自具体代表的是什么即可，下面我们来看看它们两者之间的区别 宏任务（Macrotask）主要包含 setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate（Node.js） 微任务（Microtask）主要包含 Promise.then、MutaionObserver、process.nextTick（Node.js）、Object.observe（已废弃） 这里有几个需要注意的地方 在有些地方会列出来 UI Rendering，说这个也是宏任务，可是在 规范文档 当中可以发现这很显然是和微任务平行的一个操作步骤 在 Node.js 中，会优先清空 next tick queue，即通过 process.nextTick 注册的函数，再清空 other queue，常见的如 Promise，此外，timers（setTimeout/setInterval） 会优先于 setImmediate 执行，因为前者在 timer 阶段执行，后者在 check 阶段执行（下面我们会进行介绍） 还有一个比较特殊的 requestAnimationFrame，有的将其归纳到宏任务当中，但是这里是存在一定争议的，关于这个我们会在后面来详细进行介绍 下面我们就来稍微深入的了解一下宏任务和微任务 宏任务我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），每一个宏任务会从头到尾执行完毕，不会执行其他 我们在之前提到过，JavaScript 引擎线程和 GUI 渲染线程是互斥的关系，浏览器为了能够使宏任务和 DOM 任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI 渲染线程开始工作，对页面进行渲染，有些类似于宏任务与渲染交替执行的一个过程 我们可以通过一个示例来进行了解，如下 1234document.body.style = 'background:black'document.body.style = 'background:red'document.body.style = 'background:blue'document.body.style = 'background:grey' 我们可以将上面这段代码放到浏览器的控制台下进行执行，运行以后我们会看到的结果是，页面背景会在瞬间变成灰色，因为以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时 GUI 线程会将所有 UI 改动优化合并，所以视觉效果上，只会看到页面变成灰色，我们将上面的示例稍微调整一下 12345document.body.style = 'background:blue'setTimeout(function () { document.body.style = 'background:black'}, 0) 再次执行一下，这次可以发现，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色 微任务我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务，而微任务可以理解成在当前宏任务执行后立即执行的任务，也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完，老规矩，来看示例 123456789document.body.style = 'background:blue'console.log(1)Promise.resolve().then(() =&gt; { console.log(2) document.body.style = 'background:black'})console.log(3) 控制台会输出 1 3 2，这是因为 Promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出，而页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染，我们将上面的示例稍微调整一下 12345678setTimeout(() =&gt; { console.log(1) Promise.resolve(3).then(data =&gt; console.log(data))}, 0)setTimeout(() =&gt; { console.log(2)}, 0) 上面代码共包含两个 setTimeout，也就是说除主代码块外，共有两个宏任务，其中第一个宏任务执行中，输出 1，并且创建了微任务队列，所以在下一个宏任务队列执行前，先执行微任务，在微任务执行中，输出 3，微任务执行后，执行下一次宏任务，执行中输出 2 执行流程在具体了解了什么是宏任务和微任务以后，我们就可以来使用它们简单的总结一下我们上面介绍到的 EventLoop 的执行流程，我们都知道，所有 JavaScript 代码一开始都只可能是同步代码，所以肯定是从同步开始进行的 执行『同步』代码 如果遇到到『异步任务』，『入队』到相应的队列中，不直接执行 『继续执行』后续同步代码直到『全部执行完毕』 检查『微任务』队列 如果队列不为空，『出队』一个微任务准备执行，进入『同步任务』流程 如果队列为空，进入『宏任务』流程 检查『宏任务』队列 如果队列不为空，『出队』一个宏任务准备执行，进入『同步任务』流程 如果队列为空，结束并『等待』新的任务 简答来说就是，代码中的 setInterval(fn, time) 等语句，实际上就是对异步任务的声明，然后在适当的时机，运行环境会自行将事件加入任务队列中 实例我们下面就通过几个例子来深入的理解一下，先来看一个 setTimeout() 相关示例，如下 1234567console.log(1)setTimeout(function () { console.log(2)}, 5000)console.log(3) 这里需要注意的是，定时器只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数，我们结合之前提到过的 EventLoop 来看看单线程的 JavaScript 执行引擎是如何来执行该方法的 JavaScript 执行引擎主线程运行，产生 Heap 和 Stack 从上往下执行同步代码，console.log(1) 被压入执行栈，因为 console.log() 方法是 webkit 内核支持的普通方法而非 WebAPIs 的方法，因此立即出栈被引擎执行，输出 1 JavaScript 执行引擎继续往下，遇到 setTimeout() 异步方法（如上图，setTimeout() 属于 WebAPIs），将 setTimeout(callback, 5000) 添加到执行栈 因为 setTimeout() 属于 WebAPIs 中的方法，JavaScript 执行引擎在将 setTimeout() 出栈执行时，注册 setTimeout() 延时方法交由浏览器内核其他模块（以 webkit 为例，是 webcore 模块）处理 继续运行 setTimeout() 下面的 console.log(3) 代码，原理同步骤 2 当延时方法到达触发条件，即到达设置的延时时间时（5 秒后），该延时方法就会被添加至任务队列里，这一过程由浏览器内核其他模块处理，与执行引擎主线程独立 JavaScript 执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行 将队列的第一个回调函数重新压入执行栈，执行回调函数中的代码 console.log(2)，原理同步骤 2，回调函数的代码执行完毕，清空执行栈 JavaScript 执行引擎继续轮循队列，直到队列为空 执行完毕 看完了 setTimeout()，下面再来看一个 Promise 的示例 123456789101112new Promise(resolve =&gt; { resolve(1) Promise.resolve().then(() =&gt; { // t2 console.log(2) }) console.log(4)}).then(t =&gt; { // t1 console.log(t)})console.log(3) 同样的，我们也简单的梳理一下这段代码的流程 程序运行，首先遇到 Promise 实例，构造函数首先执行，所以首先输出了 4，此时 Microtask 的任务有 t2 和 t1 代码继续运行，输出 3，至此，第一个宏任务执行完成， 执行所有的微任务，先后取出 t2 和 t1，分别输出 2 和 1 代码执行完毕 所以综上所述，最后的输出结果是 4321，但是这里可能会有一些疑惑，那就是为什么 t2 会先执行呢？我们根据 Promises/A+ 规范可知 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行 所以我们可以推断出，Promise.resolve 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象，也就是立即 resolved 的 Promise 对象，是在本轮事件循环（EventLoop）的结束时，而不是在下一轮事件循环的开始时（详细可以参考 Promise-resolve），所以 t2 比 t1 会先进入 Microtask 的 Promise 队列 最后，我们再来看一个综合两者的示例，如下 123456789101112131415console.log('script start')setTimeout(function () { console.log('timeout1')}, 10)new Promise(resolve =&gt; { console.log('promise1') resolve() setTimeout(() =&gt; console.log('timeout2'), 10)}).then(function () { console.log('then1')})console.log('script end') 首先，事件循环从宏任务（Macrotask）队列开始，当遇到任务源（task source）时，则会先分发任务到对应的任务队列中去，然后遇到了 console 语句，直接输出 script start，输出之后，任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中 任务继续往下执行，遇到 Promise 实例，Promise 构造函数中的第一个参数，是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行，而后续的 .then 则会被分发到 Microtask 的 Promise 队列中去，所以会先输出 promise1，然后执行 resolve，将 then1 分配到对应队列 构造函数继续往下执行，又碰到 setTimeout，然后将对应的任务分配到对应队列 任务继续往下执行，最后只有一句输出，所以输出 script end，至此，全局任务就执行完毕了 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks，如果有，则执行 Microtasks 直至清空 Microtask Queue，因而在任务执行完毕之后，开始查找清空微任务队列，此时，微任务中只有 Promise 队列中的一个任务 then1，因此直接执行就行了，执行结果输出 then1，当所有的 microtast 执行完毕之后，表示第一轮的循环就结束了 这个时候就得开始第二轮的循环，第二轮循环仍然从宏任务 Macrotask 开始，此时有两个宏任务 timeout1 和 timeout2，取出 timeout1 执行，输出 timeout1，此时微任务队列中已经没有可执行的任务了，直接开始第三轮循环 第三轮循环依旧从宏任务队列开始，此时宏任务中只有一个 timeout2，取出直接输出即可 这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了，那么例子的输出结果就显而易见 123456script startpromise1script endthen1timeout1timeout2 关于 requestAnimationFrame我们先来看看 requestAnimationFrame 的基本用法，然后再来看看它与事件轮询的关系 基本用法requestAnimationFrame 是浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘，设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果，代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘，它主要有两个特点 按帧对网页进行重绘，该方法告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画 由系统来决定回调函数的执行时机，在运行时浏览器会自动优化方法的调用 关于第二点，显示器有固定的刷新频率（60Hz 或 75Hz），也就是说每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想让页面重绘的频率与这个刷新频率保持同步，比如显示器屏幕刷新率为 60Hz，使用 requestAnimationFrame API，那么回调函数就每 1000ms / 60 ≈ 16.7ms 执行一次，如果显示器屏幕的刷新率为 75Hz，那么回调函数就每 1000ms / 75 ≈ 13.3ms 执行一次 另外，一旦页面不处于浏览器的当前标签，就会自动停止刷新 当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 visibilitychange 事件，并设置 document.hidden 属性为 true 当页面切换到显示状态，页面变为可见，同时触发一个 visibilitychange 事件，设置 document.hidden 属性为 false 不过有一点需要注意是 requestAnimationFrame 是在主线程上完成，这意味着如果主线程非常繁忙，requestAnimationFrame 的动画效果会大打折扣，requestAnimationFrame 使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用 1id = window.requestAnimationFrame(callback) 它会返回一个 id 结果，主要是用于传递给 window.cancelAnimationFrame(id) 来取消重绘，在浏览器当中的执行过程大致如下 首先判断 document.hidden 属性是否为 true（页面是否可见），页面处于可见状态才会执行后面步骤 浏览器清空上一轮的动画函数 requestAnimationFrame 将回调函数追加到动画帧请求回调函数列表的末尾，当执行 requestAnimationFrame(callback) 的时候，不会立即调用 callback 函数，只是将其放入队列，每个回调函数都有一个布尔标识 cancelled，该标识初始值为 false，并且对外不可见 当浏览器再执行列表中的回调函数的时候，判断每个元组的 callback 的 cancelled，如果为 false 则执行 callback，当页面可见并且动画帧请求回调函数列表不为空，浏览器会定期将这些回调函数加入到浏览器 UI 线程的队列中 当调用 cancelAnimationFrame(handle) 时，浏览器会设置该 handle 指向的回调函数的 cancelled 为 true（无论该回调函数是否在动画帧请求回调函数列表中），如果该 handle 没有指向任何回调函数，则什么也不会发生 更为底层的原理可以参考 深入理解 requestAnimationFrame，这里就不详细展开了，但是在这里我们多提及两点，第一个就是递归调用，要想实现一个完整的动画，应该在回调函数中递归调用回调函数 12345678910let count = 0let rafId = nullfunction requestAnimation(time) { // requestAnimationFrame 调用该函数时，自动传入的一个时间 console.log(time) if (count &lt; 50) { // 动画没有执行完，则递归渲染 count++ rafId = requestAnimationFrame(requestAnimation) // 渲染下一帧 }}requestAnimationFrame(requestAnimation) // 渲染第一帧 另外如果如果在执行回调函数或者 Document 的动画帧请求回调函数列表被清空之前多次调用 requestAnimationFrame 调用同一个回调函数，那么列表中会有多个元组指向该回调函数（它们的 handle 不同，但 callback 都为该回调函数），采集所有动画任务操作会执行多次该回调函数（类比定时器 setTimeout） 123456789101112function counter() { let count = 0 function animate(time) { if (count &lt; 50) { count++ console.log(count) requestAnimationFrame(animate) } } requestAnimationFrame(animate)}btn.addEventListener('click', counter, false) 例如上面这个示例，多次点击按钮，会发现打印出来多个序列数值 结论在了解完它的基本用法以后，我们不难发现，requestAnimationFrame 其实不属于 Task，它只是浏览器渲染过程的一步，和 Task/Microtask 的执行是分离的，我们在这里简单的总结一下就是 setTimeout 的执行时间并不是确定的，在 JavaScript 中，setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些 与 setTimeout 相比，requestAnimationFrame 最大的优势是『由系统来决定回调函数的执行时机』，系统每次绘制之前会主动调用 requestAnimationFrame 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每 16.7ms 被执行一次，如果绘制频率是 75Hz，那么这个间隔时间就变成了 1000 / 75 = 13.3ms，换句话说就是 requestAnimationFrame 的执行步伐跟着系统的绘制频率走，它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题 至于具体是什么样的流程，我们可以参考规范当中的 事件循环处理模型，简化后的流程是下面这样 执行最早的（宏）任务 微任务 如果这是渲染的好时机 准备工作 运行 requestAnimationFrame 回调 渲染 但是这里也会存在一个问题，就是如果你在不同的浏览器上进行测试，结果可能会有所不同，但是现在 Chrome/Firefox/iOS Safari/Legacy Edge 等都在向着规范靠拢，所以我们还是以规范为准吧 Node.js 中的表现Node.js 也是单线程，但是在处理 EventLoop 上与浏览器稍微有些不同，就单从 API 层面上来理解，Node.js 新增了两个方法可以用来使用，微任务的 process.nextTick 以及宏任务的 setImmediate Node.js 的运行机制也是基于事件轮询（EventLoop）的，详细见 Node.js 中的事件轮询机制 setImmediate 与 setTimeout 的区别在官方文档中的定义，setImmediate 为一次 EventLoop 执行完毕后调用，setTimeout 则是通过计算一个延迟时间后进行执行，但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发 因为如果主进程中先注册了两个任务，然后执行的代码耗时超过设定的期限，而这时定时器已经处于可执行回调的状态了，所以会先执行定时器，而执行完定时器以后才是结束了一次 EventLoop，这时才会执行 setImmediate 12setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate')) 比如上面的代码，可以试验一下，执行多次的话会得到不同的结果，但是如果后续添加一些代码以后，就可以保证 setTimeout 一定会在 setImmediate 之前触发了 12345678setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate'))let countdown = 1e9// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout 已经可以执行回调了// 所以会先执行 setTimeout 然后再结束这一轮循环，也就是说开始执行 setImmediate while (countdown--) { } 如果在另一个宏任务中，必然是 setImmediate 先执行 12345// 如果使用一个设置了延迟的 setTimeout 也可以实现相同的效果require('fs').readFile(__dirname, _ =&gt; { setTimeout(_ =&gt; console.log('timeout')) setImmediate(_ =&gt; console.log('immediate'))}) process.nextTick就像上边说的，这个可以认为是一个类似于 Promise 和 MutationObserver 的微任务实现，在代码执行的过程中可以随时插入 nextTick，并且会保证在下一个宏任务开始之前所执行，在使用方面的一个最常见的例子就是一些事件绑定类的操作 1234567891011121314class Lib extends require('events').EventEmitter { constructor() { super() this.emit('init') }}const lib = new Lib()lib.on('init', _ =&gt; { // 这里将永远不会执行 console.log('init!')}) 因为上述的代码在实例化 Lib 对象时是同步执行的，在实例化完成以后就立马发送了 init 事件，而这时在外层的主程序还没有开始执行到 lib.on('init') 监听事件的这一步，所以会导致发送事件时没有回调，回调注册后事件不会再次发送，我们可以很轻松的使用 process.nextTick 来解决这个问题 12345678910111213class Lib extends require('events').EventEmitter { constructor() { super() process.nextTick(_ =&gt; { this.emit('init') }) // 同理使用其他的微任务 // 比如 Promise.resolve().then(_ =&gt; this.emit('init')) // 也可以实现相同的效果 }} 这样会在主进程的代码执行完毕后，程序空闲时触发 EventLoop 流程查找有没有微任务，然后再发送 init 事件 但是这里也需要注意，循环调用 process.nextTick 会导致报警，后续的代码永远不会被执行 Async/Await因为 Async/Await 本质上还是基于 Promise 的一些封装，而 Promise 是属于微任务的一种，所以在使用 await 关键字与 Promise.then 效果类似 1234567891011setTimeout(_ =&gt; console.log(4))async function main() { console.log(1) await Promise.resolve() console.log(3)}main()console.log(2) async 函数在 await 之前的代码都是同步执行的，可以理解为 await 之前的代码属于 new Promise 时传入的代码，await 之后的所有代码都是在 Promise.then 中的回调 Web Workers最后我们来简单的了解一下 Web Workers 的相关内容，不过需要注意的是，Worker 是浏览器（即宿主环境）的功能，实际上和 JavaScript 语言本身几乎没有什么关系，也就是说 JavaScript 当前并没有任何支持多线程执行的功能 浏览器可以提供多个 JavaScript 引擎实例，各自运行在自己的线程上，这样你可以在每个线程上运行不同的程序，程序中每一个这样的的独立的多线程部分被称为一个 Worker，这种类型的并行化被称为『任务并行』，因为其重点在于把程序划分为多个块来并发运行，下面是 Worker 的运作流图 下面是一个计算阶乘的示例 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;fieldset&gt; &lt;legend&gt;计算阶乘&lt;/legend&gt; &lt;input id=\"input\" type=\"number\" placeholder=\"请输入一个正整数\" /&gt; &lt;button id=\"btn\"&gt;计算&lt;/button&gt; &lt;p&gt;计算结果：&lt;span id=\"result\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;legend&gt;&lt;/legend&gt; &lt;script&gt; const input = document.getElementById('input'); const btn = document.getElementById('btn'); const result = document.getElementById('result'); btn.addEventListener('click', () =&gt; { const worker = new Worker('./worker.js'); // 向 Worker 发送消息 worker.postMessage(input.value); // 接收来自 Worker 的消息 worker.addEventListener('message', e =&gt; { result.innerHTML = e.data; // 使用完 Worker 后记得关闭 worker.terminate(); }); }); &lt;/script&gt;&lt;/body&gt; 然后我们在同目录下新建一个 worker.js，内容如下 12345678910111213141516171819202122232425function memorize(f) { const cache = {} return function () { const key = Array.prototype.join.call(arguments, ',') if (key in cache) { return cache[key] } else { return (cache[key] = f.apply(this, arguments)) } }}const factorial = memorize(n =&gt; { return n &lt;= 1 ? 1 : n * factorial(n - 1)})// 监听主线程发过来的消息self.addEventListener( 'message', function (e) { // 响应主线程 self.postMessage(factorial(e.data)) }, false,) 参考 并发模型与事件循环 JavaScript 的并发模型 事件循环处理模型 从一道题浅说 JavaScript 的事件循环 Tasks, microtasks, queues and schedules window.requestAnimationFrame MutationObserver What is the EventLoop","link":"/2018/08/12/JavaScript/30/"},{"title":"深入 TypeScript 当中的泛型","text":"我们在之前的 重温 TypeScript 与 深入 TypeScript 的章节当中介绍了一些 TypeScript 的基本使用方式和一些进阶内容，本来是打算将泛型相关内容一同整理到其中的，但是梳理下来发现泛型涉及到的内容还是比较多的，所以就另起篇幅来单独介绍介绍泛型的相关内容，主要参考的是 Typescript Generics，在原文基础之上有所调整，主要是方便自己理解，想要了解更为详细的内容可以参考原文 下面就让我们从头开始看起，其中主要包括以下相关内容 泛型是什么 泛型接口 泛型类 泛型约束 泛型参数默认类型 泛型条件类型 泛型工具类型 使用泛型创建对象 泛型是什么其实简单来说，设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是类的实例成员、类的方法、函数参数和函数返回值等 也就是说，泛型允许我们同一个函数接受不同类型参数，相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型，下面我们来一步一步揭示泛型的作用，就从一个通用的 identity 函数开始看起，该函数接收一个参数并直接返回它 12345function identity(value) { return value}identity(1) 现在，我们将 identity 函数做适当的调整，以支持 TypeScript 的 Number 类型的参数 1234567function identity(value: Number): Number { return value}identity(1) // ✅identity('1') // ❌ 这里 identity 的问题是我们将 Number 类型分配给参数和返回类型，使该函数仅可用于该原始类型，此时如果我们传入一个字符串类型的参数，编辑器会提示我们有错误存在，也就是说该函数并不是可扩展或通用的，很明显这并不是我们所希望的 我们确实可以把 Number 换成联合类型又或是 any，但是我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用，我们的目标是让 identity 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下 1234567function identity&lt;T&gt;(value: T): T { return value}identity&lt;Number&gt;(1) // ✅identity&lt;string&gt;('1') // ✅ 看上去是不是很轻松，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型，如下图所示 参考上面的图片可以发现，当我们调用 identity&lt;Number&gt;(1) 的时候，Number 类型就像参数 1 一样，它将在出现 T 的任何位置填充该类型，图中 &lt;T&gt; 内部的 T 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 value 参数用来代替它的类型（此时 T 充当的是类型，而不是特定的 Number 类型） 其中函数当中的 T 代表着 Type，在定义泛型时通常用作第一个类型变量名称，但实际上 T 可以用任何有效名称代替，除了 T 之外，以下是常见泛型变量代表的意思 K（Key），表示对象中的键类型 V（Value），表示对象中的值类型 E（Element），表示元素类型 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量，比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数 123456function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message) return value}identity&lt;Number, string&gt;(18, 'zhangsan') 这里我们在使用的时候明确的指定了 T 和 U 是 Number 和 string 类型，并做为一个参数传给函数，使用了 &lt;&gt; 括起来而不是 ()，但是另外一种更为普遍的做法是使用『类型推论』，我们可以完全省略尖括号，也就是说让编译器来根据我们传入的参数自动地来确定 T 或者 U 的类型，从而使代码更简洁 123456function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message) return value}identity(18, 'zhangsan') 这一点我们可以也通过编辑器的代码提示功能来进行发现 12345678// function identity&lt;18, number&gt;(value: 18, message: number): 18identity(18, 18)// function identity&lt;'abc', number&gt;(value: 'abc', message: number): 'abc'identity('abc', 18)// function identity&lt;'abc', string&gt;(value: 'abc', message: string): 'abc'identity('abc', 'abc') 另外，我们还可以为泛型中的类型参数指定默认类型，因为当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用 1234function identity&lt;T = string, U = number&gt;(value: T, message: U): T { console.log(message) return value} 以上过程，我们可以参考下面这张动图，来直观地感受一下类型传递的过程 如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件，现在我们再回过头来看一下我们的 identity 函数 1234function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message) return value} 相比之前定义的 identity 函数，新的 identity 函数增加了一个类型变量 U，但是该函数的返回类型我们仍然使用 T，如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型 123function identity&lt;T, U&gt;(value: T, message: U): [T, U] { return [value, message]} 虽然使用元组可以解决上述的问题，但是有没有其它更好的解决方案呢？答案是有的，那就是我们可以使用『泛型接口』 泛型接口为了解决上面提到的问题，首先让我们创建一个用于的 identity 函数通用 Identities 接口 1234interface Identities&lt;V, M&gt; { value: V, message: M} 在上述的 Identities 接口中，我们引入了类型变量 V 和 M，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 Identities 接口作为 identity 函数的返回类型 123456789function identity&lt;T, U&gt;(value: T, message: U): Identities&lt;T, U&gt; { let identities: Identities&lt;T, U&gt; = { value, message } return identities}identity(18, 'zhangsan') 运行后可以发现，是可以正常运行的，当然泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型 泛型类在类中使用泛型也很简单，我们只需要在类名后面，使用 &lt;T, ...&gt; 的语法定义任意多个类型变量，具体示例如下 123456789101112131415161718192021interface GenericInterface&lt;U&gt; { value: U getIdentity: () =&gt; U}class IdentityClass&lt;T&gt; implements GenericInterface&lt;T&gt; { value: T constructor(value: T) { this.value = value } getIdentity(): T { return this.value }}const myNumberClass = new IdentityClass&lt;Number&gt;(18)myNumberClass.getIdentity() // 18const myStringClass = new IdentityClass&lt;string&gt;('zhangsan')myStringClass.getIdentity() // zhangsan 接下来我们以实例化 myNumberClass 为例，来分析一下其调用过程 在实例化 IdentityClass 对象时，我们传入 Number 类型和构造函数参数值 18，之后在 IdentityClass 类中，类型变量 T 的值变成 Number 类型 IdentityClass 类实现了 GenericInterface&lt;T&gt;，而此时 T 表示 Number 类型，因此等价于该类实现了 GenericInterface&lt;Number&gt; 接口 而对于 GenericInterface&lt;U&gt; 接口来说，类型变量 U 也变成了 Number 所以说，使用泛型类可确保在整个类中一致地使用指定的数据类型，通常在决定是否使用泛型时，我们有以下两个参考标准 当函数、接口或类将处理多种数据类型时 当函数、接口或类在多个地方使用该数据类型时 通常而言，但是随着项目的发展，组件的功能通常会被扩展，这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下引入泛型将比复制组件来满足一系列数据类型更干净，下面我们再来看看 Typescript 泛型提供的一些其他功能 泛型约束有时我们可能希望限制每个类型变量接受的类型数量，而这就是泛型约束的作用，下面我们通过几个例子来了解一下泛型约束 确保属性存在有时候，我们希望类型变量对应的类型上存在某些属性，在这种情况下，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在，一个很好的例子是在处理字符串或数组时，我们会假设 length 属性是可用的，还是以上面的示例为例，我们来简单的调整一下，尝试输出参数的长度 12345function identity&lt;T&gt;(arg: T): T { // ❌ console.log(arg.length) return arg} 在上面的示例当中，我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了，在这种情况下，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量，这也被称为『泛型约束』 在这种情况下，编译器将不会知道 T 确实含有 length 属性，尤其是在可以将任何类型赋给类型变量 T 的情况下，所以我们需要做的就是让类型变量 extends 一个含有我们所需属性的接口 123456789101112interface Length { length: number}function identity&lt;T extends Length&gt;(arg: T): T { console.log(arg.length) return arg}identity('zhangsan') // ✅identity(1234567890) // ❌ &lt;T extends Length&gt; 用于告诉编译器，我们支持已经实现 Length 接口的任何类型，之后当我们使用不含有 length 属性的对象作为参数调用 identity 函数时，TypeScript 都会提示我们相关的错误信息，也就是说，现在这个泛型函数已经被定义了约束，因此它不再是适用于任意类型，所以我们需要传入符合约束类型的值，当然具有 length 属性的对象也是可以的 12// ✅identity({ length: 10, value: 3 }) 此外，我们还可以使用 , 号来分隔多种约束类型，比如 &lt;T extends Length, Type2, Type3&gt;，而对于上述的 length 属性问题来说，我们也可以显式地将变量设置为数组类型，这样也可以解决该问题，具体方式如下 1234567891011function identity&lt;T&gt;(arg: T[]): T[] { console.log(arg.length) return arg}// orfunction identity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; { console.log(arg.length) return arg} 另外，多个类型参数之间也是可以互相约束的，比如下面这个示例 12345678910function copyFields&lt;T extends U, U&gt;(target: T, source: U): T { for (let id in source) { target[id] = (&lt;T&gt;source)[id] } return target}let x = { a: 1, b: 2, c: 3, d: 4 }copyFields(x, { b: 10, d: 20 }) 在上面的示例当中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段，其中 &lt;T&gt;source 的写法等同于 source as T，其实就是把 source 断言成 T 类型 检查对象上的键是否存在泛型约束的另一个常见的使用场景就是检查对象上的键是否存在，而这一点主要依靠的是 keyof 操作符，keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型 12345678interface Person { name: string age: number}type K2 = keyof Person[] // number | 'length' | 'push' ...type K1 = keyof Person // 'name' | 'age'type K3 = keyof { [x: string]: Person } // string | number 这里关于 keyof { [x: string]: Person } 的使用方式我们多提及一些，我们在之前的章节当中曾经提到过，在 TypeScript 中支持两种索引签名，数字索引和字符串索引 123456789interface StringArray { // 字符串索引 =&gt; keyof StringArray =&gt; string | number [index: string]: string;}interface StringArray1 { // 数字索引 =&gt; keyof StringArray1 =&gt; number [index: number]: string;} 为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类，其中的原因就是当使用数值索引时，JavaScript 在执行索引操作时，会先把数值索引先转换为字符串索引，所以 keyof { [x: string]: Person } 的结果会返回 string | number 让我们在回到 keyof 操作符上，通过 keyof 操作符，我们就可以获取指定类型的所有键，这样一来我们就可以结合前面介绍的 extends 约束，即限制输入的属性名包含在 keyof 返回的联合类型中，具体的使用方式如下 123function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]} 在以上的 getProperty 函数中，我们通过 K extends keyof T 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误，这是一个类型安全的解决方案，与简单调用 let value = obj[key] 不同，下面我们来看一下如何使用 getProperty 函数 12345678910111213141516171819enum Difficulty { Easy, Intermediate, Hard}function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]}let tsInfo = { name: 'Typescript', supersetOf: 'Javascript', difficulty: Difficulty.Intermediate}let difficulty: Difficulty = getProperty(tsInfo, 'difficulty') // ✅let supersetOf: string = getProperty(tsInfo, 'superset_of') // ❌ 在以上示例中，对于 getProperty(tsInfo, 'superset_of') 这个表达式，TypeScript 编译器会提示以下错误信息 1Argument of type '\"superset_of\"' is not assignable to parameter of type '\"difficulty\" | \"name\" | \"supersetOf\"'.(2345) 很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性，接下来我们来看一看泛型参数的默认类型 泛型参数默认类型这个特性我们在上面也简单提及过，在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型，当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用，泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 &lt;T = Default Type&gt;，对应的使用示例如下 123456interface A&lt;T = string&gt; { name: T}const str: A = { name: 'zhangsan' }const num: A&lt;number&gt; = { name: 18 } 泛型参数的默认类型遵循以下规则 有默认类型的类型参数被认为是可选的 必选的类型参数不能在可选的类型参数后 如果类型参数有约束，类型参数的默认类型必须满足这个约束 当指定类型实参时，我们只需要指定必选类型参数的类型实参，未指定的类型参数会被解析为它们的默认类型 如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果 一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型，也可以引入新的类型参数，只要它指定了默认类型 泛型条件类型在 TypeScript 2.8 中引入了条件类型，使得我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束，尽管代码中使用了 extends 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性，条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一 1T extends U ? X : Y 以上表达式的意思是若 T 能够赋值给 U，那么类型是 X，否则为 Y，在条件类型表达式中，我们通常还会结合 infer 关键字，实现类型抽取 123456789interface Dictionary&lt;T = any&gt; { [key: string]: T}type StrDict = Dictionary&lt;string&gt;type DictMember&lt;T&gt; = T extends Dictionary&lt;infer V&gt; ? V : nevertype StrDictMember = DictMember&lt;StrDict&gt; // string 在上面示例中，当类型 T 满足 T extends Dictionary 约束时，我们会使用 infer 关键字声明了一个类型变量 V（关于 infer 我们下面会进行介绍），并返回该类型，否则返回 never 类型，这里关于 never 类型，我们多提及一点 在 TypeScript 中，never 类型表示的是那些永不存在的值的类型，例如 never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型，另外，需要注意的是，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外），即使 any 也不可以赋值给 never 除了上述的应用外，利用条件类型和 infer 关键字，我们还可以方便地实现获取 Promise 对象的返回值类型 123456789101112131415161718async function stringPromise() { return 'hello, zhangsan'}interface Person { name: string age: number}async function personPromise() { return { name: 'zhangsan', age: 30 } as Person}type PromiseType&lt;T&gt; = (args: any[]) =&gt; Promise&lt;T&gt;type UnPromisify&lt;T&gt; = T extends PromiseType&lt;infer U&gt; ? U : nevertype extractStringPromise = UnPromisify&lt;typeof stringPromise&gt; // stringtype extractPersonPromise = UnPromisify&lt;typeof personPromise&gt; // Person 泛型工具类型为了方便开发者，TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等，不过在详细展开之前我们先来了解一下几个比较常用的操作符 in 操作符 in 操作符可以用来遍历枚举类型 123456type Keys = 'a' | 'b' | 'c'// =&gt; { a: any, b: any, c: any }type Obj = { [p in Keys]: any} typeof 操作符 typeof 操作符可以用来获取一个变量声明或对象的类型 12345678910111213interface Person { name: string age: number}const sem: Person = { name: 'zhangsan', age: 18 }function toArray(x: number): Array&lt;number&gt; { return [x]}type Sem = typeof sem // =&gt; Persontype Func = typeof toArray // =&gt; (x: number) =&gt; Array&lt;number&gt; 需要注意以下这种使用方式 123456789101112131415161718class Greeter { static message = 'hello' greet() { return Greeter.message }}// 获取的是实例的类型，该类型可以获取实例对象上的属性或方法let greeter1: Greeter = new Greeter()greeter1.greet() // 'hello'// 获取的是类的类型，该类型可以获取类上面的静态属性或方法let greeterTwo: typeof Greeter = GreetergreeterTwo.message = 'hey'let greeter2: Greeter = new greeterTwo()greeter2.greet() // 'hey' infer 操作符 infer 最早是出现在这个 PR 当中，表示在 extends 条件语句中待推断的类型变量 1type ParamType&lt;T&gt; = T extends (param: infer P) =&gt; any ? P : T 在这个条件语句 T extends (param: infer P) =&gt; any ? P : T 中，infer P 表示待推断的函数参数，如果 T 能赋值给 (param: infer P) =&gt; any，则结果是 (param: infer P) =&gt; any 类型中的参数 P，否则返回为 T 1234567891011type ParamType&lt;T&gt; = T extends (param: infer P) =&gt; any ? P : Tinterface User { name: string age: number}type Func = (user: User) =&gt; voidtype Param = ParamType&lt;Func&gt; // Param = Usertype AA = ParamType&lt;string&gt; // string 而在 2.8 版本中，TypeScript 也已经内置了一些与 infer 有关的映射类型，比如用于提取函数类型的返回值类型 1type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer P ? P : any 相比于之前的示例，ReturnType&lt;T&gt; 只是将 infer P 从参数位置移动到返回值位置，因此此时 P 即是表示待推断的返回值类型 12type Func = () =&gt; Usertype Test = ReturnType&lt;Func&gt; // Test = User 另外还可以用于提取构造函数中参数（实例）类型，比如一个构造函数可以使用 new 来实例化，因此它的类型通常表示如下 1type Constructor = new (...args: any[]) =&gt; any 当 infer 用于构造函数类型中，可用于参数位置 new (...args: infer P) =&gt; any 和返回值位置 new (...args: any[]) =&gt; infer P，因此就内置如下两个映射类型 12345678910111213// 获取参数类型type ConstructorParameters&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends new (...args: infer P) =&gt; any ? P : never// 获取实例类型type InstanceType&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends new (...args: any[]) =&gt; infer R ? R : anyclass TestClass { constructor(public name: string, public age: number) { }}type Params = ConstructorParameters&lt;typeof TestClass&gt; // [string, number]type Instance = InstanceType&lt;typeof TestClass&gt; // TestClass 当然关于 infer 还有许多的『骚操作』，比如 tuple 转 union，union 转 tuple 等等，这里就不详细展开了，可以参考 infer 的一些用例 和 union to tuple 这两个链接来了解更多 extends 操作符 这个我们之前提到过，有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束 12345678interface Lengthwise { length: number}function identity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length) return arg} 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型 12// =&gt; 类型 `number` 的参数不能赋给类型 `Lengthwise` 的参数identity(3) 这时我们需要传入符合约束类型的值，必须包含必须的属性 12345// ❌identity({ value: 3 })// ✅identity({ length: 10, value: 3 }) Omit 操作符 有时候我们需要复用一个类型，但是又不需要此类型内的全部属性，因此需要剔除某些属性，这个方法在 React 中经常用到，当父组件通过 props 向下传递数据的时候，通常需要复用父组件的 props 类型，但是又需要剔除一些无用的类型 123456789interface User { username: string id: number token: string avatar: string role: string}type UserWithoutToken = Omit&lt;User, 'token'&gt; 下面我们就正式来看看之前提到的 TypeScript 当中内置的一些常用的工具类型 PartialPartial&lt;T&gt; 的作用就是将某个类型里的属性全部变为可选项 ?，定义如下 1234567/** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */type Partial&lt;T&gt; = { [P in keyof T]?: T[P]} 在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值，中间的 ? 号，用于将所有属性变为可选，比如下面这个示例 1234567891011121314151617interface Todo { title: string description: string}function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) { return { ...todo, ...fieldsToUpdate }}const todo1 = { title: 'title', description: 'description',}const todo2 = updateTodo(todo1, { description: 'update-description',}) 在上面的 updateTodo方法中，我们利用 Partial&lt;T&gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial&lt;Todo&gt;，即 1234{ title?: string | undefined description?: string | undefined} RecordRecord&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型，定义如下 1234567/** * node_modules/typescript/lib/lib.es5.d.ts * Construct a type with a set of properties K of type T */type Record&lt;K extends keyof any, T&gt; = { [P in K]: T} 一个示例 1234567891011interface PageInfo { title: string}type Page = 'home' | 'about' | 'contact'const x: Record&lt;Page, PageInfo&gt; = { about: { title: 'about' }, contact: { title: 'contact' }, home: { title: 'home' }} PickPick&lt;T, K extends keyof T&gt; 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型 1234567/** * node_modules/typescript/lib/lib.es5.d.ts * From T, pick a set of properties whose keys are in the union K */type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]} 一个示例 123456789101112interface Todo { title: string description: string completed: boolean}type TodoPreview = Pick&lt;Todo, 'title' | 'completed'&gt;const todo: TodoPreview = { title: 'home', completed: false} 另外一个示例 123456interface Test { arr: string[]}// 返回的结果 =&gt; {arr: string[]}let aaa: Pick&lt;Test, 'arr'&gt; = { arr: ['1'] } ExcludeExclude&lt;T, U&gt; 的作用是将某个类型中属于另一个的类型移除掉，定义如下 12345/** * node_modules/typescript/lib/lib.es5.d.ts * Exclude from T those types that are assignable to U */type Exclude&lt;T, U&gt; = T extends U ? never : T 如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型，最终实现的效果就是将 T 中某些属于 U 的类型移除掉，下面是一个简单的示例 123type T0 = Exclude&lt;'a' | 'b' | 'c', 'a'&gt; // 'b' | 'c'type T1 = Exclude&lt;'a' | 'b' | 'c', 'a' | 'b'&gt; // 'c'type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt; // string | number ReturnTypeReturnType&lt;T&gt; 的作用是用于获取函数 T 的返回类型，定义如下 12345/** * node_modules/typescript/lib/lib.es5.d.ts * Obtain the return type of a function type */type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any 几个简单的示例 12345678type T0 = ReturnType&lt;() =&gt; string&gt; // stringtype T1 = ReturnType&lt;(s: string) =&gt; void&gt; // voidtype T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt; // {}type T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt; // number[]type T4 = ReturnType&lt;any&gt; // anytype T5 = ReturnType&lt;never&gt; // anytype T6 = ReturnType&lt;string&gt; // ❌type T7 = ReturnType&lt;Function&gt; // ❌ 在了解完了泛型工具类型以后，最后我们再来看看如何使用泛型来创建对象 使用泛型创建对象有时，泛型类可能需要基于传入的泛型 T 来创建其类型相关的对象，比如 1234567891011121314151617181920class FirstClass { id: number | undefined}class SecondClass { name: string | undefined}class GenericCreator&lt;T&gt; { create(): T { // ❌ return new T() }}const creator1 = new GenericCreator&lt;FirstClass&gt;()const firstClass: FirstClass = creator1.create()const creator2 = new GenericCreator&lt;SecondClass&gt;()const secondClass: SecondClass = creator2.create() 在以上代码中，我们定义了两个普通类和一个泛型类 GenericCreator&lt;T&gt;，在通用的 GenericCreator 泛型类中，我们定义了一个名为 create 的成员方法，该方法会使用 new 关键字来调用传入的实际类型的构造函数来创建对应的对象，但可惜的是，以上代码并不能正常运行，对于以上代码，在 TypeScript v3.9.2 编译器下会提示以下错误 1'T' only refers to a type, but is being used as a value here. 这个错误的意思是 T 类型仅指类型，但此处被用作值，那么如何解决这个问题呢？根据 TypeScript 文档，为了使通用类能够创建 T 类型的对象，我们需要通过其构造函数来引用 T 类型，对于上述问题，在介绍具体的解决方案前，我们先来介绍一下构造签名 构造签名在 TypeScript 接口中，我们可以使用 new 关键字来描述一个构造函数 123interface Point { new(x: number, y: number): Point} 以上接口中的 new(x: number, y: number) 我们称之为『构造签名』，其语法如下 1ConstructSignature: new TypeParametersopt(ParameterListopt) TypeAnnotationopt 在上述的构造签名中，TypeParametersopt、ParameterListopt 和 TypeAnnotationopt 分别表示可选的类型参数、可选的参数列表和可选的类型注解，与该语法相对应的几种常见的使用形式如下 123new Cnew C ( ... )new C &lt; ... &gt; ( ... ) 在了解完构造签名以后，我们再来看看一个与之相关的概念，即『构造函数类型』 构造函数类型在 TypeScript 语言规范中这样定义构造函数类型 12An object type containing one or more construct signatures is said to be a constructor type.Constructor types may be written using constructor type literals or by including construct signatures in object type literals. 通过规范中的描述信息，我们可以得出以下结论 包含一个或多个构造签名的对象类型被称为构造函数类型 构造函数类型可以使用构造函数类型字面量或包含构造签名的对象类型字面量来编写 那么什么是构造函数类型字面量呢？构造函数类型字面量是包含单个构造函数签名的对象类型的简写，具体来说，构造函数类型字面量的形式如下 1new &lt; T1, T2, ... &gt; ( p1, p2, ... ) =&gt; R 该形式与以下对象类型字面量是等价的 1{ new &lt; T1, T2, ... &gt; ( p1, p2, ... ) : R } 下面我们来看一个实际的示例 12// 构造函数类型字面量new (x: number, y: number) =&gt; Point 等价于以下对象类型字面量 123{ new (x: number, y: number): Point} 构造函数类型的应用在介绍构造函数类型的应用前，我们先来看个例子 1234567891011121314151617interface Point { new(x: number, y: number): Point x: number y: number}class Point2D implements Point { readonly x: number readonly y: number constructor(x: number, y: number) { this.x = x this.y = y }}const point: Point = new Point2D(1, 2) 对于以上的代码，TypeScript 编译器会提示以下错误信息 123Class 'Point2D' incorrectly implements interface 'Point'.Type 'Point2D' provides no match for the signature 'new (x: number, y: number): Point'. 我们先来尝试着解决这个错误，要解决这个问题，我们就需要把对前面定义的 Point 接口进行分离，即把接口的属性和构造函数类型进行分离 12345678910111213141516171819202122232425262728interface Point { x: number y: number}interface PointConstructor { new(x: number, y: number): Point}class Point2D implements Point { readonly x: number readonly y: number constructor(x: number, y: number) { this.x = x this.y = y }}function newPoint( pointConstructor: PointConstructor, x: number, y: number): Point { return new pointConstructor(x, y)}const point: Point = newPoint(Point2D, 1, 2) 完成接口拆分之后，除了前面已经定义的 Point2D 类之外，我们又定义了一个 newPoint 工厂函数，该函数用于根据传入的 PointConstructor 类型的构造函数，来创建对应的 Point 对象 使用泛型创建对象在了解完构造签名和构造函数类型之后，下面我们来开始解决开头部分 GenericCreator&lt;T&gt; 示例当中 T 被用作值的问题，首先我们需要重构一下 create 方法，具体如下所示 12345class GenericCreator&lt;T&gt; { create&lt;T&gt;(c: { new(): T }): T { return new c() }} 在以上代码中，我们重新定义了 create 成员方法，根据该方法的签名，我们可以知道该方法接收一个参数，其类型是构造函数类型，且该构造函数不包含任何参数，调用该构造函数后会返回类型 T 的实例 如果构造函数含有参数的话，比如包含一个 number 类型的参数时，我们可以这样定义 create 方法 123create&lt;T&gt;(c: { new(a: number): T }, num: number): T { return new c(num)} 更新完 GenericCreator 泛型类，我们就可以使用我们新的 create 方法来创建 FirstClass 和 SecondClass 类的实例 12345678910111213141516171819class FirstClass { id: number | undefined}class SecondClass { name: string | undefined}class GenericCreator&lt;T&gt; { create&lt;T&gt;(c: { new(): T }): T { return new c() }}const creator1 = new GenericCreator&lt;FirstClass&gt;()const firstClass: FirstClass = creator1.create(FirstClass)const creator2 = new GenericCreator&lt;SecondClass&gt;()const secondClass: SecondClass = creator2.create(SecondClass) 现在可以发现，程序已经可以正常运行 参考 Typescript Generics Typescript Generics Explained TypeScript Tip of the Week: Generics","link":"/2021/01/09/JavaScript/58/"},{"title":"React 中的 Hook","text":"我们在之前 React 中的 Mixin 和 React 中的 HOC 的章节当中介绍了 Mixin 和 HOC 的相关内容，了解了它们大致的实现原理和使用方式，也知道了 HOC 的出现就是为了替代 Mixin，但是 HOC 也并非完美无缺，它其实也是存在着一些缺陷的，比如 HOC 需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难 HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突 所以在本章当中我们就来看看 React 中的 Hook 是如何同时解决 Mixin 和 HOC 所带来的问题的 为什么要使用 Hook如果说为什么要使用 Hook，那么我们可以先来看看 Hook 主要解决的问题，主要有下面三个 在组件之间复用状态逻辑很难，Hook 使你在无需修改组件结构的情况下复用状态逻辑 复杂组件变得难以理解，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据） 难以理解的 Class，Hook 使你在非 Class 的情况下可以使用更多的 React 特性 那么到底什么是 Hook 呢？ 什么是 HookReact 在 16.8 的版本当中新增了 Hook 这个特性，它可以让我们在不编写 Class 的情况下使用 state 以及其他的 React 特性，使用 Hook，你可以在将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，同时 Hook 可以帮助你在不重写组件结构的情况下复用这些逻辑，所以它也可以作为一种实现状态逻辑复用的方案 React 内置了一些像 useState 这样的 Hook，你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑，其实简单来说 Hook 就是我们常见的 JavaScript 函数，但是使用它们会有两个额外的规则，如下 只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用 只能在 React 函数式组件或自定义 Hook 中使用 Hook，不要在其他 JavaScript 函数中调用 之所以不要在循环当中去调用 Hook，这是因为 Hook 是通过数组实现的，每次 useState 都会改变下标，React 需要利用调用顺序来正确更新相应的状态，如果 useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误，我们可以利用 eslint 插件来帮助我们避免这些问题 1234567891011121314// 安装npm install eslint-plugin-react-hooks --save-dev// 配置{ \"plugins\": [ // ... \"react-hooks\" ], \"rules\": { // ... \"react-hooks/rules-of-hooks\": \"error\" }} 当然官方也提供了一些默认的 Hook，如下 钩子名 作用 useState 初始化和设置状态 useEffect componentDidMount/componentDidUpdate/componentWillUnmount 结合体，所以可以监听 useState 定义值的变化 useContext 定义一个全局的对象，类似 Context useReducer 可以增强函数提供类似 Redux 的功能 useCallback 记忆作用，共有两个参数，第一个参数为一个匿名函数，就是我们想要创建的函数体，第二参数为一个数组，里面的每一项是用来判断是否需要重新创建函数体的变量，如果传入的变量值保持不变，返回记忆结果，如果任何一项改变，则返回新的结果 useMemo 作用和传入参数与 useCallback 一致，useCallback 返回函数，useDemo 返回值 useRef 获取 ref 属性对应的 DOM useImperativeMethods 自定义使用 Ref 时公开给父组件的实例值 useMutationEffect 作用与 useEffect 相同，但在更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发 useLayoutEffect 作用与 useEffect 相同，但在所有 DOM 改变后同步触发 我们下面来看几个平时使用频率较高的 Hook useState()那么为什么要使用 useState 呢？简单来说就是为了在函数组件里面使用 Class 组件才有的 setState 方法，因为当我们一个函数组件想要有自己维护的 state 的时候，不得已只能转换成 Class 组件，这样操作会很麻烦，所以就有了 useState，下面我们来看看如何使用 123456789export default function Button() { const [text, setText] = useState('click me') function handleClick() { setText('clicked') } return &lt;button onClick={handleClick}&gt;{text}&lt;/button&gt;} 在上面示例当中，useState 就是一个 Hook，通过在函数组件里调用它来给组件添加一些内部 state，React 会在重复渲染时保留这个 state useState 会返回一对值，包括『当前状态』和『一个让你更新它的函数』，你可以在事件处理函数中或其他一些地方调用这个函数，它类似 Class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并，useState 唯一的参数就是初始 state，值得注意的是，不同于 this.state，这里的 state 不一定要是一个对象，并且这个初始 state 参数只有在第一次渲染时会被用到 更新方式另外 useState 的更新方式也有两种，即直接更新和函数式更新，其应用场景的区分点在于 直接更新不依赖于旧 state 的值 函数式更新依赖于旧 state 的值 比如在上面的示例当中，我们只是简单的调用了 handleClick，但是如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState，该函数将接收先前的 state，并返回一个更新后的值 1234567891011export default function App() { const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;{count}&lt;/p&gt; &lt;button onClick={_ =&gt; setCount(0)}&gt;重置&lt;/button&gt; &lt;button onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt;增加&lt;/button&gt; &lt;button onClick={() =&gt; setCount(prev =&gt; prev - 1)}&gt;减少&lt;/button&gt; &lt;/div&gt; )} 实现合并与 Class 组件中的 setState 方法不同，useState 不会自动合并更新对象，而是直接替换它，不过我们可以使用函数式的 setState 结合展开运算符来达到合并更新对象的效果 1234setState(prevState =&gt; { // 也可以使用 Object.assign return { ...prevState, ...updatedValues }}) 惰性初始化 StateinitialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略，也就是说 useState 的初始值，只在第一次有效，也就是再次更新是无效的，比如下面这个示例 12345678910111213141516171819202122const Child = ({ data }) =&gt; { const [name, setName] = useState(data) return ( &lt;div&gt; &lt;div&gt;Child&lt;/div&gt; &lt;div&gt;{name} -- {data}&lt;/div&gt; &lt;/div&gt; )}const App = _ =&gt; { const [count, setCount] = useState(0) const [name, setName] = useState('zhangsan') return ( &lt;div&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;button onClick={_ =&gt; setCount(count + 1)}&gt;update count&lt;/button&gt; &lt;button onClick={_ =&gt; setName('list')}&gt;update name&lt;/button&gt; &lt;Child data={name} /&gt; &lt;/div&gt; )} 其应用场景在于，因为创建初始 state 很昂贵时，例如需要通过复杂计算获得，那么则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用 小结 不像 Class 中的 this.setState，Hook 更新 state 变量总是替换它而不是合并它 推荐使用多个 state 变量而不是单个 state 变量，因为 state 的替换逻辑而不是合并逻辑，并且利于后续的相关 state 逻辑抽离 调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行（React 使用 Object.is 比较算法来比较 state） useEffect()useEffect 主要用来引入具有副作用的操作，比如数据获取、订阅或者手动修改过 DOM 等操作就可以称之为副作用，这里我们就以数据请求为例，在之前我们处理数据请求一般都是放在 componentDidMount 当中来进行的，但是现在我们可以放在 useEffect 当中来进行，useEffect 的用法如下 1234567useEffect(() =&gt; { // 只要组件 render 后就会执行})useEffect(() =&gt; { // 只有 count 改变时才会执行}, [count]) useEffect 接受两个参数 第一个参数是一个回调函数，在第组件一次 render 和之后的每次 update 后运行，React 保证在 DOM 已经更新完成之后才会运行回调 第二个参数是一个状态依赖数组，当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数，第二个参数可以省略，这时每次组件渲染时，就会重新执行 useEffect() 执行顺序另外关于 useEffect 的执行顺序，有下面几点需要我们注意 正常情况下，useEffect 会在 render 后按照前后顺序执行 useEffect 内部执行是异步的 useEffect 的回调函数也是按照先后顺序同时执行的 下面我们就先来看一个使用 useEffect 的示例，如下 12345678910111213141516171819202122232425262728293031323334353637const Book = ({ id }) =&gt; { const [loading, setLoading] = useState(true) const [book, setBook] = useState({}) useEffect(() =&gt; { setLoading(true) fetch(`http://rap2api.taobao.org/app/mock/251195/list/${id}/`) .then(res =&gt; res.json()) .then(data =&gt; { setBook(data) setLoading(false) }) }, [id]) if (loading === true) { return &lt;p&gt;Loading ...&lt;/p&gt; } return ( &lt;div&gt; &lt;p&gt;{book.title}&lt;/p&gt; &lt;/div&gt; )}export default function App() { const [show, setShow] = useState('1') return ( &lt;div&gt; &lt;Book id={show} /&gt; &lt;div&gt; &lt;button onClick={_ =&gt; setShow('1')}&gt;第一页&lt;/button&gt; &lt;button onClick={_ =&gt; setShow('2')}&gt;第二页&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 在上面示例当中，我们传入 [id] 作为 useEffect 第二个参数，如果 id 的值在重新渲染的时候没有发生变化，React 会跳过这个 effect，这就实现了性能的优化，不过这里也需要注意 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中会使用的变量，否则你的代码会引用到先前渲染中的旧变量，即数组最好包含所有在 effect 当中使用的可能变化的变量 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数，这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 所以我们可以利用传递空数组的特性来模拟 componentDidMount 和 componentWillUnmount，其中 componentDidMount 等价于 useEffect 的回调仅在页面初始化完成后执行一次，当 useEffect 的第二个参数传入一个空数组时可以实现这个效果，但是我们最好忘掉生命周期，只记副作用 同时，useEffect 的第一个参数还可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次 useEffect 之前，会调用这个函数（组件卸载的时候也会执行清除操作），这个函数常常用来对上一次调用 useEffect 进行清理 123456useEffect(() =&gt; { // 这里是某些操作 return function cleanup() { // 命名为 cleanup 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字 }}) 下面是一个具体的示例 123456789101112131415export default function HookTest() { const [count, setCount] = useState(0) useEffect(() =&gt; { console.log('执行...', count) return () =&gt; { console.log('清理...', count) } }, [count]) return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; { setCount(count + 1); setNumber(number + 1) }}&gt;Click me&lt;/button&gt; &lt;/div&gt; )} 在控制台当中我们看到对应的输出，但是如果加上浏览器渲染的情况，结果应该是这样的 1234567891011渲染 ==&gt; 1执行 ==&gt; 1渲染 ==&gt; 2清理 ==&gt; 1执行 ==&gt; 2渲染 ==&gt; 3清理 ==&gt; 2执行 ==&gt; 3渲染 ==&gt; 4清理 ==&gt; 3执行 ==&gt; 4 那么这里就存在一个问题了，那就是为什么在浏览器渲染完后，再执行清理方法的时候还能找到上次的 state 呢？原因很简单，因为我们在 useEffect 中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染，可以参考下面的代码来进行理解 123456789101112131415161718var flag = 1var cleanfunction effect(flag) { return function () { console.log(flag) }}clean = effect(flag)flag = 2clean()clean = effect(flag)flag = 3clean()clean = effect(flag) 执行后的结果是下面这样的 12345effect ==&gt; 1clean ==&gt; 1effect ==&gt; 2clean ==&gt; 2effect ==&gt; 3 注意事项但是关于 useEffect 的使用也有一些需要注意的地方，主要有以下几点 useEffect 里面使用到的 state 的值，是会被固定在 useEffect 内部，不会被改变，除非 useEffect 刷新，重新固定 state 的值，也就是说它是在生成 useEffect 时候的当前值，不会随着时间改变而变化 123456789const [count, setCount] = useState(0)useEffect(() =&gt; { const timer = setInterval(() =&gt; { console.log(count) setCount(count + 1) }, 1000) return () =&gt; clearInterval(timer)}, []) useEffect 不能被判断包裹 12345678const [count, setCount] = useState(0)if (2 &lt; 5) { useEffect(() =&gt; { const timer = setInterval(() =&gt; setCount(count + 1), 1000) return () =&gt; clearInterval(timer) })} useEffect 不能被打断 1234567const [count, setCount] = useState(0)useEffect(...)return // 函数提前结束了useEffect(...) 关于以上几点的原因，其实是跟 useEffect 的生成执行规则有关，我们会在 深入 useEffect 章节当中来深入探讨为什么会这样 小结 可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合 在 React 的 Class 组件中，render 函数是不应该有任何副作用的，一般来说在这里执行操作太早，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作 useContext()useContext() 通常用来处理多层级传递数据的方式，在以前组件树中，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事 也就是说，如果需要在多个组件之间共享状态，那么这种情况下就可以考虑使用 useContext()，其实和 React 之前提供的 Context 的使用方式有些类似，比如下面这种情况，我们有 A 和 B 两个组件，它们需要共享标题内容 1234567891011121314151617181920212223242526272829303132const AppContext = React.createContext({})const A = () =&gt; { const { title } = useContext(AppContext) return ( &lt;div&gt; &lt;p&gt;标题为 { title }&lt;/p&gt; &lt;p&gt;A 组件的内容&lt;/p&gt; &lt;/div&gt; )}const B = () =&gt; { const { title } = useContext(AppContext) return ( &lt;div&gt; &lt;p&gt;标题为 { title }&lt;/p&gt; &lt;p&gt;B 组件的内容&lt;/p&gt; &lt;/div&gt; )}export default function App() { return ( &lt;div&gt; &lt;AppContext.Provider value={{title: '文章标题'}}&gt; &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt; &lt;/AppContext.Provider&gt; &lt;/div&gt; )} 我们首先使用了 React.createContext({}) 在组件外部建立一个 Context，然后使用 &lt;AppContext.Provider&gt; 来提供了一个 Context 对象，这个对象可以被子组件共享，这里需要注意的是不能直接使用 &lt;AppContext&gt;，否则会报错，另外需要注意在传递值的时候使用的两层大括号 最后我们在需要被共享内容的子组件内使用 useContext() 钩子函数用来引入 Context 对象，从中来获取 title 属性，这是因为当前的 Context 的值是由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 所决定 但是这里有一个需要我们注意的地方，比如我们上方的 B 组件变成了下面这种情况，即不在依赖 Context，但是渲染的时候仍然放在 &lt;AppContext.Provider&gt; 当中 1234567const B = () =&gt; { return ( &lt;div&gt; &lt;p&gt;B 组件的内容&lt;/p&gt; &lt;/div&gt; )} 这样一来就会涉及到下面两个问题 useContext 的组件总会在 Context 值变化时重新渲染， 所以 &lt;MyContext.Provider&gt; 包裹的越多，层级越深，性能会造成影响 &lt;MyContext.Provider&gt; 的 value 发生变化时候，包裹的组件无论是否订阅 content value，所有组件都会从新渲染 所以在这种情况下，我们自然而然的可以想到，如果组件没有订阅的话，是不是可以避免不必要的渲染，答案是有的，我们可以使用 React.memo 来进行优化，我们将 B 组件调整如下 123const B = React.memo((props) =&gt; { return &lt;div&gt;B 组件的内容&lt;/div&gt;}) 但是需要注意的是，默认情况下 React.memo() 只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现，这部分内容我们会在下面的 useMemo() 部分来进行介绍，也可以参考 Preventing rerenders with React.memo and useContext hook 了解更多 useReducer()React 本身不提供状态管理功能，通常我们需要借住一些第三方库（比如 Redux）来进行实现，而 Redux 的核心概念是，组件不能直接修改共享状态，而是需要发出 action 与状态管理器通信，状态管理器收到 action 以后，使用 reducer 函数计算出新的状态进行返回 通常 reducer 函数的形式是 (state, action) =&gt; newState，而 useReducers() 钩子就是用来引入 reducer 功能的，比如下面这个计数器的示例 123456789101112131415161718192021222324252627282930313233const myReducer = (state, action) =&gt; { switch (action.type) { case 'add': return { ...state, count: state.count + 1 } case 'dec': return { ...state, count: state.count - 1 } case 'reset': return { ...state, count: action.payload || 0 } default: return state }}export default function App() { const [state, dispatch] = useReducer(myReducer, { count: 10 }) return ( &lt;div&gt; &lt;p&gt;{state.count}&lt;/p&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'reset' })}&gt;重置&lt;/button&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'add' })}&gt;增加&lt;/button&gt; &lt;button onClick={_ =&gt; dispatch({ type: 'dec' })}&gt;减少&lt;/button&gt; &lt;/div&gt; )} 以上就是 useReducer 的简单用法，可以发现其相对于 Redux 而言代码简化了不少，所以 useReducer() 在这些方面是可以取代 Redux 的，但是它并没有提供例如中间件（middleware）和时间旅行（time travel）等功能，所以还是根据实际情况来进行使用 useRef()使用 useRef Hook，我们可以轻松的获取到 DOM 的 ref 123456789101112export default function Input() { const inputEl = useRef(null) const onButtonClick = () =&gt; { inputEl.current.focus() } return ( &lt;div&gt; &lt;input ref={inputEl} type=\"text\" /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/div&gt; )} 但是 useRef 并不仅仅可以用来当作获取 ref 使用，使用 useRef 产生的 ref 的 current 属性是可变的，这意味着你可以用它来保存一个任意值，但是需要注意的是，这样方式有点类似于全局作用域，一处被修改，其他地方全都会更新 123456789const [count, setCount] = useState(0)const countRef = useRef(0)useEffect(() =&gt; { const timer = setInterval(() =&gt; { setCount(++countRef.current) }, 1000) return () =&gt; clearInterval(timer)}, []) 不过相对于上面这个示例，采用下面这种方式更为妥善一些 123456useEffect(() =&gt; { const timer = setInterval(() =&gt; { setCount(c =&gt; c + 1) }, 1000) return () =&gt; clearInterval(timer)}, []) 这样一来我们就不需要实时保存当前的值了，而是调整成了仅仅告知 React，让其去递增状态就行，而不用管它现在具体是什么值，更为深层次的运行原理可以参考 深入 useEffect 来了解更多 同样的，我们也可以使用 useRef 来模拟 componentDidUpdate，componentDidUpdate 就相当于除去第一次调用的 useEffect，我们可以借助 useRef 生成一个标识，来记录是否为第一次执行 12345678910function useDidUpdate(callback, prop) { const init = useRef(true) useEffect(() =&gt; { if (init.current) { init.current = false } else { return callback() } }, prop)} 简单总结一下就是 useRef 返回一个可变的 ref 对象，它会在每次渲染时返回同一个 ref 对象，在整个组件的生命周期内是唯一的 useRef 可以保存任何可变的值，即也可以存储那些不需要引起页面重新渲染的数据 如果你刻意地想要从某些异步回调中读取最新的 state，你可以用一个 ref 来保存它，修改它，并从中读取（关于这点可以参考官方文档当中的 有类似实例变量的东西吗？） useMemo()先来看看我们为什么要使用 useMemo 呢？我们还是以上面 useState 章节当中的示例为例，稍微的调整一下 1234567891011121314151617181920212223const Child = ({ data }) =&gt; { console.log(`子组件渲染`) return ( &lt;div&gt; &lt;div&gt;{data.name}&lt;/div&gt; &lt;/div&gt; )}const App = () =&gt; { const [count, setCount] = useState(0) const [name, setName] = useState('zhangsan') const data = { name } return ( &lt;div&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;update count&lt;/button&gt; &lt;Child data={data} /&gt; &lt;/div&gt; )} 仔细观察控制台的输出可以发现，在我们每次点击按钮去更新 count 的时候，我们的子组件每次也都会跟着重新渲染，但是我们此时并没有去修改 name 的值，也就是说子组件用到的值其实是没有改变的，那么这样一来就是多余的渲染了，在这样的情况下我们通常会使用 React.memo 来解决这样的问题 123456789101112131415161718192021222324252627282930const isEqual = (prevProps, nextProps) =&gt; { if (prevProps.name !== nextProps.name) { return false } return true}const Child = memo(({ data }) =&gt; { console.log(`子组件渲染`) return ( &lt;div&gt; &lt;div&gt;{data.name}&lt;/div&gt; &lt;/div&gt; )}, isEqual)const App = () =&gt; { const [count, setCount] = useState(0) const [name, setName] = useState('zhangsan') const data = { name } return ( &lt;div&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;update count&lt;/button&gt; &lt;Child data={data} /&gt; &lt;/div&gt; )} 我们使用 React.memo 将我们的子组件包裹了起来，并且传入了第二个参数 isEqual，它是一个函数，它的作用是判断两次 name 是否一致，只有在不一致的时候才会重新触发渲染 调整以后我们再次运行，可以发现此时子组件在 name 属性不改变的情况下就不会再次重新渲染了，但是在这种情况下，我们需要额外提供一个比对函数来对传入的数据进行比对后再决定是否重新渲染，那么有没有更为简便的方式呢？方法是有的，在这种情况下我们就可以考虑使用 useMemo，调整后代码如下 1234567891011121314151617181920212223const Child = (data) =&gt; { return useMemo(() =&gt; { console.log(`子组件渲染`) return &lt;div&gt; &lt;p&gt;{data.name}&lt;/p&gt; &lt;/div&gt; }, [data.name])}const App = () =&gt; { const [count, setCount] = useState(0) const [name, setName] = useState('zhangsan') const data = { name } return ( &lt;div&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;update count&lt;/button&gt; &lt;Child data={data} /&gt; &lt;/div&gt; )} 我们使用 useMemo 将我们子组件的渲染部分包裹了起来，并且传递了第二个参数，它是一个依赖数组，作用与我们上面的比对函数 isEqual 是一致的，这样一来我们就不在需要手动的提供比对函数了，React 在渲染的时候就会事先根据我们提供的依赖数组里面的 name 值先去判断一下，如果没有改变则会跳过这次更新，因为 useMemo 帮助我们暂存了上一次的 name 结果，但是在 useMemo 使用过程当中有一个我们需要注意的地方，那就是 useMemo 是在 render 期间执行的，所以在其中不能进行一些额外的副操作，比如网络请求等 看到这里，你也许会问了，那么 React.memo 与 useMemo 又有什么区别呢？其实简单来说 React.memo 和 useMemo 实现的功能都是一样的，首先就是 React.memo 是在最外层包装了整个组件，并且需要手动的去写一个方法来比对数据是否有所改变来决定是否重新渲染，而在某些场景下，我们只是希望组件的部分内容不进行重新渲染，而不是整个组件全都不去重新渲染，也就是说想要实现局部 Pure 的功能，针对于这种情况就可以使用 useMemo 的方式来替代 React.memo 另外需要注意的一点就是，如果函数组件被 React.memo 包裹，并且其实现中拥有 useState 或 useContext 的 Hook 的时候，那么当 context 发生变化时，它是仍会重新渲染的，所以在使用的时候一定要小心 那么什么又是 Pure 功能呢？其实就是之前比较流行使用的 React.PureComponent 功能，它和 React.Component 类似，都是定义一个组件类，不同的是 React.Component 并没有实现 shouldComponentUpdate() 而 React.PureComponent 通过 props 和 state 的浅比较实现了，它与 React.memo/useMemo 最主要的区别就是 React.PureComponent 是作用在类中，而 React.memo 是作用在函数中 一般来说，如果组件的 props 和 state 相同时，render 的内容也一致，那么就可以使用 React.PureComponent 来提高组件的性能，下面是一个 React.PureComponent 简单的使用示例 123456789101112// 组件直接继承 React.PureComponent 即可class TwentyOneChild extends React.PureComponent { render() { return &lt;div&gt;{this.props.name}&lt;/div&gt; }}export default class TwentyOne extends React.Component { render() { return &lt;TwentyOneChild name={`React.PureComponent`}&gt;&lt;/TwentyOneChild&gt; }} useCallback()我们在上面介绍的 useMemo 解决了值的缓存问题，那么如果想要缓存函数的话，我们该如何处理呢？来看下面这个示例，也就是上面 useMemo 当中的示例，我们简单的调整了一下 1234567891011121314151617181920const App = () =&gt; { const [count, setCount] = useState(0) const onChange = e =&gt; { setCount(e.target.value) } return ( &lt;div&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;update count&lt;/button&gt; &lt;Child onChange={onChange} /&gt; &lt;/div&gt; )}const Child = ({ onChange }) =&gt; { return useMemo(() =&gt; { console.log(`子组件渲染`) return &lt;input type=\"text\" onChange={onChange} /&gt; }, [onChange])} 当我们点击按钮的时候，会生成了一个 onChange 函数，赋值给了子组件，但是我们可以发现，子组件还是会随着按钮的点击而不停的渲染，尽管子组件什么都没有做，在这种情况下，我们就可以使用 useCallback 将我们的 onChange 函数包裹起来即可，如下 123const onChange = useCallback(e =&gt; { setCount(e.target.value)}, []) 再次点击后就可以发现，子组件不会再重复的渲染了，其实本质上来说，useCallback 与 useMemo 类似，都是有着缓存的作用，不同之处可能在于 useMemo 是缓存值的 useCallback 是缓存函数的 另外如果没有依赖，我们可以添加空的依赖，也就是空数组 Mixin/Render Props/HOC/Hook 的优缺点我们在之前的内容当中介绍过了 Mixin/Render Props/HOC/Hook 的一些用法和需要注意的地方，所以在本小节当中我们就来简单的汇总一下，看看它们几者之间的优缺点 Mixin 的缺陷 组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知道这种依赖关系） 多个 Mixin 之间可能产生冲突（比如定义了相同的 state 字段） Mixin 倾向于增加更多状态，这降低了应用的可预测性，导致复杂度剧增 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升 难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互影响 组价自身的方法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它 Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个 Mixin 的输入输出 HOC 相比 Mixin 的优势 HOC 通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State 不存在冲突和互相干扰，这就降低了耦合度 HOC 具有天然的层级结构（组件树结构），这降低了复杂度 HOC 的缺陷 扩展性限制，HOC 无法从外部访问子组件的 State 因此无法通过 shouldComponentUpdate() 滤掉不必要的更新（提供了 React.PureComponent() 来解决这个问题） Ref 传递问题，Ref 被隔断（提供了 React.forwardRef() 来解决这个问题） Wrapper Hell，HOC 可能出现多层包裹组件的情况，多层抽象同样增加了复杂度和理解成本 命名冲突，如果高阶组件多次嵌套，没有使用命名空间的话会产生冲突，然后覆盖老属性 不可见性，HOC 相当于在原有组件外层再包装一个组件，无法得知外层的包装是什么 Render Props 优点 上述 HOC 的缺点 Render Props 都可以解决 Render Props 缺陷 使用繁琐，HOC 使用只需要借助装饰器语法通常一行代码就可以进行复用，Render Props 无法做到如此简单 嵌套过深，Render Props 虽然摆脱了组件多层嵌套的问题，但是转化为了函数回调的嵌套 React Hooks 优点 减少状态逻辑复用的风险，多个 Hook 之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上 避免地狱式嵌套，Hook 解决了 HOC 和 Render Props 的嵌套问题，更加简洁 解耦让组件更容易理解，Hook 可以更方便地把 UI 和状态分离，可以让我们更大限度的将公用逻辑抽离，将一个组件分割成一个个更小的函数，做到更彻底的解耦 组合，Hook 中可以引用另外的 Hook 形成新的 Hook 函数友好，Hook 为函数组件而生，从而解决了类组件的几大问题 this 指向容易错误 分割在不同声明周期中的逻辑使得代码难以理解和维护 代码复用成本高（高阶组件容易使代码量剧增） React Hooks 缺陷 额外的学习成本（Functional Component 与 Class Component 之间的困惑） 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本 破坏了 PureComponent、React.memo() 浅比较的性能优化效果（为了取最新的 props 和 state，每次 render() 都要重新创建事件处函数） 在闭包场景可能会引用到旧的 state、props 值 React.memo() 并不能完全替代 shouldComponentUpdate()（因为拿不到 state change，只针对 props change） 不过还是那句老话，我们应该根据实际使用场景来进行选择 Hook 的本质其实我们在上面提到的 Hook，本身就是为了解决组件间逻辑公用的问题的，回顾我们现在的做法，几乎都是面向生命周期编程 而 Hook 的出现是把这种面向生命周期编程变成了面向业务逻辑编程，让我们不用再去关注生命周期 而且在最新的 React 中，预置了大量的 Hook，其中比较重要两个的就是 useState 和 useEffect useState 使我们在不借助 ES6 Class 的前提下，在组件内部使用 state 成为可能 useEffect 取代了 componentDidMount/componentDidUpdate/componentWillUnmount，提供了一个统一的 API 当然除了这两个比较重要的和上面我们介绍到的几个其他的 Hook 之外，我们还可以在 官方文档 中发现更多 Hook 深入 Hook 的原理 本小节内容主要参考 Under the hood of React’s hooks system 我们在之前的章节当中花了大量篇幅来介绍了官方提供的一些 Hook，以及在使用它的过程当中的一些注意事项，但是我们并没有太过深入的去介绍 Hook 内部运行的机制，所以在本节当中我们就来简单的了解一些它的运行机制，首先我们先来看看 React Hook 系统的简单示意图，如下 DispatcherDispatcher 是一个包含了 Hook 函数的共享对象，基于 ReactDOM 的渲染状态，它将会被动态的分配或者清理，并且它将会确保用户不能在 React 组件之外获取到 Hook（源码），在切换到正确的 Dispatcher 来呈现根组件之前，我们通过一个名为 enableHooks 的标志来启用或者禁用 Hook，在技术上来说，这就意味着我们可以在运行时开启或关闭 Hook，React 16.6+ 版本的实验性功能中也加入了它，但它默认处于禁用状态（源码） 当我们完成渲染工作后，我们会废弃 Dispatcher 并禁止 Hook，来防止在 ReactDOM 的渲染周期之外不小心使用了它，这个机制能够保证用户不会做傻事（源码），Dispatcher 在每次 Hook 的调用中都会被函数 resolveDispatcher() 解析，如果是在 React 的渲染周期之外，React 将会提示我们说 Hook 只能在函数组件内部调用（源码） 下面是我们模拟的 Dispatcher 的简单实现方式 12345678910111213141516171819let currentDispatcherconst dispatcherWithoutHooks = { /* ... */ }const dispatcherWithHooks = { /* ... */ }function resolveDispatcher() { if (currentDispatcher) return currentDispatcher throw Error(`Hooks can't be called`)}function useXXX(...args) { const dispatcher = resolveDispatcher() return dispatcher.useXXX(...args)}function renderRoot() { currentDispatcher = enableHooks ? dispatcherWithHooks : dispatcherWithoutHooks performWork() currentDispatcher = null} Hook 队列在 React 后台，Hook 会被表示为节点，并以调用顺序连接起来，这样表示的原因是 Hook 并不是被简单的创建然后丢弃，它们有一套独有的机制，一个 Hook 会有数个属性，我们首先需要明确以下几点 在初次渲染的时候，它的初始状态会被创建 它的状态可以在运行时更新 React 可以在后续渲染中记住 Hook 的状态 React 能根据调用顺序提供给你正确的状态 React 知道当前 Hook 属于哪个部分 另外，我们需要重新思考我们看待组件状态的方式，目前，我们只把它看作一个简单的对象，也就是下面这样 12345{ foo: &apos;foo&apos;, bar: &apos;bar&apos;, baz: &apos;baz&apos;,} 但是当处理 Hook 的时候，状态需要被看作是一个队列，每个节点都表示了对象的一个模块 12345678910{ memoizedState: &apos;foo&apos;, next: { memoizedState: &apos;bar&apos;, next: { memoizedState: &apos;bar&apos;, next: null } }} 在每个函数组件调用前，一个名为 prepareHooks() 的函数将先被调用，在这个函数中，当前结构和 Hook 队列中的第一个 Hook 节点将被保存在全局变量中，这样我们无论何时调用 Hook 函数（useXXX()），它都能知道运行上下文 1234567891011121314151617181920212223242526272829303132333435363738let currentlyRenderingFiberlet workInProgressQueuelet currentHookfunction prepareHooks(recentFiber) { currentlyRenderingFiber = workInProgressFiber currentHook = recentFiber.memoizedState}function finishHooks() { currentlyRenderingFiber.memoizedState = workInProgressHook currentlyRenderingFiber = null workInProgressHook = null currentHook = null}function resolveCurrentlyRenderingFiber() { if (currentlyRenderingFiber) return currentlyRenderingFiber throw Error(`Hooks can't be called`)}function createWorkInProgressHook() { workInProgressHook = currentHook ? cloneHook(currentHook) : createNewHook() currentHook = currentHook.next workInProgressHook}function useXXX() { const fiber = resolveCurrentlyRenderingFiber() const hook = createWorkInProgressHook() // ...}function updateFunctionComponent(recentFiber, workInProgressFiber, Component, props) { prepareHooks(recentFiber, workInProgressFiber) Component(props) finishHooks()} Hook 队列的简单实现一旦更新完成，一个名为 finishHooks() 的函数将会被调用，在这个函数中，Hook 队列的第一个节点的引用将会被保存在渲染了的结构的 memoizedState 属性中，这就意味着 Hook 队列和它的状态可以在外部定位到，也就是说我们可以从外部读取某一组件记忆的状态 12345678910111213141516171819202122const ChildComponent = () =&gt; { useState('foo') useState('bar') useState('baz') return null}const ParentComponent = () =&gt; { const childFiberRef = useRef() useEffect(() =&gt; { let hookNode = childFiberRef.current.memoizedState assert(hookNode.memoizedState, 'foo') hookNode = hooksNode.next assert(hookNode.memoizedState, 'bar') hookNode = hooksNode.next assert(hookNode.memoizedState, 'baz') }) return &lt;ChildComponent ref={childFiberRef} /&gt;} State Hook下面我们来看看在官方提供的一些 Hook 当中，它们是如何运作的，我们先从使用最为广泛的 State Hook 开始看起 你也许会很吃惊，但是 useState 这个 Hook 在后台其实是使用了 useReducer，并且它将 useReducer 作为预定义的 reducer（源码），这意味着 useState 返回的结果实际上已经是 reducer 的状态，同时也是 action dispatcher 123function basicStateReducer(state, action) { return typeof action === 'function' ? action(state) : action} 所以正如我们期望的那样，我们可以直接将 action dispatcher 和新的状态传入，也就是说我们也可以传入带 action 函数的 dispatcher，这个 action 函数可以接收旧的状态并返回新的状态，这意味着，当你向组件树发送状态设置器的时候，你可以修改父级组件修改状态，同时不用将它作为另一个属性传入，比如下面这个根据旧状态返回新状态的示例 1234567891011const ParentComponent = () =&gt; { const [name, setName] = useState() return &lt;ChildComponent toUpperCase={setName} /&gt;}const ChildComponent = (props) =&gt; { useEffect(() =&gt; { props.toUpperCase((state) =&gt; state.toUpperCase()) }, [true]) return null} Effect Hook最后我们再来看看 Effect Hook 是如何工作的，Effect Hook 对于组件的生命周期影响很大，但是它和其他 Hook 的行为有一些区别，并且它有一个附加的逻辑层 它在渲染时被创建，但是在浏览器绘制后运行 如果给出了销毁指令，它们将在下一次绘制前被销毁 它会按照定义的顺序被运行 因此，就应该有另一个队列来保存这些 Effect Hook，并且在绘制后能够被定位到，通常来说应该是组件保存包含了 effect 节点的队列，每个 effect 节点都是一个不同的类型，并能在适当的时候被定位到 在修改之前调用 getSnapshotBeforeUpdate() 实例（源码） 运行所有插入、更新、删除和 ref 的卸载（源码） 运行所有生命周期函数和 ref 回调函数，生命周期函数会在一个独立的通道中运行，所以整个组件树中所有的替换、更新、删除都会被调用，这个过程还会触发任何特定于渲染器的初始 Effect Hook（源码） useEffect() 调度的 effect 也被称为 被动的 effect Effect Hook 将会被保存在组件一个称为 updateQueue 的属性上，每个 effect 节点都有如下的结构（源码） tag，一个二进制数字，它控制了 effect 节点的行为（下面会进行介绍） create，『绘制之后』运行的回调函数 destroy，它是 create() 返回的回调函数，将会在『初始渲染前』运行 inputs，一个集合，该集合中的值将会决定一个 effect 节点是否应该被销毁或者重新创建 next，它指向下一个定义在函数组件中的 effect 节点 React 官方提供了一些比较特殊的 Hook，比如 useMutationEffect() 和 useLayoutEffect()，其实这两个 Effect Hook 内部使用了 useEffect()，实际上这就意味着它们能创建 Effect Hook，但是却使用了不同的 tag 属性值，这个 tag 属性值是由二进制的值组合而成（源码），下面是 React 支持的 Effect Hook 类型 12345678export const NoEffect = /* */ 0b00000000;export const UnmountSnapshot = /* */ 0b00000010;export const UnmountMutation = /* */ 0b00000100;export const MountMutation = /* */ 0b00001000;export const UnmountLayout = /* */ 0b00010000;export const MountLayout = /* */ 0b00100000;export const MountPassive = /* */ 0b01000000;export const UnmountPassive = /* */ 0b10000000; 这些二进制值中最常用的情景是使用管道符号（|）连接，将比特相加到单个某值上，然后我们就可以使用符号（&amp;）检查某个 tag 属性是否能触发一个特定的动作，如果结果是非零的，就表示能触发，关于位运算符更为详细的内容可以参考 标志位与掩码，下面是如何使用 React 的二进制设计模式的示例 123const effectTag = MountPassive | UnmountPassiveassert(effectTag, 0b11000000)assert(effectTag &amp; MountPassive, 0b10000000) 下面是 React 支持的 Effect Hook，以及它们的 tag 属性（源码） UnmountPassive | MountPassive（Default effect） UnmountSnapshot | MountMutation（Mutation effect） UnmountMutation | MountLayout（Layout effect） 下面是 React 如何检查动作触发的（源码） 123456if ((effect.tag &amp; unmountTag) !== NoHookEffect) { // Unmount}if ((effect.tag &amp; mountTag) !== NoHookEffect) { // Mount} 所以，基于我们前面介绍的 Effect Hook，我们可以实际操作，也就是从外部向组件插入一些 effect 12345678910111213141516171819202122232425function injectEffect(fiber) { const lastEffect = fiber.updateQueue.lastEffect const destroyEffect = () =&gt; { console.log('on destroy') } const createEffect = () =&gt; { console.log('on create') return destroy } const injectedEffect = { tag: 0b11000000, next: lastEffect.next, create: createEffect, destroy: destroyEffect, inputs: [createEffect], } lastEffect.next = injectedEffect}const ParentComponent = ( &lt;ChildComponent ref={injectEffect} /&gt;) 参考 Hook 简介 React Hooks 入门教程 从 Mixin 到 HOC 再到 Hook React Hooks 详解","link":"/2020/10/31/React/16/"},{"title":"Fiber 架构的简单实现","text":"我们在之前的文章当中梳理了 React Fiber 相关内容，了解了 Fiber 的基本作用以及它内部一些简单的运行原理，所以在本章当中我们来继续深入理解其原理，尝试尝试手动的模拟实现一个简易版本的 Fiber 架构，本文主要参考的是 Build your own React，内容有所调整，主要是为了方便自己理解，更多详细内容可以查看原文，下面我们就先从 JSX 开始看起 完整代码地址可见 Fiber 架构的简单实现 JSX我们都知道，JSX 是一种特殊的语法，在之前版本的 React 当中如果想要支持 JSX 语法的话还需要一个额外库的来进行支持（JSXTransformer.js），不过后来 JSX 的转换工作全部都集成到了 Babel 当中，比如下面这段简单的代码 1234567891011const App = ( &lt;div&gt; &lt;h1 id=\"title\"&gt;Title&lt;/h1&gt; &lt;a href=\"###\"&gt;Link&lt;/a&gt; &lt;section&gt; &lt;p&gt; Article &lt;/p&gt; &lt;/section&gt; &lt;/div&gt;) 我们可以通过 Babel 的 在线预览功能 来查看它转化后的样子，它是下面这样的 1234567891011121314151617181920212223var App = React.createElement( 'div', null, React.createElement( 'h1', { id: 'title', }, 'Title', ), React.createElement( 'a', { href: '###', }, 'Link', ), React.createElement( 'section', null, React.createElement('p', null, 'Article'), ),) 可以发现，我们书写的 JSX 代码已经被转换成了 React.createElement 的写法，同时从转换后的代码我们也可以发现 React.createElement 是支持多个参数的 type，也就是节点类型 config，节点上的属性，比如 id 和 href children，从第三个参数开始就全部是子元素，子元素可以有多个，类型可以是简单的文本，也可以还是 React.createElement，如果是 React.createElement 的话其实就是子节点了，子节点下面还可以有子节点，这样就用 React.createElement 的嵌套关系实现了 HTML 节点的树形结构 而我们上面这段 JSX 代码如果想在 React 框架下运行起来，还需要 React 提供的额外两个库来进行支持，如下 123456789101112131415161718import React from 'react'import ReactDOM from 'react-dom'const App = _ =&gt; { return ( &lt;div&gt; &lt;h1 id=\"title\"&gt;Title&lt;/h1&gt; &lt;a href=\"###\"&gt;Link&lt;/a&gt; &lt;section&gt; &lt;p&gt; Article &lt;/p&gt; &lt;/section&gt; &lt;/div&gt; )}ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 通过观察我们可以发现，这里面用到了 React 的地方其实就两个，一个是 JSX，也就是 React.createElement，另一个就是 ReactDOM.render，所以下面我们就先来简单的看看 createElement 和 render 这两个方法 createElement对于 &lt;h1 id=&quot;title&quot;&gt;Title&lt;/h1&gt; 这样一个简单的节点，我们都知道原生 DOM 会附加一大堆属性和方法在上面，所以我们在 createElement 的时候最好能将它转换为一种比较简单的数据结构，只包含我们需要的元素，比如下面这样 1234567{ type: 'h1', props: { id: 'title', children: 'Title' }} 有了这个数据结构后，我们对于 DOM 的操作其实可以转化为对这个数据结构的操作，新老 DOM 的对比其实也可以转化为这个数据结构的对比，这样我们就不需要每次操作都去渲染页面，而是等到需要渲染的时候才将这个数据结构渲染到页面上，这其实就是所谓的『虚拟 DOM』（以下我们简称为 vDom），而我们 createElement 就是负责来构建这个 vDom 的方法 这里关于 createElement 的实现就不具体展开了，详细可以参考我们之前已经整理过的 什么是 Virtual DOM 系列文章或是 官方源码 ，核心逻辑并不复杂，这里我们只需要知道它是用来帮助我们构建 vDom 的方法即可 render在上面的代码中我们使用 createElement 将 JSX 代码转换成了 vDom，但是我们又该如何将 vDom 渲染为真实的 DOM 节点呢？所以我们还需要一个 render 方法来帮助我们实现这个功能，我们通过上面的使用可以发现，render 方法接收两个参数 根组件，其实是一个 JSX 组件，也就是一个 createElement 返回的 vDom 父节点，也就是我们要将这个 vDom 渲染的位置 有了这些了解以后我们就可以来实现我们自己的 render 方法了 123456789101112131415161718192021222324function render(vDom, container) { let dom if (typeof vDom !== 'object') { dom = document.createTextNode(vDom) } else { dom = document.createElement(vDom.type) } // 将 vDom 上除了 children 外的属性都挂载到真正的 DOM 上去 if (vDom.props) { Object.keys(vDom.props) .filter(key =&gt; key != 'children') .forEach(item =&gt; { dom[item] = vDom.props[item] }) } // 如果还有子元素，递归调用 if (vDom.props &amp;&amp; vDom.props.children &amp;&amp; vDom.props.children.length) { vDom.props.children.forEach(child =&gt; render(child, dom)) } container.appendChild(dom)} 当然，上述代码只是简化版本的 render 方法，我们没有考虑节点具体类型的区别，又或是挂载和更新的不同处理逻辑等，详细内容同样可以参考我们之前已经整理过的 什么是 Virtual DOM 系列文章或是对应的 官方源码 来了解更多，因为这一部分在本文当中不是我们重点关注的内容，所以我们只是简单介绍一二，下面我们主要来看看 Fiber 的相关内容 render 的拆分我们在上面实现了将 vDom 渲染到页面上的代码，这部分的工作在 React 官方当中被称为 renderer，renderer 是第三方可以自己实现的一个模块，其中有个核心模块叫做 reconsiler，而 reconsiler 的一大功能就是大家熟知的 Diff，它会计算出应该更新哪些页面节点，然后将需要更新的节点 vDom 传递给 renderer，renderer 负责将这些节点渲染到页面上 但是这个流程有个问题，也是我们在 React Fiber 章节开头部分所提到的，那就是虽然 React 的 Diff 算法是经过优化的，但是它却是同步的，renderer 负责操作 DOM 的一些操作也是同步的，也就是说如果有大量节点需要更新，JavaScript 线程的运行时间可能会比较长，在这段时间浏览器是不会响应其它事件的，因为 JavaScript 线程和 GUI 线程是互斥的，如果这个时间太长了，用户就可能看到卡顿，这也就是为什么 React 会推出 Fiber 的原因，Fiber 可以将长时间的同步任务拆分成多个小任务，从而让浏览器能够抽身去响应其它事件，等它有空了再回来继续计算 但是我们在上面实现的 render 方法，它是直接递归遍历了整个树，如果我们在中途某一步停下来，下次再调用时其实并不知道上次在哪里停下来的，不知道从哪里开始，即使你将上次的结束节点记下来了，你也不知道下一个该执行哪个，所以之前简单的 vDom 树形结构并不满足中途暂停，下次继续的需求，所以我们就需要改造它的数据结构 而另一个需要解决的问题是，拆分下来的小任务什么时候执行？我们的目的是让用户有更流畅的体验，所以我们最好不要阻塞高优先级的任务，比如用户输入，动画之类，等它们执行完了我们再计算，那我怎么知道现在有没有高优先级任务，浏览器是不是空闲呢？所以总结下来，Fiber 要想达到目的，需要解决两个问题 新的任务调度，有高优先级任务的时候将浏览器让出来，等浏览器空了再继续执行 新的数据结构，可以随时中断，下次进来可以接着执行 所幸，针对这两点我们都已经有了对应的解决方式，也就是 之前文章 当中所提及到的 Fiber 数据结构与 requestIdleCallback 这个 API，这里我们就不过多介绍了，只简单提及一二 requestIdleCallbackrequestIdleCallback 接收一个回调，这个回调会在浏览器空闲时调用，每次调用会传入一个 IdleDeadline，可以得到当前还空余多久，options 可以传入参数最多等多久，等到了时间浏览器还不空就强制执行了，使用这个 API 可以解决我们之前提到的任务调度的问题，让浏览器在空闲时才计算 Diff 并渲染，调用方式如下 12345// 开启调用var handle = window.requestIdleCallback(callback[, options])// 结束调用Window.cancelIdleCallback(handle) 但是这个 API 还处在实验阶段，兼容性不好，所以 React 官方自己实现了一套，但是在这里我们就不考虑那么多了，还是使用 requestIdleCallback 来进行任务调度，我们进行任务调度的思想是将任务拆分成多个小任务，requestIdleCallback 里面不断的把小任务拿出来执行，当所有任务都执行完或者超时了就结束本次执行，同时要注册下次执行 这里我们可以借住官方的 workLoopSync 实现方式得出大致架子，如下所示 12345678910111213141516function workLoop(deadline) { // while 循环会在任务执行完或者时间到了的时候结束 while (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; 1) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork) } // 如果任务还没完，但是时间到了，我们需要继续注册 requestIdleCallback requestIdleCallback(workLoop)}// performUnitOfWork 用来执行任务，参数是我们的当前 fiber 任务，返回值是下一个任务function performUnitOfWork(fiber) {}requestIdleCallback(workLoop) Fiber 数据结构在上面的代码中，我们完成了任务的拆分，下面我们就来看看如果能让我们的任务可以随时中断，并且下次进来的时候还可以接着执行，上面示例中的 performUnitOfWork 方法我们暂时还没有实现，但是从上面的结构可以看出来，它接收的参数是一个小任务，同时通过这个小任务还可以找到它的下一个小任务，而 Fiber 构建的就是这样一个数据结构，而我们之前的 vDom 的数据结构是一棵树，父节点的 children 指向了子节点，但是只有这一个指针是不能实现中断继续的，所以我们需要对之前的结构进行一定的调整，可以参考官方演讲当中的方式，如下 我们可以发现和之前 vDom 当中父节点指向所有子节点不同，这里有三个指针 child，父节点指向第一个子元素的指针 sibling，从第一个子元素往后，指向下一个兄弟元素 return，所有子元素都有的指向父元素的指针 有了这几个指针后，我们可以在任意一个元素中断遍历并恢复，比如在上图 List 处中断了，恢复的时候可以通过 child 找到他的子元素，也可以通过 return 找到他的父元素，如果他还有兄弟节点也可以用 sibling 找到，Fiber 这个结构外形看着还是棵树，但是没有了指向所有子元素的指针，父节点只指向第一个子节点，然后子节点有指向其他子节点的指针，所以可以发现这其实是个『链表结构』 这里需要注意的是，真正的 Fiber 结构并不仅仅只多了这三个节点，但是这里我们只使用这三个节点来理解其原理就足够了，更多 Fiber 节点相关内容可见 Fiber 节点 Fiber 的实现有了以上内容的铺垫以后，下面我们就可以来实现一下我们自己的 Fiber 了，我们需要将我们之前的 vDom 结构转换为 Fiber 的数据结构，同时需要能够通过其中任意一个节点返回下一个节点，其实就是遍历这个链表 遍历的时候从根节点出发，先找子元素，如果子元素存在，直接返回，如果没有子元素了就找兄弟元素，找完所有的兄弟元素后再返回父元素，然后再找这个父元素的兄弟元素，整个遍历过程其实是个『深度优先遍历』，从上到下，然后最后一行开始从左到右遍历 比如下图从 div1 开始遍历的话，遍历的顺序就应该是 div1 ==&gt; div2 ==&gt; h1 ==&gt; a ==&gt; div2 ==&gt; p ==&gt; div1，可以看到这个序列中，当我们 return 父节点时，这些父节点会被第二次遍历，所以我们在设计的时候，return 的父节点不会作为下一个任务返回，只有 sibling 和 child 才会作为下一个任务返回 同样我们可以参考官方当中的 performUnitOfWork 来进行实现，它的作用是用来执行任务，参数是我们当前的 Fiber 任务，返回值是下一个任务，我们这里只是简单的模拟实现，官方版本当中的实现方式远比我们要复杂很多 1234567891011121314151617181920212223242526272829303132333435363738394041424344function performUnitOfWork(fiber) { if (!fiber.dom) { // 根节点的 dom 就是 container，如果没有这个属性，说明当前 fiber 不是根节点 fiber.dom = createDom(fiber) // 创建一个DOM挂载上去 } if (fiber.return) { // 如果有父节点，将当前节点挂载到父节点上 fiber.return.dom.appendChild(fiber.dom) } const elements = fiber.children // 将我们前面的 vDom 结构转换为 fiber 结构 let prevSibling = null if (elements &amp;&amp; elements.length) { for (let i = 0; i &lt; elements.length; i++) { const element = elements[i] const newFiber = { type: element.type, props: element.props, return: fiber, dom: null } if (i === 0) { // 父级的 child 指向第一个子元素 fiber.child = newFiber } else { // 每个子元素拥有指向下一个子元素的指针 prevSibling.sibling = newFiber } prevSibling = newFiber } } // 这个函数的返回值是下一个任务，这其实是一个深度优先遍历 // 先找子元素，没有子元素了就找兄弟元素，兄弟元素也没有了就返回父元素 // 然后再找这个父元素的兄弟元素，最后到根节点结束 // 这个遍历的顺序其实就是从上到下，从左到右 if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.return }} 统一提交上面我们的 performUnitOfWork 一边构建 Fiber 结构一边操作 DOM（appendChild），但是如果某次我们同时更新了好几个节点，而且在操作了第一个节点之后就中断了，那么我们可能只会看到第一个节点渲染到了页面，后续几个节点要等到浏览器空了才会去陆续渲染 为了避免这种情况，我们应该将 DOM 操作都搜集起来，最后统一执行，而这就是 commit 操作，为了能够记录位置，我们还需要一个全局变量 workInProgressRoot 来记录根节点，然后在 workLoop 检测如果任务执行完了，就统一 commit 1234567891011121314function workLoop(deadline) { // while 循环会在任务执行完或者时间到了的时候结束 while (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; 1) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork) } // 任务做完后统一渲染 if (!nextUnitOfWork &amp;&amp; workInProgressRoot) { commitRoot() } // 如果任务还没完，但是时间到了，我们需要继续注册 requestIdleCallback requestIdleCallback(workLoop)} 因为我们是在 Fiber 树完全构建后再执行的 commit，而且有一个变量 workInProgressRoot 指向了 Fiber 的根节点，所以我们可以直接把 workInProgressRoot 拿过来递归渲染就行了 123456789101112131415161718// 统一操作 DOMfunction commitRoot() { commitRootImpl(workInProgressRoot.child) // 开启递归 workInProgressRoot = null // 操作完后将 workInProgressRoot 重置}function commitRootImpl(fiber) { if (!fiber) { return } const parentDom = fiber.return.dom parentDom.appendChild(fiber.dom) // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child) commitRootImpl(fiber.sibling)} 协调协调其实就是 vDom 的 Diff 操作，需要添加新的节点，删除不需要的节点和更新修改过的节点，为了能在中断后能回到工作位置，我们还需要一个变量 currentRoot，然后在 fiber 节点里面添加一个属性 alternate，这个属性指向上一次运行的根节点，也就是 currentRoot currentRoot 会在第一次 render 后的 commit 阶段赋值，也就是每次计算完后都会把当次状态记录在 alternate 上，后面更新了就可以把 alternate 拿出来跟新的状态做 Diff，然后 performUnitOfWork 里面需要添加协调子元素的代码，所以我们可以新增一个比对函数 reconcileChildren 来将老节点跟新节点进行对比，逻辑如下 如果新老节点类型一样，复用老节点 DOM，更新 props 如果类型不一样，而且新的节点存在，创建新节点替换老节点 如果类型不一样，没有新节点，有老节点，删除老节点 注意删除老节点的操作是直接将 oldFiber 加上一个删除标记就行，同时用一个全局变量 deletions 记录所有需要删除的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function reconcileChildren(workInProgressFiber, elements) { // 构建 fiber 结构 let oldFiber = workInProgressFiber.alternate &amp;&amp; workInProgressFiber.alternate.child // 获取上次的 fiber 树 let prevSibling = null let index = 0 if (elements &amp;&amp; elements.length) { if (!oldFiber) { // 第一次没有 oldFiber，那全部是 REPLACEMENT for (let i = 0; i &lt; elements.length; i++) { const element = elements[i] const newFiber = buildNewFiber(element, workInProgressFiber) if (i === 0) { // 父级的 child 指向第一个子元素 workInProgressFiber.child = newFiber } else { prevSibling.sibling = newFiber // 每个子元素拥有指向下一个子元素的指针 } prevSibling = newFiber } } while (index &lt; elements.length &amp;&amp; oldFiber) { let element = elements[index] let newFiber = null const sameType = oldFiber // 对比 oldFiber 和当前 element（检测类型是否一样） &amp;&amp; element &amp;&amp; oldFiber.type === element.type if (sameType) { // 先比较元素类型，如果类型一样，复用节点，更新 props newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, return: workInProgressFiber, alternate: oldFiber, // 记录下上次状态 effectTag: 'UPDATE' // 添加一个操作标记 } } else if (!sameType &amp;&amp; element) { // 如果类型不一样，有新的节点，创建新节点替换老节点 newFiber = buildNewFiber(element, workInProgressFiber) } else if (!sameType &amp;&amp; oldFiber) { // 如果类型不一样，没有新节点，有老节点，删除老节点 oldFiber.effectTag = 'DELETION' // 添加删除标记 deletions.push(oldFiber) // 一个数组收集所有需要删除的节点 } oldFiber = oldFiber.sibling // 循环处理兄弟元素 if (index === 0) { // 父级的child指向第一个子元素 workInProgressFiber.child = newFiber } else { prevSibling.sibling = newFiber // 每个子元素拥有指向下一个子元素的指针 } prevSibling = newFiber index++ } }} 然后就是在 commit 阶段处理真正的 DOM 操作，具体的操作是根据我们的 effectTag 来进行判断的 1234567891011121314151617function commitRootImpl(fiber) { if (!fiber) { return } const parentDom = fiber.return.dom if (fiber.effectTag === 'REPLACEMENT' &amp;&amp; fiber.dom) { parentDom.appendChild(fiber.dom) } else if (fiber.effectTag === 'DELETION') { parentDom.removeChild(fiber.dom) } else if (fiber.effectTag === 'UPDATE' &amp;&amp; fiber.dom) { // 更新 DOM 属性 updateDom(fiber.dom, fiber.alternate.props, fiber.props) } // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child) commitRootImpl(fiber.sibling)} 替换和删除的 DOM 操作都比较简单，更新属性的会稍微麻烦点，需要再写一个辅助函数 updateDom 来实现 12345678910111213141516171819202122232425// 更新 DOM 的操作function updateDom(dom, prevProps, nextProps) { // 1、过滤 children 属性 // 2、老的存在，新的没了，取消 // 3、新的存在，老的没有，新增 Object.keys(prevProps) .filter(name =&gt; name !== 'children') .filter(name =&gt; !(name in nextProps)) .forEach(name =&gt; { if (name.indexOf('on') === 0) { dom.removeEventListener(name.substr(2).toLowerCase(), prevProps[name], false) } else { dom[name] = '' } }) Object.keys(nextProps) .filter(name =&gt; name !== 'children') .forEach(name =&gt; { if (name.indexOf('on') === 0) { dom.addEventListener(name.substr(2).toLowerCase(), nextProps[name], false) } else { dom[name] = nextProps[name] } })} 这里我们只是简单处理了 on 开头的一些事件，并且兼容性可能也会存在问题，而且 prevProps 和 nextProps 可能会遍历到相同的属性，有重复赋值，但是在这里我们也就不多做处理了，这里的主要目的其实是为了让我们了解其原理，更为完整的实现方式可以参考我们之前已经整理过的 渲染器的核心 Diff 算法 下面我们来看看如何支持函数组件 函数组件函数组件是 React 里面很常见的一种组件，但是我们之前的 fiber 节点上的 type 都是 DOM 节点的类型，比如 h1 之类的，而函数组件的节点 type 应该就是一个函数了，所以我们需要对这种节点进行单独处理，首先需要在更新的时候检测当前节点是不是函数组件，如果是的话那么 children 的处理逻辑会稍微有些不太一样，我们首先来调整一下我们的 performUnitOfWork 函数 12345678910111213141516171819202122232425262728293031323334function performUnitOfWork(fiber) { // ... const isFunctionComponent = fiber.type instanceof Function if (isFunctionComponent) { updateFunctionComponent(fiber) } else { updateHostComponent(fiber) } // ...}function updateFunctionComponent(fiber) { // 函数组件的 type 就是个函数，直接拿来执行可以获得 DOM 元素 const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children)}// updateHostComponent 就是之前的操作，只是单独抽取了一个方法function updateHostComponent(fiber) { if (!fiber.dom) { // 创建一个 DOM 挂载上去 fiber.dom = createDom(fiber) } // 将我们前面的 vDom 结构转换为 fiber 结构 const elements = fiber.props.children // 协调子元素 reconcileChildren(fiber, elements)} 然后在我们提交 DOM 操作的时候因为函数组件没有 DOM 元素，所以需要注意两点 获取父级 DOM 元素的时候需要递归往上找到真正的 DOM 删除节点的时候需要递归往下找到真正的节点 所以我们来修改下 commitRootImpl 12345678910111213141516171819202122232425262728293031323334353637function commitRootImpl(fiber) { if (!fiber) { return } // 不再直接获取，而是向上查找真正的 DOM // const parentDom = fiber.return.dom let parentFiber = fiber.return while (!parentFiber.dom) { parentFiber = parentFiber.return } const parentDom = parentFiber.dom if (fiber.effectTag === 'REPLACEMENT' &amp;&amp; fiber.dom) { parentDom.appendChild(fiber.dom) } else if (fiber.effectTag === 'DELETION') { // 这里也不再使用 parentDom.removeChild(fiber.dom) commitDeletion(fiber, parentDom) } else if (fiber.effectTag === 'UPDATE' &amp;&amp; fiber.dom) { // 更新DOM属性 updateDom(fiber.dom, fiber.alternate.props, fiber.props) } // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child) commitRootImpl(fiber.sibling)}function commitDeletion(fiber, domParent) { if (fiber.dom) { // DOM 存在，是普通节点 domParent.removeChild(fiber.dom) } else { // DOM 不存在，是函数组件，向下递归查找真实 DOM commitDeletion(fiber.child, domParent) }} 现在我们可以传入函数组件了 123456789101112131415161718192021import React from './myReact'const ReactDOM = Reactfunction App(props) { return ( &lt;div&gt; &lt;h1 id=\"title\"&gt;{props.title}&lt;/h1&gt; &lt;a href=\"xxx\"&gt;Jump&lt;/a&gt; &lt;section&gt; &lt;p&gt; Article &lt;/p&gt; &lt;/section&gt; &lt;/div&gt; )}ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 实现 useStateuseState 是 React Hooks 里面的一个 API，相当于之前 Class Component 里面的 state，用来管理组件内部状态，现在我们已经有一个简化版的 React 了，我们也可以尝试下来实现这个 API 简单版我们还是从用法入手来实现最简单的功能，我们一般使用 useState 是这样的 1234567891011121314151617function App(props) { const [count, setCount] = React.useState(1) const onClickHandler = () =&gt; { setCount(count + 1) } return ( &lt;div&gt; &lt;h1&gt;Count: {count}&lt;/h1&gt; &lt;button onClick={onClickHandler}&gt;Count + 1&lt;/button&gt; &lt;/div&gt; )}ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 上述代码可以看出，我们的 useState 接收一个初始值，返回一个数组，里面有这个 state 的当前值和改变 state 的方法，但是需要注意的是 App 作为一个函数组件，每次 render 的时候都会运行，也就是说里面的局部变量每次 render 的时候都会重置，那我们的 state 就不能作为一个局部变量，而是应该作为一个全部变量来进行存储 12345678910111213141516let state = nullfunction useState(init) { state = state === null ? init : state const setState = value =&gt; { // 修改 state 的方法 state = value workInProgressRoot = { // 只要修改了 state，我们就需要重新处理节点 dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改 nextUnitOfWork 指向 workInProgressRoot，这样下次就会处理这个节点了 nextUnitOfWork = workInProgressRoot deletions = [] } return [state, setState]} 这样其实我们就可以使用了 支持多个 state但是上面的代码当中只有一个 state 变量，如果我们有多个 useState 怎么办呢？为了能支持多个 useState，我们的 state 就不能是一个简单的值了，我们可以考虑把他改成一个数组，多个 useState 按照调用顺序放进这个数组里面，访问的时候通过下标来访问 123456789101112131415161718let state = []let hookIndex = 0function useState(init) { const currentIndex = hookIndex state[currentIndex] = state[currentIndex] === undefined ? init : state[currentIndex] const setState = value =&gt; { state[currentIndex] = value workInProgressRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } nextUnitOfWork = workInProgressRoot deletions = [] } hookIndex++ return [state[currentIndex], setState]} 支持多个组件上面的代码虽然我们支持了多个 useState，但是仍然只有一套全局变量，如果有多个函数组件，每个组件都来操作这个全局变量，那相互之间不就是污染了数据了吗？所以我们数据还不能全都存在全局变量上面，而是应该存在每个 Fiber 节点上，处理这个节点的时候再将状态放到全局变量用来通讯 12345// 申明两个全局变量，用来处理 useState// wipFiber 是当前的函数组件 fiber 节点// hookIndex 是当前函数组件内部 useState 状态计数let wipFiber = nulllet hookIndex = null 因为 useState 只在函数组件里面可以用，所以我们之前的 updateFunctionComponent 里面需要初始化处理 useState 变量 12345678function updateFunctionComponent(fiber) { wipFiber = fiber // 支持 useState，初始化变量 hookIndex = 0 wipFiber.hooks = [] // hooks 用来存储具体的 state 序列 // ...} 因为 Hooks 队列放到 Fiber 节点上去了，所以我们在 useState 取之前的值时需要从 fiber.alternate 上取，完整代码如下 12345678910111213141516171819202122function useState(init) { const oldHook = wipFiber.alternate // 取出上次的 Hook &amp;&amp; wipFiber.alternate.hooks &amp;&amp; wipFiber.alternate.hooks[hookIndex] const hook = { // Hook 数据结构 state: oldHook ? oldHook.state : init // state 是每个具体的值 } wipFiber.hooks.push(hook) // 将所有 useState 调用按照顺序存到 fiber 节点上 hookIndex++ const setState = value =&gt; { // 修改 state 的方法 hook.state = value workInProgressRoot = { // 只要修改了 state，我们就需要重新处理这个节点 dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改 nextUnitOfWork 指向 workInProgressRoot，这样下次 requestIdleCallback 就会处理这个节点了 nextUnitOfWork = workInProgressRoot deletions = [] } return [hook.state, setState]} 在上面的代码当中可以看出，我们在将 useState 和存储的 state 进行匹配的时候是用的 useState 的调用顺序匹配 state 的下标，如果这个下标匹配不上了，state 就错了，所以在 React 文档当中特意强调了不要在判断当中使用 useState 123if (something) { const [state, setState] = useState(1)} 比如上述代码就不能保证每次 something 都满足，可能导致 useState 这次 render 执行了，下次又没执行，这样新老节点的下标就匹配不上了，对于这种代码，React 就会直接报错 用 Hooks 模拟 Class 组件这个算是一个扩展功能，通过前面实现的 Hooks 来模拟实现 Class 组件，我们可以写一个方法将 Class 组件转化为前面的函数组件 12345678910function transfer(Component) { return function (props) { const component = new Component(props) let [state, setState] = useState(component.state) component.props = props component.state = state component.setState = setState return component.render() }} 然后就可以写 Class 了，这个 Class 长得很像我们在 React 里面写的 Class，有 state，setState 和 render 12345678910111213141516171819202122232425262728import React from './myReact'class Count { constructor(props) { this.props = props this.state = { count: 1 } } onClickHandler = () =&gt; { this.setState({ count: this.state.count + 1 }) } render() { return ( &lt;div&gt; &lt;h3&gt;Class Component Count: {this.state.count}&lt;/h3&gt; &lt;button onClick={this.onClickHandler}&gt;Count + 1&lt;/button&gt; &lt;/div&gt; ) }}// export 的时候用 transfer 包装下export default React.transfer(Count) 然后使用的时候直接使用 &lt;Count&gt; 就行了 123&lt;div&gt; &lt;Count&gt;&lt;/Count&gt;&lt;/div&gt; 当然你也可以在 React 里面建一个空的 Class Component，让 Count 继承它，这样就更像了 完整代码汇总以后的代码如下，完整代码地址可见 Fiber 架构的简单实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321// 最基本的 vDomfunction createTextVDom(text) { return { type: 'TEXT', props: { nodeValue: text, children: [] } }}function createElement(type, props, ...children) { // 核心逻辑不复杂，将参数都房到一个对象上返回就行 // 将 children 放到 props 当中，这样我们在组件里面就能通过 this.props.children 拿到子元素 return { type, props: { ...props, children: children.map(child =&gt; { return typeof child === 'object' ? child : createTextVDom(child) }) } }}// 创建 DOM 的操作function createDom(vDom) { let dom // 检查当前节点是文本还是对象 if (vDom.type === 'TEXT') { dom = document.createTextNode(vDom.props.nodeValue) } else { dom = document.createElement(vDom.type) // 将 vDom 上除了 children 外的属性都挂载到真正的 DOM 上去 if (vDom.props) { Object.keys(vDom.props) .filter(key =&gt; key !== 'children') .forEach(item =&gt; { if (item.indexOf('on') === 0) { dom.addEventListener(item.substr(2).toLowerCase(), vDom.props[item], false) } else { dom[item] = vDom.props[item] } }) } } return dom}// 更新 DOM 的操作function updateDom(dom, prevProps, nextProps) { // 1. 过滤 children 属性 // 2. 老的存在，新的没了，取消 // 3. 新的存在，老的没有，新增 Object.keys(prevProps) .filter(name =&gt; name !== 'children') .filter(name =&gt; !(name in nextProps)) .forEach(name =&gt; { if (name.indexOf('on') === 0) { dom.removeEventListener(name.substr(2).toLowerCase(), prevProps[name], false) } else { dom[name] = '' } }) Object.keys(nextProps) .filter(name =&gt; name !== 'children') .forEach(name =&gt; { if (name.indexOf('on') === 0) { dom.addEventListener(name.substr(2).toLowerCase(), nextProps[name], false) } else { dom[name] = nextProps[name] } })}// 统一操作 DOMfunction commitRoot() { deletions.forEach(commitRootImpl) // 执行真正的节点删除 commitRootImpl(workInProgressRoot.child) // 开启递归 currentRoot = workInProgressRoot // 记录一下 currentRoot workInProgressRoot = null // 操作完后将 workInProgressRoot 重置}function commitDeletion(fiber, domParent) { if (fiber.dom) { domParent.removeChild(fiber.dom) // DOM 存在，是普通节点 } else { commitDeletion(fiber.child, domParent) // DOM 不存在，是函数组件，向下递归查找真实 DOM }}function commitRootImpl(fiber) { if (!fiber) { return } // 不再直接获取，而是向上查找真正的 DOM // const parentDom = fiber.return.dom let parentFiber = fiber.return while (!parentFiber.dom) { parentFiber = parentFiber.return } const parentDom = parentFiber.dom if (fiber.effectTag === 'REPLACEMENT' &amp;&amp; fiber.dom) { parentDom.appendChild(fiber.dom) } else if (fiber.effectTag === 'DELETION') { // 这里也不再使用 parentDom.removeChild(fiber.dom) commitDeletion(fiber, parentDom) } else if (fiber.effectTag === 'UPDATE' &amp;&amp; fiber.dom) { // 更新 DOM 属性 updateDom(fiber.dom, fiber.alternate.props, fiber.props) } // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child) commitRootImpl(fiber.sibling)}// 任务调度，使用 workLoop 用来调度任务let nextUnitOfWork = nulllet workInProgressRoot = nulllet currentRoot = nulllet deletions = nullfunction workLoop(deadline) { while (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; 1) { // 这个 while 循环会在任务执行完或者时间到了的时候结束 nextUnitOfWork = performUnitOfWork(nextUnitOfWork) } // 任务做完后统一渲染 if (!nextUnitOfWork &amp;&amp; workInProgressRoot) { commitRoot() } // 如果任务还没完，但是时间到了，我们需要继续注册 requestIdleCallback requestIdleCallback(workLoop)}function buildNewFiber(fiber, workInProgressFiber) { return { type: fiber.type, props: fiber.props, dom: null, // 构建 fiber 时没有 DOM，下次 perform 这个节点是才创建 DOM return: workInProgressFiber, alternate: null, // 新增的没有老状态 effectTag: 'REPLACEMENT' // 添加一个操作标记 }}function reconcileChildren(workInProgressFiber, elements) { // 构建 fiber 结构 let oldFiber = workInProgressFiber.alternate &amp;&amp; workInProgressFiber.alternate.child // 获取上次的 fiber 树 let prevSibling = null let index = 0 if (elements &amp;&amp; elements.length) { if (!oldFiber) { // 第一次没有 oldFiber，那全部是 REPLACEMENT for (let i = 0; i &lt; elements.length; i++) { const element = elements[i] const newFiber = buildNewFiber(element, workInProgressFiber) if (i === 0) { // 父级的 child 指向第一个子元素 workInProgressFiber.child = newFiber } else { prevSibling.sibling = newFiber // 每个子元素拥有指向下一个子元素的指针 } prevSibling = newFiber } } while (index &lt; elements.length &amp;&amp; oldFiber) { let element = elements[index] let newFiber = null const sameType = oldFiber // 对比 oldFiber 和当前 element（检测类型是否一样） &amp;&amp; element &amp;&amp; oldFiber.type === element.type if (sameType) { // 先比较元素类型，如果类型一样，复用节点，更新 props newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, return: workInProgressFiber, alternate: oldFiber, // 记录下上次状态 effectTag: 'UPDATE' // 添加一个操作标记 } } else if (!sameType &amp;&amp; element) { // 如果类型不一样，有新的节点，创建新节点替换老节点 newFiber = buildNewFiber(element, workInProgressFiber) } else if (!sameType &amp;&amp; oldFiber) { // 如果类型不一样，没有新节点，有老节点，删除老节点 oldFiber.effectTag = 'DELETION' // 添加删除标记 deletions.push(oldFiber) // 一个数组收集所有需要删除的节点 } oldFiber = oldFiber.sibling // 循环处理兄弟元素 if (index === 0) { // 父级的child指向第一个子元素 workInProgressFiber.child = newFiber } else { prevSibling.sibling = newFiber // 每个子元素拥有指向下一个子元素的指针 } prevSibling = newFiber index++ } }}// 申明两个全局变量，用来处理 useState// wipFiber 是当前的函数组件 fiber 节点// hookIndex 是当前函数组件内部 useState 状态计数let wipFiber = nulllet hookIndex = nullfunction useState(init) { const oldHook = wipFiber.alternate // 取出上次的 Hook &amp;&amp; wipFiber.alternate.hooks &amp;&amp; wipFiber.alternate.hooks[hookIndex] const hook = { // Hook 数据结构 state: oldHook ? oldHook.state : init // state 是每个具体的值 } wipFiber.hooks.push(hook) // 将所有 useState 调用按照顺序存到 fiber 节点上 hookIndex++ const setState = value =&gt; { // 修改 state 的方法 hook.state = value workInProgressRoot = { // 只要修改了 state，我们就需要重新处理这个节点 dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改 nextUnitOfWork 指向 workInProgressRoot，这样下次 requestIdleCallback 就会处理这个节点了 nextUnitOfWork = workInProgressRoot deletions = [] } return [hook.state, setState]}function updateFunctionComponent(fiber) { wipFiber = fiber // 支持 useState，初始化变量 hookIndex = 0 wipFiber.hooks = [] // Hooks 用来存储具体的 state 序列 const children = [fiber.type(fiber.props)] // 函数组件的 type 就是个函数，直接拿来执行可以获得 DOM 元素 reconcileChildren(fiber, children)}// updateHostComponent 就是之前的操作，只是单独抽取了一个方法function updateHostComponent(fiber) { if (!fiber.dom) { // 创建一个 DOM 挂载上去 fiber.dom = createDom(fiber) } // 将我们前面的 vDom 结构转换为 fiber 结构 const elements = fiber.props.children // 协调子元素 reconcileChildren(fiber, elements)}// performUnitOfWork 用来执行任务，参数是我们的当前 fiber 任务，返回值是下一个任务function performUnitOfWork(fiber) { // 检测函数组件 const isFunctionComponent = fiber.type instanceof Function if (isFunctionComponent) { updateFunctionComponent(fiber) } else { updateHostComponent(fiber) } // 这个函数的返回值是下一个任务，这其实是一个深度优先遍历 // 先找子元素，没有子元素了就找兄弟元素，兄弟元素也没有了就返回父元素 // 然后再找这个父元素的兄弟元素，最后到根节点结束 // 这个遍历的顺序其实就是从上到下，从左到右 if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.return }}// 使用 requestIdleCallback 开启 workLooprequestIdleCallback(workLoop)function render(vDom, container) { workInProgressRoot = { dom: container, props: { children: [vDom] }, alternate: currentRoot } deletions = [] nextUnitOfWork = workInProgressRoot}class Component { constructor(props) { this.props = props }}function transfer(Component) { return function (props) { const component = new Component(props) let [state, setState] = useState(component.state) component.props = props component.state = state component.setState = setState return component.render() }}export default { createElement, render, useState, Component, transfer} 总结我们简单总结一下上面涉及到的一些知识点 我们写的 JSX 代码最终会被 Babel 转化成了 React.createElement() 的形式 React.createElement() 返回的其实就是虚拟 DOM 结构 ReactDOM.render 方法是将 vDom 渲染到页面上 vDom 的协调和渲染可以简单粗暴的递归，但是这个过程是同步的，如果需要处理的节点过多，可能会阻塞用户输入和动画播放，造成卡顿 为了解决这个问题，React 引入了 Fiber 结构，目的是将同步的协调变成异步的 Fiber 改造了 vDom 的结构，形成具有『父元素 ==&gt; 第一个子元素』，『子元素 ==&gt; 兄弟元素』，『子元素 ==&gt; 父元素』这样的链表结构，有了这几个指针，可以从任意一个 Fiber 节点找到其他节点 Fiber 将整棵树的同步任务拆分成了每个节点可以单独执行的异步执行结构 Fiber 可以从任意一个节点开始遍历，遍历是深度优先遍历，顺序是『父元素 ==&gt; 子元素 ==&gt; 兄弟元素 ==&gt; 父元素』，也就是从上往下，从左往右 Fiber 的协调阶段可以是异步的小任务，但是提交阶段（commit）必须是同步的，因为异步的 commit 可能让用户看到节点一个一个接连出现，体验不好 函数组件其实就是这个节点的 type 是个函数，直接将 type 拿来运行就可以得到 vDom useState 是在 Fiber 节点上添加了一个数组，数组里面的每个值对应了一个 useState，useState 调用顺序必须和这个数组下标匹配，不然会报错（所以不能在判断当中使用 useState） 参考 ReactFiberWorkLoop.new A Cartoon Intro to Fiber React Fiber 浅析 React Fiber React Fiber 架构","link":"/2020/12/19/React/19/"},{"title":"移动端开发相关内容汇总","text":"最后更新于 2019-12-02 由于最近在工作当中经常遇到移动端的一些相关问题，所以打算抽些时间来重新的梳理一下，主要目的是厘清 Web 移动端开发的前前后后，一些技术的发展过程，一些问题的优化手段以及给出一些常见的兼容性问题的解决方案，主要参考的是 移动端的兼容适配 这篇文章，内容有所调整，主要是方便自己理解，如果想了解更为详细的流程可以参考原文 响应式设计首先我们先来看看『响应式设计』，这个与移动端开发有着密切的联系，响应式设计即是 RWD（Responsive Web Design） 根据维基百科及其参考文献，理论上响应式界面能够适应不同的设备，描述响应式界面最著名的一句话就是 Content is like water，翻译成中文便是『如果将屏幕看作容器，那么内容就像水一样』 为什么要设计响应式界面那么为什么要费神的尝试统一所有设备呢？简单来说主要有以下几点 即便是 PC 或 Mac 用户，调查显示只有一半的人会将浏览器全屏显示，而剩下的一般人使用多大的浏览器，很难预知 台式机、投影、电视、笔记本、手机、平板、手表、VR 等智能设备正在不断增加，主流设备的概念正在消失 屏幕分辨率正飞速发展，同一张图片在不同设备上看起来，大小可能天差地别 鼠标、触屏、笔、摄像头手势等不可预期的操控方式正在不断出现 响应式界面的四个层次 同一页面在不同大小和比例上看起来都应该是舒适的 同一页面在不同分辨率上看起来都应该是合理 同一页面在不同操作方式（如鼠标和触屏）下，体验应该是统一的 同一页面在不同类型的设备（手机、平板、电脑）上，交互方式应该是符合习惯的 响应式界面的基本规则 可伸缩的内容区块，内容区块的在一定程度上能够自动调整，以确保填满整个页面 可自由排布的内容区块，当页面尺寸变动较大时，能够减少或是增加排布的列数 适应页面尺寸的边距，到页面尺寸发生更大变化时，区块的边距也应该变化 能够适应比例变化的图片，对于常见的宽度调整，图片在隐去两侧部分时，依旧保持美观可用 能够自动隐藏或是显示部分的内容，如在电脑上显示的的大段描述文本，在手机上就只能少量显示或全部隐藏 能自动折叠的导航和菜单，展开还是收起，应该根据页面尺寸来判断 放弃使用像素作为尺寸单位，用 dp（对于前端来说，这里可能是 em/rem）尺寸等方法来确保页面在分辨率相差很大的设备上，看起来也能保持一致，同时也要求提供的图片应该比预想的更大，才能适应高分辨率的屏幕 上面一段我觉得已经涵盖了响应式设计的绝大部分，简单总结起来，可以概括为 媒体查询，边界断点的规则设定（Media queries &amp;&amp; break point） 内容的可伸缩性效果（Flexibel visuals） 流式网格布局（Fluid grids） 主要内容呈现及图片的高质量（Main content and high quality） 响应式和自适应响应式设计是 Responsive Web Design（RWD），自适应设计是 Adaptive Web Design（AWD），经常有人会将两者混为一谈，或者其实根本也区分不了所谓的响应式与自适应 RWD 和 AWD 两者都是为了适配各种不同的移动设备，致力于提升用户体验所产生的的技术，核心思想是用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕，通常认为 RWD 是 AWD 的子集 RWD，Ethan Marcote 的文章是大家认为 RWD 的起源，他提出的 RWD 方案是通过 HTML 和 CSS 的媒体查询技术，配合流体布局实现，RWD 倾向于只改变元素的外观布局，而不大幅度改变内容，Jeffrey Zeldman 总结说，我们就把 RWD 定义为一切能用来为各种分辨率和设备性能优化视觉体验的技术 AWD，Adaptive Design 是 Aaron Gustafson 的书的标题，他认为 AWD 在包括 RWD 的 CSS 媒体查询技术以外，也要用 JavaScript 来操作 HTML 来更适应移动设备的能力，AWD 有可能会针对移动端用户减去内容，减去功能，AWD 可以在服务器端就进行优化，把优化过的内容送到终端上 一图胜千言 从定义上而言 RWD 是一套代码，适用于所有屏幕，而 AWD 则是多端多套代码，本文不会过多去纠结响应式与自适应区别，这两者的本质都是致力于适配不同设备，更好地提升用户体验，更多相关内容可以参考下面两个链接 Responsive Design vs. Adaptive Design Responsive design 和 Adaptive design 的区别 渐进增强和优雅降级 渐进增强（progressive enhancement），针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 优雅降级（graceful degradation），一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 两者的区别是，优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要，降级意味着往回看，而渐进增强则意味着朝前看，同时保证其根基处于安全地带 渐进增强和优雅降级通常是 AWD 会牵扯到的另一个技术术语，本质上而言即是随着屏幕的大小的改变，功能会一点一点增强，也通常会用在一些高级 CSS3 属性上，我们对一些 CSS 属性进行特性检测，甚至不进行特性检测直接使用，后果是在支持它的网页上该属性正常展示，而不支持它的网页该属性不生效，但也不影响用户的基本使用 典型的例子是 CSS3 逐渐被大众认可并被使用，PC 端页面开始由低版本的 IE 向兼容性更好的 IE 9+，Chrome，Firefox 浏览器转变的时期，我们可以对页面元素直接使用阴影，圆角等属性，对于不支持它的低版本 IE 而言，没有什么损失，而对于支持它的高级浏览器而言，带给了用户更好的交互视觉体验，这就是渐进增强 移动端屏幕适配方案我们在下面会针对一些具体的案例来深入的了解，首先来看高保真还原设计稿，也就是如何适配移动端繁杂的屏幕大小，通常而言设计师只会给出单一分辨率下的设计稿，而我们要做的，就是以这个设计稿为基准，去适配所有不同大小的移动端设备 在此之前，有一些基础概念需要我们先行理解 设备独立像素这里以 iPhone 6/7/8 为例，我们打开 Chrome 开发者工具，如下图 这里的 375 * 667 表示的是设备独立像素（DIP），也可以理解为 CSS 像素，也称为『逻辑像素』，简单来说就是 设备独立像素 = CSS 像素 = 逻辑像素 物理像素那么什么又是物理像素呢，我们到电商网站购买手机，都会看一看手机的参数，以 iPhone 7 为例 可以看到，iPhone 7 的分辨率是 1334 x 750，这里描述的就是屏幕实际的物理像素，物理像素又称为『设备像素』，显示屏是由一个个物理像素点组成的，1334 x 750 表示手机分别在垂直和水平上所具有的像素点数，通过控制每个像素点的颜色，就可以使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位为 pt，简单来说就是 设备像素 = 物理像素 DPR（Device Pixel Ratio）设备像素比有了上面两个概念以后，我们就可以顺理成章引出下一个概念，DPR（Device Pixel Ratio）设备像素比，这个与我们通常说的视网膜屏（多倍屏，Retina 屏）有关 设备像素比描述的是未缩放状态下，物理像素和设备独立像素的初始比例关系，简单的计算公式是下面这样的 DPR = 物理像素 / 设备独立像素 我们套用一下上面 iPhone 7 的数据（取设备的物理像素宽度与设备独立像素宽度进行计算），可以发现 iPhone 7 的 DPR = iPhone 7 的物理像素宽度 / iPhone 7 的设备独立像素宽度 = 2 其实也就是 750 / 375 = 2 或者是 1334 / 667 = 2，所以我们可以得到 iPhone 7 的 dpr 为 2，这也就是我们常说的『视网膜屏幕』，而视网膜（Retina）屏幕是苹果公司的一个营销术语，简单来说就是苹果公司将 dpr &gt; 1 的屏幕称为视网膜屏幕 在视网膜屏幕中，以 dpr = 2 为例，把 4（2 x 2）个像素当 1 个像素使用，这样让屏幕看起来更精致，但是元素的大小本身不会改变 下面我们再来看看 iPhone XS Max 它的物理像素如上图是 2688 x 1242 而它的 CSS 像素是 896 x 414，所以我们可以很容易得出 iPhone XS Max 的 dpr 为 3 至此，我们也算是完成了一个小的里程碑，我们通常说的 H5 手机适配其实也就是指的这两个维度 适配不同屏幕大小，也就是适配不同屏幕下的 CSS 像素 适配不同像素密度，也就是适配不同屏幕下 dpr 不一致导致的一些问题 当然这里还有一些其他比较重要的概念，比如 PPI、DPI 等，但是我们就不详细展开了，可以自行去加深理解 适配不同屏幕大小通常我们在移动端开发过程当中，都会添加一个移动端专用的 meta 标签，也就是下面这样的 1&lt;meta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;\"&gt; 那么它的具体含义是什么样的呢？其中视口（viewport）代表当前可见的计算机图形区域，在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI，菜单栏等，即指你正在浏览的文档的那一部分，而关于 content 参数的含义可以参考下表 属性 含义 取值 width 定义视口的宽度，单位为像索 正整数或设备宽度 device-width height 定义视口的高度，单位为像索 正整数或 device-height initial-scale 定义初始缩放值 整数或小数 minimum-scale 定义缩小最小比例，它必须小于或等于 maximum-scale 设置 整数或小数 maximum-scale 定义放大最大比例，它必须大于或等于 minimum-scale 设置 整数或小数 user-scalable 定义是否允许用户手动缩放页面，默认值 yes yes/no 我们在移动端视口要想视觉效果和体验好，那么我们的视口宽度必去无限接近理想视口，而所谓的理想视口，一般来讲，这个视口其实不是真是存在的，它对设备来说是一个最理想布局视口尺寸，在用户不进行手动缩放的情况下，可以将页面理想地展示，那么所谓的理想宽度就是浏览器（屏幕）的宽度了 于是上述的 meta 设置，就是我们的理想设置，它规定了我们的视口宽度为屏幕宽度，初始缩放比例为 1，就是初始时候我们的视觉视口就是理想视口，下面我们就来看看有哪些比较常用的适配方法 通常来说，适配不同屏幕大小，也就是适配不同屏幕下的 CSS 像素，最早移动端屏幕 CSS 像素适配方案是媒体查询，但是无法做到接近 100% 的还原，适配不同屏幕大小其实只需要遵循一条原则，确保页面元素大小的与屏幕大小保持一定比例，也就是『按比例还原设计稿』 假设我们现在拿到标注为 375 * 667 的大小的设计稿，其中一个元素的标注如下 以页面宽度为基准的话，那么 元素的宽度为 209 / 375 = 55.73% 元素的高度为 80 / 375 = 21.33% 元素的上左右边距依次计算 这样，无论屏幕的 CSS 像素宽度是 320px 还是 375px 还是 414px，按照等量百分比还原出来的界面总是正确的 然而，理想很丰满，现实很骨感，实现上述百分比方案的核心需要一个全局通用的基准单位，让所有百分比展示以它为基准，但是在 CSS 中，根据 CSS Values and Units Module Level 4 的定义 百分比值总要相对于另一个量，比如长度，每个允许使用百分比值的属性，同时也要定义百分比值参照的那个量，这个量可以是相同元素的另一个属性的值，也可以是祖先元素的某个属性的值，甚至是格式化上下文的一个度量（比如包含块的宽度） 具体来说就是 宽度（width）、间距（maring/padding）支持百分比值，但默认的相对参考值是包含块的宽度 高度（height）百分比的大小是相对其父级元素高的大小 边框（border）不支持百分值 边框圆角半径（border-radius）支持百分比值，但水平方向相对参考值是盒子的宽度，垂直方向相对参考值是盒子的高度 文本大小（font-size）支持百分比值，但相对参考值是父元素的 font-size 的值 盒阴影（box-shadow）和文本阴影（text-shadow）不支持百分比值 首先，支持百分比单位的度量属性有其各自的参照基准，其次并非所有度量属性都支持百分比单位，所以我们需要另辟蹊径 rem 适配方案在 vw 方案出来之前，最被大众接受的就是使用 rem 进行适配的方案，因为 rem 满足上面说的，可以是一个全局性的基准单位 rem（font size of the root element）在 CSS Values and Units Module Level 3 中的定义就是，根据网页的根元素来设置字体大小，和 em（font size of the element）的区别是，em 是根据其父元素的字体大小来设置，而 rem 是根据网页的跟元素（html）来设置字体大小 flexible基于此，淘宝早年推行的一套以 rem 为基准的适配方案 lib-flexible，其核心做法在于 根据设备的 dpr 动态改写 &lt;meta&gt; 标签，设置 viewport 的缩放 给 &lt;html&gt; 元素添加 data-dpr 属性，并且动态改写 data-dpr 的值 根据 document.documentElement.clientWidth 动态修改 &lt;html&gt; 的 font-size，页面其他元素使用 rem 作为长度单位进行布局，从而实现页面的等比缩放 只不过关于上面划掉的两点，是因为现在的 lib-flexible 库已经不再去缩放 viewport，字体大小的设定也直接使用了 rem hotcsshotcss 不是一个库，也不是一个框架，它是一个移动端布局开发解决方案，使用 hotcss 可以让移动端布局开发更容易，本质的思想与 flexible 完全一致 rem 方案的一些总结使用 flexible/hotcss 作为屏幕宽度适配解决方案，是存在一些问题的 动态修改 viewport 是存在一定的风险的，譬如通过 viewport 改变了页面的缩放之后，获取到的 innerWidth/innerHeight 也会随之发生变化，如果业务逻辑有获取此类高宽进行其他计算的，可能会导致意想不到的错误（其实到今天，其实存在很多在 flexible 基础上演化而来的各种 rem 解决方案，有的不会对 viewport 进行缩放处理，自行处理 1px 边框问题） flexible/hotcss 都并非纯 CSS 方案，需要引入一定的 JavaScript 代码 rem 的设计初衷并非是用于解决此类问题，用 rem 进行页面的宽度适配多少有一种 hack 的感觉 存在一定的兼容性问题，对于安卓 4.4 以下版本系统不支持 viewport 缩放（当然 flexible 处理 Android 系列时，始终认为其 dpr 为 1，没有进行 viewport 缩放） vw 适配方案严格来说，使用 rem 进行页面适配其实是一种 hack 手段，rem 单位的初衷本身并不是用来进行移动端页面宽度适配的，到了今天有了一种更好的替代方案，那就是使用 vw 进行适配，也就是『百分比适配』 百分比适配方案的核心需要一个全局通用的基准单位，rem 是不错，但是需要借助 JavaScript 进行动态修改根元素的 font-size，而 vw/vh（vmax/vmin）的出现则很好弥补 rem 需要 JavaScript 辅助的缺点 CSS Values and Units Module Level 4 的定义，vw 等于初始包含块（html 元素）宽度的 1%，也就是 1vw 等于 window.innerWidth 的数值的 1% 1vh 等于 window.innerHeight 的数值的 1% 再以上面设计稿图的元素为例，那么 元素的宽度为 209 / 375 = 55.73% = 55.73vw 元素的高度为 80 / 375 = 21.33% = 21.33vw 元素的上左右边距依次计算 根据相关的测试，可以使用 vw 进行长度单位的有 容器大小适配，可以使用 vw 文本大小的适配，可以使用 vw 大于 1px 的边框、圆角、阴影都可以使用 vw 内距和外距，可以使用 vw 简单的一个页面，看看效果，完全是等比例缩放的效果，线上预览地址可见 CodePen 自动转换插件当我们使用 rem 作为长度单位的时，通常会有借助 Sass/Less 实现一个转换函数，像是这样 123456// 假设设计稿的宽度是 375px，假设取设计稿宽度下 1rem = 100px$baseFontSize: 100;@function px2rem($px) { @return $px / $baseFontSize * 1rem;} 同理，在 vw 方案下，我们只需要去改写这个方法 1234// 假设设计稿的宽度是 375px@function px2vw($px) { @return $px / 375 * 100vw;} 当然，我们还可以借助一些插件包去实现这个自动转换，提高效率，譬如 postcss-px-to-viewport vw polyfill但是 vw 目前毕竟还是存在兼容问题的，如下 看上去其实已经覆盖了绝大部分设备，但是如果在业务使用中又真的出现了兼容问题，应该怎么处理呢？通常来说，有下面两种方式可以进行降级处理 CSS Houdini，通过 CSS Houdini 针对 vw 做处理，调用 CSS Typed OM Level1 提供的 CSSUnitValue API CSS Polyfill，通过相应的 Polyfill 做相应的处理，目前针对于 vw 单位的 Polyfill 主要有 vminpoly、Viewport Units Buggyfill、vunits.js 和 Modernizr 等 对于 vw 方案的一些总结vw 确实看上去很不错，但是也是存在它的一些问题 也没能很好的解决 1px 边框在高清屏下的显示问题，需要自行处理 由于 vw 方案是完全的等比缩放，在完全等比还原设计稿的同时带来的一个问题是无法很好的限定一个最大最小宽度值，由于 rem 方案是借助 JavaScript 的，所以这一点 rem 比 vw 会更加的灵活 当然，两个方案现阶段其实都可以使用甚至一起搭配使用，更多详情可以参考下面几个链接 再聊移动端页面的适配 H5 必知必会之像素级还原设计稿 Responsive And Fluid Typography With vh And vw Units 使用 VH 和 VW 实现真正的流体排版 1px 边框上面我们说到使用 vw 适配屏幕大小方案，其中有一个缺点就是在 Retina 屏下，无法很好的展示真正的 1px 物理像素线条，设计师想要的 Retina 下 border: 1px，其实是 1 物理像素宽度，而不是 1 CSS 像素宽度，对于 CSS 而言 在 dpr = 1 时，此时 1 物理像素等于 1 CSS 像素宽度 在 dpr = 2 时，此时 1 物理像素等于 0.5 CSS 宽度像素，可以认为 border-width: 1px 这里的 1px 其实是 1 CSS 像素宽度，等于 2 像素物理宽度，设计师其实想要的是 border-width: 0.5px 在 dpr = 3 时，此时 1 物理像素等于 0.33 CSS 宽度像素，设计师其实想要的是 border-width: 0.333px 然而并不是所有手机浏览器都能识别 border-width: 0.5px，在 iOS 7 以下，Android 等其他系统里，小于 1px 的单位会被当成为 0px 处理，那么如何实现这 0.5px、0.33px 呢？ 比较常见的解决方式有以下几种，线上预览地址可见 CodePen 渐变实现 使用缩放实现 使用图片实现（base64） 使用 SVG 实现（嵌入 background-url） 图片适配及优化图像通常占据了网页上下载资源绝的大部分，优化图像通常可以最大限度地减少从网站下载的字节数以及提高网站性能，通常我们可以采取以下这些通用的优化手段 消除多余的图像资源 尽可能利用 CSS3/SVG 矢量图像替代某些光栅图像 谨慎使用字体图标，使用网页字体取代在图像中进行文本编码 选择正确的图片格式 为不同 DPR 屏幕提供最适合的图片尺寸 在这里我们主要重点关注如何在不同的 dpr 屏幕下，让图片看起来都不失真，首先就是上述的第二点，尽可能利用 CSS3/SVG 矢量图像替代某些光栅图像，而像某些简单的几何图标，可以用 CSS3 快速实现的图形，都应该尽量避免使用光栅图像，这样能够保证它们在任何尺寸下都不会失真 其次，实在到了必须使用光栅图像的地步，也是有许多方式能保证图像在各种场景下都不失真 无脑多倍图在移动端假设我们需要一张 CSS 像素为 300 x 200 的图像，考虑到现在已经有了 dpr = 3 的设备，那么要保证图片在 dpr = 3 的设备下也正常高清展示，我们最大可能需要一张 900 x 600 的原图，这样不管设备的 dpr 是否为 3，我们统一都使用 3 倍图，这样即使在 dpr = 1，dpr = 2 的设备上，也能非常好的展示图片 当然这样并不可取，会造成大量带宽的浪费，并且现代浏览器，提供了更好的方式，让我们能够根据设备 dpr 的不同，提供不同尺寸的图片 srcset 配合 1x 2x 像素密度描述符简单来说，srcset 可以根据不同的 dpr 拉取对应尺寸的图片 1234567&lt;div class='illustration'&gt; &lt;img src='illustration-small.png' srcset='images/illustration-small.png 1x, images/illustration-big.png 2x' style='max-width: 500px' /&gt;&lt;/div&gt; 上面 srcset 里的 1x，2x 表示『像素密度描述符』，简单来说就是 当屏幕的 dpr = 1 时，使用 images/illustration-small.png 这张图 当屏幕的 dpr = 2 时，使用 images/illustration-big.png 这张图 srcset 属性配合 sizes 属性 w 宽度描述符上面的 1x，2x 的写法比较容易接受易于理解，但是除此之外，srcset 属性还有一个 w 宽度描述符，配合 sizes 属性一起使用可以覆盖更多的面，比如下面这个示例 12345&lt;img sizes=\"(min-width: 600px) 600px, 300px\" src=\"photo.png\" srcset=\"photo@1x.png 300w, photo@2x.png 600w, photo@3x.png 1200w\"/&gt; 其中 sizes = &quot;(min-width: 600px) 600px, 300px&quot; 的意思是，如果屏幕当前的 CSS 像素宽度大于或者等于 600px，则图片的 CSS 宽度为 600px，反之则图片的 CSS 宽度为 300px 也就是 sizes 属性声明了在不同宽度下图片的 CSS 宽度表现，这里可以理解为，大屏幕下图片宽度为 600px，小屏幕下图片宽度为 300px（具体的媒体查询代码由 CSS 实现） 但是需要注意的是，这里的 sizes 属性只是声明了在不同宽度下图片的 CSS 宽度表现，而具体使图片在大于 600px 的屏幕上展示为 600px 宽度的代码需要另外由 CSS 或者 JavaScript 实现 而 srcset = &quot;photo@1x.png 300w, photo@2x.png 600w, photo@3x.png 1200w&quot; 里面的 300w，600w，900w 叫宽度描述符，那么我们该如何确定当前场景会选取哪张图片呢？ 当前屏幕 dpr = 2，CSS 宽度为 375px当前屏幕 CSS 宽度为 375px，则图片 CSS 宽度为 300px，分别用上述 3 个宽度描述符的数值除以 300 300 / 300 = 1 600 / 300 = 2 1200 / 300 = 4 上面得到的 1、2、4 即是算出的有效的像素密度，换算成和 x 描述符等价的值，这里 600w 算出的 2 即满足 dpr = 2 的情况选择此张图 当前屏幕 dpr = 3，CSS 宽度为 414px当前屏幕 CSS 宽度为 414px，则图片 CSS 宽度仍为 300px，再计算一次 300 / 300 = 1 600 / 300 = 2 1200 / 300 = 4 因为 dpr = 3，2 已经不满足了，则此时会选择 1200w 这张图 当前屏幕 dpr = 1，CSS 宽度为 1920px当前屏幕 CSS 宽度为 1920px，则图片 CSS 宽度变为了 600px，再计算一次 300 / 600 = .5 600 / 600 = 1 1200 / 600 = 2 因为 dpr = 1，所以此时会选择 600w 对应的图片，具体使用方式可以参考 CodePen 这个示例 简单总结就是此方案的意义在于考虑到了响应性布局的复杂性与屏幕的多样性，利用上述规则，可以一次适配 PC 端大屏幕和移动端高清屏，一箭多雕，此外 CSS 还有个类似的属性 image-set()，搭配使用，效果更佳，其他更多内容可以参考以下链接 Google Web Fundamentals – Web Responsive Images 响应式图片 srcset 全新释义 sizes 属性 w 描述符 字体适配方案本小节当中我们主要来看看字体相关的适配方案 字体大小字体是很多前端开发同学容易忽略的一个点，但是其中也是有很多小知识点，首先要知道，浏览器有最小字体限制 PC 上最小 font-size = 12px 手机上最小 font-size = 8px 如果小于最小字体，那么字体默认就是最小字体，其次很多早期的文章规范都建议不要使用奇数级单位来定义字体大小（如 13px，15px 等），容易在一些低端设备上造成字体模糊，出现锯齿 字体的选择展示在字体适配上面，我们需要从『性能』和『展示效果』两个维度去考虑，完整的一个字体资源实在太大了，所以我们应该尽可能的使用用户设备上已有的字体，而不是额外去下载字体资源，从而使加载时间明显加快 而从展示效果层面来说，使用系统字体能更好的与当前操作系统使用的相匹配，得到最佳的展示效果，所以我们在字体使用方面，有一个应该尽量去遵循的原则，也是现在大部分网站在字体适配上使用的策略，那就是『尽量去使用各个支持平台上的默认系统字体』 兼顾各个操作系统我们通常比较常见的操作系统有 Windows、Windows Phone、Mac OS X、iPhone、Android Phone、Linux 等，当然对于普通用户而言，无须关注 Linux 系统，我们下面就以 CSS-Trick 网站最新的 font-family 为例，看看是如何在字体选择上做到适配各个操作系统的 1234{ font-family: system-ui, -apple-system, BlinkMacSystemFont, segoe ui, Roboto, Helvetica, Arial, sans-serif, apple color emoji, segoe ui emoji, segoe ui symbol;} font-family 关键字对于 CSS 中的 font-family 而言，它有两类取值 一类是类似这样的具体的字体族名定义 font-family: Arial 这里定义了一个具体的字体样式，字体族名为 Arial 一类是通用字体族名，它是一种备选机制，用于在指定的字体不可用时给出较好的字体，类似这样 font-family: sans-serif 其中 sans-serif 表无衬线字体族，例如 'Open Sans'，'Arial'，'微软雅黑' 等等，关于通用字体族名，在 CSS Fonts Module Level 3 – Basic Font Properties 中定义了 5 个，也就是我们熟知的几个通用字体族名 serif，衬线字体族 sans-serif，非衬线字体族 monospace，等宽字体，即字体中每个字宽度相同 cursive，草书字体 fantasy，主要是那些具有特殊艺术效果的字体 新增通用字体族关键字而在 CSS Fonts Module Level 4 – Basic Font Properties 中，新增了几个关键字 system-ui，系统默认字体 emoji，用于兼容 emoji 表情符号字符 math，适用于数学表达式 fangsong，此字体系列用于中文的（仿宋）字体 下面我们还是以上面的 font-family 为例，看看它们几者之间的区别 system-ui简单而言，font-family: system-ui 的目的就是在不同的操作系统的 Web 页面下，自动选择本操作系统下的默认系统字体 默认使用特定操作系统的系统字体可以提高性能，因为浏览器或者 WebView 不必去下载任何字体文件，而是使用已有的字体文件，font-family: system-ui 字体设置的优势之处在于它与当前操作系统使用的字体相匹配，对于文本内容而言，它可以得到最恰当的展示 San Francisco Fonts我们在上面简单的了解了 system-ui 字体族，但是像 -apple-system、BlinkMacSystemFont 并没有在最新的标准里出现，那它们又代表什么意思呢？ 在此之前，我们需要先了解一下 San Francisco Fonts，San Francisco Fonts 又叫旧金山字体，是一款西文字体，随着 iOS 9 更新面世，在 WatchOS 中随 Apple Watch 一起悄然发售，并且还将在 Apple TV 上的新 tvOS 中使用 San Francisco Fonts 在 iOS 系统上用于替代升级另外一款西文字体 Helvetica Neue，Apple 做了一些重要的改变，使其成为平台上更好的，甚至是完美的西文字体 -apple-system/BlinkMacSystemFont话说回来，正如每个前端开发人员都知道的那样，将一个功能纳入规范是一回事，将其纳入浏览器又是另一回事，幸运的是 system-ui 的普及很快，Chrome 和 Safari 都可以在各种平台上完全支持它，只有 Mozilla 和 Windows 相对落后，我们来看看 system-ui 的兼容性 仔细看上图的最后两行 Supported as the -apple-system value（only on macOS and iOS） Supported as the BlinkMacSystemFont value（only on macOS） 考虑到不同平台及向后兼容，在 macOS 和 iOS 上，我们需要使用 -apple-system 及 BlinkMacSystemFont 来兼容适配 system-ui 标准 Segoe UISegoe UI 是 Windows 从 Vista 开始的默认西文字体族，只有西文，不支持汉字，属于无衬线体，它也表示一个系列而不是某一款字体 使用 font-family: Segoe UI 可以在 Windows 平台及 Windows Phone 上选取最佳的西文字体展示 RobotoRoboto 是为 Android 操作系统设计的一个无衬线字体家族，Google 描述该字体为现代的、但平易近人和有感情的 这个字体家族包含 Thin、Light、Regular、Medium、Bold、Black 六种粗细及相配的斜体 总结到此，我们可以总结一下了，还是以上面 CSS-Trick 网站的 font-family 定义为例子 1234{ font-family: system-ui, -apple-system, BlinkMacSystemFont, segoe ui, Roboto, Helvetica, Arial, sans-serif, apple color emoji, segoe ui emoji, segoe ui symbol;} system-ui，使用各个支持平台上的默认系统字体 -apple-system， 在一些稍低版本 Mac OS X 和 iOS 上，它针对旧版上的 Neue Helvetica 和 Lucida Grande 字体，升级使用更为合适的 San Francisco Fonts BlinkMacSystemFont，针对一些 Mac OS X 上的 Chrome 浏览器，使用系统默认字体 segoe ui，在 Windows 及 Windows Phone 上选取系统默认字体 Roboto，面向 Android 和一些新版的的 Chrome OS Helvetica/Arial，在针对不同操作系统不同平台设定采用默认系统字体后，针对一些低版本浏览器的降级方案 sans-serif，兜底方案，保证字体风格统一，至少也得是无衬线字体 上述 5 个字体族定义，优先级由高到底，可以看到，它们 5 个都并非某个特定字体，基本的核心思想都是选择对应平台上的默认系统字体，涵盖了 iOS、MAC OS X、Android、Windows、Windows Phone 基本所有用户经常使用的主流操作系统 使用系统默认字体的主要原因是性能，字体通常是网站上加载的最大（也可能是最重）的资源之一，如果我们可以使用用户机器上已有的字体，我们就完全不需要再去获取字体资源，从而使加载时间明显加快，并且系统字体的优点在于它与当前操作系统使用的相匹配，因此它的文本展示必然也是一个让人舒适展示效果 当然，上述 font-family 的定义不一定是最佳的，譬如天猫移动端在 font-family 最前面添加了 'PingFang SC'，'miui' 等字体，想必也是有他们业务上的考虑，这里我们就再来简单的看看天猫的字体定义与 Github 的字体定义，比较比较它们两者有什么异同 天猫 的定义为 font-family: &quot;PingFang SC&quot;, miui, system-ui, -apple-system, BlinkMacSystemFont, Helvetica Neue, Helvetica, sans-serif; Github 的定义为 font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol; 对比可以发现，它们总体遵循了这样一个基本原则 尽量使用系统默认字体 使用系统默认字体的主要原因是性能，并且系统字体的优点在于它与当前操作系统使用的相匹配，因此它的文本展示必然也是一个让人舒适展示效果 兼顾中西，西文在前，中文在后 中文或者西文（英文）都要考虑到，由于大部分中文字体也是带有英文部分的，但是英文部分又不怎么好看，但是英文字体中大多不包含中文，通常会先进行英文字体的声明，选择最优的英文字体，这样不会影响到中文字体的选择，中文字体声明则紧随其次 兼顾多操作系统 选择字体的时候要考虑多操作系统，例如 MAC OS 下的很多中文字体在 Windows 都没有预装，为了保证 MAC 用户的体验，在定义中文字体的时候，先定义 MAC 用户的中文字体，再定义 Windows 用户的中文字体 兼顾旧操作系统，以字体族系列 serif 和 sans-serif 结尾 当使用一些非常新的字体时，要考虑向下兼容，兼顾到一些极旧的操作系统，使用字体族系列 serif 和 sans-serif 结尾总归是不错的选择 暂时就总结这么多，更多的关于字体方面的细节知识，可以参考下面这几个链接 Web 字体 font-family 再探秘 你该知道的字体 – font-family Web 字体 font-family 再探秘 Using UI System Fonts In Web Design: A Quick Practical Guide System Fonts in CSS Apple’s San Francisco Font 前端布局的兼容适配最后我们再来简单的了解一下前端布局的兼容适配，因为前端工程师的一大工作内容就是页面布局，无论在 PC 端还是移动端，页面布局的兼容适配都是重中之重，在整个前端发展的历程中，布局的方法也在不断的推陈出新 布局发展历程简单来说，前端的布局发展历程经历了下面几个过程 表格布局 ==&gt; 定位布局 ==&gt; 浮动布局 ==&gt; flexbox 布局 ==&gt; gridbox 布局 每一种布局在特定时期都发挥了重要的作用，而每一种新的布局方式的出现，往往都是因为现有的布局方式已经在该时期已经无法很好的满足开发者的需求，无法满足越来越潮流的页面布局的方式，以 Flexbox 的出现为例子，在 Flexbox 被大家广为接受使用之前，我们一直在使用定位+浮动的布局方式，像下面这个布局 容器宽度不定，内部三个元素，均分排列且占满整个空间，并且垂直居中，如果使用定位加浮动的布局方式，你无法很快想到最佳的解决方式，三个元素并排那么必然需要浮动或者绝对定位，容器宽度不定且中间元素始终居中，需要顾虑的方面就很多了，也许使用 text-align: justufy 可以 hack 实现等等，然而使用 flexbox 布局的话，只需要下面三行代码就可以了 12345.container { display: flex; justify-content: space-between; align-items: center;} flexbox 的出现，一次性解决了流动布局，弹性布局，排列方式等多个问题，并且它是简洁的，可控的，再来看一个例子，水平垂直居中一个元素，使用 flexbox 也许是最便捷的，线上预览地址可见 CodePen 1234567.container { display: flex;}.item { margin: auto;} CSS Grid Layoutflexbox 已经足够优秀了，为什么 gird 网格布局的出现又是为什么？它又解决了哪些 flex 布局无法很好解决的问题呢？先来看看下面这张图 flexbox 是一维布局，他只能在一条直线上放置你的内容区块，而 grid 是一个二维布局，它除了可以灵活的控制水平方向之外，还能轻易的控制垂直方向的布局模式，对于上图那样的九宫格布局，它就可以轻而易举的完成，如果用图片来进行表示的话，flexbox 是下面这样的 而 gridbox 则是 在现阶段，移动端布局应当更多使用 flexbox 去完成（相对那些还在使用 float 布局的），而考虑到未来页面布局的推陈出新，对于 Grid 布局我们应当像前几年对待 flexbox 一样，重视起来，随着兼容性的普及，Grid 布局也会慢慢成为主流","link":"/2017/08/12/JavaScript/02/"},{"title":"深入 Vuex","text":"在上一章 Vuex 框架核心流程 当中，我们介绍了 Vuex 的一些常见的 API 以及初始化装载与注入的流程，我们可以再来看一下入口文件，源码如下 12345678910111213import { Store, install } from './store'import { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from './helpers'export default { Store, install, version: '__VERSION__', mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers} 通过观察可以发现，其实 Vuex 真正核心的就是 store 这个东西，而始化装载与注入（install）我们在上一章已经介绍过了，剩下的一些也都是一些辅助方法，所以在本章，我们就深入的来了解一下这个 store 到底是什么东西 通常我们在使用 Vuex 的时候，会实例化 store 类，然后传入一个对象，包括我们定义好的 actions，getters，mutations，state 等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象，store 对象的逻辑比较复杂，下面有一个构造方法的整体逻辑流程 环境判断12345678910// store.js ==&gt; https://github.com/vuejs/vuex/blob/dev/src/store.js// 使用断言函数，// 确保 Vue 的存在，也就是在实例化 Store 之前，必须要保证之前的 install 方法已经执行过// 另外一点就是需要支持 promise 语法，因为 Vuex 是依赖 promise 的if (process.env.NODE_ENV !== 'production') { assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `Store must be called with the new operator.`)} assert 函数是一个简单的断言函数 1234// util.jsexport function assert(condition, msg) { if (!condition) throw new Error(`[vuex] ${msg}`)} 数据初始化、module 树构造然后根据 new 构造传入的 options 或默认值，初始化内部数据 1234567// 利用解构赋值，拿到 options 里面的 plugins 和 strict// plugins 表示应用的插件// strict 表示是否开启严格模式const { plugins = [], strict = false} = options 12345678910111213141516171819202122232425// 是否在进行提交状态标识，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中// 而不能在外部随意修改 statethis._committing = false// 存储用户定义的所有的 actionsthis._actions = Object.create(null)this._actionSubscribers = []// mutationsthis._mutations = Object.create(null)// 封装后的 getters 集合对象this._wrappedGetters = Object.create(null)// 用于支持 store 分模块传入，存储分析后的 modulesthis._modules = new ModuleCollection(options)// 模块命名空间 mapthis._modulesNamespaceMap = Object.create(null)// 订阅函数集合，Vuex 提供了 substcribe 功能，用来存储所有对 mutation 变化的订阅者this._subscribers = []// 一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化this._watcherVM = new Vue() new ModuleCollection(options)调用 new Vuex.Store(options) 时传入的 options 对象，用于构造 MoudleCollection 类 12345678910111213141516171819202122232425262728293031323334353637383940// module/module-collection.jsclass ModuleCollection { constructor(rawRootModule) { // 将传入的 options 对象整个构造为一个 module 对象 // 并循环调用 register() 方法为其中的 modules 属性进行模块注册，使其都成为 module 对象 // 最后 options 对象被构造成一个完整的组件树 // register root module (Vuex.Store options) this.register([], rawRootModule, false) } // ... register(path, rawModule, runtime = true) { // ... // 分割模块的情况 const newModule = new Module(rawModule, runtime) if (path.length === 0) { this.root = newModule // &lt;=== 这里是 ① } else { const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) } // register nested modules if (rawModule.modules) { forEachValue(rawModule.modules, (rawChildModule, key) =&gt; { this.register(path.concat(key), rawChildModule, runtime) }) } }}// util.jsexport function forEachValue(obj, fn) { Object.keys(obj).forEach(key =&gt; fn(obj[key], key))} 然后绑定 dispatch 与 commit 方法 123456789101112131415161718192021// 把 Store 类的 dispatch 和 commit 方法的 this 指针指向当前 store 的实例上// bind commit and dispatch to selfconst store = thisconst { dispatch, commit } = this// 封装替换原型中的 dispatch 和 commit 方法，详细解释见下方this.dispatch = function boundDispatch(type, payload) { return dispatch.call(store, type, payload)}this.commit = function boundCommit(type, payload, options) { return commit.call(store, type, payload, options)}// 是否开启严格模式this.strict = strict// state 没有放在上面 options 对象中初始化了，改为在 module/module.js 下初始化// 详细可见 module/module.jsconst state = this._modules.root.state dispatch 和 commit 方法dispatchdispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action，因为支持两种调用方式，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行 12345678910111213141516171819202122232425dispatch(_type, _payload) { // check object-style dispatch const { type, payload } = unifyObjectStyle(_type, _payload) // 配置参数处理 const action = { type, payload } // 当前 type 下所有 action 处理函数集合 const entry = this._actions[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown action type: ${type}`) } return } // 订阅者函数遍历执行，传入当前的 action 对象和当前的 state this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload)} commit12345678910111213141516171819202122232425262728293031323334353637commit(_type, _payload, _options) { // check object-style commit const { type, payload, options } = unifyObjectStyle(_type, _payload, _options) // 同上 const mutation = { type, payload } const entry = this._mutations[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown mutation type: ${type}`) } return } // 专用修改 state 方法，其余修改 state 的方法均为非法修改 this._withCommit(() =&gt; { entry.forEach(function commitIterator(handler) { handler(payload) }) }) // 同上，传入参数的不同 this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) { console.warn( `[vuex] mutation type: ${type}. Silent option has been removed. ` + `Use the filter functionality in the vue-devtools` ) }} 初始化核心 - Store1234567891011// init root module.// this also recursively registers all sub-modules// and collects all module getters inside this._wrappedGettersinstallModule(this, state, [], this._modules.root)// initialize the store vm, which is responsible for the reactivity// (also registers _wrappedGetters as computed properties)resetStoreVM(this, state)// apply pluginsplugins.forEach(plugin =&gt; plugin(this)) 上面这三个方法就是 store 的核心内容了 installModule 主要完成模块的 state，mutations，actions 和 getters 的注册工作 resetStoreVM 这个方法是对 state 和 getters 进行最后的使用处理，从而用户可以调用这些状态 plugins 这个不用多说，应用插件 接下来会详细介绍 store 中的三个核心方法 installModule，resetStoreVM 和 plugins installModuleinstallModule 的作用主要是初始化组件树根组件，注册所有子组件，并将其中所有的 getters 存储到 this._wrappedGetters 属性中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 接收五个参数// store 当前 Store 的实例// rootState 根 state// path 当前嵌套模块的路径数组// module 当前安装的模块// hot 当动态改变 modules 或者热更新的时候为 truefunction installModule(store, rootState, path, module, hot) { // 判断是否为根 const isRoot = !path.length /** * 我们在构造函数中调用的时候为 installModule(this, state, [], options) * 所以这里的 path.length 为空，所以 isRoot 为 true * 而 module 自然就是传递进来的 options * 即 state，actions，mutations，getters 和嵌套的 modules */ // 新增的模块命名空间 const namespace = store._modules.getNamespace(path) // register in namespace map // 是否设置了命名空间，若存在则在 namespace 中进行 module 的存储 if (module.namespaced) { store._modulesNamespaceMap[namespace] = module } // set state // 非根组件设置 state 方法 if (!isRoot &amp;&amp; !hot) { // 在不是根组件且不是 hot 条件的情况下 // 通过 getNestedState 方法拿到该 module 父级的 state /** // 根据 path 查找 state 上的嵌套 state function getNestedState (state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state } */ const parentState = getNestedState(rootState, path.slice(0, -1)) // 由于模块的 path 是根据模块的名称 concat 连接的 // 所以 path 的最后一个元素就是当前模块的模块名 // 然后拿到其所在的 moduleName const moduleName = path[path.length - 1] /** _withCommit (fn) { // 保存之前的提交状态 const committing = this._committing // 进行本次提交，若不设置为 true，直接修改 state // 在 strict 模式下，Vuex 将会产生非法修改 state 的警告 this._committing = true // 执行 state 的修改操作 fn() // 修改完成后还原本次修改之前的状态 this._committing = committing } */ // 一个代理方法，Vuex 中所有触发 mutation 的进行 state 的修改操作都会经过它 // 保证同步修改 state 的过程中 this._committing 的值始终为 true // 可以统一管理监控 state 状态的修改 // 这样当我们观测 state 的变化的时候，如果 this._committing 不为 true，则说明这个状态的修改是有问题的 // 拿到 parentState 和 moduleName // 然后利用 Vue.set 方法将 state 设置到父级 state 对象的 moduleName 属性中 // 由此实现该模块的 state 注册 // 注：如果是首次执行，因为是根目录注册，所以并不会执行该条件中的方法 store._withCommit(() =&gt; { Vue.set(parentState, moduleName, module.state) }) } // module 上下文环境设置 // 命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值 // makeLocalContext 方法会为该 module 设置局部的 dispatch，commit 方法以及 getters 和 state（namespace 的存在需要做兼容处理） const local = module.context = makeLocalContext(store, namespace, path) // 分别对 mutations，actions，getters 进行注册，见下 // 注册对应模块的 mutation，供 state 修改使用 module.forEachMutation((mutation, key) =&gt; { const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) }) // 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用 module.forEachAction((action, key) =&gt; { const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) }) // 注册对应模块的 getters，供 state 读取使用 module.forEachGetter((getter, key) =&gt; { const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) }) // 这个是 Store 中的 Module // 需要注意这里传入的 path 参数是不为空的 // 注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身 // 为子组件注册其 state，actions、mutations 以及 getters 等 module.forEachChild((child, key) =&gt; { installModule(store, rootState, path.concat(key), child, hot) })} mutations、actions 以及 getters 注册定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等，逻辑关系见下图 registerMutation简单来说，就是获取 store 中的对应的 mutation type 的处理函数集合，将新的处理函数 push 进去，这里对设置在 mutation type 上对应的 handler 进行封装，给原函数传入 state，所以在执行比如 commit('xxx', payload) 的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload，这就是在 handler 里面拿到 state 的原因 1234567891011121314151617// 接收四个参数// store 为当前 Store 实例// type 为 mutation 的 type// handler 为 mutation 执行的回调函数，作用就是同步修改当前模块的 state// local 为当前模块的路径function registerMutation(store, type, handler, local) { // 通过 type 拿到对应的 mutation 对象数组 const entry = store._mutations[type] || (store._mutations[type] = []) // 将 mutation 包装成函数 push 到数组当中，同时添加载荷 payload 参数 // 所以 commit 实际调用的不是我们传入的 handler，而是经过封装的 entry.push(function wrappedMutationHandler(payload) { // 调用 handler 并将 state 传入 handler.call(store, local.state, payload) })} registerAction 和 registerGetteraction 和 getter 的注册也是同理，唯一区别就是 action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作，registerAction 函数是对 store 的 action 的初始化，它和 registerMutation 的参数一致，不同的地方在于，mutation 是同步修改当前模块的 state，而 action 是可以异步的通过提交一个 mutation 去修改 state 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function registerAction(store, type, handler, local) { // 通过 type 拿到对应的 actions 对象数组 const entry = store._actions[type] || (store._actions[type] = []) // 存储新的封装过的 action handler entry.push(function wrappedActionHandler(payload, cb) { // 传入 state 等对象供我们之前的 action handler 使用 let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload, cb) /* export function isPromise (val) { return val &amp;&amp; typeof val.then === 'function' } */ // 兼容 Promise if (!isPromise(res)) { res = Promise.resolve(res) } // 判断 store._devtoolHook，只有当用到 Vuex devtools 开启的时候，才能捕获 Promise 过程 if (store._devtoolHook) { return res.catch(err =&gt; { store._devtoolHook.emit('vuex:error', err) throw err }) } else { return res } })}function registerGetter(store, type, rawGetter, local) { // getters 只允许存在一个处理函数，若重复需要报错 if (store._wrappedGetters[type]) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] duplicate getter key: ${type}`) } return } // 存储新的封装过的 getters 处理函数 store._wrappedGetters[type] = function wrappedGetter(store) { // 为之前的 getters 传入对应的状态 return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) }} resetStoreVM执行完各 module 的 install 之后，执行 resetVM 方法，进行 store 组件的初始化，本质上，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state，actions，mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function resetStoreVM(store, state, hot) { // 缓存前 vm 组件，保留 state 树 const oldVm = store._vm // bind store public getters store.getters = {} const wrappedGetters = store._wrappedGetters const computed = {} // 循环所有处理过的 getters，并新建 computed 对象进行存储 // 通过 Object.defineProperty 方法为 getters 对象建立属性 // 使得我们可以通过 this.$store.getters.xxxgetter 能够访问到该 getters // store._vm[xxxgetter] ==&gt; computed[xxxgetter] ==&gt; xxxgetter 对应的回调函数 forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent // 暂时设置为静默模式，避免因而加载某些插件触发的警告 Vue.config.silent = true // 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的） store._vm = new Vue({ data: { $$state: state }, computed }) // 恢复 Vue 的模式 Vue.config.silent = silent // enable strict mode for new vm if (store.strict) { // 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state enableStrictMode(store) } // 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null // 强制更新所有监听者（watchers），待更新生效 // DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用 if (oldVm) { if (hot) { // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; { oldVm._data.$$state = null }) } Vue.nextTick(() =&gt; oldVm.$destroy()) }}// 监视 state 的变化，如果没有通过 this._withCommit() 方法进行 state 修改，则报错function enableStrictMode(store) { store._vm.$watch(function () { return this._data.$$state }, () =&gt; { if (process.env.NODE_ENV !== 'production') { assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`) } }, { deep: true, sync: true })} plugin 注入最后就是 plugin 的注入 12// apply pluginsplugins.forEach(plugin =&gt; plugin(this)) 源码整体汇总最后，我们在将之前介绍的一些零散的源码来进行汇总，结果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762// store.js// 定义局部变量 Vue，用于判断是否已经装载和减少全局作用域查找let Vue // bind on installexport class Store { constructor(options = {}) { // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 // 源码中所涉及到的方法 /* // store.js 最后导出部分 export function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue) } // mixin.js export default function (Vue) { const version = Number(Vue.version.split('.')[0]) if (version &gt;= 2) { Vue.mixin({ beforeCreate: vuexInit }) } else { // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = {}) { options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) } } function vuexInit() { const options = this.$options // 将初始化 Vue 根组件时传入的 store 设置到 this 对象的 $store 属性上 // 子组件从其父组件引用 $store 属性，层层嵌套进行设置 if (options.store) { this.$store = typeof options.store === 'function' ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { this.$store = options.parent.$store } } } */ // 判断若处于浏览器环境下且加载过 Vue，则执行 install 方法 // 见上方 install ==&gt; applyMixin ==&gt; mixin.js 中的 vuexInit if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) { install(window.Vue) } // 使用断言函数， // 确保 Vue 的存在，也就是在实例化 Store 之前，必须要保证之前的 install 方法已经执行过 // 另外一点就是需要支持 Promise 语法，因为 Vuex 是依赖 Promise 的 if (process.env.NODE_ENV !== 'production') { assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `Store must be called with the new operator.`) } // 利用解构赋值，拿到 options 里面的 plugins 和 strict // plugins 表示应用的插件 // strict 表示是否开启严格模式 const { plugins = [], strict = false } = options // store internal state // 是否在进行提交状态标识，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中 // 而不能在外部随意修改 state this._committing = false // 存储用户定义的所有的 actions this._actions = Object.create(null) this._actionSubscribers = [] // mutations this._mutations = Object.create(null) // 封装后的 getters 集合对象 this._wrappedGetters = Object.create(null) /* // module/module-collection.js class ModuleCollection { constructor(rawRootModule) { // 将传入的 options 对象整个构造为一个 module 对象 // 并循环调用 register() 方法为其中的 modules 属性进行模块注册，使其都成为 module 对象 // 最后 options 对象被构造成一个完整的组件树 // register root module (Vuex.Store options) this.register([], rawRootModule, false) } // ... register(path, rawModule, runtime = true) { // ... // 分割模块的情况 const newModule = new Module(rawModule, runtime) if (path.length === 0) { this.root = newModule // &lt;=== 这里是 ① } else { const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) } // register nested modules // util.js export function forEachValue (obj, fn) { Object.keys(obj).forEach(key =&gt; fn(obj[key], key)) } if (rawModule.modules) { forEachValue(rawModule.modules, (rawChildModule, key) =&gt; { this.register(path.concat(key), rawChildModule, runtime) }) } } } */ // 用于支持 store 分模块传入，存储分析后的 modules // ModuleCollection 见上方 this._modules = new ModuleCollection(options) // 模块命名空间 map this._modulesNamespaceMap = Object.create(null) // 订阅函数集合，Vuex 提供了 substcribe 功能，用来存储所有对 mutation 变化的订阅者 this._subscribers = [] // 一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化 this._watcherVM = new Vue() // bind commit and dispatch to self // 把 Store 类的 dispatch 和 commit 方法的 this 指针指向当前 store 的实例上 const store = this const { dispatch, commit } = this // 封装替换原型中的 dispatch 和 commit 方法，详细解释见下方 this.dispatch = function boundDispatch(type, payload) { return dispatch.call(store, type, payload) } this.commit = function boundCommit(type, payload, options) { return commit.call(store, type, payload, options) } // strict mode // 是否开启严格模式 this.strict = strict // state 没有放在上面 options 对象中初始化了，改为在 module/module.js 下初始化，见上面 ① // 详细可见 module/module.js const state = this._modules.root.state /* 下面这三个方法就是 Store 的三个核心方法 */ // init root module. // this also recursively registers all sub-modules // and collects all module getters inside this._wrappedGetters // 见下方 installModule(this, state, [], this._modules.root) // initialize the store vm, which is responsible for the reactivity // (also registers _wrappedGetters as computed properties) resetStoreVM(this, state) // apply plugins plugins.forEach(plugin =&gt; plugin(this)) if (Vue.config.devtools) { devtoolPlugin(this) } } /* ============================================== 下面这些就是一些内部方法或者是向外部暴露的方法（API） ============================================== */ get state() { return this._vm._data.$$state } set state(v) { if (process.env.NODE_ENV !== 'production') { assert(false, `Use store.replaceState() to explicit replace store state.`) } } commit(_type, _payload, _options) { // check object-style commit const { type, payload, options } = unifyObjectStyle(_type, _payload, _options) // 配置参数处理 const mutation = { type, payload } const entry = this._mutations[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown mutation type: ${type}`) } return } // 专用修改 state 方法，其余修改 state 的方法均为非法修改 this._withCommit(() =&gt; { entry.forEach(function commitIterator(handler) { handler(payload) }) }) // 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) { console.warn( `[vuex] mutation type: ${type}. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) } } dispatch(_type, _payload) { // check object-style dispatch const { type, payload } = unifyObjectStyle(_type, _payload) // 配置参数处理 const action = { type, payload } // 当前 type 下所有 action 处理函数集合 const entry = this._actions[type] if (!entry) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] unknown action type: ${type}`) } return } // 订阅者函数遍历执行，传入当前的 action 对象和当前的 state this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) } subscribe(fn) { return genericSubscribe(fn, this._subscribers) } subscribeAction(fn) { return genericSubscribe(fn, this._actionSubscribers) } // watch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调 // getter 接收 store 的 state 作为唯一参数 watch(getter, cb, options) { if (process.env.NODE_ENV !== 'production') { assert(typeof getter === 'function', `store.watch only accepts a function.`) } // 函数首先断言 watch 的 getter 必须是一个 func // 接着利用了 this._watcherVM 的 $watch 方法，观测 getter 方法返回值的变化 // 如果有变化则调用 cb 函数，回调函数的参数为新值和旧值 // watch 方法返回的是一个方法，调用它则取消观测 return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options) } // 替换整个 rootState（一般用于调试） // 调用 this._withCommit 方法修改 Store 的 rootState // 因为不能在 mutation 的回调函数外部去改变 state replaceState(state) { this._withCommit(() =&gt; { this._vm._data.$$state = state }) } // 动态注册一个模块 installModule registerModule(path, rawModule, options = {}) { // 判断 path ==&gt; 转为 Array if (typeof path === 'string') path = [path] if (process.env.NODE_ENV !== 'production') { assert(Array.isArray(path), `module path must be a string or an Array.`) assert(path.length &gt; 0, 'cannot register the root module by using registerModule.') } this._modules.register(path, rawModule) installModule(this, this.state, path, this._modules.get(path), options.preserveState) // reset store to update getters... // 这个方法在下面 resetStoreVM(this, this.state) } // 与上面那个方法相对应，注销一个动态模块 unregisterModule(path) { if (typeof path === 'string') path = [path] if (process.env.NODE_ENV !== 'production') { assert(Array.isArray(path), `module path must be a string or an Array.`) } this._modules.unregister(path) this._withCommit(() =&gt; { const parentState = getNestedState(this.state, path.slice(0, -1)) Vue.delete(parentState, path[path.length - 1]) }) resetStore(this) } // 热加载新的 action 和 mutation hotUpdate(newOptions) { this._modules.update(newOptions) resetStore(this, true) } _withCommit(fn) { const committing = this._committing this._committing = true fn() this._committing = committing }}function genericSubscribe(fn, subs) { if (subs.indexOf(fn) &lt; 0) { subs.push(fn) } return () =&gt; { const i = subs.indexOf(fn) if (i &gt; -1) { subs.splice(i, 1) } }}// 重置 store 对象，然后再次安装 Module 对应的属性function resetStore(store, hot) { store._actions = Object.create(null) store._mutations = Object.create(null) store._wrappedGetters = Object.create(null) store._modulesNamespaceMap = Object.create(null) const state = store.state // init all modules // 最后一个参数传入 true，即 hot 参数为 true // 这样会在 installModule 当中的 if (!isRoot &amp;&amp; !hot) { ... } 的逻辑便不会执行 // 由于 hot 为 true，就不会重新对状态树做设置，则 state 会保持不变 // 因为已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters installModule(store, state, [], store._modules.root, true) // reset vm // 重置 Store 的 _vm 对象 resetStoreVM(store, state, hot)}function resetStoreVM(store, state, hot) { const oldVm = store._vm // bind store public getters store.getters = {} const wrappedGetters = store._wrappedGetters const computed = {} forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent Vue.config.silent = true store._vm = new Vue({ data: { $$state: state }, computed }) Vue.config.silent = silent // enable strict mode for new vm if (store.strict) { enableStrictMode(store) } if (oldVm) { if (hot) { // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; { oldVm._data.$$state = null }) } Vue.nextTick(() =&gt; oldVm.$destroy()) }}/* 接收五个参数 store，当前 Store 的实例 rootState，根 state path，当前嵌套模块的路径数组 module，当前安装的模块 hot，当动态改变 modules 或者热更新的时候为 true*/function installModule(store, rootState, path, module, hot) { // 判断是否为根 const isRoot = !path.length /** * 我们在构造函数中调用的时候为 installModule(this, state, [], options) * 所以这里的 path.length 为空，所以 isRoot 为 true * 而 module 自然就是传递进来的 options * 即 state，actions，mutations，getters 和嵌套的 modules */ // 新增的模块命名空间 const namespace = store._modules.getNamespace(path) // register in namespace map // 是否设置了命名空间，若存在则在 namespace 中进行 module 的存储 if (module.namespaced) { store._modulesNamespaceMap[namespace] = module } // set state // 非根组件设置 state 方法 if (!isRoot &amp;&amp; !hot) { // 在不是根组件且不是 hot 条件的情况下 // 通过 getNestedState 方法拿到该 module 父级的 state /** // 根据 path 查找 state 上的嵌套 state function getNestedState (state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state } */ const parentState = getNestedState(rootState, path.slice(0, -1)) // 由于模块的 path 是根据模块的名称 concat 连接的 // 所以 path 的最后一个元素就是当前模块的模块名 // 然后拿到其所在的 moduleName const moduleName = path[path.length - 1] /** _withCommit (fn) { // 保存之前的提交状态 const committing = this._committing // 进行本次提交，若不设置为 true，直接修改 state // 在 strict 模式下，Vuex 将会产生非法修改 state 的警告 this._committing = true // 执行 state 的修改操作 fn() // 修改完成后还原本次修改之前的状态 this._committing = committing } */ // 一个代理方法，Vuex 中所有触发 mutation 的进行 state 的修改操作都会经过它 // 保证同步修改 state 的过程中 this._committing 的值始终为 true // 可以统一管理监控 state 状态的修改 // 这样当我们观测 state 的变化的时候，如果 this._committing 不为 true，则说明这个状态的修改是有问题的 // 拿到 parentState 和 moduleName // 然后利用 Vue.set 方法将 state 设置到父级 state 对象的 moduleName 属性中 // 由此实现该模块的 state 注册 // 注：如果是首次执行，因为是根目录注册，所以并不会执行该条件中的方法 store._withCommit(() =&gt; { Vue.set(parentState, moduleName, module.state) }) } // module 上下文环境设置 // 命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值 // makeLocalContext 方法会为该 module 设置局部的 dispatch，commit 方法以及 getters 和 state（namespace 的存在需要做兼容处理） const local = module.context = makeLocalContext(store, namespace, path) // 分别对 mutations，actions，getters 进行注册，见下 // 注册对应模块的 mutation，供 state 修改使用 module.forEachMutation((mutation, key) =&gt; { const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) }) // 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用 module.forEachAction((action, key) =&gt; { const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) }) // 注册对应模块的 getters，供 state 读取使用 module.forEachGetter((getter, key) =&gt; { const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) }) // 这个是 Store 中的 Module // 需要注意这里传入的 path 参数是不为空的 // 注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身 // 为子组件注册其 state，actions、mutations 以及 getters 等 module.forEachChild((child, key) =&gt; { installModule(store, rootState, path.concat(key), child, hot) })}/** * make localized dispatch, commit, getters and state * if there is no namespace, just use root ones */function makeLocalContext(store, namespace, path) { const noNamespace = namespace === '' const local = { dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; { const args = unifyObjectStyle(_type, _payload, _options) const { payload, options } = args let { type } = args if (!options || !options.root) { type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) { console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`) return } } return store.dispatch(type, payload) }, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; { const args = unifyObjectStyle(_type, _payload, _options) const { payload, options } = args let { type } = args if (!options || !options.root) { type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) { console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`) return } } store.commit(type, payload, options) } } // getters and state object must be gotten lazily // because they will be changed by vm update Object.defineProperties(local, { getters: { get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) }, state: { get: () =&gt; getNestedState(store.state, path) } }) return local}function makeLocalGetters(store, namespace) { const gettersProxy = {} const splitPos = namespace.length Object.keys(store.getters).forEach(type =&gt; { // skip if the target getter is not match this namespace if (type.slice(0, splitPos) !== namespace) return // extract local getter type const localType = type.slice(splitPos) // Add a port to the getters proxy. // Define as getter property because // we do not want to evaluate the getters in this time. Object.defineProperty(gettersProxy, localType, { get: () =&gt; store.getters[type], enumerable: true }) }) return gettersProxy}/* 接收四个参数 store 为当前 Store 实例 type 为 mutation 的 type handler 为 mutation 执行的回调函数，作用就是同步修改当前模块的 state local 为当前模块的路径*/function registerMutation(store, type, handler, local) { // 通过 type 拿到对应的 mutation 对象数组 const entry = store._mutations[type] || (store._mutations[type] = []) // 将 mutation 包装成函数 push 到数组当中，同时添加载荷 payload 参数 // 所以 commit 实际调用的不是我们传入的 handler，而是经过封装的 entry.push(function wrappedMutationHandler(payload) { // 调用 handler 并将 state 传入 handler.call(store, local.state, payload) })}function registerAction(store, type, handler, local) { // 通过 type 拿到对应的 actions 对象数组 const entry = store._actions[type] || (store._actions[type] = []) // 存储新的封装过的 action handler entry.push(function wrappedActionHandler(payload, cb) { // 传入 state 等对象供我们之前的 action handler 使用 let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload, cb) /* export function isPromise (val) { return val &amp;&amp; typeof val.then === 'function' } */ // 兼容 Promise if (!isPromise(res)) { res = Promise.resolve(res) } // 判断 store._devtoolHook，只有当用到 Vuex devtools 开启的时候，才能捕获 Promise 过程 if (store._devtoolHook) { return res.catch(err =&gt; { store._devtoolHook.emit('vuex:error', err) throw err }) } else { return res } })}function registerGetter(store, type, rawGetter, local) { // getters 只允许存在一个处理函数，若重复需要报错 if (store._wrappedGetters[type]) { if (process.env.NODE_ENV !== 'production') { console.error(`[vuex] duplicate getter key: ${type}`) } return } // 存储新的封装过的 getters 处理函数 store._wrappedGetters[type] = function wrappedGetter(store) { // 为之前的 getters 传入对应的状态 return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) }}function enableStrictMode(store) { store._vm.$watch(function () { return this._data.$$state }, () =&gt; { if (process.env.NODE_ENV !== 'production') { assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`) } }, { deep: true, sync: true })}function getNestedState(state, path) { return path.length ? path.reduce((state, key) =&gt; state[key], state) : state}function unifyObjectStyle(type, payload, options) { if (isObject(type) &amp;&amp; type.type) { options = payload payload = type type = type.type } if (process.env.NODE_ENV !== 'production') { assert(typeof type === 'string', `Expects string as the type, but found ${typeof type}.`) } return { type, payload, options }}export function install(_Vue) { if (Vue &amp;&amp; _Vue === Vue) { if (process.env.NODE_ENV !== 'production') { console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) } return } Vue = _Vue applyMixin(Vue)} 参考 Vuex 源码深度解析 Vuex 源码分析 Vuex 源码阅读分析 Vuex 框架原理与源码分析","link":"/2018/08/25/Vue/04/"},{"title":"浏览器的渲染机制","text":"在展开渲染机制相关内容之前，我们先来简单的了解一下常见的浏览器内核有哪些，浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是 JavaScript 引擎（比如我们经常可以听到的 V8 引擎），渲染引擎在不同的浏览器中也不是都相同的，目前市面上常见的浏览器内核主要有以下这些 浏览器/RunTime 内核（渲染引擎） JavaScript 引擎 Chrome Blink（28~）Webkit（Chrome 27） V8 FireFox Gecko SpiderMonkey Safari Webkit JavaScriptCore Edge EdgeHTML Chakra(for JavaScript) IE Trident Chakra(for JScript) PhantomJS Webkit JavaScriptCore Node.js - V8 这里面大家最耳熟能详的可能就是 Webkit 内核了，其中的 Blink 其实就是 Webkit 的一个分支，也就是说它也是基于 Webkit 的，所以本章也就以 Webkit 为例，来看看浏览器的渲染机制到底是一个什么样的过程，不过在此之前，我们先来简单的了解一下浏览器的主要组成部分和它包含的一些主要进程，这有助于我们下面更好的理解浏览器当中的渲染机制 浏览器的主要组成部分主要分为以下几部分 用户界面，包括地址栏、前进/后退 按钮、书签菜单等，除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面 浏览器引擎，在用户界面和呈现引擎之间传送指令 呈现引擎，负责显示请求的内容，如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上 网络，用于网络调用，比如 HTTP 请求，其接口与平台无关，并为所有平台提供底层实现 用户界面后端，用于绘制基本的窗口小部件，比如组合框和窗口，其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法 JavaScript 解释器，用于解析和执行 JavaScript 代码 数据存储，这是持久层，浏览器需要在硬盘上保存各种数据，例如 Cookie，新的 HTML 规范（HTML5）定义了『网络数据库』，这是一个完整（但是轻便）的浏览器内数据库 如下图所示 浏览器的主要进程我们在之前的章节当中已经简单介绍了进程和线程的一些相关内容（可见 JavaScript 中的事件轮询机制），这里我们简单的复习一下 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 不同进程之间也可以通信，不过代价较大 单线程与多线程，都是指在一个进程内的单和多 对于计算机来说，每一个应用程序都是一个进程，而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过子进程来实现的，对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的 而对于浏览器来说，浏览器就是多进程的，比如我们在 Chrome 浏览器中打开了多个 TAB，然后打开控制管理器是可以看到一个 Chrome 浏览器启动了好多个进程，那么浏览器又是具体包含了哪些进程呢？可以参考下面这个图片 可以归纳为以下这些 主进程（Browser Process） 协调控制其他子进程（创建、销毁） 浏览器界面显示，用户交互，前进、后退、收藏 将渲染进程得到的内存中的 Bitmap，绘制到用户界面上 处理不可见操作，网络请求，文件访问等 第三方插件进程（Plugin Process） 每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU 进程（GPU Process） 最多只有一个，用于 3D 绘制等 渲染进程（Renderer Process） 也称为浏览器渲染进程或浏览器内核，内部是多线程的 主要负责页面渲染，脚本执行，事件处理等 每个 TAB 页一个渲染进程 其实上面的有些进程我们不需要太过理解，在这里我们只需要重点关心渲染进程，也就是我们常说的浏览器内核 渲染进程（浏览器内核） 进程和线程是一对多的关系，也就是说一个进程包含了多条线程，而对于渲染进程来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程，主要有以下这些 GUI 渲染线程 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等 当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行 注意，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行 JavaScript 引擎线程 该线程也称为 JavaScript 内核，负责处理 JavaScript 脚本程序（例如 V8 引擎） JavaScript 引擎线程负责解析 JavaScript 脚本，运行代码 JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序 注意，GUI 渲染线程与 JavaScript 引擎线程是互斥的，所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞 事件触发线程 归属于浏览器而不是 JavaScript 引擎，用来控制事件循环（可以理解，JavaScript 引擎自己都忙不过来，需要浏览器另开线程协助） 当 JavaScript 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、Ajax 异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理 注意，由于 JavaScript 的单线程关系，所以这些待处理队列中的事件都得排队等待 JavaScript 引擎处理（当 JavaScript 引擎空闲时才会去执行） 定时触发器线程 传说中的 setInterval 与 setTimeout 所在线程 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JavaScript 引擎空闲后执行） 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 异步 HTTP 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行 在了解完浏览器的一些相关内容后，下面我们就来正式的看看浏览器的渲染过程到底是什么样子的 渲染过程本小节内容主要参考的是 Critical Rendering Path 当中的内容，这里有所调整，主要是方便自己理解，如果想要了解更为详细的内容可以参考原文 大家都听说过 &lt;script&gt; 标签会阻塞 HTML 页面解析，而 &lt;link&gt; 标签则不会，结果也确实是这样的，&lt;link&gt; 等样式资源的下载、解析确实不会阻塞页面的解析，但它们会阻塞页面的渲染，我们来看看两者的区别 页面解析，阻塞 HTML 页面解析，HTML 页面会被继续下载，但阻塞点后面的标签不会被解析，&lt;img&gt;，&lt;link&gt; 等不会发请求获取外部资源 页面渲染，阻塞 HTML 页面渲染，HTML 页面会被继续下载，阻塞点后面的标签会继续被解析，&lt;img&gt;，&lt;link&gt; 等会继续发送请求获取外部资源，但不会合成 Rendering Tree 或不会触发页面渲染，也不会执行 JavaScript 代码 至于为什么会这样，我们就需要在浏览器的渲染机制当中来寻找答案了，简单来说有以下几个步骤 1、解析 HTML 标签，构建 DOM 树这个阶段对应着 Create/Update DOM And request CSS/Images/JavaScript 的过程，也就是说浏览器请求到 HTML 代码后，在生成 DOM 的最开始阶段（应该是 Bytes → characters 后），并行发起 CSS、Images、JavaScript 的请求，无论他们是否在 HEAD 里 不过需要注意的是，发起 JavaScript 文件的下载 request，并不需要 DOM 处理到那个 script 节点 2. 解析 CSS 标签，构建 CSSOM 树这个阶段对应着 Create/Update Render CSSOM 的过程，即 CSS 文件下载完成，开始构建 CSSOM，其中的 CSSOM 即 CSS Object Model，是浏览器将 CSS 代码解析成树形的数据结构，这个我们会在下方来进行介绍 其中 DOM 和 CSSOM 都是以下图当中所示的流程，也就是依次经过 Bytes（字节数据），Characters（字符串），Tokens，Nodes 最后到 Object Model 这样的方式生成最终的数据，也就是如下几个步骤 转码，浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串 生成 Tokens，之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens 构建 Nodes，对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope 生成 DOM Tree，通过 Node 包含的指针确定的关系构建出 DOM Tree 在这里我们需要注意的是，DOM 树的构建过程是一个深度遍历过程，当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点 3. 把 DOM 和 CSSOM 组合成渲染树 这个阶段对应着 Create/Update Render Tree 的过程，所有 CSS 文件下载完成，CSSOM 构建结束后，和 DOM 一起生成 Render Tree 4. 在渲染树的基础上进行布局，计算每个节点的几何结构这个阶段对应着 Layout 的过程，有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，这一步操作之所以称为 Layout，顾名思义就是计算出每个节点在屏幕中的位置 5. 把每个节点绘制到屏幕上这个阶段对应着 Painting 的过程，Layout 后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的 CSS 属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry），就进入了最后一步 Painting，按照算出来的规则，通过显卡，把内容画到屏幕上 Render Tree 和 DOM 一样，以多叉树的形式保存了每个节点的 CSS 属性、节点本身属性、以及节点的孩子节点 这里有一个比较特殊的情况，就是 display: none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以如果某个节点最开始是不显示的，设为 display: none 是更优的 以上五个步骤前三个步骤之所有使用 Create/Update 是因为 DOM、CSSOM、Render Tree 都可能在第一次 Painting 后又被更新多次，比如 JavaScript 修改了 DOM 或者 CSS 属性，Layout 和 Painting 也会被重复执行，除了 DOM、CSSOM 更新的原因外，图片下载完成后也需要调用 Layout 和 Painting 来更新网页 渲染过程拆解我们在上面小节当中提到的渲染过程的五个步骤看起来可能比较抽象，下面我们就来将它们拆解成我们经常遇到的一些操作，然后简单的归纳一下各个步骤 通常来说我们在编写 Web 页面时，我们需要理解我们所写的页面代码是如何被转换成屏幕上显示的像素的，这个转换过程我们可以归纳为这样的一个流水线，包含五个关键步骤 JavaScript 一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果，比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序、或者往页面里添加一些 DOM 元素等，当然除了JavaScript 还有其他一些常用方法也可以实现视觉变化效果，比如 CSS Animations，Transitions 和 Web Animation API Style calculations（计算样式） 这个过程是根据 CSS 选择器，比如 .headline 或 .nav &gt; .nav_item，对每个 DOM 元素匹配对应的 CSS 样式，这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则 Layout（布局） 上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置，Web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化，比如 &lt;body&gt; 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响，因此对于浏览器来说，布局过程是经常发生的 Paint（绘制） 本质上就是填充像素的过程，包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果，一般来说，这个绘制过程是在多个图层上完成的 Compositing（组合） 由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的，在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上，对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常 上述过程的每一步中都有产生掉帧的问题，因此一定要弄清楚我们的代码将会运行在哪一步，有时我们可能会听到栅格化（rasterize）与绘制一起使用，这是因为绘制这个动作实际是包含两步 产生系列的格子 往格子中填充像素 这个过程后来被称之为栅格化（rasterization），所以我们在 DevTools 中看到的绘制记录，应该要知道其中已经包含了栅格化这一过程，但是我们不需要了解所有帧画面渲染流程上的所有流程，实际上，当我们修改视图的时候，有三种方式会重新生成一个帧画面，无论是修改 JavaScript，CSS 还是 Web Animations，这里我们重点关注这三种方式 JavaScript/CSS &gt; Style &gt; layout &gt; Paint &gt; Composite 如果我们修改布局属性（元素的几何形状），比如宽度，高度以及位置，那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个 reflow 过程完成重新布局，被 reflow 的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面 JavaScript/CSS &gt; Style &gt; Paint &gt; Composite 如果我们只是修改了绘制属性，比如说背景图片，字体颜色，阴影等，这些属性不属于页面布局，因此浏览器会在完成样式计算之后，跳过布局过程，只做绘制和渲染层合并过程 JavaScript/CSS &gt; Style &gt; Composite 如果我们修改的属性既不属于布局，也不属于绘制，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并，第三种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用第三种渲染流程 如果想知道哪些 CSS 属性会触发这三种方式，可以参考 CSS Triggers，而对于高性能动画方面则可以参考 使用渲染层合并属性 补充说明我们下面来看几个在上面过程当中延伸出来的问题 1. CSSOMCSSOM 是 CSS Object Model 的缩写，大体上来说，CSSOM 是一个建立在 Web 页面上的 CSS 样式的映射，它和 DOM 类似，但是只针对 CSS 而不是 HTML，浏览器将 DOM 和 CSSOM 结合来渲染 Web 页面 CSSOM 是做什么的CSSOM 将样式表中的规则映射到页面对应的元素上，虽然 CSSOM 采取了复杂的措施来做这件事，但是 CSSOM 最终的功能还是将样式映射到它们应该对应的元素上去，更确切地说，CSSOM 识别 tokens 并把这些 Tokens 转换成一个树结构上的对应的结点，所有结点以及它们所关联的页面中的样式就是所谓的 CSS Object Model，从上面的渲染机制可以看出，CSSOM 对于 Web 页面的展示起着重要作用 使用 CSSOM其实我们不必为了优化 Web 页面而去了解 CSSOM 是怎样工作的，这里有几个关于 CSSOM 的关键点是我们需要知道的，利用这些关键点可以优化页面的加载速度 CSSOM 阻止任何东西渲染 CSSOM 在加载一个新页面时必须重新构建 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的 下面我们就分别来看看以上三种情况 CSSOM 阻止任何东西渲染 所有的 CSS 都是阻塞渲染的（意味着在 CSS 没处理好之前所有东西都不会展示），具体的原因是如果浏览器在 CSS 检查之前展示了页面，那么每个页面都是没有样式的，等一会之后又突然有了样式，整个页面的体验就会很糟糕 由于 CSSOM 被用作创建 Render Tree，那么如果不能高效的利用 CSS 会有一些严重的后果，而主要的后果就是我们的页面在加载时白屏 CSSOM 在加载一个新页面时必须重新构建 这意味着即使我们的 CSS 文件被缓存了，也并不意味着这个已经构建好了的 CSSOM 可以应用到每一个页面，当用户跳到我们的另一个页面时（即使浏览器缓存了所有需要的 CSS），CSSOM 也必须重新构建一遍，也就是说，如果我们的 CSS 文件写得很蹩脚，或者体积很大，这也会对我们页面加载产生负面的影响 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的 JavaScript 的加载可能会阻塞 CSSOM 的构建，简单来说，CSSOM 是展示任何东西的必需品，在 CSSOM 构建之前，所有东西都不会展示 如果我们阻塞了 CSSOM 的构建，CSSOM 的构建就会消耗更长的时间，这就意味着页面的渲染也需要更长的时间 如果我们的 JavaScript 阻塞了 CSSOM 的构建，我们的用户就会面对更长时间的白屏 2. 为什么 JavaScript 是单线程的首先是历史原因，在创建 JavaScript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好，其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高 如果 JavaScript 是多线程的方式来操作这些 UI DOM，则可能出现 UI 操作的冲突，在多线程的交互下，处于 UI 中的 DOM 节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果 当然我们可以通过锁来解决上面的问题，但为了避免因为引入了锁而带来更大的复杂性，JavaScript 在最初就选择了单线程执行 3. 为什么 GUI 渲染线程为什么与 JavaScript 引擎线程互斥由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了，因此为了防止渲染出现不可预期的结果，浏览器『设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系』 当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行，浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JavaScript 程序执行完成，才会接着执行 因此如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉 4. CSS 加载会造成阻塞吗在上面的浏览器渲染流程当中我们可以看出，DOM 和 CSSOM 通常是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析，然而由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，所以它必须等待到 CSSOM Tree 构建完成，也就是 CSS 资源加载完成（或者 CSS 资源加载失败）后，才能开始渲染，因此 CSS 加载会阻塞 DOM 的渲染 由于 JavaScript 是可以操纵 DOM 和 CSS 样式的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了，因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系 这样一来，样式表会在后面的 JavaScript 执行前先加载执行完毕，所以 CSS 会阻塞后面 JavaScript 的执行 5. DOMContentLoaded 与 onload 的区别当 DOMContentLoaded 事件触发时，仅当 DOM 解析完成后，不包括样式表和图片，我们在上面提到过，CSS 加载会阻塞 DOM 的渲染和后面 JavaScript 的执行，也就是说 JavaScript 会阻塞 DOM 解析 所以我们可以得到结论，当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件，如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等 CSSOM 构建完成才能执行，在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成 而当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片等资源已经加载完毕，所以流程应该是由 DOMContentLoaded 到 onload 6. 如何优化 CRPCRP，即关键渲染路径（Critical Rendering Path），它是浏览器将 HTML/CSS/JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤，也就是我们上面说的浏览器渲染流程，为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素 关键资源的数量，可能阻止网页首次渲染的资源 关键路径长度，获取所有关键资源所需的往返次数或总时间 关键字节，实现网页首次渲染所需的总字节数，等同于所有关键资源传送文件大小的总和 优化 DOM 删除不必要的代码和注释包括空格，尽量做到最小化文件 可以利用 GZIP 压缩文件 结合 HTTP 缓存文件 优化 CSSOM缩小、压缩以及缓存同样重要，对于 CSSOM 我们前面重点提过了它会阻止页面呈现，因此我们可以从这方面考虑去优化，步骤如下 减少关键 CSS 元素数量 当我们声明样式表时，请密切关注媒体查询的类型，它们极大地影响了 CRP 的性能 优化 JavaScript当浏览器遇到 &lt;script&gt; 标记时，会阻止解析器继续操作，直到 CSSOM 构建完毕，JavaScript 才会运行并继续完成 DOM 构建过程，所以我们可以考虑以下方式 Async，当我们在 &lt;script&gt; 标记中添加 Async 属性以后，浏览器遇到这个标记时会继续解析 DOM，同时脚本也不会被 CSSOM 阻止，即不会阻止 CRP Defer，与 Async 的区别在于，脚本需要等到文档解析后（DOMContentLoaded 事件前）执行，而 Async 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 DOM，但执行会） 当我们的脚本不会修改 DOM 或 CSSOM 时推荐使用 Async 预加载（preload &amp;&amp; prefetch） DNS 预解析（dns-prefetch） 总结 分析并用 关键资源数 关键字节数 关键路径长度 来描述我们的 CRP 最小化关键资源数，消除它们（内联）、推迟它们的下载（Defer）或者使它们异步解析（Async）等等 优化关键字节数（缩小、压缩）来减少下载时间 优化加载剩余关键资源的顺序，让关键资源（CSS）尽早下载以减少 CRP 长度 更多相关内容可以参考 前端性能优化之关键路径渲染优化 7. Async 和 Defer 的区别我们先来对比下 Async 和 Defer 属性的区别，如下图所示 其中蓝色线代表 JavaScript 加载，红色线代表 JavaScript 执行，绿色线代表 HTML 解析，所以我们也对应的分别来看看三种情况 1&lt;script src=\"example.js\"&gt;&lt;/script&gt; 没有 Async 和 Defer，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行 1&lt;script async src=\"example.js\"&gt;&lt;/script&gt; Async 属性表示异步执行引入的 JavaScript，与 Defer 的区别在于，如果已经加载好，就会开始执行，即无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后，不过需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件，换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行 1&lt;script defer src=\"example.js\"&gt;&lt;/script&gt; Defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的，整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件 因此，我们可以得出结论 Defer 和 Async 在网络读取（下载）这部分是一样的，都是异步的（相较于 HTML 解析） 在加载多个 JavaScript 脚本的时候，Async 是无顺序的加载，而 Defer 是有顺序的加载 差别在于脚本下载完之后何时执行，显然 Defer 是最接近我们对于应用脚本加载和执行的要求的 Async 是乱序执行，它的加载和执行是紧紧挨着的，所以不管声明的顺序如何，只要它加载完了就会立刻执行 通常来说，Async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的 8. 如何解析 CSS 选择器浏览器会『从右往左』解析 CSS 选择器，我们知道 DOM Tree 与 Style Rules 合成为 Render Tree，实际上是需要将 Style Rules 附着到 DOM Tree 上，因此需要根据选择器提供的信息对 DOM Tree 进行遍历，才能将样式附着到对应的 DOM 元素上，我们以下面这段 CSS 为例 1.mod-nav h3 span {font-size: 16px;} 对应的 DOM Tree 如下 若从左向右的匹配，过程是 从 .mod-nav 开始，遍历子节点 header 和子节点 div 然后各自向子节点遍历，在右侧 div 的分支中，最后遍历到叶子节点 a，发现不符合规则 所以需要回溯到 ul 节点，再遍历下一个 li-a，一颗 DOM 树的节点动不动上千，所以可以发现这种效率很低 如果从右至左的匹配 先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3 由 h3 再向上寻找 .mod-nav 的节点 最后找到根元素 html 则结束这个分支的遍历 两者对比下来，可以明显的发现后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面 9. 回流与重绘渲染的流程基本上是这样（如下图黄色的四个步骤） 计算 CSS 样式 构建 Render Tree Layout 定位坐标和大小 正式开画 这里需要注意上图流程中有很多连接线，这表示了 JavaScript 动态修改了 DOM 属性或是 CSS 属性会导致重新 Layout，但有些改变不会重新 Layout，就是上图中那些指到天上的箭头，比如修改后的 CSS rule 没有被匹配到元素，这里重要要说两个概念，一个是 Reflow，另一个是 Repaint 重绘，当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节） 回流，当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来，这个过程就是回流（也叫重排） 我们知道，当网页生成的时候，至少会渲染一次，在用户访问的过程中，还会不断重新渲染，重新渲染会重复 回流 + 重绘 或者只有重绘，回流必定会发生重绘，重绘不一定会引发回流，重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能，回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流 常见引起回流属性和方法任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流，比如下面这些方式 1234567clientWidth、clientHeight、clientTop、clientLeftoffsetWidthoffsetHeight、offsetTop、offsetLeftscrollWidthscrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()getComputedStyle()、getBoundingClientRect()、scrollTo() 具体表现为 添加或者删除可见的 DOM 元素 元素尺寸改变（边距、填充、边框、宽度和高度） 内容变化，比如用户在 input 框中输入文字 浏览器窗口尺寸改变（resize 事件发生时） 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 常见引起重绘属性和方法 如何减少回流、重绘 使用 transform 替代 top 使用 visibility 替换 display: none，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量，就下面这样 1234for (let i = 0; i &lt; 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop)} 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，比如对于 video 标签来说，浏览器会自动将该节点变为图层 集中改变样式，即通过改变 class 的方式来集中改变样式 12345// 判断是否是黑色系样式const theme = isDark ? 'dark' : 'light'// 根据判断来设置不同的classele.setAttribute('className', theme) 使用 DocumentFragment，我们可以通过 createDocumentFragment 创建一个游离于 DOM 树之外的节点，然后在此节点上批量操作，最后插入 DOM 树中，因此只触发一次重排 123456789var fragment = document.createDocumentFragment()for (let i = 0; i &lt; 10; i++) { let node = document.createElement('p') node.innerHTML = i fragment.appendChild(node)}document.body.appendChild(fragment) 提升为合成层（关于合成层我们会在下面进行介绍），将元素提升为合成层有以下优点 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，不会触发 layout 和 paint 通常来说，提升合成层的最好方式是使用 CSS 的 will-change 属性 更多关于合成层的相关内容可以参考 无线性能优化：Composite 123#target { will-change: transform;} 10. 性能优化策略基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能 JavaScript 优化，&lt;script&gt; 标签加上 Defer 属性和 Async 属性用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行 Defer 属性，用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行 Async 属性，HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码 CSS 优化，&lt;link&gt; 标签的 rel 属性中的属性值设置为 preload 能够让我们在 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能 11. 浏览器解析 JavaScript 的过程早期，浏览器内部对 JavaScript 的处理过程大致如下 读取代码，进行词法分析（Lexical Analysis），将代码分解成词元（token） 对词元进行语法分析（Parsing），将代码整理成语法树（Syntax Tree） 使用翻译器（Translator），将代码转为字节码（Bytecode） 使用字节码解释器（Bytecode Interpreter），将字节码转为机器码 逐行解释将字节码转为机器码，是很低效的，为了提高运行速度，现代浏览器改为采用即时编译（Just In Time compiler，JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（Inline Cache），通常来说，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升 关于这部分更为详细的内容可以参考我们之前整理过的 V8 引擎机制 这篇文章了解更多 12. 什么是渲染层合并（Composite）渲染层合并，对于页面中 DOM 元素的绘制（Paint）是在多个层上进行的，在每个层上完成绘制过程之后，浏览器会将绘制的位图发送给 GPU 绘制到屏幕上，将所有层按照合理的顺序合并成一个图层，然后在屏幕上呈现，对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常 如上图 RenderLayers 渲染层，这是负责对应 DOM 子树 GraphicsLayers 图形层，这是负责对应 RenderLayers 子树 RenderObjects 保持了树结构，一个 RenderObjects 知道如何绘制一个 Node 的内容，通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 Nodes 每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后画到屏幕上，此时我们的页面也就展现到了屏幕上 GraphicsContext 绘图上下文的责任就是向屏幕进行像素绘制（这个过程是先把像素级的数据写入位图中，然后再显示到显示器），在 Chrome 里，绘图上下文是包裹了的 Skia（Chrome 自己的 2D 图形绘制库） 某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个 合成层的优点一旦 renderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升 合成层的位图，会交由 GPU 合成，比 CPU 处理要快，也就是说，提升到合成层后合成层的位图会交 GPU 处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层，当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style，layout 那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间 对于 transform 和 opacity 效果，不会触发 layout 和 paint，仅仅是 transform 和 opacity 不会引发 layout 和 paint，其他的属性不确定 一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能 注意不能滥用 GPU 加速，一定要分析其实际性能表现，因为 GPU 加速创建渲染层是有代价的，每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理，并且在移动端 GPU 和 CPU 的带宽有限制，创建的渲染层过多时，合成也会消耗跟多的时间，随之而来的就是耗电更多，内存占用更多，过多的渲染层来带的开销而对页面渲染性能产生的影响，甚至远远超过了它在性能改善上带来的好处 更多详细内容可以参考下面几个链接 Accelerated Rendering in Chrome CSS GPU Animation: Doing It Right 无线性能优化：Composite 总结 浏览器渲染工作的主流程分为下面五个步骤（如下图所示） 解析 HTML 文件，构建 DOM 树，同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成，解析 CSS 文件成树形的数据结构，然后结合 DOM 树合并成 RenderObject 树 布局 RenderObject 树（Layout/reflow），负责 RenderObject 树中的元素的尺寸，位置等计算 绘制 RenderObject 树（paint），绘制页面的像素信息 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成（composite），最后显示出页面 CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树 通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 &lt;script&gt; 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JavaScript，最后才重新 DOM 构建 参考 解秘 FOUC CSSOM 介绍 Critical Rendering Path","link":"/2019/07/07/JavaScript/37/"},{"title":"V8 引擎机制","text":"最近在梳理 JavaScript 相关知识，发现 V8 引擎机制相关内容还是较多的而且在之前工作的过程当中也是涉及比较少的，所以就抽些时间出来，在这里大致的整理一下，主要参考的是 V8 执行流程概述 这篇文章，内容有所调整，主要是为了方便自己理解，如果想了解更为详细的流程可以参考原文 在开始之前，我们先来简单的了解一下 V8 解析 JavaScript 的过程分为哪些步骤，这样我们可以在全局上对 V8 的整个执行流程有一个比较清晰的认识，简单来说，有以下几个步骤 预解析，检查语法错误但不生成 AST 生成 AST，经过词法/语法分析，生成抽象语法树 生成字节码，基线编译器（Ignition）将 AST 转换成字节码 生成机器码，优化编译器（Turbofan）将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度 下面我们就从头开始，也就是什么是 V8 引擎开始看起 V8 引擎看到 V8 这个词，我们可能会联想到发动机，因为 V8、V10、V12 发动机这种概念可能都有所耳闻，的确，V8 的名字正是来源于汽车的 V 型 8 缸发动机，因为马力十足而广为人知，V8 引擎的命名是 Google 向用户展示它是一款强力并且高速的 JavaScript 引擎 V8 未诞生之前，早期主流的 JavaScript 引擎是 JavaScriptCore 引擎（Safari），JavaScriptCore 是主要服务于 Webkit 浏览器内核，它们都是由苹果公司开发并开源出来，据说 Google 是不满意 JavaScriptCore 和 Webkit 的开发速度和运行速度，Google 另起炉灶开发全新的 JavaScript 引擎和浏览器内核引擎，所以诞生了 V8 和 Chromium 两大引擎，到现在已经是最受欢迎的浏览器相关软件，当然发展至今，V8 不在局限于浏览器内核引擎，也应用于很多场景，例如流行的 Node.js，Weex 等，在 V8 当中，有以下几个比较重要的部件 Ignition（基线编译器） TurboFan（优化编译器） Orinoco（垃圾回收器） Liftoff（WebAssembly 基线编译器） 这里有个需要注意的地方，Liftoff 是从 V8 6.8 开始启用的针对 WebAssembly 的基线编译器，但是 WebAssembly 相关内容不在本文范围内，所以我们这里也就不做介绍了，相关内容可以参考 V8 引擎中全新的 WebAssembly 这篇文章 早期架构V8 引擎的诞生带着使命而来，就是要在速度和内存回收上进行革命的，JavaScriptCore 的架构是采用生成字节码的方式，然后执行字节码，Google 觉得 JavaScriptCore 这套架构不行，生成字节码会浪费时间，不如直接生成机器码快，所以 V8 在前期的架构设计上是非常激进的，采用了直接编译成机器码的方式，后期的实践证明 Google 的这套架构速度是有改善，但是同时也造成了内存消耗问题，下面是 V8 的初期流程图 早期 V8 执行管道由基线编译器 Full-Codegen 与优化编译器 Crankshaft 组成，V8 首先用 Full-Codegen 把所有的代码都编译一次，生成对应的机器码，JavaScript 在执行的过程中，V8 内置的 Profiler 筛选出热点函数并且记录参数的反馈类型，然后交给 Crankshaft 来进行优化，所以 Full-Codegen 本质上是生成的是未优化的机器码，而 Crankshaft 生成的是优化过的机器码 缺陷但是随着版本的引进，网页的复杂化，V8 也渐渐的暴露出了自己架构上的缺陷，比如下面这些 Full-Codegen，编译直接生成机器码，导致内存占用大，编译时间长，启动速度慢等 Crankshaft，无法优化 try-catch/finally 等关键字划分的代码块，如果新加语法支持，需要为此编写适配不同 CPU 的架构代码 新的架构为了解决上述缺点，经过多年演进 V8 目前形成了由解析器、基线编译器（Ignition）和优化编译器（TurboFan）组成的 JavaScript 执行管道，也就是下图这样 解析器将 JavaScript 源代码转换成 AST，基线编译器（Ignition）将 AST 编译为字节码，当代码满足一定条件时，将被优化编译器重新编译生成优化的字节码 Ignition 是 V8 的解释器，背后的原始动机是减少移动设备上的内存消耗，Ignition 的字节码可以直接用 TurboFan 生成优化的机器代码，而不必像 Crankshaft 那样从源代码重新编译，Ignition 的字节码在 V8 中提供了更清晰且更不容易出错的基线执行模型，简化了去优化机制，这是 V8 自适应优化的关键特性，最后由于生成字节码比生成 Full-codegen 的基线编译代码更快，因此激活 Ignition 通常会改善脚本启动时间，从而改善网页加载 TurboFan 是 V8 的优化编译器，TurboFan 项目最初于 2013 年底启动，旨在解决 Crankshaft 的缺点，Crankshaft 只能优化 JavaScript 语言的子集，例如它不是设计用于使用结构化异常处理优化 JavaScript 代码，即由 JavaScript 的 try-catch 和 finally 关键字划分的代码块，很难在 Crankshaft 中添加对新语言功能的支持，因为这些功能几乎总是需要为九个支持的平台编写特定于体系结构的代码 在采用新架构后，不同架构下 V8 的内存对比，如下图 可以明显看出 Ignition + TurboFan 架构比 Full-codegen + Crankshaft 架构内存降低一半多，我们可以再来看看网页速度提升对比 可以明显看出 Ignition + TurboFan 架构比 Full-codegen + Crankshaft 架构 70% 网页速度是有提升的 解析器与 AST学过编译原理的同学可能知道，JavaScript 文件只是一个源码，机器是无法执行的，词法分析就是把源码的字符串分割出来，生成一系列的 Token，如下图可知不同的字符串对应不同的 Token 类型 词法分析完后，接下来的阶段就是进行语法分析，语法分析语法分析的输入就是词法分析的输出，输出是 AST 抽象语法树，当程序出现语法错误的时候，V8 在语法分析阶段抛出异常 但是解析代码需要时间，所以 JavaScript 引擎会尽可能避免完全解析源代码文件，而另一方面又因为在一次用户访问中，页面中会有很多代码其实是不会被执行到的，比如一些通过用户交互行为触发的动作，正因为如此，所有主流浏览器都实现了惰性解析（Lazy Parsing），解析器不必为每个函数生成 AST，而是可以决定预解析（pre-parsing）或完全解析它所遇到的函数，预解析会检查源代码的语法并抛出语法错误，但不会解析函数中变量的作用域或生成 AST，完全解析则将分析函数体并生成源代码对应的 AST 数据结构，相比正常解析，预解析的速度快了两倍 生成 AST生成 AST 主要经过两个阶段，分词和语义分析，AST 旨在通过一种结构化的树形数据结构来描述源代码的具体语法组成，常用于语法检查（静态代码分析）、代码混淆、代码优化等，我们可以借助 AST Explorer 工具来生成 JavaScript 代码的 AST，比如我们的函数为 123function add(x, y) { return x + y;} 编译后 JSON 大概是下面这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566{ \"type\": \"Program\", \"start\": 0, \"end\": 38, \"body\": [ { \"type\": \"FunctionDeclaration\", \"start\": 0, \"end\": 38, \"id\": { \"type\": \"Identifier\", \"start\": 9, \"end\": 12, \"name\": \"add\" }, \"expression\": false, \"generator\": false, \"async\": false, \"params\": [ { \"type\": \"Identifier\", \"start\": 13, \"end\": 14, \"name\": \"x\" }, { \"type\": \"Identifier\", \"start\": 16, \"end\": 17, \"name\": \"y\" } ], \"body\": { \"type\": \"BlockStatement\", \"start\": 19, \"end\": 38, \"body\": [ { \"type\": \"ReturnStatement\", \"start\": 23, \"end\": 36, \"argument\": { \"type\": \"BinaryExpression\", \"start\": 30, \"end\": 35, \"left\": { \"type\": \"Identifier\", \"start\": 30, \"end\": 31, \"name\": \"x\" }, \"operator\": \"+\", \"right\": { \"type\": \"Identifier\", \"start\": 34, \"end\": 35, \"name\": \"y\" } } } ] } } ], \"sourceType\": \"module\"} 也就类似于下图这样 但是这里需要注意的是，上图仅描述 AST 的大致结构，V8 有一套自己的 AST 表示方式，生成的 AST 结构有所差异，详细可见 ast.h 基线编译器 Ignition接下来就是根据抽象语法树生成字节码，V8 引入 JIT（Just In Time，即时编译）技术，通过 Ignition 基线编译器快速生成字节码进行执行，如下图可以看出 add 函数生成对应的字节码 BytecodeGenerator 类的作用是根据抽象语法树生成对应的字节码，不同的节点会对应一个字节码生成函数 优化编译器 TurboFan编译器需要考虑的函数输入类型变化越少，生成的代码就越小、越快，众所周知，JavaScript 是弱类型语言，ECMAScript 标准中有大量的多义性和类型判断，因此通过基线编译器生成的代码执行效率低下 Turbofan 是根据字节码和热点函数反馈类型生成优化后的机器码，Turbofan 很多优化过程，基本和编译原理的后端优化差不多，采用的 sea-of-node 比如我们针对之前提到的 add 函数优化 1234567function add(x, y) { return x + y;}add(1, 2);%OptimizeFunctionOnNextCall(add); V8 是有函数可以直接调用指定优化哪个函数，执行 %OptimizeFunctionOnNextCall 主动调用 Turbofan 优化 add 函数，根据上次调用的参数反馈优化 add 函数，很明显这次的反馈是整型数，所以 turbofan 会根据参数是整型数进行优化直接生成机器码，下次函数调用直接调用优化好的机器码 注意执行 V8 需要加上 --allow-natives-syntax，OptimizeFunctionOnNextCall 为内置函数，只有加上 --allow-natives-syntax，JavaScript 才能调用内置函数，否则执行会报错 JavaScript 的 add 函数生成对应的机器码如下 如果把 add 函数的传入参数改成字符 1234567function add(x, y) { return x+y;}add('1', '2');%OptimizeFunctionOnNextCall(add); 优化后的add函数生成对应的机器码如下 对比上面两图可以发现，add 函数传入不同的参数，经过优化生成不同的机器码 如果传入的是整型，则本质上是直接调用 add 汇编指令 如果传入的是字符串，则本质上是调用 V8 的内置 Add 函数 至此，整个 V8 的执行流程就算是结束了，这里我们关于 V8 的相关内容就介绍到这里，其实主要目的也只是简单的了解其运行原理，想要深入了解可以另外查询资料深入学习 下面我们再来看看 JavaScript 当中的内存管理和垃圾回收机制 JavaScript 中的内存管理 在 C 和 C++ 这样的底层语言当中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过 malloc() 函数去手动分配，在用完之后，还要时刻记得用 free() 函数去清理释放，否则这块内存就会被永久占用，造成内存泄露 而对于 JavaScript 来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时『自动』释放内存，而这个自动释放内存的过程就被称为『垃圾回收机制』，正因为自动垃圾回收机制的存在，虽然不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露 下面我们就先从内存的生命周期开始看起，这有助于我们更好的理解下面将要介绍到的垃圾回收机制，通常而言，JavaScript 环境中分配的内存有如下生命周期，也就是我们熟知的三个步骤 内存分配，当我们申明变量、函数、对象的时候，系统会自动为它们分配内存 内存使用，即读写内存，也就是使用变量、函数等 内存回收，使用完毕，由垃圾回收机制自动回收不再使用的内存 内存分配在上面我们也有提到过，JavaScript 在定义变量时就已经完成了内存分配，比如下面这几个示例 123456789101112131415161718var n = 123 // 给数值变量分配内存var s = 'abc' // 给字符串分配内存var o = { // 给对象及其包含的值分配内存 a: 1, b: null}var a = [1, null, 'abc'] // 给数组及其包含的值分配内存（就像对象一样）function f(a) { // 给函数（可调用的对象）分配内存 return a + 2}// 函数表达式也能分配一个对象someElement.addEventListener('click', function () { someElement.style.backgroundColor = 'blue'}, false) 有些函数调用结果是分配对象内存 123var d = new Date() // 分配一个 Date 对象var e = document.createElement('div') // 分配一个 DOM 元素 有些方法分配新变量或者新对象 12345678910// 因为字符串是不变量，JavaScript 可能决定不分配内存，所以只是存储了 [0 - 3] 的范围var s = 'abc'// s2 是一个新的字符串var s2 = s.substr(0, 3)// 新数组 a3 有四个元素，是 a1 连接 a2 的结果var a1 = ['a', 'b']var a2 = ['c', 'd']var a3 = a.concat(a2) 内存使用使用值的过程实际上是对分配内存进行读取与写入的操作，读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数 123var a = 10 // 分配内存console.log(a) // 对内存的使用 内存回收JavaScript 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？其实简单来说，就是找出那些不再继续使用的值，然后释放其占用的内存，并且大多数内存管理的问题都在这个阶段 但是在这里最艰难的任务就是找到不再需要使用的变量，不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用（闭包），那么该变量会被标记回收，全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收 因为自动垃圾回收机制的存在，所以通常我们可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的，不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况 虽然无法回收所有的极端情况，但是这里也会存在着一个小问题，那就是我们该如何判断此时是否可以进行回收了呢？这也就是我们下面将要介绍的 JavaScript 当中的垃圾回收机制 垃圾回收机制垃圾回收算法主要依赖于『引用』的概念，在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象，例如一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用），对象的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域），下面我们就先从『引用计数』开始看起 另外这里需要注意的一点就是，我们所说的垃圾回收机制，其实主要指的是『堆内存』到底是如何进行垃圾回收并进行优化的 引用计数引用计数的垃圾收集策略不太常见，含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1，如果同一个值又被赋给另一个变量，则该值的引用次数加 1，相反如果包含对这个值引用的变量改变了引用对象，则该值引用次数减 1 当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来，这样当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存 这也是最初级的垃圾收集算法，此算法把『对象是否不再需要』简化定义为『对象有没有其他对象引用到它』，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，先来看下面几个示例 123456789101112131415var o = { // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o（我们这里称为原始对象） a: { // 很显然，没有一个可以被垃圾收集 b: 2 }}var o2 = o // o2 变量是第二个对原始对象的引用o = 1 // 现在，原始对象的原始引用o被o2替换了var oa = o2.a // 引用原始对象的 a 属性，现在原始对象有两个引用了，一个是 o2，一个是 oao2 = 'yo' // 最初的对象现在已经是零引用了，显然可以被垃圾回收了 // 然而它的属性 a 的对象还在被 oa 引用，所以还不能回收oa = null // 我们将 oa 置为 null，现在它就可以被回收了 由上面可以看出，引用计数算法虽然是个简单有效的算法，但是它却存在着一个致命的问题，那就是『循环引用』，如果两个对象相互引用，尽管它们已不再使用，垃圾回收不会进行回收，导致内存泄露，比如下面这个循环引用的例子 123456789function f() { var o = {} var o2 = {} o.a = o2 // o 引用 o2 o2.a = o // o2 引用 o return 'abc'}f() 上面我们申明了一个函数 f，其中包含两个相互引用的对象，在调用函数结束后，对象 o1 和 o2 实际上已离开函数范围，因此不再需要了，也就是说可以被回收了，然而根据引用计数的原则考虑到它们互相都有至少一次引用，因此这部分内存不会被回收，这样一来内存泄露就不可避免了 下面我们再来看一个平常经常会遇到的示例，其实我们大部分人时刻都在写着循环引用的代码，比如下面这个例子，相信大家都这样写过 12345var el = document.getElementById('#el')el.onclick = function (event) { console.log(`clicked`)} 我们为一个元素的点击事件绑定了一个匿名函数，我们通过 event 参数是可以拿到相应元素 el 的信息的，但是我们仔细想想，这是不是就是一个循环引用呢？ el 有一个属性 onclick 引用了一个函数（其实也是个对象），函数里面的参数又引用了 el，这样 el 的引用次数一直是 2，即使当前这个页面关闭了，也无法进行垃圾回收，如果这样的写法很多很多，就会造成内存泄露，所以我们一般可以通过在页面卸载时清除事件引用，这样就可以被回收了 1234// 页面卸载时将绑定的事件清空window.onbeforeunload = function () { el.onclick = null} 下面我们再来看另外一种垃圾回收机制，也是现代浏览器使用较多的『标记清除』 标记清除当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为进入环境，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为离开环境 标记清除算法将『不再使用的对象』定义为『无法达到的对象』，简单来说就是从根部（在 JavaScript 中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收 从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象），但反之未必成立，此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段（sweep） 标记阶段，垃圾回收器会从根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作 它的流程是下面这样的 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记 从根部出发将能触及到的对象的标记清除 那些还存在标记的变量被视为准备删除的变量 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间 如果放到具体阶段，那么顺序是是下图这样 在标记阶段，从根对象 1 可以访问到 B，从 B 又可以访问到 E，那么 B 和 E 都是可到达对象，同样的道理 F、G、J 和 K 都是可到达对象 在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收 这样一来，循环引用不再是问题了，我们再来看之前循环引用的例子 123456789function f() { var o = {} var o2 = {} o.a = o2 // o 引用 o2 o2.a = o // o2 引用 o return 'abc'}f() 函数调用返回之后，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取它们的引用，因此它们将会被垃圾回收器回收，正因为如此，从 2012 年起，所有现代浏览器都使用了『标记清除』垃圾回收算法，所有对 JavaScript 垃圾回收算法的改进都是基于『标记清除』算法的改进，并没有改进算法本身和它对『对象是否不再需要』的简化定义 另外一个需要我们注意的地方就是『何时开始垃圾回收』，通常来说在使用标记清除算法时，未引用对象并不会被立即回收，取而代之的做法是，垃圾对象将一直累计到内存耗尽为止，当内存耗尽时，程序将会被挂起，垃圾回收开始执行 虽然我们在上面列举了『标记清除』的许多优点，但是同样的『标记清除』算法也是存在一些缺陷的 那些无法从根对象查询到的对象都将被清除 垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表 1 个单位的内存，如果有一个对象需要占用 3 个内存单位的话，那么就会导致 Mutator 一直处于暂停状态，而 Collector 一直在尝试进行垃圾收集，直到 Out of Memory V8 垃圾回收策略 自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低，所以 V8 采用了一种代回收的策略，将内存分为两个生代，新生代（new generation）和老生代（old generation） 新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫『晋升』 而这种垃圾回收的方式我们称之为『分代回收』（Generation GC），本质上和 Java 回收策略思想是一致的，目的是通过区分『临时』与『持久』对象（也就是我们经常听闻的『新生代』与『老生代』对象） 多回收『临时对象区』（young generation） 少回收『持久对象区』（tenured generation） 减少每次需遍历的对象，从而减少每次 GC 的耗时，Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略，如下图所示 但是在展开回收策略之前，我们需要先来了解一下 V8 当中的内存限制 V8 内存限制在 Node.js 中，JavaScript 能使用的内存是有限制的，通常来说 64 位系统下约为 1.4GB 32 位系统下约为 0.7GB 对应到分代内存中，默认情况下 32 位系统新生代内存大小为 16MB，老生代内存大小为 700MB 64 位系统新生代内存大小为 32MB，老生代内存大小为 1.4GB 这个限制在 Node.js 启动的时候可以通过传递 --max-old-space-size 和 --max-new-space-size 来调整 12node --max-old-space-size=1700 app.js // 单位为 MBnode --max-new-space-size=1024 app.js // 单位为 MB 上述参数在 V8 初始化时生效，一旦生效就不能再动态改变，但是这里我们可能会有一个疑问，那就是 V8 为什么会有内存限制呢？主要原因有以下几点 表面上的原因是 V8 最初是作为浏览器的 JavaScript 引擎而设计，不太可能遇到大量内存的场景 而深层次的原因则是由于 V8 的垃圾回收机制的限制，由于 V8 需要保证 JavaScript 应用逻辑与垃圾回收器所看到的不一样，V8 在执行垃圾回收时会阻塞 JavaScript 应用逻辑，直到垃圾回收结束再重新执行 JavaScript 应用逻辑，这种行为被称为『全停顿』（stop-the-world） 若 V8 的堆内存为 1.5GB，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上，这样浏览器将在 1s 内失去对用户的响应，造成假死现象，如果有动画效果的话，动画的展现也将显著受到影响 在简单了解完 V8 内存限制相关内容以后，下面我们就来正式的看看 V8 垃圾回收策略相关内容，先从新生代算法开始看起 新生代算法（Scavenge）新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收，而新生代中的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 的具体实现中，主要采用 Cheney 算法，Cheney 算法将内存平均分成两块相等的内存空间，叫做 semispace，每块内存大小 8MB（32 位）或 16MB（64 位），一块处于使用状态，一块处于闲置状态 它的主要流程是下面这样的 Cheney 算法是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，这两个空间中只有一个处于使用中，一个处于闲置状态 处于使用状态的空间称为 From 空间，处于闲置的空间称为 To 空间 分配对象时，先是在 From 空间中进行分配，当开始垃圾回收时，会检查 From 空间中的存活对象，并将这些存活对象复制到 To 空间中，而非存活对象占用的空间被释放 完成复制后，From 空间和 To 空间的角色互换 简而言之，垃圾回收过程中，就是通过将存活对象在两个空间中进行复制 但是 Scavenge 算法也是存在一定缺点的，那就是只能使用堆内存中的一半，但由于它只复制存活的对象，对于生命周期短的场景存活对象只占少部分，所以在时间效率上有着优异的表现 晋升以上我们所说的新生代算法是在纯 Scavenge 算法中，但是在分代式垃圾回收的前提下，From 空间中存活的对象在复制到 To 空间之前需要进行检查，在一定条件下，需要将存活周期较长的对象移动到老生代中，这个过程称为对象『晋升』，对象晋升的条件主要有两个 第一点，对象从 From 空间复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收，如果已经经历过了，会将该对象从 From 空间移动到老生代空间中，如果没有，则复制到 To 空间，总结来说，如果一个对象是第二次经历从 From 空间复制到 To 空间，那么这个对象会被移动到老生代中 第二点，当要从 From 空间复制一个对象到 To 空间时，如果 To 空间已经使用了超过 25%，则这个对象直接晋升到老生代中，设置 25% 这个阈值的原因是当这次 Scavenge 回收完成后，这个 To 空间会变为 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配 老生代算法（Mark-Sweep，Mark-Compact）在老生代中，存活对象占较大比重，如果继续采用 Scavenge 算法进行管理，就会存在两个问题 由于存活对象较多，复制存活对象的效率会很低 采用 Scavenge 算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重 所以 V8 在老生代中主要采用了 Mark-Sweep 和 Mark-Compact 相结合的方式进行垃圾回收 Mark-Sweep（标记-清除算法）这个算法我们在上文已经介绍过了，这里再简单的总结一下 与 Scavenge 不同，Mark-Sweep 并不会将内存分为两份，所以不存在浪费一半空间的行为，Mark-Sweep 在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象 也就是说，Scavenge 只复制活着的对象，而 Mark-Sweep 只清除死了的对象，活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因 但是这个算法有个比较大的问题是，内存碎片太多，如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的，所以在此基础上提出 Mark-Compact 算法 Mark-Compact为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 就被提出来了，Mark-Compact 是标记整理的意思，是在 Mark-Sweep 的基础上演变而来的 Mark-Compact 在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存 两者结合在 V8 的回收策略中，Mark-Sweep 和 Mark-Conpact 两者是结合使用的，由于 Mark-Conpact 需要移动对象，所以它的执行速度不可能很快 在取舍上，V8 主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用 Mark-Compact 总结其实简单来说，V8 的垃圾回收机制分为新生代和老生代 新生代主要使用 Scavenge 进行管理，主要实现是 Cheney 算法，将内存平均分为两块，使用空间叫 From，闲置空间叫 To，新对象都先分配到 From 空间中，在空间快要占满时将存活对象复制到 To 空间中，然后清空 From 的内存空间，此时调换 From 空间和 To 空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代 老生代主要采用 Mark-Sweep 和 Mark-Compact 算法，一个是标记清除，一个是标记整理，两者不同的地方是，Mark-Sweep 在垃圾回收后会产生碎片内存，而 Mark-Compact 在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些，在 V8 中，老生代是 Mark-Sweep 和 Mark-Compact 两者共同进行管理的 内存泄漏在梳理完垃圾回收机制相关内容以后，最后我们再来简单的了解一下内存泄漏相关问题，那么什么是内存泄漏呢？ 简单来说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存，对于持续运行的服务进程（daemon），必须及时释放不再用到的内存，否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃 本质上讲，内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费 内存泄漏的识别方法经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏，这就要求实时查看内存的占用情况，这一点我们可以通过 Chrome 的开发者工具来查看内存占用情况 打开开发者工具，选择 Performance 面板 在顶部勾选 Memory 点击左上角的 record 按钮 在页面上进行各种操作，模拟用户的使用情况 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况 来看一张效果图 我们有两种方式来判定当前是否有内存泄漏 多次快照后，比较每次快照中内存的占用情况，如果呈上升趋势，那么可以认为存在内存泄漏 某次快照后，看当前内存占用的趋势图，如果走势不平稳，呈上升趋势，那么可以认为存在内存泄漏 而如果是在服务器环境中的话，则可以使用 Node.js 提供的 process.memoryUsage 方法查看内存情况 1234567console.log(process.memoryUsage())// {// rss: 27709440,// heapTotal: 5685248,// heapUsed: 3449392,// external: 8772// } process.memoryUsage 返回一个对象，包含了 Node.js 进程的内存占用信息，该对象包含四个字段，单位是字节，含义如下 rss（resident set size），所有内存占用，包括指令区和堆栈 heapTotal，堆所占用的内存，包括用到的和没用到的 heapUsed，用到的堆的部分， external，V8 引擎内部的 C++ 对象占用的内存 通常我们判断内存泄漏均是以 heapUsed 字段为准 常见的内存泄露下面我们来了解几种常见的 JavaScript 当中的内存泄漏 意外的全局变量JavaScript 处理未定义变量的方式比较宽松，未定义的变量会在全局对象创建一个新变量，在浏览器中，全局对象是 window 12345678// 忘记使用 var/const/let，意外创建了一个全局变量 bar，此例泄漏了一个简单的字符串function foo(arg) { bar = 'this is a hidden global variable'}function foo(arg) { window.bar = 'this is an explicit global variable'} 另一种意外的全局变量可能由 this 创建 123456function foo() { this.variable = 'potential accidental global'}// this 指向了全局对象（window）foo() 针对于上述情况，解决办法也很简单，我们可以在 JavaScript 文件头部加上 'use strict'，使用严格模式解析 JavaScript 避免意外的全局变量，此时上例中的 this 指向 undefined，如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义 尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾，它们被定义为不可回收（除非定义为空或重新分配），尤其当全局变量用于临时存储和处理大量信息时，需要多加小心，如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义 与全局变量相关的增加内存消耗的一个主因是缓存，缓存数据是为了重用，缓存必须有一个大小上限才有用，高内存消耗导致缓存突破上限，因为缓存内容无法被回收 循环引用1234567function func() { let A = {} let B = {} A.a = B // A 引用 B B.a = A // B 引用 A} 对于纯粹的 ECMAScript 对象而言，只要没有其他对象引用对象 A、B，也就是说它们只是相互之间的引用，那么仍然会被垃圾收集系统识别并回收处理，但是在 Internet Explorer 中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会发现它们之间的循环关系与系统中的其他对象是隔离的并释放它们，最终它们将被保留在内存中，直到浏览器关闭 如果想要解决这个问题，只需要将 A 和 B 都设为 null 即可 被遗忘的定时器或延时器在 JavaScript 中使用 setInterval 和 setTimeout 很常见，但是使用完之后通常会忘记清理 123456789let result = getData()setInterval(function () { let node = document.getElementById('id') if (node) { // 处理 node 和 result node.innerHTML = JSON.stringify(result) }}, 1000) 上面示例当中几个需要注意的地方 最好将获取 node 的操作放到定时器之外 setInterval、setTimeout 中的 this 指向的是 window 对象，所以内部定义的变量也挂载到了全局 if 内引用了 result 变量，如果没有清除，setInterval 的话 result 也得不到释放，同理 setTimeout 也一样 解决办法，用完后记得使用 clearInterval、clearTimeout 来清除定时器 闭包JavaScript 当中的闭包有一个十分关键的点，那就是匿名函数可以访问其父级作用域的变量 123456function bindEvent() { let obj = document.createElement('id') obj.onclick = function () { // ... }} 闭包可以维持函数内局部变量，使其得不到释放，上例定义事件回调时，由于是函数内定义函数，并且内部函数，也就是事件回调的引用外暴了，形成了闭包 解决办法有两种 将事件处理函数定义在外部，解除闭包 在定义事件处理函数的外部函数中，删除对 DOM 的引用，通常而言在闭包中，作用域中没用的属性可以删除，以减少内存消耗 12345678910111213141516171819// 方法一function bindEvent() { let obj = document.createElement('id') obj.onclick = onclickHandler}function onclickHandler() { // ...}// 方法二function bindEvent() { let obj = document.createElement('id') obj.onclick = function () { // ... } obj = null} DOM 引起的内存泄露当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在 IE 中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露 12345let btn = document.getElementById('btn')btn.onclick = function () { document.getElementById('id').innerHTML = 'abc'} 解决办法有两种 手动移除事件 采用事件委托 123456789101112131415// 手动移除事件let btn = document.getElementById('btn')btn.onclick = function () { btn.onclick = null document.getElementById('id').innerHTML = 'abc'}// 采用事件委托document.onclick = function (event) { event = event || window.event if (event.target.id == 'btn') { document.getElementById('id').innerHTML = 'abc' }} 另外未清除的 DOM 引用也可能会引起内存泄露 123let myDiv = document.getElementById('id')document.body.removeChild(myDiv) myDiv 不能回收，因为存在变量 myDiv 对它的引用，解决办法也很简单，直接将 myDiv 设为 null 即可 最后我们再来看一个可能会忽略的问题，那就是 DOM 对象添加的属性是一个对象的引用，这种情况下也可能会引起内存泄露 123let MyObject = {}document.getElementById('myDiv').myProp = MyObject 解决办法就是在页面 onunload 事件中进行释放，比如 document.getElementById('myDiv').myProp = null 自动类型转换123let s = 'abc'console.log(s.length) s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JavaScript 引擎会自动创建一个临时 String 对象来封装 s，而这个对象一定会泄露 解封办法就是记得所有值类型做运算之前先显式转换一下 123let s = 'abc'console.log(new String(s).length) 小结其实关于如何避免内存泄漏，我们只需要记住一个原则『不用的东西，及时归还』 减少不必要的全局变量，使用严格模式避免意外创建全局变量 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除等） 组织好逻辑，避免死循环等造成浏览器卡顿，崩溃的问题 参考 JS 引擎与字节码的不解之缘 认识 V8 引擎 V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道 V8 是怎么跑起来的 —— V8 中的对象表示 DLS Keynote: Ignition: Jump-starting an Interpreter for V8 Turbofan IR V8 小整数（smi）和指针","link":"/2020/08/02/JavaScript/54/"},{"title":"深入 TypeScript","text":"接上回 重温 TypeScript，在之前的章节当中，我们简单的梳理一下 TypeScript 的基础内容和基本用法，本章当中我们就来看一些 TypeScript 当中的进阶内容，也算是针对于 TypeScript 做一个比较深入的学习记录吧，主要包括以下内容 类型别名 字面量类型 元组 枚举 类 类与接口 泛型（因为泛型涉及的相关内容较多，所以另起篇幅来进行介绍） 下面我们就先从比较简单的类型别名和字符串字面量类型开始看起 类型别名这个很好理解，就是用来给一个类型起个新名字，方式是使用 type 来创建类型别名 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n } else { return n() }} 关于首字母大写的问题，通常来说在语法上没有限制，不过参考 TypeScript 官方 的写法，一般建议首字母大写 字面量类型同类型别名一样，字面量类型也是使用 type 来进行定义，它的作用简单来说就是用来约束取值只能是某几个字段当中的一个，比如下面这个示例 12345678type EventNames = 'click' | 'scroll' | 'mousemove'function handleEvent(ele: Element, event: EventNames) { // ...}const el = document.getElementById('el')handleEvent(el, 'click') // ✅handleEvent(el, 'dblclick') // ❌ 在上面的示例当中，我们使用 type 定义了一个字符串字面量类型 EventNames，它规定只能取三种事件名当中的一种，如果定义了约定以外的字段，就会报错 当然除了字符串字面量类型，数值类型也是可以的 1234type Nums = 1 | 2 | 3let x: Nums = 1 // ✅let y: Nums = 4 // ❌ 元组我们在之前的章节当中介绍了数组的类型，众所周知，数组一般由同种类型的值组成，也就是合并了相同类型的对象，但有时我们需要在单个变量中存储不同类型的值，在这种情况下我们就可以使用元组，它可以理解为是合并了不同类型的对象 在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组，元组可用于定义具有有限数量的未命名属性的类型，每个属性都有一个关联的类型，使用元组时必须提供每个属性的值 为了更直观地理解元组的概念，我们来看一个具体的例子 1let x: [string, number] = ['zhangsan', 18] 在上面代码中，我们定义了一个名为 x 的变量，它的类型是一个类型数组 [string, number]，然后我们按照正确的类型依次初始化 x 变量，与数组一样，我们可以通过下标来访问元组中的元素并且操作它们 1234567let x: [string, number] = ['zhangsan', 18]x[0] = 'lisi'x[1] = 20x[0].slice(1)x[1].toFixed() 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，否则会报错 1234let x: [string, number]x = ['zhangsan', 18] // ✅x = ['zhangsan'] // ❌ 另外需要注意的是，如果当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型 1234567let x: [string, number] = ['zhangsan', 18]x.push('lisi') // ✅x.push(true) // ❌console.log(x) // ✅console.log(x[2]) // ❌ 但是通常不建议超出范围，因为使用元祖可以确定元素数据类型，可以把元祖理解为固定长度，但是超出范围不能保证其类型 枚举枚举（Enum）类型在某些方面与我们之前介绍的元组有一些类似的地方，它主要用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等等，使用 enum 关键字来定义 1enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat } 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射 1234enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }Days[0] // SunDays['Sun'] // 0 我们也可以给枚举项手动赋值 12345enum Days { Sun = 7, Mon, Tue = 1, Wed, Thu, Fri, Sat }Days['Sun'] // 7Days['Mon'] // 8Days['Wed'] // 2 运行后可以发现，未手动赋值的枚举项会接着上一个枚举项依次递增，但是需要注意的是，如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的 1234enum Days { Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat }Days['Sun'] === 3 // trueDays['Wed'] === 3 // true 在上面的示例当中，递增到 3 的时候与我们前面手动赋值的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 'Sun'，而后又被 'Wed' 覆盖了，但是我们在实际应用场景当中需要注意，最好不要出现这种覆盖的情况 当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1 12345enum Days { Sun = 1.2, Mon, Tue, Wed, Thu, Fri, Sat }Days['Mon'] // 2.2Days['Tue'] // 3.2Days['Wed'] // 4.2 这里我们简单总结一下枚举成员的特点，主要有两点 是只读属性，无法修改 枚举成员值默认从 0 开始递增，可以自定义设置初始值 1234567enum Gender { BOY = 1, GIRL}Gender.BOY // 1Gender // { '1': 'BOY', '2': 'GIRL', BOY: 1, GIRL: 2 } 而枚举成员值有以下特点 可以没有初始值 可以是一个对常量成员的引用 可以是一个常量表达式 也可以是一个非常量表达式 123456789101112enum Char { // const member 常量成员，在编译阶段被计算出结果 a, // 没有初始值 b = Char.a, // 对常量成员的引用 c = 1 + 3, // 常量表达式 // computed member 计算成员，表达式保留到程序的执行阶段 d = Math.random(), // 非常量表达式 e = '123'.length, f = 6, // 紧跟在计算成员后面的枚举成员必须有初始值 g} 常量枚举与普通枚举的区别主要有以下一些区别 常量枚举会在编译阶段被删除 枚举成员只能是常量成员 12345678const enum Colors { Red, Yellow, Blue}// 常量枚举会在编译阶段被删除let myColors = [Colors.Red, Colors.Yellow, Colors.Blue] 上面代码经过编译以后是下面这样 12'use strict'var myColors = [0 /* Red */, 1 /* Yellow */, 2 /* Blue */] 常量枚举不能包含计算成员，如果包含了计算成员，则会在编译阶段报错 1234// ❌const enum Color { Red, Yellow, Blue = 'blue'.length }console.log(Colors.RED) 枚举的使用场景我们先来看一段经常会遇见的代码风格，如下 1234567891011function initByRole(role) { if (role === 1 || role == 2) { console.log('1, 2') } else if (role == 3 || role == 4) { console.log('3, 4') } else if (role === 5) { console.log('5') } else { console.log('') }} 上面的代码虽然可以正常运行，但是也存在着一些问题 可读性差，很难记住数字的含义 可维护性差，硬编码，后续修改的话牵一发动全身 我们可以使用枚举的方式来改善一下 1234567891011121314151617181920212223242526272829enum Role { Reporter, Developer, Maintainer, Owner, Guest}function init(role: number) { switch (role) { case Role.Reporter: console.log('Reporter: 1') break case Role.Developer: console.log('Developer: 2') break case Role.Maintainer: console.log('Maintainer: 3') break case Role.Owner: console.log('Owner: 4') break default: console.log('Guest: 5') break }}init(Role.Developer) 使用数字类型作为标志这种使用方式经常在一些第三方类库当中可以看到，因为枚举的一个很好用途是使用枚举作为标志，这些标志允许你检查一组条件中的某个条件是否为真，比如下面这个例子，我们有一组关于 animals 的属性 1234567enum AnimalFlags { None = 0, HasClaws = 1 &lt;&lt; 0, CanFly = 1 &lt;&lt; 1, EatsFish = 1 &lt;&lt; 2, Endangered = 1 &lt;&lt; 3} 在这里我们使用了左移的位运算符，将数字 1 的二进制向左移动位置得到数字 0001、0010、0100 和 1000（换成十进制结果是 1，2，4，8），当我们在使用这种标记的时候，|（或）、&amp;（和）、~（非）等位运算符将会是很好的搭配 1234567891011121314151617181920212223242526272829303132333435enum AnimalFlags { None = 0, HasClaws = 1 &lt;&lt; 0, CanFly = 1 &lt;&lt; 1}interface Animal { flags: AnimalFlags [key: string]: any}function printAnimalAbilities(animal: Animal) { var animalFlags = animal.flags if (animalFlags &amp; AnimalFlags.HasClaws) { console.log('animal has claws') } if (animalFlags &amp; AnimalFlags.CanFly) { console.log('animal can fly') } if (animalFlags == AnimalFlags.None) { console.log('nothing') }}var animal = { flags: AnimalFlags.None }printAnimalAbilities(animal) // nothinganimal.flags |= AnimalFlags.HasClawsprintAnimalAbilities(animal) // animal has clawsanimal.flags &amp;= ~AnimalFlags.HasClawsprintAnimalAbilities(animal) // nothinganimal.flags |= AnimalFlags.HasClaws | AnimalFlags.CanFlyprintAnimalAbilities(animal) // animal has claws, animal can fly 在上面的示例当中 我们使用 |= 来添加一个标志 组合使用 &amp;= 和 ~ 来清理一个标志 使用 | 来合并标志 因为组合标志可以在枚举类型中定义方便快捷的方式，比如下面的 EndangeredFlyingClawedFishEating 123456789enum AnimalFlags { None = 0, HasClaws = 1 &lt;&lt; 0, CanFly = 1 &lt;&lt; 1, EatsFish = 1 &lt;&lt; 2, Endangered = 1 &lt;&lt; 3, EndangeredFlyingClawedFishEating = HasClaws | CanFly | EatsFish | Endangered} 以上关于枚举的相关内容我们就暂时介绍到这里，因为毕竟平时涉及到的有限，如果后续工作当中有遇到相关内容的话再来进行完善，枚举的其他一些用法可以参考文档当中的 枚举 类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承，而在 ES6 中，我们终于迎来了 class，TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法，下面就让我们就来看看 TypeScript 中类的用法 TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected public，修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private，修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected，修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 下面我们来看几个示例 123456789101112class Person { public name public constructor(name) { this.name = name }}let a = new Person('zhangsan')a.name // zhangsana.name = 'lisi'a.name // lisi 在上面示例当中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的，如果我们希望有的属性是无法直接存取的，这时候就可以用 private 了 1234567891011class Person { private name public constructor(name) { this.name = name }}let a = new Person('zhangsan')// ❌，因为属性 name 为私有属性，只能在类 Person 中访问console.log(a.name) 但是需要注意的是，在 TypeScript 编译之后的代码中，其实并没有限制 private 属性在外部的可访问性 12345678910var Person = (function () { function Person(name) { this.name = name } return Person})()var a = new Person('zhangsan')a.name // zhangsan 同时，使用 private 修饰的属性或方法，在子类中也是不允许访问的 1234567891011121314class Person { private name public constructor(name) { this.name = name }}class Man extends Person { constructor(name) { super(name) // ❌ console.log(this.name) }} 而如果是用 protected 修饰，则允许在子类中访问 1234567891011121314class Person { protected name public constructor(name) { this.name = name }}class Man extends Person { constructor(name) { super(name) // ✅ console.log(this.name) }} 如果我们不想让该类被继承或者实例化，那么可以在构造函数上设置 private 修饰 1234567891011class Person { public name private constructor(name) { this.name = name }}// ❌class Man extends Person { // ...} 当构造函数修饰为 protected 时，该类只允许被继承 123456789101112131415class Person { public name protected constructor(name) { this.name = name }}// ✅class Man extends Person { // ...}// ❌let man = new Person() 同样的，上面介绍到的修饰符和下面提到的 readonly 都可以使用在构造函数的参数当中，等同于类中定义该属性的同时给该属性赋值 1234567891011121314class Person { public name protected constructor(name) { this.name = name }}// 等同于 ==&gt;class Person { protected constructor(public name) { }} readonly只读属性关键字，表示只允许出现在属性声明或索引签名或构造函数中，比如我们可以指定一个类的属性为只读，然后在声明时或者构造函数中初始化它们 123456789101112class Person { readonly name public constructor(name) { this.name = name }}// ✅let man = new Person('zhangsan')// ❌man.name = 'list' 不过需要注意的是，如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面 1234567891011class Person { // ✅ public readonly name // ❌ readonly public name public constructor(name) { this.name = name }} 当然也可以在 interface 和 type 里使用 readonly 12345678type Foo = { readonly bar: number readonly bas: number}const foo: Foo = { bar: 123, bas: 456 }foo.bar = 456 // ❌ 甚至可以把索引签名标记为只读 12345678interface Foo { readonly [x: number]: number}const foo: Foo = { 0: 123, 2: 345 }console.log(foo[0]) // ✅foo[0] = 456 // ❌ 属性只读，不可操作 如果想以不变的方式使用原生 JavaScript 数组，可以使用 TypeScript 提供的 ReadonlyArray&lt;T&gt; 接口 1234567let foo: ReadonlyArray&lt;number&gt; = [1, 2, 3]console.log(foo[0]) // ✅foo.push(4) // ❌ ReadonlyArray 上不存在 push，因为它会改变数组foo = foo.concat(4) // ✅ 创建副本是可行的 还有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型 123456789101112type Foo = { bar: number bas: number}type FooReadonly = Readonly&lt;Foo&gt;const foo: Foo = { bar: 123, bas: 456 }const fooReadonly: FooReadonly = { bar: 123, bas: 456 }foo.bar = 456 // ✅fooReadonly.bar = 456 // ❌ 另外在 React 当中我们也可以标记 Props 和 State 为不可变数据 1234567891011121314interface Props { readonly foo: number}interface State { readonly bar: number}export class Something extends React.Component&lt;Props, State&gt; { someMethod() { this.props.foo = 123 // ❌ props 是不可变的 this.state.baz = 456 // ❌ state 也是同理，应该使用 this.setState() }} 然而我们并不需要这样操作，因为 React 的声明文件已经标记这些为 readonly（通过传入泛型参数至一个内部包装，来把每个属性标记为 readonly） 123456export class Something extends React.Component&lt;{ foo: number }, { baz: number }&gt; { someMethod() { this.props.foo = 123 // ❌ props 是不可变的 this.state.baz = 456 // ❌ state 也是同理，应该使用 this.setState() }} 最后我们再来简单的了解一下 readonly 与 const 之间的区别，首先 const 用于变量，而 readonly 用于属性，比如下面这个示例 12345const foo = 123 // 变量let bar: { readonly bar: number // 属性} 另外 const 变量不能重新赋值给其他任何事物，而 readonly 用于别名，可以修改属性 1234567891011const foo: { readonly bar: number } = { bar: 123}function iMutateFoo(foo: { bar: number }) { foo.bar = 456}iMutateFoo(foo)console.log(foo.bar) // 456 当然如果我们在上面的 iMutateFoo 当中明确的表示参数是不可修改的，那么编译器会发出错误警告 1234567891011121314interface Foo { readonly bar: number}let foo: Foo = { bar: 123}function iTakeFoo(foo: Foo) { // ❌ 属性只读，不可操作 foo.bar = 456}iTakeFoo(foo) 抽象类使用 abstract 来定义抽象类和其中的抽象方法，那么什么是抽象类呢？首先抽象类是不允许被实例化的 123456789abstract class Person { public name public constructor(name) { this.name = name }}// ❌let man = new Person('zhangsan') 在上面的例子当中，我们定义了一个抽象类 Person，可以发现在实例化抽象类的时候报错了，另外如果抽象类当中存在抽象方法（指不包含具体实现的方法），如下 1234567abstract class Person { public name public constructor(name) { this.name = name } public abstract say()} 其中的抽象方法必须被子类实现 123456789101112131415161718abstract class Person { public name public constructor(name) { this.name = name } public abstract say()}class Man extends Person { // 这里需要实现父类当中的抽象方法，否则会报错 public say() { console.log(this.name) }}let man = new Man('zhangsan')man.say() 私有字段在 TypeScript 3.8 版本就开始支持 ECMAScript 私有字段，使用方式如下 12345678910111213141516class Person { #name: string constructor(name: string) { this.#name = name } greet() { console.log(`${this.#name}`) }}let man = new Person('zhangsan')// ❌man.#name 可以发现，会有报错信息，提示我们属性 #name 在类 Person 外部不可访问，另外，私有字段与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段需要约定以下几点规则 私有字段以 # 字符开头，有时候我们称其为『私有名称』 每个私有字段名称都唯一地限定于其包含的类 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private） 私有字段不能在包含的类之外访问，甚至不能被检测到 在使用私有字段的过程当中，不得不让我们想起另外一个与其十分类似的东西，那就是 private 修饰符，那么使用 # 定义的私有字段与 private 修饰符定义字段有什么区别呢？先让我们来看一个 private 的示例 12345678class Person { constructor(private name: string) { }}let person = new Person('zhangsan')// ❌console.log(person.name) 在上面代码中，我们创建了一个 Person 类，该类中使用 private 修饰符定义了一个私有属性 name，接着使用该类创建一个 person 对象，然后通过 person.name 来访问 person 对象的私有属性，这时 TypeScript 编译器会提示我们有以下异常 1Property 'name' is private and only accessible within class 'Person'.(2341) 那如何解决这个异常呢？当然我们可以使用类型断言把 person 转为 any 类型 12345(&lt;any&gt;person).name// or(person as any).name 通过这种方式虽然解决了 TypeScript 编译器的异常提示，但是在运行时我们依然可以发现还是可以访问到 Person 类内部的私有属性，至于为什么会这样，我们来看一下编译生成的 ES5 代码就知道答案了 12345678910var Person = /** @class */ (function () { function Person(name) { this.name = name } return Person}())var person = new Person('zhangsan')person.name 下面我们再来看看在 TypeScript 3.8 以上版本通过 # 号定义的私有字段编译后会生成什么代码，这里还是以上面的代码为例 1234567891011class Person { #name: string constructor(name: string) { this.#name = name } greet() { console.log(`${this.#name}`) }} 我们将编译的目标设置为 ES2015，会编译生成以下代码 1234567891011121314151617181920212223242526272829'use strict'var __classPrivateFieldSet = (this &amp;&amp; this.__classPrivateFieldSet) || function (receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError('attempted to set private field on non-instance') } privateMap.set(receiver, value) return value }var __classPrivateFieldGet = (this &amp;&amp; this.__classPrivateFieldGet) || function (receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError('attempted to get private field on non-instance') } return privateMap.get(receiver) }var _nameclass Person { constructor(name) { _name.set(this, void 0) __classPrivateFieldSet(this, _name, name) } greet() { console.log(`${__classPrivateFieldGet(this, _name)}`) }}_name = new WeakMap() 通过观察我们可以发现，在使用 # 号定义的私有字段当中，会通过 WeakMap 对象来存储，同时编译器会生成 __classPrivateFieldSet 和 __classPrivateFieldGet 这两个方法用于设置值和获取值，这样一来我们就无法在外部进行 name 属性的访问了 类与接口实现（implements）是面向对象中的一个重要概念，一般来说一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现，这个特性大大提高了面向对象的灵活性 1234567891011121314151617interface SayName { sayName(): void}class Animal { }class Cat extends Animal implements SayName { sayName() { console.log(`cat`) }}class Dog extends Animal implements SayName { sayName() { console.log(`dog`) }} 同样的，一个类可以实现多个接口 12345678910111213141516interface SayName { sayName(): void}interface SayAge { sayAge(): void}class Rabbit implements SayName, SayAge { sayName() { console.log(`cat`) } sayAge() { console.log(`3`) }} 但是需要注意一点，接口与接口之间也是可以是继承关系的 12345678910111213141516interface SayName { sayName(): void}interface SayAge extends SayName { sayAge(): void}class Rabbit implements SayAge { sayName() { console.log(`cat`) } sayAge() { console.log(`3`) }} 接口继承类最后我们再来看一种比较有趣的情况，但是也是平常使用较少的一种情况，那就是接口继承类，在常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的 1234567891011121314class Point { x: number y: number constructor(x: number, y: number) { this.x = x this.y = y }}interface Point3d extends Point { z: number}let point3d: Point3d = { x: 1, y: 2, z: 3 } 但是为什么 TypeScript 会支持接口继承类呢？实际上当我们在声明 class Point 的时候，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型） 所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例） 12345678910class Point { x: number y: number constructor(x: number, y: number) { this.x = x this.y = y }}const p = new Point(1, 2) 也可以将 Point 当做一个类型来用 1234567891011121314class Point { x: number y: number constructor(x: number, y: number) { this.x = x this.y = y }}function printPoint(p: Point) { console.log(p.x, p.y)}printPoint(new Point(1, 2)) 上面这个例子实际上可以等价于 12345678910111213141516171819class Point { x: number y: number constructor(x: number, y: number) { this.x = x this.y = y }}interface PointInstanceType { x: number y: number}function printPoint(p: PointInstanceType) { console.log(p.x, p.y)}printPoint(new Point(1, 2)) 在上面示例当中我们新声明了一个 PointInstanceType 的类型，其实本质上与声明 class Point 时创建的 Point 类型是等价的，所以在回过头来看我们之前的示例，就很容易的理解为什么 TypeScript 会支持接口继承类了 1234567891011121314151617181920class Point { x: number y: number constructor(x: number, y: number) { this.x = x this.y = y }}interface PointInstanceType { x: number y: number}// 其实等价于 interface Point3d extends PointInstanceTypeinterface Point3d extends Point { z: number}let point3d: Point3d = { x: 1, y: 2, z: 3 } 当我们声明 interface Point3d extends Point 的时候，本质上 Point3d 继承的是类 Point 的实例的类型，我们可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType，所以『接口继承类』和『接口继承接口』没有什么本质的区别 但是需要注意的是，那就是 PointInstanceType 相比于 Point 缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point 类型是不包含构造函数的，另外除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法） 换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法 123456789101112131415161718192021222324class Point { static origin = new Point(0, 0) // 静态属性，坐标系原点 static distanceToOrigin(p: Point) { // 静态方法，计算与原点距离 return Math.sqrt(p.x * p.x + p.y * p.y) } x: number // 实例属性 x 轴的值 y: number // 实例属性 y 轴的值 constructor(x: number, y: number) { this.x = x this.y = y } printPoint() { // 实例方法 console.log(this.x, this.y) }}interface PointInstanceType { x: number y: number printPoint(): void}let p1: Pointlet p2: PointInstanceType 上例中最后的类型 Point 和类型 PointInstanceType 本质上是等价的，所以我们可以发现，在接口继承类的时候，只会继承它的实例属性和实例方法 类型接口之间的区别这里我们简单的总结一下几种不同的类型接口之间的区别 『可索引类型接口』 这个我们在上面也有所提及，它一般用来约束数组和对象，其中『数字索引』通常用来约束数组，其中的 index 可以任意取名，只要 index 的类型是 number，那么值的类型必须是 string 123456789interface StringArray { // key 的类型为 number，一般都代表是数组 // 限制 value 的类型为 string [index: number]: string}let arr: StringArray = ['aaa', 'bbb']console.log(arr) 而『字符串索引』通常用来约束对象，只要 index 的类型是 string，那么值的类型必须是 string 1234567interface StringObject { // key 的类型为 string，一般都代表是对象 // 限制 value 的类型为 string [index: string]: string}let obj: StringObject = { name: 'ccc' } 『函数类型接口』 通常是对方法传入的参数和返回值进行约束，但是需要注意普通的接口与函数类型接口之间的区别 1234// 普通的接口interface discount1 { getNum: (price: number) =&gt; number} 12345678910// 函数类型接口interface discount2 { // `:` 前面的是函数的签名，用来约束函数的参数 // `:` 后面的用来约束函数的返回值 (price: number): number}let cost: discount2 = function (price: number): number { return price * .8} 另外，也可以使用类型别名 123type Add = (x: number, y: number) =&gt; numberlet add: Add = (a: number, b: number) =&gt; a + b 『类类型接口』 简单来说，就是对类的约束，让类去实现接口（可以实现多个接口），如果接口用于一个类的话，那么接口会表示『行为的抽象』，并且接口只能约束类的公有成员（实例属性或方法），而无法约束私有成员、构造函数、静态属性或方法 123456789101112131415161718192021interface Speakable { name: string speak(words: string): void}interface Speakable2 { age: number}class Dog implements Speakable, Speakable2 { name!: string age = 18 speak(words: string) { console.log(words) }}let dog = new Dog()dog.speak('wang') 『混合类型接口』 简单来说就是一个对象可以同时做为函数和对象使用，也就是我们之前提到过的接口与接口之间的继承 12345678interface FnType { (getName: string): string}interface MixedType extends FnType { name: string age: number} 123456789101112131415161718interface Counter { (start: number): string interval: number reset(): void}function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) { } counter.interval = 123 counter.reset = function () { } return counter}let c = getCounter()c(10)c.reset()c.interval = 5.0 interface 与 type 的区别最后我们再来看看 interface 与 type 之间的区别，其实简单来说，interface 主要用于描述『数据结构』，而 type 主要用于描述『类型关系』，下面我们通过一些示例来进行区分 相同点一，都可以描述一个对象或者函数 1234567891011121314151617// interfaceinterface User { name: string age: number}interface SetUser { (name: string, age: number): void}// typetype User = { name: string age: number}type SetUser = (name: string, age: number) =&gt; void 相同点二，都允许拓展（extends） interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type，type 也可以 extends interface，虽然效果差不多，但是两者语法不同 123456789101112131415161718192021222324252627282930313233// interface extends interfaceinterface Name { name: string}interface User extends Name { age: number}// type extends typetype Name = { name: string}type User = Name &amp; { age: number }// interface extends typetype Name = { name: string}interface User extends Name { age: number}// type extends interfaceinterface Name { name: string}type User = Name &amp; { age: number} 不同点一，type 可以而 interface 不行 type 可以声明基本类型别名，联合类型，元组等类型 12345678910111213141516// 基本类型别名type Name = string// 联合类型interface Dog { wang()}interface Cat { miao()}type Pet = Dog | Cat// 具体定义数组每个位置的类型type PetList = [Dog, Pet] 还可以使用 typeof 获取实例的 类型进行赋值 1234// 当我们想获取一个变量的类型时，可以使用 typeoflet div = document.createElement('div')type B = typeof div 另外还可以用来做一些骚操作 12345678910111213type StringOrNumber = string | numbertype Text = string | { text: string }type NameLookup = Dictionary&lt;string, Person&gt;type Callback&lt;T&gt; = (data: T) =&gt; voidtype Pair&lt;T&gt; = [T, T]type Coordinates = Pair&lt;number&gt;type Tree&lt;T&gt; = T | { left: Tree&lt;T&gt;, right: Tree&lt;T&gt; } 不同点二，interface 可以而 type 不行 好像只有一点，那就是 interface 能够声明合并 12345678910111213141516interface User { name: string age: number}interface User { sex: string}/*User 接口为 { name: string age: number sex: string}*/ 其实一般来说，如果不清楚什么时候用 interface/type，能用 interface 实现，就用 interface，如果不能就用 type，并没有强行规定谁好或是谁不好 tsconfig.json最后的最后，我们再来简单的看一下 tsconfig.json 这个配置文件和平常遇到的一些与其相关的配置问题，我们先来看看 tsconfig.json 的作用，总的来说，tsconfig.json 的作用主要有以下几点 用于标识 TypeScript 项目的根路径 用于配置 TypeScript 编译器 用于指定编译的文件 而其中涉及到的字段较多，我们这里只是挑选几个比较重要的简单介绍一下，如下 files，设置要编译的文件的名称 include，设置需要进行编译的文件，支持路径模式匹配 exclude，设置无需进行编译的文件，支持路径模式匹配 compilerOptions，设置与编译流程相关的选项 这里我们重点关注一下 compilerOptions 这个字段，compilerOptions 支持很多选项，常见的有 baseUrl、target、baseUrl、moduleResolution 和 lib 等，每个选项的详细说明如下所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980{ \"compilerOptions\": { /* 基本选项 */ \"incremental\": true, // 开启增量编译，第一次编译的时候会生成一个存储编译信息的文件，下一次编译的时候，会根据这个文件进行增量的编译，以此提高编译速度 \"tsBuildInfoFile\": \"./\", // 指定存储增量编译信息的文件位置 \"diagnostics\": true, // 打印诊断信息 \"listEmittedFiles\": true, // 打印输出的文件 \"listFiles\": true, // 打印编译的文件（包括引用的声明文件） \"target\": \"es5\", // 指定 ECMAScript 目标版本，包括 ES3（默认）/ES5/ES6/ES2016/ES2017/ESNEXT \"module\": \"commonjs\", // 指定使用模块，包括 none/commonjs/amd/system/umd/es2015/ESNext \"lib\": [], // 指定要包含在编译中的库文件（引用类库，即申明文件） \"allowJs\": true, // 允许编译 JavaScript 文件 \"checkJs\": true, // 检查 JavaScript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成，包括 preserve/react-native/react /* 声明文件相关配置 */ \"declaration\": true, // 生成相应的 .d.ts 文件 \"declarationDir\": \"./d\", // 声明文件的输出路径 \"emitDeclarationOnly\": true, // 只生成声明文件，不生成 JavaScript \"typeRoots\": [], // 声明文件目录，默认 node_modules/@types \"types\": [], // 要导入的声明文件包，默认导入上面声明文件目录下的所有声明文件 \"outFile\": \"./\", // 将多个相互依赖的文件合并并且把编译后的内容输出到一个文件里 \"outDir\": \"./out\", // 指定编译文件的输出目录 \"rootDir\": \"./\", // 指定输入文件的根目录，用于控制输出目录的结构 \"composite\": true, // 启用项目编译 \"removeComments\": true, // 输出的时候移除注释 \"noEmit\": true, // 不生成输出文件 \"noEmitOnError\": true, // 发生错误时不输出文件 \"noEmitHelpers\": true, // 不生成 helper 函数，类似于 babel，会给每个文件都生成 helper 函数，会使得最终编译后的包的体积变大 \"importHelpers\": true, // 现在可以通过 tslib（TS 内置的库）引入 helper 函数（文件必须是模块） \"downlevelIteration\": true, // 当目标是 ES5 或 ES3 的时候提供对 for-of、扩展运算符和解构赋值中对于迭代器的完整支持 \"isolatedModules\": true, // 把每一个文件转译成一个单独的模块 /* 严格检查配置 */ \"strict\": true, // 开启所有的严格检查配置 \"noImplicitAny\": true, // 不允许使用隐式的 any 类型 \"strictNullChecks\": true, // 不允许把 null、undefined 赋值给其他类型变量 \"strictFunctionTypes\": true, // 不允许函数参数双向协变 \"strictBindCallApply\": true, // 使用 bind/call/apply 时，严格检查函数参数类型 \"strictPropertyInitialization\": true, // 类的实例属性必须初始化 \"noImplicitThis\": true, // 不允许 this 有隐式的 any 类型，即 this 必须有明确的指向 \"alwaysStrict\": true, // 在严格模式下解析并且向每个源文件中注入 use strict /* 额外的语法检查配置，建议交给 eslint 处理，无需配置 */ \"noUnusedLocals\": true, // 有未使用到的本地变量时报错 \"noUnusedParameters\": true, // 有未使用到的函数参数时报错 \"noImplicitReturns\": true, // 每个分支都要有返回值 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误（即不允许 switch 的 case 语句贯穿） /* 模块解析配置 */ \"moduleResolution\": \"node\", // 选择模块解析策略，包括 node（Node.js）和 classic（TypeScript pre-1.6） \"baseUrl\": \"./\", // 在解析非绝对路径模块名的时候的基准路径 \"paths\": {}, // 基于 baseUrl 的路径映射集合 \"rootDirs\": [\"src\", \"out\"], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"esModuleInterop\": true, // 允许 export = xx 导出 ，并使用 import xx form 'module-name' 导入 \"allowSyntheticDefaultImports\": true, // 当模块没有默认导出的时候，允许被别的模块默认导入，只是在类型检查的时候生效 \"preserveSymlinks\": true, // 不需要 symlinks 解析的真正路径 \"allowUmdGlobalAccess\": true, // 允许在模块中以全局变量的方式访问 UMD 模块内容 /* Source Map 配置 */ \"sourceRoot\": \"\", // 指定 ts 文件位置 \"mapRoot\": \"\", // 指定 map 文件存放的位置 \"sourceMap\": true, // 生成目标文件的 sourceMap \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置 --inlineSourceMap 或 --sourceMap 属性 \"inlineSourceMap\": true, // 生成目标文件的 inline sourceMap，源文件和 sourcemap 文件在同一文件中，而不是把 map 文件放在一个单独的文件里 \"declarationMap\": true, // 生成声明文件的 sourceMap /* 实验性的配置 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true, // 为装饰器提供元数据的支持 /* 高级配置 */ \"forceConsistentCasingInFileNames\": true // 强制区分大小写 } \"files\": [], // 指定需要编译的单个文件列表 \"include\": [\"src\"] // 设置需要进行编译的文件，支持路径模式匹配，只写一个目录名等价于 \"./src/**/*\" \"exclude\": [] // 设置无需进行编译的文件，支持路径模式匹配 \"extends\": \"./tsconfig.base.json\" // 配置文件继承} 下面我们再来看看平常会遇到的一些与 tsconfig.json 相关的配置问题 如何对 .js 文件进行类型检查 在 tsconfig.json 中可以设置 checkJs: true 来对 .js 文件进行类型检查和错误提示 通过在 .js 文件顶部添加 // @ts-nocheck 注释，让编译器忽略当前文件的类型检查 相反可以通过不设置 checkJs: true 并在 .js 文件顶部添加一个 // @ts-check 注释，让编译器检查当前文件 也可以在 tsconfig.json 中配置 include/exclude，选择或是排除对某些文件进行类型检查 你还可以使用 // @ts-ignore 来忽略本行的错误 在 .js 文件里，类型可以和在 .ts 文件里一样被推断出来，当类型不能被推断时，可以通过 jsdoc 来指定类型 另外，在 TypeScript 当中支持 jsdoc 注解 12345/** @type {number} */var xx = 0 // OKx = false // Error: boolean is not assignable to number for-of 无法遍历 map 数据结构比如如下示例，当我们设置 &quot;target&quot;: &quot;es5&quot; 的时候，会报错误，并且无法执行 for 语句 12345678910111213const map = new Map([ ['F', 'no'], ['T', 'yes'],])for (let key of map.keys()) { console.log(key)}// 用 forEach 也可以遍历map.forEach((value, key) =&gt; { console.log(key)}) 编辑器会提示我们有错误存在 1TS2569: Type 'Map&lt;string, string&gt;' is not an array type or a string type. Use compiler. option '- downlevellteration' to allow iterating of iterators. 针对于这种情况，我们就需要配置 tsconfig.json 当中的 dom.iterable 和 downlevelIteration 1234567891011{ /* 当目标是 ES5 或 ES3 的时候提供对 for-of、扩展运算符和解构赋值中对于迭代器的完整支持 */ \"downlevelIteration\": true, \"lib\": [ \"dom\", \"es5\", \"es6\", \"es7\", \"dom.iterable\" ]} 当然，如果配置的是 &quot;target&quot;: &quot;es6&quot; 的时候，也可以正常执行，具体原因可见 tsc CLI Options，但是在这里我们需要了解一下在配置 lib 时需要注意的问题 当我们在安装 TypeScript 时，会顺带安装 lib.d.ts 等声明文件，此文件包含 JavaScript 运行时以及 DOM 中存在各种常见的环境声明 它自动包含在 TypeScript 项目的编译上下文中 它能让你快速开始书写经过类型检查的 JavaScript 代码 而 tsconfig.json 中的 lib 选项用来指定当前项目需要注入哪些声明库文件，如果没有指定，默认注入的库文件列表为 12For --target ES5: DOM, ES5, ScriptHostFor --target ES6: DOM, ES6, DOM.Iterable, ScriptHost 如果在 TypeScript 中想要使用一些 ES6 以上版本或者特殊的语法，就需要引入相关的类库，例如 ES7、DOM.Iterable 等 另外需要注意的一点就是，如果配置的是 &quot;target&quot;: &quot;es6&quot;，则 TSC 就会默认使用 &quot;classic&quot; 模块解析策略，这个策略对于 import * as abc from &quot;@babel/types&quot; 这种非相对路径的导入，不能正确解析，解决方法就是指定解析策略为 node，也就是配置 &quot;moduleResolution&quot;: &quot;node&quot; 关于 moduleResolution 的解析策略可见 模块解析 为什么在 exclude 列表里的模块还会被编译器使用有时候是被 tsconfig.json 自动加入的，如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了 因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 import 或使用了 /// 指令的文件 如何在 TypeScript 当中使用 JSX如果想在 TypeScript 当中使用 JSX，必须具备两个条件 首先给文件一个 .tsx 扩展名 其次启用 jsx 选项 TypeScript 具有三种 JSX 模式，即 preserve/react/react-native，这些模式只在代码生成阶段起作用，类型检查并不受影响 preserve 模式下不会将 JSX 编译成 JavaScript，生成代码中会保留 JSX，以供后续的转换操作使用（比如 Babel），另外输出文件会带有 .jsx 扩展名 react 模式下直接将 JSX 编译成 JavaScript，会生成 React.createElement 的形式，在使用前不需要再进行转换操作了，输出文件的扩展名为 .js react-native 模式下相当于 preserve，它也保留了所有的 JSX，但是输出文件的扩展名是 .js 具体区别如下表所示 模式 输入 输出 输出文件扩展名 preserve &lt;div /&gt; &lt;div /&gt; .jsx react &lt;div /&gt; React.createElement('div') .js react-native &lt;div /&gt; &lt;div /&gt; .js esModuleInterop 与 allowSyntheticDefaultImports esModuleInterop 如果一个模块遵循 ES6 模块规范，当默认导出内容时（export default xx），ES6 模块系统会自动给当前模块的顶层对象加上一个 default 属性，指向导出的内容 当一个 ES6 模块引入该模块时（import moduleName from 'xx'），ES6 模块系统默认会自动去该模块中的顶层对象上查找 default 属性并将值赋值给 moduleName，而如果一个非 ES6 规范的模块引入 ES6 模块直接使用时（var moduleName = require('xx')）就会报错，需要通过 moduleName.default 来使用 TypeScript 为了兼容，引入了 esModuleInterop 选项，设置 esModuleInterop 为 true，在编译时自动给该模块添加 default 属性，就可以通过 import moduleName from 'xx' 的形式导入非 ES6 模块，不再需要使用 import moduleName = require('xx') 的形式 allowSyntheticDefaultImports 它的作用是允许默认导入没有设置默认导出（export default xx）的模块，可以以 import xx from 'xx' 的形式来引入模块 1234567// 配置前import * as React from 'react'import * as ReactDOM from 'react-dom'// 配置后import React from 'react'import ReactDOM from 'react-dom' 总结我们在 重温 TypeScript 一节当中梳理了一些 TypeScript 的基础内容，也算是回顾一下 TypeScript 的基本用法，而在本章当中则是简单的介绍了一些比较常用的姑且算是进阶的内容 但是 TypeScript 当中所涉及到的内容并不仅仅只有我们介绍到的这些，其它一些相关内容比如 函数输入的类型推论 或是 多态 等平常很少涉及到的内容，我们也就没有多做提及，不过以后如果在工作当中遇到相关内容的话会再来完善这两章的相关内容 更多相关内容可以参考 官方手册 来了解更多，中文版可见 TypeScript 中文 参考 The unknown Type in TypeScript 官方手册 TypeScript 中文 TypeScript 一份不可多得的 TS 学习指南","link":"/2021/01/01/JavaScript/57/"},{"title":"体系结构与操作系统","text":"最近在复习相关内容，感觉对于操作系统方面的知识都是一片空白，所以打算简单的学习学习，顺便简单的汇总整理一下，其实也就是一些基本概念的介绍，主要方便时不时回来看看复习一下 第一部分，体系结构基础主要包括以下内容 冯·诺依曼体系结构 原码，反码和补码 位（Bit）、字节（Byte）、字（Word） 冯·诺依曼体系结构如下图 特点分为三部分 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 原码，反码和补码在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念，对于一个数，计算机要使用一定的编码方式进行存储，上面的三种方式是机器存储一个具体数字的编码方式 机器数 由于计算机中符号和数字一样，都必须用二进制数串来表示，因此正负号也必须用 0、1 来表示，用最高位 0 表示正、1 表示负，这种正负号数字化的机内表示形式就称为『机器数』，而相应的机器外部用正负号表示的数称为『真值』，将一个真值表示成二进制字串的机器数的过程就称为编码 原码 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值，原码是人脑最容易理解和计算的表示方式，比如如果是 8 位二进制 123[+1]原 = 0000 0001[-1]原 = 1000 0001 因为第一位是符号位，所以 8 位二进制数的取值范围就是 1[1111 1111 , 0111 1111] 即 1[-127 , 127] 反码 正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反 123[+1] = [00000001]原 = [00000001]反[-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算 补码 正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 + 1（即在反码的基础上 + 1） 123[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值 定点数与浮点数 定点数是小数点固定的数，在计算机中没有专门表示小数点的位，小数点的位置是约定默认的 一般固定在机器数的最低位之后，或是固定在符号位之后，前者称为定点纯整数，后者称为定点纯小数 定点数表示法简单直观，但是数值表示的范围太小，运算时容易产生溢出 浮点数是小数点的位置可以变动的数，为增大数值表示范围，防止溢出，采用浮点数表示法 浮点表示法类似于十进制中的科学计数法 在计算机中通常把浮点数分成『阶码』和『尾数』两部分来表示，其中阶码一般用补码定点整数表示，尾数一般用补码或原码定点小数表示，为保证不损失有效数字，对尾数进行规格化处理，也就是平时所说的科学记数法，即保证尾数的最高位为 1，实际数值通过阶码进行调整，阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示规格化后的小数值 1N = 尾数 × 基数阶码（指数） 位（Bit）、字节（Byte）、字（Word） 位，位（Bit）是电子计算机中最小的数据单位，每一位的状态只能是 0 或 1 字节，8 个二进制位构成 1 个字节（Byte），它是存储空间的基本计量单位，1 个字节可以储存 1 个英文字母或者半个汉字，换句话说，1 个汉字占据 2 个字节的存储空间 字，由若干个字节构成，字（Word）的位数叫做字长，不同档次的机器有不同的字长，例如一台 8 位机，它的 1 个字就等于 1 个字节，字长为 8 位，如果是一台 16 位机，那么，它的 1 个字就由 2 个字节构成，字长为 16 位，字是计算机进行数据处理和运算的单位 字节序 字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序 小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处 大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处 基于 X86 平台的 PC 机是小端字节序的，而有的嵌入式平台则是大端字节序的，所有网络协议也都是采用 big endian 的方式来传输数据的，所以有时我们也会把 big endian 方式称之为『网络字节序』，比如数字 0x12345678 在两种不同字节序 CPU 中的存储顺序如下所示 12345678910111213Big Endian低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 12 | 34 | 56 | 78 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Little Endian低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 78 | 56 | 34 | 12 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 从上面两图可以看出，采用 Big Endian 方式存储数据是符合我们人类的思维习惯的，联合体 union 的存放顺序是所有成员都从低地址开始存放，利用该特性，就能判断 CPU 对内存采用 Little-endian 还是 Big-endian 模式读写 12345678910111213141516171819union test { short i; char str[sizeof(short)]; }tt; void main() { tt.i = 0x0102; if(sizeof(short) == 2) { if(tt.str[0] == 1 &amp;&amp; tt.str[1] == 2) printf(\"大端字节序\"); else if(tt.str[0] = 2 &amp;&amp; tt.str[1] == 1) printf(\"小端字节序\"); else printf(\"结果未知\"); } else printf(\"sizof(short) = %d 不等于 2\", sizeof(short)); } 字节对齐 现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐，那么问题来了，为什么要进行字节对齐呢，主要因为下面两点原因 某些平台只能在特定的地址处访问特定类型的数据 最根本的原因是效率问题，字节对齐能提存取数据的速度 比如有的平台每次都是从偶地址处读取数据，对于一个 int 型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量，但是若从奇地址单元处存放，则需要 2 个读取周期读取该变量 字节对齐的原则 数据成员对齐规则，结构（struct 或联合）的数据成员，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始（比如 int 在 32 位机为 4 字节，则要从 4 的整数倍地址开始存储） 结构体作为成员，如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（struct a 里存有 struct b，b 里有 char，int，double 等元素，那 b 应该从 8 的整数倍开始存储） 收尾工作，结构体的总大小，也就是 sizeof 的结果，必须是其内部最大成员的整数倍，不足的要补齐 第二部分，操作系统基础操作系统的五大功能，分别为『作业管理』、『文件管理』、『存储管理』、『输入输出设备管理』、『进程及处理机管理』，主要介绍以下内容 中断 系统调用 中断所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序，等这些特殊事情处理完之后再回去执行之前的程序，中断一般分为三类 由计算机硬件异常或故障引起的中断，称为内部异常中断 由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断） 由外部设备请求引起的中断，称为外部中断，简单来说，对中断的理解就是对一些特殊事情的处理 中断处理程序 当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了 中断的优先级 中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别，中断的优先级也表明了中断需要被处理的紧急程度，每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理，优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略，典型的中断优先级如下所示 1机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt; 终端 &gt; 软件中断 当发生软件中断时，其他所有的中断都可能发生并被处理，但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了 系统调用进程的执行在系统上的两个级别是用户级和核心级，也称为用户态和系统态（user mode and kernel mode），程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用 Linux 系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口，当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态，但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求 系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断，产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了，那么用户态和核心态之间的区别是什么呢？（摘至《UNIX 操作系统设计》） 用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据），然而核心态下的进程能够存取内核和用户地址 某些机器指令是特权指令，在用户态下执行特权指令会引起错误 对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的 第三部分，并发技术主要介绍以下内容 进程 线程 锁 协程 IO 多路复用 多任务在上古时代，CPU 资源十分昂贵，如果让 CPU 只能运行一个程序，那么当 CPU 空闲下来（例如等待 I/O 时），CPU 就空闲下来了，为了让 CPU 得到更好的利用，人们编写了一个监控程序，如果发现某个程序暂时无须使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU 资源，这种方法被称为『多道程序』（Multiprogramming） 对于多道程序来说，最大的问题是程序之间不区分轻重缓急，对于交互式程序来说，对于 CPU 计算时间的需求并不多，但是对于响应速度却有比较高的要求，而对于计算类程序来说则正好相反，对于响应速度要求低，但是需要长时间的 CPU 计算，想象一下我们同时在用浏览器上网和听音乐，我们希望浏览器能够快速响应，同时也希望音乐不停掉，这时候多道程序就没法达到我们的要求了，于是人们改进了多道程序，使得每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间，这样像浏览器这样的交互式程序就能够快速地被处理，同时计算类程序也不会受到很大影响，这种程序协作方式被称为『分时系统』（Time-Sharing System） 在分时系统的帮助下，我们可以边用浏览器边听歌了，但是如果某个程序出现了错误，导致了死循环，不仅仅是这个程序会出错，整个系统都会死机，为了避免这种情况，一个更为先进的操作系统模式被发明出来，也就是我们现在很熟悉的『多任务』（Multi-tasking）系统，操作系统从最底层接管了所有硬件资源，所有的应用程序在操作系统之上以『进程』（Process） 的方式运行，每个进程都有自己独立的地址空间，相互隔离，CPU 由操作系统统一进行分配，每个进程都有机会得到 CPU，同时在操作系统控制之下，如果一个进程运行超过了一定时间，就会被暂停掉，失去 CPU 资源，这样就避免了一个程序的错误导致整个系统死机，如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切换，就像很多进程都同时在运行的样子，几乎所有现代操作系统都是采用这样的方式支持多任务，例如 Unix，Linux，Windows 以及 macOS 进程进程是一个具有独立功能的程序关于某个数据集合的一次运行活动，它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体，它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示 进程的概念主要有以下两点 进程是一个实体，每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region） 文本区域存储处理器执行的代码 数据区域存储变量和进程执行期间使用的动态分配的内存 堆栈区域存储着活动过程调用的指令和本地变量 进程是一个执行中的程序 程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程 进程的基本状态 有三个状态 等待态，等待某个事件的完成 就绪态，等待系统分配处理器以便运行 运行态，占有处理器正在运行 1234567运行态 ==&gt; 等待态，往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的等待态 ==&gt; 就绪态，则是等待的条件已满足，只需分配到处理器后就能运行运行态 ==&gt; 就绪态，不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态（例如时间片用完，或有更高优先级的进程来抢占处理器等）就绪态 ==&gt; 运行态，系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态 进程调度 调度种类分为高级、中级和低级，调度作业从提交开始直到完成，往往要经历下述三级调度 高级调度（High-Level Scheduling），又称为作业调度，它决定把后备作业调入内存运行 中级调度（Intermediate-Level Scheduling），又称为在虚拟存储器中引入，在内、外存对换区进行进程对换 低级调度（Low-Level Scheduling），又称为进程调度，它决定把就绪队列的某进程获得 CPU 非抢占式调度与抢占式调度 非抢占式 分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程 抢占式 操作系统将正在运行的进程强行暂停，由调度程序将 CPU 分配给其他就绪进程的调度方式 调度策略的设计 响应时间，从用户输入到产生反应的时间 周转时间，从任务开始到任务结束的时间 CPU 任务可以分为『交互式任务』和『批处理任务』，调度最终的目标是合理的使用 CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间 调度算法 先来先服务调度算法（FCFS） 短作业优先（SJF）的调度算法 时间片轮转调度算法（RR） 优先级调度算法（HPF） 多级反馈队列调度算法 高响应比优先调度算法 关于调度算法详细内容可以参考 作业调度算法 这篇文章 临界资源与临界区 在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源），但对于某些资源来说，其在同一时间只能被一个进程所占用，这些一次只能被一个进程所占用的资源就是所谓的临界资源，典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等（如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题） 对于临界资源的访问，必须是互斥进行，也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放，而进程内访问临界资源的代码被称为『临界区』，对于临界区的访问过程分为四个部分 进入区，查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞 临界区，在临界区做操作 退出区，清除临界区被占用的标志 剩余区，进程与临界区不相关部分的代码 解决临界区问题可能的方法 一般软件方法 关中断方法 硬件原子指令方法 信号量方法 信号量 信号量是一个确定的二元组（s, q），其中 s 是一个具有非负初值的整形变量，q 是一个初始状态为空的队列，整形变量 s 表示系统中某类资源的数目 当其值 &gt;= 0 时，表示系统中当前可用资源的数目 当其值 &lt; 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目 除信号量的初值外，信号量的值仅能由 P 操作和 V 操作更改，操作系统利用它的状态对进程和资源进行管理 P 操作记为 P(s)，其中 s 为一信号量，它执行时主要完成 s.value = s.value - 1（可理解为占用 1 个资源，若原来就没有则记帐欠 1个） 若 s.value &gt;= 0，则进程继续执行，否则（即 s.value &lt; 0）则进程被阻塞，并将该进程插入到信号量 s 的等待队列 s.queue 中 实际上，P 操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令 V 操作记为 V(s)，其中 s 为一信号量，它执行时，主要完成 s.value = s.value + 1（可理解为归还 1 个资源，若原来就没有则意义是用此资源还 1 个欠帐） 若 s.value &gt; 0，则进程继续执行，否则（即 s.value &lt;= 0）则从信号量 s 的等待队 s.queue 中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行 实际上，V 操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令 下面是一个信号量方法实现生产者和消费者之间的互斥与同步控制的示例 12345678910111213141516171819202122232425semaphore fullBuffers = 0; /* 仓库中已填满的货架个数 */semaphore emptyBuffers = BUFFER_SIZE; /* 仓库货架空闲个数 */semaphore mutex = 1; /* 生产-消费互斥信号 */Producer() { while(True) { // 生产产品 item emptyBuffers.P(); mutex.P(); // item 存入仓库 buffer mutex.V(); fullBuffers.V(); }}Consumer() { while(True) { fullBuffers.P(); mutex.P(); // 从仓库 buffer 中取产品 item mutex.V(); emptyBuffers.V(); // 消费产品 item }} 死锁 死锁表示多个进程因循环等待资源而造成无法执行的现象，死锁会造成进程无法执行，同时会造成系统资源的极大浪费（资源无法释放），死锁产生的四个必要条件 互斥使用（Mutual exclusion） 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用，如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放 不可抢占（No preemption） 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放 请求和保持（Hold and wait） 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 循环等待（Circular wait）指在发生死锁时，必然存在一个『进程 ==&gt; 资源』的环形链 即进程集合 { P0, P1, P2 ... Pn } 中的 P0 正在等待一个 P1 占用的资源，P1 正在等待 P2 占用的资源 … Pn 正在等待已被 P0 占用的资源 避免死锁的方式可以采用 银行家算法，原理是判断此次请求是否造成死锁若会造成死锁，则拒绝该请求 进程间通信 本地进程间通信的方式有很多，可以总结为下面四类 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris Door 和 Sun RPC） 线程多进程解决了前面提到的多任务问题，然而很多时候不同的程序需要共享同样的资源（文件，信号量等）如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费，于是就出现了线程的概念，线程是操作系统能够进行运算调度的最小单位，『线程是隶属于进程的，被包含于进程之中』 一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的 同一块代码，可以根据系统 CPU 核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的，同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等，但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage），之所以设置线程这个单位，是因为 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型 线程较进程来讲，更轻 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 CPU 的利用率 下面是一个使用 pthread 线程库实现的生产者与消费者模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BUFFER_SIZE 10static int buffer[BUFFER_SIZE] = { 0 };static int count = 0;pthread_t consumer, producer;pthread_cond_t cond_producer, cond_consumer;pthread_mutex_t mutex;void* consume(void* _) { while(1) { pthread_mutex_lock(&amp;mutex); while(count == 0) { printf(\"empty buffer, wait producer\\n\"); pthread_cond_wait(&amp;cond_consumer, &amp;mutex); } count--; printf(\"consume a item\\n\"); pthread_mutex_unlock(&amp;mutex); pthread_cond_signal(&amp;cond_producer); // pthread_mutex_unlock(&amp;mutex); } pthread_exit(0);}void* produce(void* _) { while(1) { pthread_mutex_lock(&amp;mutex); while(count == BUFFER_SIZE) { printf(\"full buffer, wait consumer\\n\"); pthread_cond_wait(&amp;cond_producer, &amp;mutex); } count++; printf(\"produce a item.\\n\"); pthread_mutex_unlock(&amp;mutex); pthread_cond_signal(&amp;cond_consumer); // pthread_mutex_unlock(&amp;mutex); } pthread_exit(0);}int main() { pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond_consumer, NULL); pthread_cond_init(&amp;cond_producer, NULL); int err = pthread_create(&amp;consumer, NULL, consume, (void*)NULL); if(err != 0) { printf(\"consumer thread created failed\\n\"); exit(1); } err = pthread_create(&amp;producer, NULL, produce, (void*)NULL); if(err != 0) { printf(\"producer thread created failed\\n\"); exit(1); } pthread_join(producer, NULL); pthread_join(consumer, NULL); // sleep(1000) pthread_cond_destroy(&amp;cond_consumer); pthread_cond_destroy(&amp;cond_producer); pthread_mutex_destroy(&amp;mutex); return 0;} 单线程 单线程就是一个进程只开一个线程，所谓的单线程和多线程，本质上指在『一个进程内』的单线程和多线程 单线程，单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序 多线程，多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的 多线程 多线程就是没有一个进程只开一个线程的限制，可以有效避免代码阻塞导致的后续请求无法处理，多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽，类似于上面单线程模型中例举的例子，需要一定的计算会造成当前线程阻塞的，还是推荐使用多线程来处理 线程同步 线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步），也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的 锁这里讨论的主要是多线程编程中需要使用的锁，我们不会去钻名词和概念的牛角尖，而是直接从本质上试图解释一下锁这个很常用的多线程编程工具，锁要解决的是线程之间争取资源的问题，这个问题大概有下面几个角度 资源是否是独占（独占锁 &amp;&amp; 共享锁） 抢占不到资源怎么办（互斥锁 &amp;&amp; 自旋锁） 自己能不能重复抢（重入锁 &amp;&amp; 不可重入锁） 竞争读的情况比较多，读可不可以不加锁（读写锁） 上面这几个角度不是互相独立的，在实际场景中往往要它们结合起来，才能构造出一个合适的锁 独占锁 &amp;&amp; 共享锁 当一个共享资源只有一份的时候，通常我们使用独占锁，常见的即各个语言当中的 Mutex，当共享资源有多份时，可以使用前面提到的『信号量』（Semaphere） 互斥锁 &amp;&amp; 自旋锁 对于互斥锁来说，如果一个线程已经锁定了一个互斥锁，第二个线程又试图去获得这个互斥锁，则第二个线程将被挂起（即休眠，不占用 CPU 资源） 在计算机系统中，频繁的挂起和切换线程，也是有成本的，自旋锁就是解决这个问题的 自旋锁，指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环 容易看出，当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源，当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能，简单说，它们在发现资源被抢占之后，会先试着自旋等待一段时间，如果等待时间太长，则会进入挂起状态，通过这样的实现，可以较大程度上挖掘出锁的性能 重入锁 &amp;&amp; 不可重入锁 可重入锁（ReetrantLock），也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁，换一种说法，即同一个线程再次进入同步代码时，可以使用自己已获取到的锁 使用可重入锁时，在同一线程中多次获取锁，不会导致死锁，使用不可重入锁，则会导致死锁发生 读写锁 有些情况下，对于共享资源读竞争的情况远远多于写竞争，这种情况下对读操作每次都进行加速，是得不偿失的，读写锁就是为了解决这个问题 读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞，简单可以总结为，读读不互斥，读写互斥，写写互斥 对读写锁来说，有一个升级和降级的概念，即当前获得了读锁，想把当前的锁变成写锁，称为升级，反之称为降级，锁的升降级本身也是为了提升性能，通过改变当前锁的性质，避免重复获取锁 协程协程（Coroutine）又称微线程，纤程，协程可以理解为用户级线程，协程和线程的区别是，线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能 但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多 CPU 的能力，下面是一个使用协程来解决生产者与消费者问题 12345678910111213def produce(c): next(c) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()if __name__ == '__main__': c = consumer() produce(c) 可以看到，使用协程不再需要显式地对锁进行操作 IO 多路复用IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程，IO 多路复用适用如下场合 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用 I/O 复用 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现 如果一个 TCP 服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用 如果一个服务器即要处理 TCP，又要处理 UDP，一般要使用 I/O 复用 如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用 与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程或线程，也不必维护这些进程或线程，从而大大减小了系统的开销 常见的 IO 复用实现 select 函数（Linux/Windows/BSD） epoll 函数（Linux） kqueue 函数（BSD/Mac OS X） 第四部分，内存管理基础主要介绍以下内容 程序可执行文件的结构 堆和栈 内存分配 程序可执行文件的结构一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分，只读部分和可读写部分 只读部分包括程序代码（.text）和程序中的常量（.rodata） 可读写部分（也就是变量）大致可以分成下面几个部分 .data，初始化了的全局变量和静态变量 .bss，即 Block Started by Symbol，未初始化的全局变量和静态变量 Heap，堆，使用 malloc，realloc 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用 Stack，栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中 data 和 bss 区这两个区经常放在一起说，因为他们都是用来存储全局变量和静态变量的，区别在于 data 区存放的是初始化过的，bss 区存放的是没有初始化过的 12int val = 3;char string[] = \"Hello World\"; 这两个变量的值会一开始被存储在 .text 中（因为值是写在代码里面的），在程序启动时会拷贝到 .data 区中，而不初始化的话，像下面这样则会被放在 bss 区中 1static int i; 静态变量和全局变量 这两个概念都是很常见的概念，又经常在一起使用，很容易造成混淆，全局变量是指在一个代码文件当中，一个变量要么定义在函数中，要么定义在在函数外面，当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量，全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（external linkage） 当有如下两个文件时 12345678910111213141516171819// a.c#include &lt;stdio.h&gt;int a;int compute(void);int main() { a = 1; printf(\"%d %d\\n\", a, compute()); return 0;}// b.cint a;int compute(void) { a = 0; return a;} 在 Link 过程中会产生重复定义错误，因为有两个全局的 a 变量，Linker 不知道应该使用哪一个，为了避免这种情况，就需要引入静态变量（static），所谓的静态变量指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的限制如下 在函数外定义，全局变量，但是只在当前文件中可见（叫做 internal linkage） 在函数内定义，全局变量，但是只在此函数内可见（同时在多次函数调用中，变量的值不会丢失） 在类中定义（C++），全局变量，但是只在此类中可见 对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 static，另一个不使用，这样使用 static 的就会使用自己的 a 变量，而没有用 static 的会使用全局的 a 变量，当然，最好两个都使用 static 来避免更多可能的命名冲突 需要注意的是，实际上 static 跟不可改变没有关系，不可改变的变量使用 const 关键字修饰，注意不要混淆 程序在内存和硬盘上不同的存在形式 这里我们提到的几个区，是指程序在内存中的存在形式，和程序在硬盘上存储的格式不是完全对应的，程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，一个比较明显的例子可以帮你区分这个差别 之前我们提到过未定义的全局变量存储在 .bss 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间，这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成 0 存储在内存中 栈 栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域，程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预 栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小，如果申请的空间超过栈的剩余空间时，例如递归深度过深将提示 stackoverflow 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，比如分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 堆堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用 malloc 和 free 时就是在操作堆中的内存，对于堆来说释放工作由程序员控制，容易产生 memory leak 堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址，堆的大小受限于计算机系统中有效的虚拟内存，由此可见，堆获得的空间比较灵活，也比较大 对于堆来讲，频繁的 new 或者 delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低，对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出 堆都是动态分配的，没有静态分配的堆，栈有两种分配方式 静态分配，是编译器完成的，比如局部变量的分配 动态分配，由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现 计算机底层并没有对堆的支持，堆则是 C/C++ 函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低 内存分配 虚拟地址，是用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称加上段内相对地址构成，这样的程序地址称为虚拟地址 逻辑地址，是虚拟地址中，段内相对地址部分称为逻辑地址 物理地址，是实际物理内存中所看到的存储地址称为物理地址 逻辑地址空间，是在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址（逻辑地址的集合称为逻辑地址空间） 线性地址空间，是 CPU 地址总线可以访问的所有地址集合称为线性地址空间 物理地址空间，是实际存在的可访问的物理内存地址集合称为物理地址空间 内存管理单元（Memery Management Unit，简称 MMU），是实现将用户程序的虚拟地址（逻辑地址）到物理地址映射的 CPU 中的硬件电路 基地址，是在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算 偏移量，是在以段或页为单位进行地址映射时，相对于基地址的地址值 虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址 虚拟内存虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换 虚拟内存是由硬件和操作系统自动实现存储信息调度和管理的，调度方式有分页式、段式、段页式三种 第五部分，磁盘与文件主要介绍以下内容 磁盘调度 文件系统 内存分配 磁盘调度磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间，磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾 磁盘调度算法 FCFS，先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理 SSTF（Shortest-seek-time First，最短寻道时间优先），选择使磁头从当前位置开始移动最少的磁盘 I/O 请求，所以 SSTF 总是选择导致最小寻道时间的请求 总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象 SCAN，中途不回折，每个请求都有处理机会 SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止，由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法 SCAN 算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如 FCFS 算法和 SSTF 算法好 C-SCAN，直接移到另一端，两端请求都能很快处理 把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描，其中 C 是 Circular（环）的意思 LOOK 和 C-LOOK 釆用 SCAN 算法和 C-SCAN 算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点 这种形式的 SCAN 算法和 C-SCAN 算法称为 LOOK 和 C-LOOK 调度（这是因为它们在朝一个给定方向移动前会查看是否有请求） 文件系统分区表 MBR，支持最大卷为 2TB（Terabytes）并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器） GPT，支持最大卷为 18EB（Exabytes）并且每磁盘的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64 版 Windows 限制最多有 128 个分区，这也是 EFI 标准规定的分区表的最小尺寸，另外，GPT 分区磁盘有备份分区表来提高分区数据结构的完整性 RAID 技术 磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。 RAID 0，是最早出现的 RAID 模式，需要 2 块以上的硬盘，可以提高整个磁盘的性能和吞吐量 RAID 0 没有提供冗余或错误修复能力，其中一块硬盘损坏，所有数据将遗失 RAID 1，就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据 当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作，因为有镜像硬盘做数据备份，所以 RAID 1 的数据安全性在所有的 RAID 级别上来说是最好的 但无论用多少磁盘做 RAID 1，仅算一个磁盘的容量，是所有 RAID 中磁盘利用率最低的 RAID 2 这是 RAID 0 的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中 因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID 2 最少要三台磁盘驱动器方能运作 RAID 3 采用 Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用 RAID 4，它与 RAID 3 不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高（块交织技术，Block interleaving） RAID 2/3/4 在实际应用中很少使用 RAID 5，RAID Level 5 是一种储存性能、数据安全和存储成本兼顾的存储解决方案，它使用的是Disk Striping（硬盘分区）技术 RAID 5 至少需要三块硬盘，RAID 5 不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成 RAID 5 的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上 RAID 5 允许一块硬盘损坏，实际容量 Size = (N-1) * min(S1, S2, S3 ... SN) RAID 6，与 RAID 5 相比，RAID 6 增加第二个独立的奇偶校验信息块，两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用 RAID 6 至少需要 4 块硬盘，实际容量 Size = (N-2) * min(S1, S2, S3 ... SN) RAID 10/01（RAID 1 + 0，RAID 0 + 1），是先镜射再分区数据，再将所有硬盘分为两组，视为是 RAID 0 的最低组合，然后将这两组各自视为 RAID 1 运作 RAID 01 则是跟 RAID 10 的程序相反，是先分区再将数据镜射到两组硬盘，它将所有的硬盘分为两组，变成 RAID 1 的最低组合，而将两组硬盘各自视为 RAID 0 运作 当 RAID 10 有一个硬盘受损，其余硬盘会继续运作，RAID 01 只要有一个硬盘受损，同组 RAID 0 的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低，如果以六个硬盘建 RAID 01，镜射再用三个建 RAID 0，那么坏一个硬盘便会有三个硬盘脱机，因此，RAID 10 远较 RAID 01 常用，零售主板绝大部份支持 RAID 0/1/5/10，但不支持 RAID 01 RAID 10 至少需要 4 块硬盘，且硬盘数量必须为偶数 常见文件系统 Windows 中有 FAT，FAT16，FAT32，NTFS Linux 中有 ext2/3/4，btrfs，ZFS Mac OS X 中有 HFS+ Linux 文件权限Linux 文件采用 10 个标志位来表示文件权限，如下所示 12-rw-r--r-- 1 skyline staff 20B 1 27 10:34 1.txtdrwxr-xr-x 5 skyline staff 170B 12 23 19:01 ABTableViewCell 第一个字符一般用来区分文件和目录，其中 d，表示是一个目录，事实上在 ext2fs 中，目录是一个特殊的文件 －，表示这是一个普通的文件 l:，表示这是一个符号链接文件，实际上它指向另一个文件 b、c，分别表示区块设备和其他的外围设备，是特殊类型的文件 s、p，这些文件关系到系统的数据结构和管道，通常很少见到 第 2 ~ 10 个字符当中的每 3 个为一组，左边三个字符表示所有者权限，中间 3 个字符表示与所有者同一组的用户的权限，右边 3 个字符是其他用户的权限 这三个一组共 9 个字符，代表的意义如下 r（Read，读取），对文件而言，具有读取文件内容的权限，对目录来说，具有浏览目录的权限 w（Write，写入），对文件而言，具有新增、修改文件内容的权限，对目录来说，具有删除、移动目录内文件的权限 x（eXecute，执行），对文件而言，具有执行文件的权限，对目录来说该用户具有进入目录的权限 权限的掩码可以使用十进制数字表示 如果可读，权限是二进制的 100，十进制是 4 如果可写，权限是二进制的 010，十进制是 2 如果可运行，权限是二进制的 001，十进制是 1 具备多个权限，就把相应的 4、2、1 相加就可以了 若要 rwx 则 4 + 2 + 1 = 7 若要 rw- 则 4 + 2 = 6 若要 r-x 则 4 + 1 = 5 若要 r-- 则 = 4 若要 -wx 则 2 + 1 = 3 若要 -w- 则 = 2 若要 --x 则 = 1 若要 --- 则 = 0 默认的权限可用 umask 命令修改，用法非常简单，只需执行 umask 777 命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成 000，依次类推，通常 root 帐号搭配 umask 命令的数值为 022、027 和 077，普通用户则是采用 002，这样所产生的权限依次为 755、750、700、775 chmod 命令 chmod 命令非常重要，用于改变文件或目录的访问权限，用户用它控制文件或目录的访问权限 该命令有两种用法，一种是包含字母和操作符表达式的文字设定法，另一种是包含数字的数字设定法 文字设定法，chmod [who] [+ | - | =] [mode] 文件名 操作对象 who 可是下述字母中的任一个或者它们的组合 u，表示用户（user），即文件或目录的所有者 g，表示同组（group）用户，即与文件属主有相同组ID的所有用户 o，表示其他（others）用户， a，表示所有（all）用户，它是系统默认值 操作符号可以是 添加某个权限 取消某个权限 = 赋予给定权限并取消其他所有权限（如果有的话） 设置 mode 所表示的权限可用下述字母的任意组合 r，可读 w，可写 x，可执行 X，只有目标文件对某些用户是可执行的或该目标文件是目录时才追加 x 属性 s，在文件执行时把进程的属主或组 ID 置为该文件的文件属主，方式 u＋s 设置文件的用户 ID 位，g＋s 设置组 ID 位 t，保存程序的文本到交换设备上 u，与文件属主拥有一样的权限 g，与和文件属主同组的用户拥有一样的权限 o，与其他用户拥有一样的权限 文件名，以空格分开的要改变权限的文件列表，支持通配符 在一个命令行中可给出多个权限方式，其间用逗号隔开，例如 chmod g + r，o + r example 使同组和其他用户对文件 example 有读权限 数字设定法，直接使用数字表示的权限来更改 比如 $ chmod 644 mm.txt chgrp 命令 改变文件或目录所属的组，语法为 chgrp [选项] group filename，比如 $ chgrp - R book /opt/local/book，表示改变 /opt/local/book/ 及其子目录下的所有文件的属组为 book chown 命令 更改某个文件或目录的属主和属组，这个命令也很常用，chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或用户 ID，组可以是组名或组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符，语法为 chown [选项] 用户或组文件 例如 root 用户把自己的一个文件拷贝给用户 xu，为了让用户 xu 能够存取这个文件，root 用户应该把这个文件的属主设为 xu，否则用户 xu 无法存取这个文件，比如把文件 shiyan.c 的所有者改为 wang 1chown wang shiyan.c 参考第一部分，体系结构 冯·诺依曼体系结构 二进制原码、反码、补码 什么是位、字节、字、KB、MB 字节对齐 大小端字节序的判断 大小字节序 第二部分，操作系统 Linux 系统的中断、系统调用和调度概述 第三部分，并发技术 浅谈进程同步和互斥的概念 线程 进程、线程和协程的理解 IO 多路复用之 Select 总结 银行家算法 第四部分，内存管理 虚拟内存 什么是内存（二）：虚拟内存 内存分配的三种方式 程序的内存分配：栈区（stack）堆区（heap） 第五部分，磁盘与文件 磁盘阵列 RAID Linux 文件权限详解 修改 Linux 文件权限命令","link":"/2020/01/01/Essay/06/"},{"title":"渲染器","text":"最近在深入学习 Virtual DOM 的相关知识，参考了许多资料，也拜读了许多大神的文章，所以在这里大致的整理成了比较适合自己理解的方式，方便时不时回来翻翻，复习一下，篇幅较长，主要会分为三个部分来分别进行介绍，具体章节如下，目录名就差不多代表了章节的相关内容 什么是 Virtual DOM？ 渲染器 渲染器的核心 Diff 算法 在上篇的 什么是 Virtual DOM？ 章节当中我们介绍过 Virtual DOM 的相关概念，以及如何将 Virtual DOM 渲染为真实的 DOM 节点和一个辅助创建 VNode 的 h 函数，本章是第二部分，我们就接着之前的内容来介绍渲染器相关内容，参考的是 HcySunYang/vue-design，本章相关内容如下 什么是渲染器？ mount 阶段 挂载普通标签元素 挂载文本节点 挂载 Fragment 挂载 Portal 挂载有状态组件 挂载函数式组件 patch 阶段 类型不同则替换 VNode 更新标签元素 更新文本节点 更新 Fragment 更新 Portal 更新有状态组件 更新函数式组 什么是渲染器？所谓渲染器，简单的说就是将 Virtual DOM 渲染成特定平台下真实 DOM 的工具（就是一个函数，通常叫 render），渲染器的工作流程通常分为两个阶段 mount 和 patch 如果旧的 VNode 存在，则会使用新的 VNode 与旧的 VNode 进行对比，试图以最小的资源开销完成 DOM 的更新，这个过程就叫 patch（打补丁） 如果旧的 VNode 不存在，则直接将新的 VNode 挂载成全新的 DOM，这个过程叫做 mount 渲染器通常接收两个参数，第一个参数是将要被渲染的 VNode 对象，第二个参数是一个用来承载内容的容器（container），通常也叫挂载点，如下代码所示 1234567891011121314151617export default function render(vnode, container) { const prevVNode = container.vnode if (prevVNode == null) { if (vnode) { mount(vnode, container) // 没有旧的 VNode，使用 mount 函数挂载全新的 VNode container.vnode = vnode // 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了 } } else { if (vnode) { patch(prevVNode, vnode, container) // 有旧的 VNode，则调用 patch 函数打补丁 container.vnode = vnode // 更新 container.vnode } else { container.removeChild(prevVNode.el) // 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数 container.vnode = null } }} 当然渲染器不仅仅是一个把 VNode 渲染成真实 DOM 的工具，它还可以负责控制部分组件生命周期钩子的调用，又与异步渲染有直接关系，但是在这里，我们主要介绍的是其挂载和更新的操作，至于核心的 Diff 算法将会放到下一章单独介绍 mount 阶段在前面已经简单的介绍过了，渲染器的工作流程通常分为两个阶段 mount 和 patch，那我们下面就来看看如何使用 mount 函数挂载全新的 VNode 挂载普通标签元素这部分我们主要探讨渲染器的 mount 函数是如何把 VNode 渲染成真实 DOM 的，mount 函数的作用是把一个 VNode 渲染成真实 DOM，根据不同类型的 VNode 需要采用不同的挂载方式，如下 123456789101112131415// 关于 isSVG 下面会进行介绍function mount(vnode, container, isSVG, refNode) { const { flags } = vnode if (flags &amp; VNodeFlags.ELEMENT) { mountElement(vnode, container, isSVG, refNode) // 挂载普通标签 } else if (flags &amp; VNodeFlags.COMPONENT) { mountComponent(vnode, container, isSVG) // 挂载组件 } else if (flags &amp; VNodeFlags.TEXT) { mountText(vnode, container) // 挂载文本节点 } else if (flags &amp; VNodeFlags.FRAGMENT) { mountFragment(vnode, container, isSVG) // 挂载 Fragment } else if (flags &amp; VNodeFlags.PORTAL) { mountPortal(vnode, container, isSVG) // 挂载 Portal }} 我们根据 VNode 的 flags 属性值能够区分一个 VNode 对象的类型，不同类型的 VNode 采用不同的挂载函数 在之前的章节当中，我们曾经简单的实现过一个 mountElement 的方法 1234function mountElement(vnode, container) { const el = document.createElement(vnode.tag) container.appendChild(el)} 这是一个极简的用于挂载普通标签元素的 mountElement 函数，但它具有以下缺陷 VNode 被渲染为真实 DOM 之后，没有引用真实 DOM 元素 没有将 VNodeData 应用到真实 DOM 元素上 没有继续挂载子节点，即 children 不能严谨地处理 SVG 标签 这里有一点需要说明，我们之所以设计 vnode.el 这个字段 是因为在 patch 阶段对 DOM 元素进行移动时，应该确保将其放到正确的位置，而不应该始终使用 appendChild 函数有时需要使用 insertBefore 函数，这时候我们就需要拿到相应的节点引用，这时候 vnode.el 属性是必不可少的 下面我们就来针对上面的四个问题，我们逐个去解决，代码已经整合，详细的可以参见注释部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function mountElement(vnode, container, isSVG) { const domPropsRE = /\\W|^(?:value|checked|selected|muted)$/ /** * 针对第四个问题，不能严谨地处理 SVG 标签，这里需要单独说明一下，之前我们通过 vnode.flags 来判断一个标签是否是 SVG，如下 * * if (typeof tag === 'string') { * flags = tag === 'svg' ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML * } * * 我们可以注意到，只有当标签名字全等于字符串 'svg' 时，该 VNode 的 flags 才会被标记为 VNodeFlags.ELEMENT_SVG * 这意味着 &lt;circle/&gt; 标签不会被标记为 VNodeFlags.ELEMENT_SVG，所以在创建 &lt;circle/&gt; 元素时并不会使用 document.createElementNS 函数 * 但 &lt;circle/&gt; 标签确实是 svg 标签 * * 但是又因为 svg 的书写总是以 &lt;svg&gt; 标签开始的，所有我们可以认为其他 svg 相关的标签都是 &lt;svg&gt; 标签的子代元素 * 所以我们添加了一个 isSVG 变量，在 mountElement 函数中一旦 isSVG 为真，那么后续创建的所有子代元素都会被认为是 svg 标签 * * 这样即使 &lt;circle/&gt; 标签对应的 vnode.flags 不是 VNodeFlags.ELEMENT_SVG，但在 mountElement 函数看来它依然是 svg 标签 */ isSVG = isSVG || vnode.flags &amp; VNodeFlags.ELEMENT_SVG const el = isSVG ? document.createElementNS('http://www.w3.org/2000/svg', vnode.tag) : document.createElement(vnode.tag) // 针对第一个问题，VNode 被渲染为真实 DOM 之后，没有引用真实 DOM 元素 // 我们只需要将 vnode.el 指向被创建的元素即可 vnode.el = el // 针对第二个问题，没有将 VNodeData 应用到真实 DOM 元素上 // 我们使用循环，将其应用到元素之上 const data = vnode.data if (data) { for (let key in data) { // key 可能是 class、style、on 等等，所以我们使用 switch 来进行处理 switch (key) { // 如果 key 的值是 style，说明是内联样式，逐个将样式规则应用到 el case 'style': for (let k in data.style) { el.style[k] = data.style[k] } break /** * 在使用过程中，class 并不一定传递的是字符串，也有可能是数组，亦或者对象，但是我们需要对传递进来的 class 进行序列化操作 * 所以这就是前文当中的 h 函数里面的 normalizeClass() 方法的作用 */ case 'class': if (isSVG) { el.setAttribute('class', data[key]) } else { el.className = data[key] } break default: // 针对事件，我们可以在 VNodeData 中使用 onclick 来代替 click // 因为这样设计之后，我们就可以很容易地区分 VNodeData 中的某个属性是 DOM 属性还是 DOM 事件（只需要检测属性名的前两个字符是不是 on 即可） if (key[0] === 'o' &amp;&amp; key[1] === 'n') { el.addEventListener(key.slice(2), data[key]) /** * 关于属性的设置，这里需要单独说明一下 * * 需要针对 Attributes 和 DOM Properties 来分别进行处理（简单来说就是标准属性（如 id 之类）和自定义属性（如 userId）） * 因为是非标准属性，所以当你尝试通过 document.body.userId 访问其值时会得到 undefined（这也是为什么 setAttribute 方法存在的原因） * 但是也不能总是使用 setAttribute 设置全部的 DOM 属性，比如一些特殊值，如 checked/disabled 等，只要出现就会被初始化为 true * 只有调用 removeAttribute 删除这个 attribute，对应的 property 才会变成 false * 所以有些属性不能通过 setAttribute 设置，而是应该直接通过 DOM 元素设置，比如 el.checked = true * * 针对上述情况，我们创建了一个正则表达式 domPropsRE，用来检测那些应该以 Property 的方式添加到 DOM 元素上的属性，其他的属性则使用 setAttribute 方法设置 * 它还能匹配那些拥有大写字母的属性，这是为了匹配诸如 innerHTML、textContent 等属性设计的 * 这是因为拥有大写字母的属性我们都会采用 el[key] = xxx 的方式将其添加到 DOM 元素上 */ } else if (domPropsRE.test(key)) { // 当做 DOM Prop 处理 el[key] = data[key] } else { // 当做 Attr 处理 el.setAttribute(key, data[key]) } break } } } // 针对第三个问题，没有继续挂载子节点 const childFlags = vnode.childFlags const children = vnode.children // 因为 VNode 对象的 children 属性不总是数组，所以我们分类来进行处理 // 如果没有子节点则无需递归挂载 if (childFlags !== ChildrenFlags.NO_CHILDREN) { if (childFlags &amp; ChildrenFlags.SINGLE_VNODE) { // 如果是单个子节点则调用 mount 函数挂载 // 所以在这里需要把 isSVG 传递下去（原因见上方） mount(children, el, isSVG) } else if (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) { // 如果是单多个子节点则遍历并调用 mount 函数挂载 for (let i = 0; i &lt; children.length; i++) { // 所以在这里需要把 isSVG 传递下去（原因见上方） mount(children[i], el, isSVG) } } } // 当 refNode 存在时，我们应该使用 insertBefore 方法代替 appendChild 方法，为了后面 diff 算法当中进行优化操作 refNode ? container.insertBefore(el, refNode) : container.appendChild(el)} 自此，我们用于挂载普通标签元素的 mountElement 函数算是暂时告一段落，下面来看看如何挂载文本节点 挂载文本节点如果一个 VNode 的类型是 VNodeFlags.TEXT，那么 mount 函数会调用 mountText 函数挂载该纯文本元素，mountText 函数实现起来很简单，由于纯文本类型的 VNode 其 children 属性存储着与之相符的文本字符串，所以只需要调用 document.createTextNode 函数创建一个文本节点即可，然后将其添加到 container 中即可 12345function mountText(vnode, container) { const el = document.createTextNode(vnode.children) vnode.el = el container.appendChild(el)} 挂载 Fragment其实挂载 Fragment 和单纯地挂载一个 VNode 的 children 是没什么区别的，只是在没有 Fragment 的时候我们如果要想挂载一个片段，这个片段必须使用包裹元素包裹（比如 div），有了 Fragment 则不需要包裹元素，实际上对于 Fragment 类型的 VNode 的挂载，就等价于只挂载一个 VNode 的 children 1234567891011121314151617181920212223242526272829303132// 这里需要注意的地方就是对于 Fragment 类型的 VNode 来说，当它被渲染为真实 DOM 之后，其 el 属性的引用是谁的问题，可以见下方注释部分function mountFragment(vnode, container, isSVG) { const { children, childFlags } = vnode switch (childFlags) { // 如果是单个子节点，则直接调用 mount case ChildrenFlags.SINGLE_VNODE: mount(children, container, isSVG) // 如果是单个子节点，引用就指向该节点 vnode.el = children.el break // 如果没有子节点，等价于挂载空片段，会创建一个空的文本节点占位 case ChildrenFlags.NO_CHILDREN: const placeholder = createTextVNode('') mountText(placeholder, container) // 如果没有子节点，则引用指向占位的空文本节点 vnode.el = placeholder.el break // 多个子节点，遍历挂载之 default: for (let i = 0; i &lt; children.length; i++) { mount(children[i], container, isSVG) } // 如果有多个子节点，则默认指向第一个子节点 vnode.el = children[0].el }} 挂载 Portal实际上 Portal 可以『不严谨地认为是可以被到处挂载』的 Fragment，实现 Portal 的关键是要将其 VNode 的 children 中所包含的子 VNode 挂载到 tag 属性所指向的挂载点，『而非 container』（这个很重要） 123456789101112131415161718192021222324252627282930313233function mountPortal(vnode, container) { const { tag, children, childFlags } = vnode // 获取挂载点 const target = typeof tag === 'string' ? document.querySelector(tag) : tag if (childFlags &amp; ChildrenFlags.SINGLE_VNODE) { // 将 children 挂在到 target 上，而非 container mount(children, target) } else if (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) { for (let i = 0; i &lt; children.length; i++) { // 将 children 挂在到 target 上，而非 container mount(children[i], target) } } /** * 关于 Portal 类型的 VNode 其 el 属性的指向问题，需要说明一下 * 不应该指向挂载点元素，因为实际上虽然 Portal 所描述的内容可以被挂载到任何位置，但仍然需要一个占位元素 * 并且 Portal 类型的 VNode 其 el 属性应该指向该占位元素 * * 之所以这样设置，是因为 Portal 的另外一个特性，虽然 Portal 的内容可以被渲染到任意位置，但它的行为仍然像普通的DOM元素一样 * 如事件的捕获和冒泡机制仍然按照代码所编写的 DOM 结构实施 * 要实现这个功能就必须需要一个占位的 DOM 元素来承接事件，就目前来说，我们用一个空的文本节点占位即可 */ // 占位的空文本节点 const placeholder = createTextVNode('') // 将该节点挂载到 container 中（注意不是挂载到 target 下） mountText(placeholder, container, null) // el 属性引用该节点 vnode.el = placeholder.el} 挂载有状态组件组件还分为有状态组件和函数式组件，所以在 mountComponent 函数内部，我们需要再次对组件的类型进行区分，并使用不同的挂载方式 12345678// 需要再次对组件的类型进行区分，并使用不同的挂载方式function mountComponent(vnode, container, isSVG) { if (vnode.flags &amp; VNodeFlags.COMPONENT_STATEFUL) { mountStatefulComponent(vnode, container, isSVG) } else { mountFunctionalComponent(vnode, container, isSVG) }} 我们先来看看有状态组件的挂载方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 本质上来说就分四个步骤 * 1. 创建组件实例 * 2. 获取组件产出的 VNode（调用实例的 render() 方法） * 3. mount 挂载 * 4. 让组件实例的 $el 属性和 vnode.el 属性的值引用组件的根 DOM 元素 * * 组件的 render 函数会返回该组件产出的 VNode，当该 VNode 被挂载为真实DOM之后，就可以通过 instance.$vnode.el 元素拿到组件的根DOM元素 * 接着我们就可以让组件实例的 $el 属性和 vnode.el 属性的值都引用该DOM元素 * 如果组件的 render 返回的是一个片段（Fragment），那么 instance.$el 和 vnode.el 引用的就是该片段的第一个 DOM 元素 */function mountStatefulComponent(vnode, container, isSVG) { // 创建组件实例 const instance = (vnode.children = new vnode.tag()) // 初始化 props instance.$props = vnode.data // 我们把除了创建组件实例这一步之外的代码封装成一个函数 // 因为 _update 函数所做的工作就是渲染组件，这样当组件自身状态发生变化后，我们就可以再次调用 _update 函数来完成组件的更新 instance._update = function () { // 设计一个 instance._mounted 变量用来标记组件是否已经被挂载，这样 _update 函数就能够区分当前这次渲染到底是初次挂载还是后续更新了 // 如果 instance._mounted 为真，说明组件已挂载，应该执行更新操作 if (instance._mounted) { // 1. 拿到旧的 VNode（由于初次挂载组件时所产出的 VNode 存储在组件实例的 $vnode 属性中，所以我们可以通过 $vnode 属性拿到旧的 VNode） const prevVNode = instance.$vnode // 2. 重新调用 render 函数产出新的 VNode（重新渲染新的 VNode ） const nextVNode = (instance.$vnode = instance.render()) // 3. 调用 patch 函数对比新旧 VNode，完成更新操作 patch(prevVNode, nextVNode, prevVNode.el.parentNode) // 4. 我们还应该使用新的真实 DOM 元素去更新 vnode.el 属性和组件实例的 $el 属性的值（更新 vnode.el 和 $el） instance.$el = vnode.el = instance.$vnode.el } else { instance.$vnode = instance.render() // 1. 渲染VNode mount(instance.$vnode, container, isSVG) // 2. 挂载 instance._mounted = true // 3. 组件已挂载的标识 instance.$el = vnode.el = instance.$vnode.el // 4. el 属性值 和 组件实例的 $el 属性都引用组件的根 DOM 元素 // 另外如果在组件中我们使用了 mounted 生命周期钩子 // 我们只需要在组件被渲染为真实 DOM 之后调用该组件实例的 mounted 函数即可 // 更多的关于生命周期钩子函数的内容我们暂且不做深入讨论 instance.mounted &amp;&amp; instance.mounted() // 5. 调用 mounted 钩子 } } instance._update()} 挂载函数式组件在挂载函数式组件的时候，比挂载有状态组件少了一个实例化的过程，如果一个 VNode 描述的是函数式组件，那么其 tag 属性值就是该函数的引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 函数式组件相较于有状态组件更为简单，因为它就是一个返回 VNode 的函数 * 而且比挂载有状态组件少了一个实例化的过程 */function mountFunctionalComponent(vnode, container, isSVG) { vnode.handle = { /** * 这里简单介绍一下四个字段 * 1. handle.prev，存储旧的函数式组件 VNode，在初次挂载时，没有旧的 VNode 可言，所以初始值为 null * 2. handle.next，存储新的函数式组件 VNode，在初次挂载时，被赋值为当前正在挂载的函数式组件 VNode * 3. handle.container，存储的是挂载容器 * 4. handle.update ，针对函数式组件，与有状态组件不同，函数式组件没有组件实例，所以我们没办法封装类似 instance._update 这样的函数 * 所以这里我们采用把 update 函数定义在函数式组件的 VNode 上的方式 */ prev: null, next: vnode, container, update: () =&gt; { /** * 通过判断 vnode.handle.prev 是否存在来判断该函数式组件是初次挂载还是后续更新 * 由于在 patchComponent 函数内我们已经将 vnode.handle.prev 属性赋值为旧的组件 VNode * 所以如果 vnode.handle.prev 存在则说明该函数式组件并非初次挂载，而是更新 */ // 更新操作 if (vnode.handle.prev) { /** * 由于我们在 patchComponent 函数内已经更新过了 handle 对象 * 所以此时我们可以通过 vnode.handle.prev 和 vnode.handle.next 分别拿到旧的组件 VNode 和新的组件 VNode * 但是这里需要区分开来，prevVNode 和 nextVNode 是用来描述函数式组件的 VNode，并非函数式组件所产出的 VNode */ const prevVNode = vnode.handle.prev const nextVNode = vnode.handle.next /** * 因为函数式组件所产出的 VNode 存放在用来描述函数式组件的 VNode 的 children 属性中 * 所以我们通过 prevVNode.children 拿到了组件所产出的旧的 VNode 即 prevTree * 接着使用新的 props 重新调用组件函数 nextVNode.tag(props) 得到新产出的 VNode 即 nextTree */ const prevTree = prevVNode.children const props = nextVNode.data const nextTree = (nextVNode.children = nextVNode.tag(props)) // 有了 prevTree 和 nextTree 之后我们就可以调用 patch 函数执行更新操作了 patch(prevTree, nextTree, vnode.handle.container) } else { /** * 1. 获取 props（我们在调用组件函数获取 VNode 之前，要先获取 props，这里我们同样直接将整个 VNodeData 作为 props 数据） * 2. 获取 VNode（在调用组件函数 vnode.tag(props) 时将 props 作为参数传递过去，这样子组件就可以通过参数访问由父组件传递过来的数据了） * 3. 挂载 */ const props = vnode.data // 同样的，我们也用其 children 属性存储组件产出的 VNode const $vnode = (vnode.children = vnode.tag(props)) mount($vnode, container, isSVG) // el 元素引用该组件的根元素 vnode.el = $vnode.el } } } // 立即调用 vnode.handle.update 完成初次挂载 vnode.handle.update()} 以上就是 mount 阶段的全部内容了，主要就是针对各种不同的挂载类型来进行对应的处理，下面我们再来看看 patch 阶段 patch 阶段在上面我们已经介绍过了渲染器的挂载逻辑，其实 mount 阶段的本质就是将各种类型的 VNode 渲染成真实 DOM 的过程，渲染器除了将全新的 VNode 挂载成真实 DOM 之外，它的另外一个职责是负责对新旧 VNode 进行比对，并以合适的方式更新 DOM，也就是我们常说的 patch 当使用 render 渲染器渲染一个全新的 VNode 时，会调用 mount 函数挂载该 VNode，同时让容器元素存储对该 VNode 对象的引用，这样当再次调用渲染器渲染新的 VNode 对象到相同的容器元素时，由于旧的 VNode 已经存在，所以会调用 patch 函数以合适的方式进行更新 1234567891011// 旧的 VNodeconst prevVNode = h('div')// 新的 VNodeconst nextVNode = h('span')// 第一次渲染 VNode 到 #app，此时会调用 mount 函数render(prevVNode, document.getElementById('app'))// 第二次渲染新的 VNode 到相同的 #app 元素，此时会调用 patch 函数render(nextVNode, document.getElementById('app')) patch 函数会对新旧 VNode 进行比对，但是在这里，我们需要设定一定的规则，因为只有相同类型的 VNode 才有比对的意义，例如我们有两个 VNode，其中一个 VNode 的类型是标签元素，而另一个 VNode 的类型是组件，当这两个 VNode 进行比对时，最优的做法是使用新的 VNode 完全替换旧的 VNode，按照这个思路，我们先来实现一个基本版本的 patch 函数 1234567891011121314151617181920212223// patch 函数的作用是用来比对新旧 VNode，那么 patch 函数必然需要接收新旧 VNode 作为参数// 我们使用 prevVNode 形参代表旧的 VNode，使用 nextVNode 形参代表新的 VNodefunction patch(prevVNode, nextVNode, container) { // 分别拿到新旧 VNode 的类型，即 flags const nextFlags = nextVNode.flags const prevFlags = prevVNode.flags // 检查新旧 VNode 的类型是否相同，如果类型不同，则直接调用 replaceVNode 函数替换 VNode // 如果新旧 VNode 的类型相同，则根据不同的类型调用不同的比对函数 if (prevFlags !== nextFlags) { replaceVNode(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.ELEMENT) { patchElement(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.COMPONENT) { patchComponent(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.TEXT) { patchText(prevVNode, nextVNode) } else if (nextFlags &amp; VNodeFlags.FRAGMENT) { patchFragment(prevVNode, nextVNode, container) } else if (nextFlags &amp; VNodeFlags.PORTAL) { patchPortal(prevVNode, nextVNode) }} 其核心原则是 如果类型不同，则直接调用 replaceVNode 函数使用新的 VNode 替换旧的 VNode，否则根据不同的类型调用与之相符的比对函数 如下图所示 类型不同则替换 VNode替换操作并不复杂，本质就是把旧的 VNode 所渲染的 DOM 移除，再挂载新的 VNode 12345678910111213141516function replaceVNode(prevVNode, nextVNode, container) { // 将旧的 VNode 所渲染的 DOM 从容器中移除 container.removeChild(prevVNode.el) // 在后面组件的删除当中，我们还有另外一件事需要做，即调用 unmounted 钩子，所以针对组件需要单独处理一下 // 如果将要被移除的 VNode 类型是组件，则需要调用该组件实例的 unmounted 钩子函数 if (prevVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) { // 类型为有状态组件的 VNode，其 children 属性被用来存储组件实例对象 const instance = prevVNode.children instance.unmounted &amp;&amp; instance.unmounted() } // 再把新的 VNode 挂载到容器中 mount(nextVNode, container)} 更新标签元素首先即使两个 VNode 的类型同为标签元素，但它们也可能是不同的标签，也就是说它们的 tag 属性值不尽相同，所以我们可以认为『不同的标签渲染的内容不同』，例如 ul 标签下只能渲染 li 标签，所以拿 ul 标签和一个 div 标签进行比对是没有任何意义的，这种情况下我们会使用新的标签元素替换旧的标签元素 1234567function patchElement(prevVNode, nextVNode, container) { // 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode if (prevVNode.tag !== nextVNode.tag) { replaceVNode(prevVNode, nextVNode, container) return }} 如果新旧 VNode 描述的是相同的标签，那两个 VNode 之间的差异就只会出现在 VNodeData 和 children 上，所以这里主要分为两部分 VNodeData 的比对 children 的比对 我们首先先来看一下如何更新 VNodeData，在这里我们遵循的原则是 将新的 VNodeData 全部应用到元素上，再把那些已经不存在于新的 VNodeData 上的数据从元素上移除 1234567891011121314151617181920212223242526272829303132333435363738function patchElement(prevVNode, nextVNode, container) { // 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode if (prevVNode.tag !== nextVNode.tag) { replaceVNode(prevVNode, nextVNode, container) return } // 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素 const el = (nextVNode.el = prevVNode.el) // 拿到 新旧 VNodeData const prevData = prevVNode.data const nextData = nextVNode.data // 新的 VNodeData 存在时才有必要更新 if (nextData) { // 遍历新的 VNodeData for (let key in nextData) { // 根据 key 拿到新旧 VNodeData 值 const prevValue = prevData[key] const nextValue = nextData[key] switch (key) { case 'style': // 遍历新 VNodeData 中的 style 数据，将新的样式应用到元素 for (let k in nextValue) { el.style[k] = nextValue[k] } // 遍历旧 VNodeData 中的 style 数据，将已经不存在于新的 VNodeData 的数据移除 for (let k in prevValue) { if (!nextValue.hasOwnProperty(k)) { el.style[k] = '' } } break default: break } } }} 是不是有一点似成相识的感觉，实际上无论是 mountElement 函数中用来处理 VNodeData 的代码还是 patchElement 函数中用来处理 VNodeData 的代码，它们的本质都是将 VNodeData 中的数据应用到 DOM 元素上，唯一的区别就是在 mountElement 函数中没有旧数据可言，所以我们可以来稍微的封装一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数，并由 patchData 函数负责更新数据// 同时也需要遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据从元素上移除function patchElement(prevVNode, nextVNode, container) { // 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode if (prevVNode.tag !== nextVNode.tag) { replaceVNode(prevVNode, nextVNode, container) return } // 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素 const el = (nextVNode.el = prevVNode.el) const prevData = prevVNode.data const nextData = nextVNode.data if (nextData) { // 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数 for (let key in nextData) { const prevValue = prevData[key] const nextValue = nextData[key] patchData(el, key, prevValue, nextValue) } } if (prevData) { // 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除 for (let key in prevData) { const prevValue = prevData[key] if (prevValue &amp;&amp; !nextData.hasOwnProperty(key)) { // 第四个参数为 null，意味着将该数据从元素上移除 patchData(el, key, prevValue, null) } } }}// 将之前 h 方法中的 patchElement 函数中的 switch 语句块移动到了 patchData 函数中// 改动的地方，只需要添加将旧的事件回调函数移除功能即可，其他照搬过来就行function patchData(el, key, prevValue, nextValue) { const domPropsRE = /\\W|^(?:value|checked|selected|muted)$/ switch (key) { case 'style': for (let k in nextValue) { el.style[k] = nextValue[k] } for (let k in prevValue) { if (!nextValue.hasOwnProperty(k)) { el.style[k] = '' } } break case 'class': el.className = nextValue break default: if (key[0] === 'o' &amp;&amp; key[1] === 'n') { // 事件这里相较于原本在 patchElement 当中有所调整 // 如果旧的事件回调函数存在，我们先将其从 DOM 元素上移除，接着如果新的事件回调函数存在我们再将其添加到 DOM 元素中 if (prevValue) { el.removeEventListener(key.slice(2), prevValue) } if (nextValue) { el.addEventListener(key.slice(2), nextValue) } } else if (domPropsRE.test(key)) { // 当做 DOM Prop 处理 el[key] = nextValue } else { // 当做 Attr 处理 el.setAttribute(key, nextValue) } break }} 在了解完如何更新 VNodeData 以后，我们再来看看最后一小部分，那就是如何更新子节点，针对子节点，我们只需在 patchElement 函数中最后递归地更新子节点即可 123456789101112131415161718192021222324252627function patchElement(prevVNode, nextVNode, container) { if (prevVNode.tag !== nextVNode.tag) { // ... } if (nextData) { // ... } if (prevData) { // ... } // ... 省略（可以见上方） // 调用 patchChildren 函数递归地更新子节点 // patchChildren 函数的作用就是对新旧 VNode 的子节点进行同层级的比较 // 它接收五个参数，前四个参数分别是新旧 VNode 子节点以及子节点的类型 // 第五个参数 el 是这些子节点的父节点，也就是当前被更新的标签元素 patchChildren( prevVNode.childFlags, // 旧的 VNode 子节点的类型 nextVNode.childFlags, // 新的 VNode 子节点的类型 prevVNode.children, // 旧的 VNode 子节点 nextVNode.children, // 新的 VNode 子节点 el // 当前标签元素，即这些子节点的父节点 )} 接下来我们就可以思考如何来实现 patchChildren 函数，简单来说，无论是新标签还是旧标签，该标签的子节点都可以分为三种情况 只有一个子节点 没有子节点 有多个子节点 至于一个标签的子节点属于哪种类型是可以通过该标签所对应的 VNode 对象的 childFlags 属性得知的，所以根据以上规则，我们可以得出 patchChildren 函数最基本的样子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function patchChildren( prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // 旧的 children 是单个子节点，会执行该 case 语句块 case ChildrenFlags.SINGLE_VNODE: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: // 新的 children 也是单个子节点时，会执行该 case 语句块 break case ChildrenFlags.NO_CHILDREN: // 新的 children 中没有子节点时，会执行该 case 语句块 break default: // 新的 children 中有多个子节点时，会执行该 case 语句块 break } break // 旧的 children 中没有子节点时，会执行该 case 语句块 case ChildrenFlags.NO_CHILDREN: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: // 新的 children 是单个子节点时，会执行该 case 语句块 break case ChildrenFlags.NO_CHILDREN: // 新的 children 中没有子节点时，会执行该 case 语句块 break default: // 新的 children 中有多个子节点时，会执行该 case 语句块 break } break // 旧的 children 中有多个子节点时，会执行该 case 语句块 default: switch (nextChildFlags) { case ChildrenFlags.SINGLE_VNODE: // 新的 children 是单个子节点时，会执行该 case 语句块 break case ChildrenFlags.NO_CHILDREN: // 新的 children 中没有子节点时，会执行该 case 语句块 break default: // 新的 children 中有多个子节点时，会执行该 case 语句块 break } break }} 由于新旧 children 各有三种情况，所以合起来共有九种情况，我们会根据这九种情况分别来进行完善，具体处理逻辑可以参考下面几个图 所以完善后的 patchChildren 函数如下所示，一些需要注意的地方都已经标注在注释当中了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function patchChildren( prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // 旧的 children 是单个子节点 case ChildrenFlags.SINGLE_VNODE: switch (nextChildFlags) { // 新旧 children 都是单个子节点 // 在这种情况下新旧 children 的比较等价于两个 children（单个子节点）之间的比较，所以只需要递归地调用 patch 函数即可 case ChildrenFlags.SINGLE_VNODE: patch(prevChildren, nextChildren, container) break // 新的 children 中没有子节点时，在这种情况下我们只需要把旧的子节点移除即可 case ChildrenFlags.NO_CHILDREN: container.removeChild(prevChildren.el) break // 由于旧的子节点只有一个，而新的子节点有多个 // 所以我们可以采用将旧的单个子节点移除，再将新的多个子节点挂载上去的方案 default: container.removeChild(prevChildren.el) for (let i = 0; i &lt; nextChildren.length; i++) { mount(nextChildren[i], container) } break } break // 旧的 children 中没有子节点时 case ChildrenFlags.NO_CHILDREN: switch (nextChildFlags) { // 新的 children 是单个子节点时，此时只需要把新的单个子节点添加到容器元素即可 // 使用 mount 函数将新的子节点挂载到容器元素 case ChildrenFlags.SINGLE_VNODE: mount(nextChildren, container) break // 新的 children 中没有子节点时 // 什么都不做 case ChildrenFlags.NO_CHILDREN: break // 但新的 children 中有多个子节点时 // 遍历多个新的子节点，逐个使用 mount 函数挂载到容器元素 default: for (let i = 0; i &lt; nextChildren.length; i++) { mount(nextChildren[i], container) } break } break // 旧的 children 中有多个子节点时 default: switch (nextChildFlags) { // 有多个旧的子节点，但新的子节点是单个子节点 // 这时只需要把所有旧的子节点移除，再将新的单个子节点添加到容器元素即可 case ChildrenFlags.SINGLE_VNODE: for (let i = 0; i &lt; prevChildren.length; i++) { container.removeChild(prevChildren[i].el) } mount(nextChildren, container) break // 有多个旧的子节点，但没有新的子节点，这时只需要把所有旧的子节点移除即可 case ChildrenFlags.NO_CHILDREN: for (let i = 0; i &lt; prevChildren.length; i++) { container.removeChild(prevChildren[i].el) } break /** * 最复杂的当属最后一种情况，新旧子节点都是多个子节点的情况，这时将进入到至关重要的一步，即核心 diff 算法的用武之地 * 其实本质上，原理就是将旧的子节点全部移除，再将所有新的子节点添加的一种思路来完成更新 * 目前我们先暂时这样处理，关于 diff 的内容，会在后面详细的进行介绍 */ default: for (let i = 0; i &lt; prevChildren.length; i++) { container.removeChild(prevChildren[i].el) } for (let i = 0; i &lt; nextChildren.length; i++) { mount(nextChildren[i], container) } break } break }} 更新文本节点相较于标签元素，文本节点的更新非常简单，如果一个 DOM 元素是文本节点或注释节点，那么可以通过调用该 DOM 对象的 nodeValue 属性读取或设置文本节点（或注释节点）的内容 123456789function patchText(prevVNode, nextVNode) { // 拿到文本元素 el，同时让 nextVNode.el 指向该文本元素 const el = (nextVNode.el = prevVNode.el) // 由于对纯文本类型的 VNode 而言，它的 children 属性存储的就是其文本内容，所以通过对比新旧文本内容是否一致来决定是否需要更新. // 只有新旧文本内容不一致时我们才会设置文本节点的 el.nodeValue 属性的值 if (nextVNode.children !== prevVNode.children) { el.nodeValue = nextVNode.children }} 更新 Fragment实际上片段的更新是『简化版的标签元素的更新』，我们知道对于标签元素来说更新的过程分为两个步骤 首先需要更新标签本身的 VNodeData 其次更新其子节点 然而由于 Fragment 没有包裹元素，只有子节点，所以我们对 Fragment 的更新本质上就是更新两个片段的子节点 12345678910111213141516171819202122232425262728function patchFragment(prevVNode, nextVNode, container) { // 直接调用 patchChildren 函数更新 新旧片段的子节点即可 patchChildren( prevVNode.childFlags, // 旧片段的子节点类型 nextVNode.childFlags, // 新片段的子节点类型 prevVNode.children, // 旧片段的子节点 nextVNode.children, // 新片段的子节点 container ) switch (nextVNode.childFlags) { // 如果新的片段的 children 类型是单个子节点，则意味着其 vnode.children 属性的值就是 VNode 对象 // 所以直接将 nextVNode.children.el 赋值给 nextVNode.el 即可 case ChildrenFlags.SINGLE_VNODE: nextVNode.el = nextVNode.children.el break // 如果新的片段没有子节点，我们知道对于没有子节点的片段我们会使用一个空的文本节点占位，而 prevVNode.el 属性引用的就是该空文本节点 // 所以我们直接通过旧片段的 prevVNode.el 拿到该空文本元素并赋值给新片段的 nextVNode.el 即可 case ChildrenFlags.NO_CHILDREN: nextVNode.el = prevVNode.el break // 如果新的片段的类型是多个子节点，则 nextVNode.children 是一个 VNode 数组，我们会让新片段的 nextVNode.el 属性引用数组中的第一个元素 default: nextVNode.el = nextVNode.children[0].el }} 更新 Portal实际上 Portal 的更新与 Fragment 类似，我们需要更新其子节点，但由于 Portal 可以被到处挂载，所以新旧 Portal 的挂载目标可能不同，所以对于 Portal 的更新除了要更新其子节点之外，还要对比新旧挂载目标是否相同，如果新的 Portal 的挂载目标变了我们就需要将 Portal 的『内容从旧的容器中搬运到新的容器中』 1234567891011121314151617181920212223242526272829303132333435363738394041424344function patchPortal(prevVNode, nextVNode) { patchChildren( prevVNode.childFlags, nextVNode.childFlags, prevVNode.children, nextVNode.children, prevVNode.tag // 注意 container 是旧的 container ) // 让 nextVNode.el 指向 prevVNode.el nextVNode.el = prevVNode.el /** * 由于我们在更新子节点的过程中，传递给 patchChildren 函数的容器元素始终都是旧的容器元素 * 所以最终结果是，更新后的子节点也存在于旧的容器中 * 所以我们还需要做最后一步工作，就是把旧容器内的元素都搬运到新容器中 * 搬运的原理就是利用 appendChild 的特性，即被添加的元素如果已存在于页面上，那么就会移动该元素到目标容器元素下 */ // 如果新旧容器不同，才需要搬运 if (nextVNode.tag !== prevVNode.tag) { // 获取新的容器元素，即挂载目标 const container = typeof nextVNode.tag === 'string' ? document.querySelector(nextVNode.tag) : nextVNode.tag switch (nextVNode.childFlags) { case ChildrenFlags.SINGLE_VNODE: // 如果新的 Portal 是单个子节点，就把该节点搬运到新容器中 container.appendChild(nextVNode.children.el) break case ChildrenFlags.NO_CHILDREN: // 新的 Portal 没有子节点，不需要搬运 break default: // 如果新的 Portal 是多个子节点，遍历逐个将它们搬运到新容器中 for (let i = 0; i &lt; nextVNode.children.length; i++) { container.appendChild(nextVNode.children[i].el) } break } }} 更新有状态组件对于有状态组件来说它的更新方式有两种，主动更新和被动更新 主动更新，指的是组件自身的状态发生变化所导致的更新，例如组件的 data 数据发生了变化就必然需要重渲染 被动更新，一个组件所渲染的内容是很可能包含其它组件的，也就是子组件，对于子组件来讲，它除了自身状态之外，很可能还包含从父组件传递进来的外部状态（props），所以父组件自身状态的变化很可能引起子组件外部状态的变化，此时就需要更新子组件，像这种因为外部状态变化而导致的组件更新就叫做被动更新 我们先来看看主动更新，关于主动更新的关键点在于数据变化之后需要重新执行渲染函数，得到新的 VNode，这里就用到了我们在 mountStatefulComponent 方法中定义的 instance._update() 方法 123456789101112131415161718192021222324252627function patchComponent(prevVNode, nextVNode, container) { /** * 但是有时父组件自身状态的变化会导致父组件渲染不同的子组件 * 所以在这里，我们认为不同的组件渲染不同的内容，所以对于不同的组件我们采用的方案是使用新组件的内容替换旧组件渲染的内容 * tag 属性的值是组件类，我们通过对比前后组件类是否相同来确定新旧组件是否是相同的组件，如果不相同则直接调用 replaceVNode 函数使用新组件替换旧的组件 */ if (nextVNode.tag !== prevVNode.tag) { replaceVNode(prevVNode, nextVNode, container) } else if (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) { /** * 通过检查组件的 flags 判断组件是否是有状态组件，如果是有状态组件则更新之，分为三步 * 1、获取组件实例（通过 prevVNode.children 拿到组件实例） * 2、更新 props（使用新的 VNodeData 重新设置组件实例的 $props 属性） * 3、更新组件（由于组件的 $props 已更新，所以调用组件的 _update 方法，让组件重渲染） */ const instance = (nextVNode.children = prevVNode.children) // 这里需要特殊说明一下 // 在组件实例创建完成之后，我们为组件实例添加了 $props 属性，并且将 vnode.data 赋值给 $props // 这样，子组件中就可以通过 this.$props.text 访问从父组件传递进来的 props 数据 // 但是 VNodeData 中的数据并不全是 props，其中还包含事件以及其他信息（这些将在后续来进行介绍） instance.$props = nextVNode.data instance._update() } else { // 函数式组件的更新 }} 更新函数式组件其实无论是有状态组件还是函数式组件，它们的更新原理都是一样的，用组件新产出的 VNode 与之前产出的旧 VNode 进行比对，从而完成更新，这里就用到了我们在 mountFunctionalComponent 方法中定义的 update() 方法 1234567891011121314151617181920212223function patchComponent(prevVNode, nextVNode, container) { if (nextVNode.tag !== prevVNode.tag) { // ... } else if (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) { // ... 省略（见上方） } else { /** * 1. 将旧的函数式组件 VNode(prevVNode) 赋值给 handle.prev * 2. 将新的函数式组件 VNode(nextVNode) 赋值给 handle.next * 3. 更新 container（即使 container 未必会变，但仍要更新之） * 4. 最后我们调用了 handle.update 函数完成更新操作 */ // 更新函数式组件 const handle = (nextVNode.handle = prevVNode.handle) handle.prev = prevVNode handle.next = nextVNode handle.container = container handle.update() }} 参考如果想了解更多的相关内容，可以参考以下链接 深度剖析如何实现一个 Virtual DOM 算法 Diff Strategies React 源码深度解读 Vitual DOM 的内部工作原理 深入理解 React 中的虚拟 DOM 和 Diff 算法 解析 Snabbdom 源码 React 源码剖析系列 － 不可思议的 React Diff React Diff 算法 A Survey on Tree Edit Distance and Related（这一篇是介绍标准的 Diff 算法，其复杂度为 O(n ^ 3)）","link":"/2019/12/20/React/07/"},{"title":"渲染器的核心 Diff 算法","text":"最近在深入学习 Virtual DOM 的相关知识，参考了许多资料，也拜读了许多大神的文章，所以在这里大致的整理成了比较适合自己理解的方式，方便时不时回来翻翻，复习一下，篇幅较长，主要会分为三个部分来分别进行介绍，具体章节如下，目录名就差不多代表了章节的相关内容 什么是 Virtual DOM？ 渲染器 渲染器的核心 Diff 算法 在上一章当中，我们主要讨论了渲染器是如何更新各种类型的 VNode 的，本章是第三部分，也是最后一部分，主要介绍渲染器当中的核心，也就是传说中的 diff 算法，主要参考的是 HcySunYang/vue-design，本章相关内容如下 减小 DOM 操作的性能开销 尽可能的复用 DOM 元素 key 的作用 找到需要移动的节点 移动节点 添加新元素 移除不存在的元素 双端比较算法 非理想情况 添加新元素 移除不存在的元素 inferno 当中的 Diff 算法 相同的前置和后置元素 判断是否需要进行 DOM 移动 DOM 移动的方式 减小 DOM 操作的性能开销在上一章当中，我们在遇到了旧的 children 和新的 children 均为多个子节点的情况，如下图 我们当时提到，只有当新旧子节点的类型都是多个子节点时，核心 diff 算法才派得上用场，并且当时我们采用了一种仅能实现目标但并不完美的算法，即遍历旧的子节点，将其全部移除，再遍历新的子节点，将其全部添加，虽然能够达到目的，但并非最佳处理方式，在正式展开之前，我们先来思考一下上面的算法存在的问题，可以简化为下图 简单来说就是遍历旧的 VNode，通过旧 VNode 对真实 DOM 的引用取得真实 DOM，即可将已渲染的 DOM 移除，接着遍历新的 VNode 并将其全部添加到页面中，我们可以先假定它们都是 &lt;li&gt; 标签，想象一下如果它们只是单纯的交换位置，或者只是简单的调整了一下包含的文本，我们是不是可以复用已有 DOM 元素呢？ 实际上是可以的，我们在介绍 pathcElement 函数时了解到，当新旧 VNode 所描述的是相同标签时，那么这两个 VNode 之间的差异就仅存在于 VNodeData 和 children 上，所以我们完全可以通过遍历新旧 VNode，并一一比对它们，这样对于任何一个 DOM 元素来说，由于它们都是相同的标签，所以更新的过程是不会移除和新建任何 DOM 元素的，而是复用已有 DOM 元素，需要更新的只有 VNodeData 和 children，优化后的算法如下图所示 但是会发现有问题，如果新旧 children 的长度相同的话是可行的，但是如果不同呢，所以我们就可以大致的分为三种情况来单独的进行处理，代码如下 12345678910111213141516171819202122232425262728293031323334353637function patchChildren(prevChildFlags, nextChildFlags, prevChildren, nextChildren, container) { switch (prevChildFlags) { // ... // 旧的 children 中有多个子节点 default: switch (nextChildFlags) { // ... default: // 新的 children 中有多个子节点 // 获取公共长度，取新旧 children 长度较小的那一个 const prevLen = prevChildren.length const nextLen = nextChildren.length const commonLength = prevLen &gt; nextLen ? nextLen : prevLen for (let i = 0; i &lt; commonLength; i++) { patch(prevChildren[i], nextChildren[i], container) } // 如果 nextLen &gt; prevLen，将多出来的元素添加 if (nextLen &gt; prevLen) { for (let i = commonLength; i &lt; nextLen; i++) { mount(nextChildren[i], container) } // 如果 prevLen &gt; nextLen，将多出来的元素移除 } else if (prevLen &gt; nextLen) { for (let i = commonLength; i &lt; prevLen; i++) { container.removeChild(prevChildren[i].el) } } break } break }} 实际上，这个算法就是在没有 key 时所采用的算法，该算法是存在优化空间的，下面我们将分析如何进一步优化 尽可能的复用 DOM 元素在上一小节中，我们通过减少 DOM 操作的次数使得更新的性能得到了提升，但它仍然存在可优化的空间，我们假设新旧 children 如下 12345678910111213// 旧的 children[ h('li', null, 1), h('li', null, 2), h('li', null, 3)]// 新的 children[ h('li', null, 2), h('li', null, 3), h('li', null, 4)] 如果还是使用我们之前的算法，patch 函数知道它们是相同的标签，所以只会更新 VNodeData 和子节点，由于这两个标签都没有 VNodeData，所以只需要更新它们的子节点，它会依次进行比对，然后调用 patchText 方法来更新文本子节，比如在上面的示例当中，它会执行三次，实际上我们通过观察可以很明显的发现，最佳的操作应该是『通过移动元素的位置来达到更新的目的』，那么应该如何移动元素来完成更新呢？ key 的作用所以，我们需要在新旧 children 的节点中保存映射关系，以便我们能够在旧 children 的节点中找到可复用的节点，这时候我们就需要给 children 中的节点添加唯一标识，也就是我们常说的 key，有了 key 我们就能够明确的知道新旧 children 中节点的映射关系，比如下面这个例子 知道了映射关系，我们就很容易判断新 children 中的节点是否可被复用，我们只需要遍历新 children 中的每一个节点，并去旧 children 中寻找是否存在具有相同 key 值的节点 1234567891011121314// 遍历新的 childrenfor (let i = 0; i &lt; nextChildren.length; i++) { const nextVNode = nextChildren[i] let j = 0 // 遍历旧的 children for (j; j &lt; prevChildren.length; j++) { const prevVNode = prevChildren[j] // 如果找到了具有相同 key 值的两个节点，则调用 patch 函数更新之 if (nextVNode.key === prevVNode.key) { patch(prevVNode, nextVNode, container) break // 这里需要 break } }} 找到需要移动的节点我们已经找到了可复用的节点，并进行了合适的更新操作，下一步需要做的，就是判断一个节点是否需要移动以及如何移动 我们可以先来看看不需要移动的情况，如上图，我们假定以上面的算法来执行，流程是下面这样的 取出新 children 的第一个节点，并尝试在旧 children 中寻找 li-a，找到了，索引为 0 取出新 children 的第二个节点，并尝试在旧 children 中寻找 li-b，找到了，索引为 1 取出新 children 的第三个节点，并尝试在旧 children 中寻找 li-c，找到了，索引为 2 可以发现，我们先后遇到的索引顺序依次为 0 ==&gt; 1 ==&gt; 2，这是一个递增的顺序，这就说明 如果在寻找的过程中遇到的索引呈现递增趋势，则说明新旧 children 中节点顺序相同，不需要移动操作 相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作 下面再来看一个例子 还是按照我们上面的流程，来看一看执行结果 取出新 children 的第一个节点，并尝试在旧 children 中寻找 li-c，找到了，索引为 2 取出新 children 的第二个节点，并尝试在旧 children 中寻找 li-a，找到了，索引为 0 取出新 children 的第三个节点，并尝试在旧 children 中寻找 li-b，找到了，索引为 1 这次可以发现，递增的趋势被打破了，索引顺序依次为 2 ==&gt; 0 ==&gt; 1 在第二次查找过程中我们遇到了 0 &lt; 2 的情况，这说明在旧 children 中 li-a 的位置要比 li-c 靠前，但在新的 children 中 li-a 的位置要比 li-c 靠后，所以得知 li-a 是需要被移动的 在第三次查找过程中，1 也是小于 2 的，这说明在旧 children 中节点 li-b 的位置也要比 li-c 的位置靠前，但在新的 children 中 li-b 的位置要比 li-c 靠后，所以 li-b 也需要被移动 在这个过程当中可以发现，因为有 2 这个数字的存在才使得我们能够知道哪些节点需要移动，我们可以把它称为，寻找过程中在旧 children 中所遇到的最大索引值 如果在后续寻找的过程中发现存在索引值比最大索引值小的节点，意味着该节点需要被移动 实际上，这就是 React 所使用的算法，我们可以使用一个叫做 lastIndex 的变量存储寻找过程中遇到的最大索引值，并且它的初始值为 0 移动节点现在我们已经有办法找到需要移动的节点了，接下应该如何移动这些节点？先还是按照之前的流程来运行一下我们之前的示例 新 children 中的第一个节点是 li-c，它在旧 children 中的索引为 2，由于 li-c 是新 children 中的第一个节点，所以它始终都是不需要移动的，只需要调用 patch 函数更新即可 这里有一个需要注意的地方，即新 children 中的 li-c 节点在经过 patch 函数之后，也将存在对真实 DOM 元素的引用（因为我们在 patchElement 函数当中已经让 nextVNode.el 也引用了该元素） 新 children 中的第二个节点 li-a，它在旧 children 中的索引是 0，由于 0 &lt; 2 所以 li-a 是需要移动的节点，所以我们需要做的就是把 li-a 节点对应的『真实』DOM 移动到 li-c 节点所对应『真实』DOM 的后面 12345678910111213141516171819202122232425262728293031323334353637383940// 用来存储寻找过程中遇到的最大索引值let lastIndex = 0// 遍历新的 childrenfor (let i = 0; i &lt; nextChildren.length; i++) { const nextVNode = nextChildren[i] let j = 0 // 遍历旧的 children for (j; j &lt; prevChildren.length; j++) { const prevVNode = prevChildren[j] // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之 if (nextVNode.key === prevVNode.key) { patch(prevVNode, nextVNode, container) if (j &lt; lastIndex) { /** * 假设我们当前正在更新的节点是 li-a，那么如上代码中的变量 i 就是节点 li-a 在新 children 中的位置索引 * 所以 nextChildren[i - 1] 就是 li-a 节点的前一个节点，也就是 li-c 节点，由于 li-c 节点存在对真实 DOM 的引用 * 所以我们可以通过其 el 属性拿到真实 DOM * * 我们的目标是把 li-a 节点对应的真实 DOM 移动到 li-c 节点所对应真实 DOM 的后面 * 所以我们的思路应该是想办法拿到 li-c 节点对应真实 DOM 的下一个兄弟节点 * 并把 li-a 节点所对应真实 DOM 插到该节点的前面 * * 所以 refNode 引用是 li-c 节点对应真实 DOM 的下一个兄弟节点 * 拿到了正确的 refNode 之后，我们就可以调用容器元素的 insertBefore 方法来完成 DOM 的移动了 * 移动的对象就是 li-a 节点所对应的真实 DOM，由于当前正在处理的就是 li-a 节点 * 所以 prevVNode 就是旧 children 中的 li-a 节点，它是存在对真实 DOM 的引用的，即 prevVNode.el */ // 需要移动 // refNode 是为了下面调用 insertBefore 函数准备的 const refNode = nextChildren[i - 1].el.nextSibling // 调用 insertBefore 函数移动 DOM container.insertBefore(prevVNode.el, refNode) } else { // 更新 lastIndex lastIndex = j } break // 这里需要 break } }} 我们可以用下图来描述这个过程 添加新元素我们之前考虑的只是一种情况，如果在新 children 中包含了一个全新的节点，这意味着在旧 children 中是找不到该节点的，针对这种情况我们需要单独处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let lastIndex = 0for (let i = 0; i &lt; nextChildren.length; i++) { const nextVNode = nextChildren[i] /** * 我们在原来的基础上添加了变量 find，它将作为一个标志，代表新 children 中的节点是否存在于旧 children 中，初始值为 false * 一旦在旧 children 中寻找到了相应的节点，我们就将变量 find 的值设置为 true * 所以如果内层循环结束后，变量 find 的值仍然为 false，则说明在旧的 children 中找不到可复用的节点 * 这时我们就需要使用 mount 函数将当前遍历到的节点挂载到容器元素 */ let j = 0, find = false for (j; j &lt; prevChildren.length; j++) { const prevVNode = prevChildren[j] if (nextVNode.key === prevVNode.key) { find = true patch(prevVNode, nextVNode, container) if (j &lt; lastIndex) { // 需要移动 const refNode = nextChildren[i - 1].el.nextSibling container.insertBefore(prevVNode.el, refNode) break } else { // 更新 lastIndex lastIndex = j } } } /** * 我们应该按照节点在新的 children 中的位置将其添加到正确的地方 * 所以我们先找到当前遍历到的节点的前一个节点，即 nextChildren[i - 1] * 接着找到该节点所对应真实 DOM 的下一个子节点作为 refNode，即 nextChildren[i - 1].el.nextSibling * 但是由于当前遍历到的节点有可能是新 children 的第一个节点，这时 i - 1 &lt; 0，这将导致 nextChildren[i - 1] 不存在 * 所以当 i - 1 &lt; 0 时，我们只需要把新的节点插入到最前面即可（第一个节点），所以我们使用 prevChildren[0].el 作为 refNode * * 最后调用 mount 函数挂载新节点时，我们为其传递了第四个参数 refNode（这就是第四个参数的作用） * 即当 refNode 存在时，我们应该使用 insertBefore 方法代替 appendChild 方法 */ if (!find) { // 挂载新节点 // 找到 refNode const refNode = i - 1 &lt; 0 ? prevChildren[0].el : nextChildren[i - 1].el.nextSibling mount(nextVNode, container, false, refNode) }} 移除不存在的元素当然，除了要将全新的节点添加到容器元素之外，我们还应该把已经不存在了的节点移除 我们需要在外层循环结束之后，再优先遍历一次旧的 children，并尝试拿着旧 children 中的节点去新 children 中寻找相同的节点，如果找不到则说明该节点已经不存在于新 children 中了，这时我们应该将该节点对应的真实 DOM 移除 1234567891011121314151617let lastIndex = 0for (let i = 0; i &lt; nextChildren.length; i++) { // ... 省略（见上方）}// 移除已经不存在的节点// 遍历旧的节点for (let i = 0; i &lt; prevChildren.length; i++) { const prevVNode = prevChildren[i] // 拿着旧 VNode 去新 children 中寻找相同的节点 const has = nextChildren.find( nextVNode =&gt; nextVNode.key === prevVNode.key ) if (!has) { // 如果没有找到相同的节点，则移除 container.removeChild(prevVNode.el) }} 至此，第一种算法我们算是介绍完毕了，这个也就是 React 所采用的 diff 算法，不过还有可以优化的空间，我们后面在进行介绍 双端比较算法之前提到 React 的 diff 算法是存在优化空间的，想要要找到优化的关键点，我们首先要知道它存在什么问题，来看下图 我们可以通过观察可以发现，其实最优的解决方案应该是把 li-c 节点对应的真实 DOM 移动到最前面即可，只需要一次移动即可完成更新，然而 React 所采用的 diff 算法在更新如上案例的时候，会进行两次移动 所以在这种情况下，我们就可以采用一种新的思路，即『双端比较』，所谓双端比较，就是同时从新旧 children 的两端开始进行比较的一种方式，所以我们需要四个索引值，分别指向新旧 children 的两端，如下图所示 我们使用四个变量 oldStartIdx、oldEndIdx、newStartIdx 以及 newEndIdx 分别存储旧 children 和新 children 的两个端点的位置索引，除了位置索引之外，我们还需要拿到四个位置索引所指向的 VNode，用代码表示如下 123456789let oldStartIdx = 0let oldEndIdx = prevChildren.length - 1let newStartIdx = 0let newEndIdx = nextChildren.length - 1let oldStartVNode = prevChildren[oldStartIdx]let oldEndVNode = prevChildren[oldEndIdx]let newStartVNode = nextChildren[newStartIdx]let newEndVNode = nextChildren[newEndIdx] 在一次比较过程中，最多需要进行四次比较 使用旧 children 的头一个 VNode 与新 children 的头一个 VNode 比对，即 oldStartVNode 和 newStartVNode 比较对 使用旧 children 的最后一个 VNode 与新 children 的最后一个 VNode 比对，即 oldEndVNode 和 newEndVNode 比对 使用旧 children 的头一个 VNode 与新 children 的最后一个 VNode 比对，即 oldStartVNode 和 newEndVNode 比对 使用旧 children 的最后一个 VNode 与新 children 的头一个 VNode 比对，即 oldEndVNode 和 newStartVNode 比对 可以用下图来描述在一次比对过程中的四个步骤 下面是对该过程的实现，其实简单来说就是上述四个步骤分别对应着不同的结果，我们只需要针对结果进行不同的处理即可 123456789if (oldStartVNode.key === newStartVNode.key) { // 步骤一：oldStartVNode 和 newStartVNode 比对} else if (oldEndVNode.key === newEndVNode.key) { // 步骤二：oldEndVNode 和 newEndVNode 比对} else if (oldStartVNode.key === newEndVNode.key) { // 步骤三：oldStartVNode 和 newEndVNode 比对} else if (oldEndVNode.key === newStartVNode.key) { // 步骤四：oldEndVNode 和 newStartVNode 比对} 每次比对完成之后，如果在某一步骤中找到了可复用的节点，我们就需要将相应的位置索引后移或者前移一位，以上图为例 拿旧 children 中的 li-a 和新 children 中的 li-d 进行比对，由于二者 key 值不同，所以不可复用，什么都不做 拿旧 children 中的 li-d 和新 children 中的 li-c 进行比对，同样不可复用，什么都不做 拿旧 children 中的 li-a 和新 children 中的 li-c 进行比对，什么都不做 拿旧 children 中的 li-d 和新 children 中的 li-d 进行比对，由于这两个节点拥有相同的 key 值，所以我们在这次比对的过程中找到了可复用的节点 即 oldEndVNode 和 newStartVNode 拥有相同的 key 值，这说明 li-d 节点所对应的真实 DOM 原本是最后一个子节点，并且更新之后它应该变成第一个子节点，所以我们需要把 li-d 所对应的真实 DOM 移动到最前方即可 1234567891011121314151617if (oldStartVNode.key === newStartVNode.key) { // 步骤一：oldStartVNode 和 newStartVNode 比对} else if (oldEndVNode.key === newEndVNode.key) { // 步骤二：oldEndVNode 和 newEndVNode 比对} else if (oldStartVNode.key === newEndVNode.key) { // 步骤三：oldStartVNode 和 newEndVNode 比对} else if (oldEndVNode.key === newStartVNode.key) { // 步骤四：oldEndVNode 和 newStartVNode 比对 // 先调用 patch 函数完成更新 patch(oldEndVNode, newStartVNode, container) // 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点 container.insertBefore(oldEndVNode.el, oldStartVNode.el) // 更新索引，指向下一个位置 oldEndVNode = prevChildren[--oldEndIdx] newStartVNode = nextChildren[++newStartIdx]} 这一步更新完成之后，新的索引关系可以用下图来表示 这样，一次比对就完成了，并且位置索引已经更新，那么什么时候比对才能结束呢？如下 123while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { // ...} 我们将每一轮比对所做的工作封装到一个 while 循环内，循环结束的条件是要么 oldStartIdx 大于 oldEndIdx，要么 newStartIdx 大于 newEndIdx，如此往复下去，流程如下图所示 最后得到的结果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (oldStartVNode.key === newStartVNode.key) { /** * 当 oldStart === newStart 的时候 * 由于该节点无论是在新 children 中还是旧 children 中，都是当前索引范围内的第一个节点，所以位置不需要变化 * 即不需要移动操作，只需要调用 patch 函数更新即可，同时也要将相应的位置所以下移一位 */ patch(oldStartVNode, newStartVNode, container) oldStartVNode = prevChildren[++oldStartIdx] newStartVNode = nextChildren[++newStartIdx] } else if (oldEndVNode.key === newEndVNode.key) { /** * 当 oldEnd === newEnd 的时候 * 说明二者在新旧 children 中都是最末尾的一个节点 * 所以是不需要进行移动操作的，只需要调用 patch 函数更新即可，同时将相应的索引前移一位 */ patch(oldEndVNode, newEndVNode, container) oldEndVNode = prevChildren[--oldEndIdx] newEndVNode = newEndVNode[--newEndIdx] } else if (oldStartVNode.key === newEndVNode.key) { /** * 当 oldStart === newEnd 的时候 * 说明该节点对应的真实 DOM 原本是第一个子节点，但现在变成了当前索引范围内的最后一个节点 * 所以移动操作也是比较明显的，我们将 oldStartVNode 对应的真实 DOM 移动到 oldEndVNode 所对应真实 DOM 的后面即可 */ patch(oldStartVNode, newEndVNode, container) container.insertBefore( oldStartVNode.el, oldEndVNode.el.nextSibling ) oldStartVNode = prevChildren[++oldStartIdx] newEndVNode = nextChildren[--newEndIdx] } else if (oldEndVNode.key === newStartVNode.key) { /** * 当 newStart === oldEnd 的时候 * 说明该节点所对应的真实 DOM 原本是最后一个子节点，并且更新之后它应该变成第一个子节点 * 所以我们需要把该节点所对应的真实 DOM 移动到最前方即可，所以我们的操作如下 * * 1. 先调用 patch 函数完成更新 * 2. 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点 * 3. 更新索引，指向下一个位置 */ patch(oldEndVNode, newStartVNode, container) container.insertBefore(oldEndVNode.el, oldStartVNode.el) oldEndVNode = prevChildren[--oldEndIdx] newStartVNode = nextChildren[++newStartIdx] }} 如上，在经过循环对比之后，我们可以发现真实的 DOM 的顺序已经与新 children 中节点的顺序保持一致了，也就是说我们圆满的完成了目标，另外观察上述流程可以发现，此时 oldStartIdx 和 newStartIdx 分别比 oldEndIdx 和 newEndIdx 要大，所以这将是最后一轮的比对，循环将终止，以上就是双端比较的核心原理 非理想情况在之前的讲解中，我们所采用的是较理想的例子，换句话说，在每一轮的比对过程中，总会满足四个步骤中的一步，但实际上大多数情况下并不会这么理想，如下图所示，在上面的每一步对比当中，都无法找到可复用的节点，在这种情况下，我们只能拿新 children 中的第一个节点尝试去旧 children 中寻找，试图找到拥有相同 key 值的节点 12345678910111213141516while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (oldStartVNode.key === newStartVNode.key) { // ... } else if (oldEndVNode.key === newEndVNode.key) { // ... } else if (oldStartVNode.key === newEndVNode.key) { // ... } else if (oldEndVNode.key === newStartVNode.key) { // ... } else { // 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素 const idxInOld = prevChildren.findIndex( node =&gt; node.key === newStartVNode.key ) }} 这里的关键点并不在于我们找到了位置索引，而是要明白，当我们在旧的 children 中找到了与新 children 中第一个节点拥有相同 key 值的节点，这就意味着旧 children 中的这个节点所对应的真实 DOM 在新 children 的顺序中，已经变成了第一个节点，所以我们需要把该节点所对应的真实 DOM 移动到最前头 12345678910111213141516171819202122232425262728while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (oldStartVNode.key === newStartVNode.key) { // ... } else if (oldEndVNode.key === newEndVNode.key) { // ... } else if (oldStartVNode.key === newEndVNode.key) { // ... } else if (oldEndVNode.key === newStartVNode.key) { // ... } else { // 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素 const idxInOld = prevChildren.findIndex( node =&gt; node.key === newStartVNode.key ) if (idxInOld &gt;= 0) { // vnodeToMove 就是在旧 children 中找到的节点，该节点所对应的真实 DOM 应该被移动到最前面 const vnodeToMove = prevChildren[idxInOld] // 调用 patch 函数完成更新 patch(vnodeToMove, newStartVNode, container) // 把 vnodeToMove.el 移动到最前面，即 oldStartVNode.el 的前面 container.insertBefore(vnodeToMove.el, oldStartVNode.el) // 由于旧 children 中该位置的节点所对应的真实 DOM 已经被移动，所以将其设置为 undefined（这是很关键的一步） prevChildren[idxInOld] = undefined } // 将 newStartIdx 下移一位，准备进行下一轮的比较 newStartVNode = nextChildren[++newStartIdx] }} 我们用一张图来描述这个过程结束之后的状态 由于原本旧 children 中的 li-b 节点，此时已经变成了 undefined，所以在后续的比对过程中 oldStartIdx 或 oldEndIdx 二者当中总会有一个位置索引优先达到这个位置，也就是说此时 oldStartVNode 或 oldEndVNode 两者之一可能是 undefined，这说明该位置的元素在之前的比对中被移动到别的位置了，所以不再需要处理该位置的节点，这时我们需要跳过这一位置 12345678910while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (!oldStartVNode) { oldStartVNode = prevChildren[++oldStartIdx] } else if (!oldEndVNode) { oldEndVNode = prevChildren[--oldEndIdx] } else if (oldStartVNode.key === newStartVNode.key) { // ... } // ...} 当 oldStartVNode 或 oldEndVNode 不存在时，说明该节点已经被移动了，我们只需要跳过该位置即可，以上就是我们所说的双端比较的非理想情况的处理方式 添加新元素在上一小节中，我们尝试拿着新 children 中的第一个节点去旧 children 中寻找与之拥有相同 key 值的可复用节点，然后并非总是能够找得到，当新的 children 中拥有全新的节点时，就会出现找不到的情况 由于 li-d 节点的位置索引是 newStartIdx，这说明 li-d 节点是当前这一轮比较中的当前索引范围内的第一个节点，所以只要把它挂载到位于 oldStartIdx 位置的节点所对应的真实 DOM 前面就可以了，即 oldStartVNode.el，只需要增加一行代码即可 1234567891011121314151617while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (!oldStartVNode) { oldStartVNode = prevChildren[++oldStartIdx] } // ... else { if (idxInOld &gt;= 0) { // ... } else { // 使用 mount 函数挂载新节点 mount(newStartVNode, container, false, oldStartVNode.el) } newStartVNode = nextChildren[++newStartIdx] }} 我们再来看下面这种情况 在上图最后一种情况当中，此时 oldEndIdx 的值将变成 -1，它要小于 oldStartIdx 的值，这时循环的条件不在满足，意味着更新完成，然而通过上图可以很容易的发现 li-d 节点被遗漏了，所以我们需要在循环终止之后，对 oldEndIdx 和 oldStartIdx 的值再次进行检查 如果在循环结束之后 oldEndIdx 的值小于 oldStartIdx 的值则说明新的 children 中『存在还没有被处理的全新节点』，这时我们应该调用 mount 函数将其挂载到容器元素中 123456789while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { // ...}if (oldEndIdx &lt; oldStartIdx) { // 添加新节点 for (let i = newStartIdx; i &lt;= newEndIdx; i++) { mount(nextChildren[i], container, false, oldStartVNode.el) }} 这样我们就完整的实现了完整的添加新节点的功能 移除不存在的元素对于双端比较，最后一个需要考虑的情况就是当有元素被移除时的情况 通过上图可以发现，在循环结束之后，并不满足条件 oldEndIdx &lt; oldStartIdx 而是满足条件 newEndIdx &lt; newStartIdx，基于此，我们可以认为循环结束后，一旦满足条件 newEndIdx &lt; newStartId 则说明有元素需要被移除 1234567891011121314while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { // 省略...}if (oldEndIdx &lt; oldStartIdx) { // 添加新节点 for (let i = newStartIdx; i &lt;= newEndIdx; i++) { mount(nextChildren[i], container, false, oldStartVNode.el) }} else if (newEndIdx &lt; newStartIdx) { // 移除操作 for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) { container.removeChild(prevChildren[i].el) }} 以上就是相对完整的双端比较算法的实现，这是 Vue2 所采用的算法，借鉴于开源项目 snabbdom inferno 当中的 Diff 算法在 Vue3 中采用了另外一种 diff 算法，它借鉴于 ivi 和 inferno，在 DOM 操作的各个方面，ivi 和 inferno 都要稍优于 vue2 的双端比较，例如在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 diff 算法，才使得性能上产生一定的优势，本节我们就来看看这个算法的实现原理 相同的前置和后置元素实际上本节介绍的 diff 算法最早应用于两个不同文本之间的差异比较，在真正进行核心的 diff 算法之前，会有一个预处理的过程，例如可以先对两个文本进行类似相等的比较，比如我们有两段文本，如下 12text1: I use vue for app developmenttext2: I use react for app development 我们通过肉眼可以很容易的发现，这两段文本头部和尾部分别有一段相同的文本，所以真正需要进行 diff 的部分就变成了 12text1: vuetext2: react 这么做的好处是：在某些情况下，我们能够轻松的判断出单独的文本插入和删除，比如 12345678text1: I like reacttext2: I like react too// ==&gt; 实际上text1:text2: too 又或者是下面这种 12345678text1: I like react tootext2: I like react // ==&gt; 实际上text1: tootext2: 很显然，该预处理过程在上例的情况下能够避免 diff 算法的执行，从而提高 diff 效率，我们来尝试着将其应用到我们 VNode 的 diff 中，总共分为四个阶段，流程如下 如上图第一部分所示，新旧 children 拥有相同的前缀节点和后缀节点，对于前缀节点，我们可以建立一个索引，指向新旧 children 中的第一个节点，并逐步向后遍历，直到遇到两个拥有不同 key 值的节点为止 12345678910111213// 更新相同的前缀节点// j 为指向新旧 children 中第一个节点的索引let j = 0let prevVNode = prevChildren[j]let nextVNode = nextChildren[j]// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止while (prevVNode.key === nextVNode.key) { // 调用 patch 函数更新 patch(prevVNode, nextVNode, container) j++ prevVNode = prevChildren[j] nextVNode = nextChildren[j]} 操作完成的状态如上图第二部分所示，这里有一个需要注意的地方就是，当 while 循环终止时，索引 j 的值为 1，接着我们需要处理的是相同的后缀节点，由于新旧 children 中节点的数量可能不同，所以我们需要两个索引分别指向新旧 children 的最后一个节点，并逐步向前遍历，直到遇到两个拥有不同 key 值的节点为止 12345678910111213141516171819// 更新相同的后缀节点// 指向旧 children 最后一个节点的索引let prevEnd = prevChildren.length - 1// 指向新 children 最后一个节点的索引let nextEnd = nextChildren.length - 1prevVNode = prevChildren[prevEnd]nextVNode = nextChildren[nextEnd]// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止while (prevVNode.key === nextVNode.key) { // 调用 patch 函数更新 patch(prevVNode, nextVNode, container) prevEnd-- nextEnd-- prevVNode = prevChildren[prevEnd] nextVNode = nextChildren[nextEnd]} 该步操作完成以后为上图第三部分所示，同样需要注意的是，在这一步更新完成之后 prevEnd 的值为 0，nextEnd 的值为 1，现在，我们就着重的来看看这三个字段的值 123j: 1prevEnd: 0nextEnd: 1 我们发现在这种情况下 j &gt; prevEnd 并且 j &lt;= nextEnd，这说明当新旧 children 中相同的前缀和后缀被更新之后，旧 children 中的节点已经被更新完毕了，而新 children 中仍然有剩余节点 实际上新 children 中位于 j 到 nextEnd 之间的所有节点都应该是新插入的节点（上图最后一部分），观察得知，新的节点都出现在 li-b 节点的前面，而我们又可以使用 nextEnd + 1 来表示 li-b 节点的位置，所以我们可以使用一个循环遍历索引 j -&gt; nextEnd 之间的节点，并逐个将其插入到 li-b 节点之前即可 1234567891011// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入if (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) { // 所有新节点应该插入到位于 nextPos 位置的节点的前面 const nextPos = nextEnd + 1 const refNode = nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null // 采用 while 循环，调用 mount 函数挂载节点 while (j &lt;= nextEnd) { mount(nextChildren[j++], container, false, refNode) }} 同样的，我们在来看下面这个反过来的示例，分为两个阶段 在我们去掉意义上相同的后缀之后，也同样可以得到三个值 123j: 1prevEnd: 1nextEnd: 0 我们发现在这种情况下 j &gt; nextEnd 并且 j &lt;= prevEnd，这就说明在旧 children 中有位于索引 j 到 prevEnd 之间的节点，都应该被移除 1234567891011121314if (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) { // j -&gt; nextEnd 之间的节点应该被添加 const nextPos = nextEnd + 1 const refNode = nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null while (j &lt;= nextEnd) { mount(nextChildren[j++], container, false, refNode) }} else if (j &gt; nextEnd) { // j -&gt; prevEnd 之间的节点应该被移除 while (j &lt;= prevEnd) { container.removeChild(prevChildren[j++].el) }} 我们可以来观察一下以上的代码结构 12345678910111213141516171819202122232425// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止while (prevVNode.key === nextVNode.key) { // 调用 patch 函数更新 // ... j++ // ...}// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止while (prevVNode.key === nextVNode.key) { // 调用 patch 函数更新 // ... prevEnd-- nextEnd-- // ...}// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入if (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) { // j -&gt; nextEnd 之间的节点应该被添加 // ...} else if (j &gt; nextEnd) { // j -&gt; prevEnd 之间的节点应该被移除 // ...} 我们发现在两个 while 循环中，索引 j 和 索引 prevEnd、nextEnd 是以从两端向中间靠拢的趋势在变化的，而在两个 while 循环结束之后，我们会根据这三个索引的大小关系来决定应该做什么样的操作 但是我们可以发现，假设在第一个 while 循环结束之后，索引 j 的值已经大于 prevEnd 或 nextEnd，那么就已经没有必要再去执行第二个 while 循环了，因为一旦索引 j 大于 prevEnd 则说明旧 children 与新 children 中的所有节点都已经参与了 patch，这时也就没有必要再执行后续的操作了 123456789101112131415161718192021222324outer: { while (prevVNode.key === nextVNode.key) { patch(prevVNode, nextVNode, container) j++ if (j &gt; prevEnd || j &gt; nextEnd) { break outer } prevVNode = prevChildren[j] nextVNode = nextChildren[j] } // 更新相同的后缀节点 prevVNode = prevChildren[prevEnd] nextVNode = nextChildren[nextEnd] while (prevVNode.key === nextVNode.key) { patch(prevVNode, nextVNode, container) prevEnd-- nextEnd-- if (j &gt; prevEnd || j &gt; nextEnd) { break outer } prevVNode = prevChildren[prevEnd] nextVNode = nextChildren[nextEnd] }} 我们定义了 label 名字为 outer 的 label 语句块，并分别在两个 while 循环中添加了判断语句，无论在哪个循环中，只要索引 j 的值大于了 prevEnd 或 nextEnd 二者之一，我们就 break 该语句块，从而避免了无用的代码执行 判断是否需要进行 DOM 移动其实在上文部分，我们通过判断索引的大小关系，能够提前知道哪些元素被添加，哪些元素被移除，但这毕竟属于一种特殊情况，大部分情况下可能未必如此理想，如下图当中第一部分所示 实际上无论是 React 的 diff 算法，还是 snabbdom 的 diff 算法，其重点无非就是，判断是否有节点需要移动，以及应该如何移动和寻找出那些需要被添加或移除的节点，所以接下来，我们就来看看如何判断那些节点需要移动，以及如何移动 通过观察上图当中第二部分逻辑，我们会发现，此时索引 j 既不大于 prevEnd 也不大于 nextEnd，所以我们需要添加新的判断来处理这种情况，在这种情况之下，我们需要构造一个数组 source，该数组的长度等于新 children 在经过预处理之后剩余未处理节点的数量，并且该数组中每个元素的初始值为 -1，如上图第三部分所示 该数组中的每一个元素分别与新 children 中剩余未处理的节点对应，实际上 source 数组将用来存储新 children 中的节点在旧 children 中的位置，后面将会使用它计算出一个最长递增子序列，并用于 DOM 移动，如上图第四部分所示，我们可以通过两层 for 循环来完成这个工作，外层循环用于遍历旧 children，内层循环用于遍历新 children，完成后代码如下 但是这里存在一个小问题，我们使用了双层 for 循环，所以其时间复杂度为 O(n^2)，在这里我们可以采用『空间换时间的方式』，将复杂度降低到 O(n)，所以我们为新的 children 中的节点构建一个 key 到位置索引的索引表，如上图最后一部分所示，其实无论采用哪一种方式，最终我们的目的是对新旧 children 中具有相同 key 值的节点进行更新，同时检测是否需要移动操作 这里需要注意，我们可以从图中看到，我们的 source 数组的第四个元素值仍然为初始值 -1，这是因为新 children 中的 li-g 节点不存在于旧 children 中 综合后的代码如下所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 基本逻辑如下 * 我们在外层循环逐个从旧 children 中取出未处理的节点，并尝试在新 children 中寻找拥有相同 key 值的可复用节点 * 一旦找到了可复用节点，则调用 patch 函数更新之 */// 构造 source 数组const nextLeft = nextEnd - j + 1 // 新 children 中剩余未处理节点的数量const source = []for (let i = 0; i &lt; nextLeft; i++) { source.push(-1)}const prevStart = jconst nextStart = jlet moved = falselet pos = 0// 构建索引表// Index Map 中的键是节点的 key，值是节点在新 children 中的位置索引// 可以使得我们能够非常快速的定位旧 children 中的节点在新 children 中的位置const keyIndex = {}for (let i = nextStart; i &lt;= nextEnd; i++) { keyIndex[nextChildren[i].key] = i}// 我们还需要一个数量标识，用来代表已经更新过的节点的数量// 我们知道，已经更新过的节点数量应该小于新 children 中需要更新的节点数量// 一旦更新过的节点数量超过了新 children 中需要更新的节点数量，则说明该节点是多余的节点，我们也应该将其移除let patched = 0// 遍历旧 children 的剩余未处理节点for (let i = prevStart; i &lt;= prevEnd; i++) { prevVNode = prevChildren[i] if (patched &lt; nextLeft) { // 通过索引表快速找到新 children 中具有相同 key 的节点的位置 const k = keyIndex[prevVNode.key] /** * 我们试图拿旧 children 中的节点尝试去新 children 中寻找具有相同 key 值的节点，但并非总是能够找得到 * 当 k === 'undefined' 时，说明该节点在新 children 中已经不存在了，这时我们应该将其移除 */ if (typeof k !== 'undefined') { nextVNode = nextChildren[k] // patch 更新 patch(prevVNode, nextVNode, container) // 变量 patched 将作为数量标识，它的初始值为 0，只有当条件 patched &lt; nextLeft 不成立时 // 说明该节点已经不存在与新 children 中了，是一个多余的节点，于是我们将其移除 patched++ /** * 这里需要注意的是，由于 k - nextStart 的值才是正确的位置索引，而非 k 本身，并且外层循环中变量 i 的值就代表了该节点在旧 children 中的位置 * 所以直接将 i 赋值给 source[k - nextStart] 即可达到目的 */ // 更新 source 数组 source[k - nextStart] = i /** * 这里采用类似 react 的方式 * 变量 k 代表我们在遍历新 children 中遇到的节点的位置索引，变量 pos 用来存储遇到的位置索引的最大值 * 一旦发现后来遇到索引比之前遇到的索引要小，即 k &lt; pos，则说明需要移动操作，这时我们更新变量 moved 的值为 true */ // 判断是否需要移动 if (k &lt; pos) { moved = true } else { pos = k } } else { // 没找到，说明旧节点在新 children 中已经不存在了，应该移除 container.removeChild(prevVNode.el) } } else { // 多余的节点，应该移除 container.removeChild(prevVNode.el) }} DOM 移动的方式在上一小节，我们的主要目的有两个 判断出是否需要进行 DOM 移动操作，所以我们建立了 moved 变量作为标识，当它的值为 true 时则说明需要进行 DOM 移动 构建 source 数组，它的长度与去掉相同的前置或者后置节点后新 children 中剩余未处理节点的数量相等，并存储着新 children 中的节点在旧 children 中位置，后面我们会根据 source 数组计算出一个最长递增子序列，并用于 DOM 移动操作 关于最长递增子序列可见 求解给定序列的最长递增子序列，这里就不详细展开了 可以如上面小结当中最后一步流程所示，现在我们已经可以通过判断变量 moved 的值来确定是否需要进行 DOM 移动操作 12345if (moved) { // 如果 moved 为真，则需要进行 DOM 移动操作 // 调用 lis 函数求出数组 source 的最长递增子序列为 [ 0, 1 ] const seq = lis(sources) // [ 0, 1 ]} 实现流程如下图所示 我们对新 children 中的剩余未处理节点进行了重新编号，li-c 节点的位置是 0，以此类推，而最长递增子序列是 [ 0, 1 ]（代表的是最长递增子序列中的各个元素在 source 数组中的位置索引），这就说明 在新 children 的剩余未处理节点中，位于位置 0 和位置 1 的节点的先后关系与他们在旧 children 中的先后关系相同，或者我们可以理解为位于位置 0 和位置 1 的节点是不需要被移动的节点 简单总结就是，通过最长递增子序列，我们可以在上图第一部分当中得到如下信息 li-c 节点和 li-d 节点将在接下来的操作中不会被移动 换句话说只有 li-b 节点和 li-g 节点是可能被移动的节点 又因 li-g 节点位置对应的 source 数组元素的值为 -1，这说明应该作为全新的节点被挂载 所以只有 li-b 节点需要被移动 所以，如图中第二部分所示，我们使用两个索引 i 和 j 分别指向新 children 中剩余未处理节点的最后一个节点和最长递增子序列数组中的最后一个位置，并从后向前遍历，结合上图，我们可以得到如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657if (moved) { const seq = lis(source) // j 指向最长递增子序列的最后一个值 let j = seq.length - 1 /** * 变量 j 指向最长递增子序列的最后一个位置，使用 for 循环从后向前遍历新 children 中剩余未处理的子节点 * 这里的技巧在于 i 的值的范围是 0 到 nextLeft - 1，这实际上就等价于我们对剩余节点进行了重新编号 */ // 从后向前遍历新 children 中的剩余未处理节点 for (let i = nextLeft - 1; i &gt;= 0; i--) { /** * 判断当前节点的位置索引值 i 是否与子序列中位于 j 位置的值相等，总的来说分为三种情况 * 1. 如果 source[i] === -1，应该作为全新的节点挂载 * 2. 如果 i !== seq[j]，如果不相等，则说明该节点需要被移动 * 3. 如果 i === seq[j]，相等则说明该节点不需要被移动，并让 j 指向下一个位置 */ if (source[i] === -1) { // 作为全新的节点挂载 // 该节点在新 children 中的真实位置索引 const pos = i + nextStart const nextVNode = nextChildren[pos] // 该节点下一个节点的位置索引 const nextPos = pos + 1 // 挂载 mount( nextVNode, container, false, nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null ) } else if (i !== seq[j]) { // 说明该节点需要移动 // 为了将节点挂载到正确的位置，我们需要找到当前节点的真实位置索引 // 该节点在新 children 中的真实位置索引 const pos = i + nextStart const nextVNode = nextChildren[pos] // 以及当前节点的后一个节点，并挂载该节点的前面即可 const nextPos = pos + 1 // 移动 container.insertBefore( nextVNode.el, nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : null ) } else { // 当 i === seq[j] 时，说明该位置的节点不需要移动 // 并让 j 指向下一个位置 j-- } }} 参考如果想了解更多的相关内容，可以参考以下链接 深度剖析如何实现一个 Virtual DOM 算法 Diff Strategies React 源码深度解读 Vitual DOM 的内部工作原理 深入理解 React 中的虚拟 DOM 和 Diff 算法 解析 Snabbdom 源码 React 源码剖析系列 － 不可思议的 React Diff React Diff 算法 A Survey on Tree Edit Distance and Related（这一篇是介绍标准的 Diff 算法，其复杂度为 O(n ^ 3)）","link":"/2019/12/22/React/08/"},{"title":"深入 React Fiber","text":"我们都知道，React 是一个用于构建用户交互界面的 JavaScript 库，其核心机制就是跟踪组件的状态变化，并将更新的状态映射到到新的界面，在 React 中，我们将此过程称之为『协调』（Reconcilation），我们调用 setState 方法来改变状态，而框架本身会去检查 state 或 props 是否已经更改来决定是否重新渲染组件，React 的官方文档对 协调机制 进行了良好的抽象描述，即 React 的元素、生命周期、render 方法，以及应用于组件子元素的 Diffing 算法综合起到的作用，就是『协调』 我们将从 render 方法返回的不可变的 React 元素通常称为『虚拟 DOM』，但是除了『虚拟 DOM』之外，React 框架总是在内部维护一个实例来持有状态（如组件、DOM 节点等），从版本 16 开始，React 推出了新的内部实例树的实现方法，也就是我们经常听闻的 Fiber 算法，但是在本章当中我们并不会太过深入的去介绍源码相关内容，而是主要来探索一下这个所谓的 Fiber 到底是什么以及它出现的缘由和解决的一些问题 存在的问题之所以会推出新的 Fiber，那就说明在之前的 React 版本当中是存在一定的问题的，那么下面我们就来先看看之前的版本当中到底是存在哪些问题，这个我们可以从官方提供的 示例 开始看起，运行效果如下 至于根本原因，我们可以通过查看其对应的 源码 来分析具体原因，通过观察源码我们可以发现，代码当中使用了 requestAnimationFrame 这个 API，关于 requestAnimationFrame 这个接口的使用我们就不介绍更多内容了，直接来看代码的实现，详细可以参考之前我们整理过的 requestAnimationFrame 的使用 以及 并发模型中的 requestAnimationFrame 1234567891011var start = new Date().getTime()function update() { ReactDOM.render( &lt;ExampleApplication elapsed={new Date().getTime() - start} /&gt;, document.getElementById('container') ) requestAnimationFrame(update)}requestAnimationFrame(update) 另外，为了每秒更新一次圆点中的数字，ExampleApplication 组件维护了一个 seconds 状态，使用 setInterval 每秒更新一次 123456789componentDidMount() { this.intervalID = setInterval(this.tick, 1000)}tick() { this.setState(state =&gt; ({ seconds: (state.seconds % 10) + 1 }))} 以上效果之所以会卡顿，究其原因，对绝大多的浏览器来说，它的页面刷新频率取决于显示器的刷新频率，比如一台刷新频率是 60FPS 的显示器，requestAnimationFrame 会每 16.66ms（1000ms / 60）执行一次回调函数，但为了给主线程时间处理其他事务，一般要求产出一帧画面的时间不要超过 10ms，所以 requestAnimationFrame 的执行频率不会比显示器更高，但有可能更低 默认情况下，JavaSceipr 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系，如果 JavaSceipr 运算持续占用主线程，页面就没法得到及时的更新，当我们调用 setState 更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI，整个过程是一气呵成，不能被打断的，如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，这是就容易出现掉帧的现象，也就是说，其根本原因是因为大量的同步计算任务阻塞了浏览器的 UI 渲染 而 React 的 Reconcilation 是 CPU 密集型的操作，旧版 React 通过『递归』的方式进行渲染，使用的是 JavaSceipr 引擎自身的函数调用栈，它会一直执行到栈空为止，也就是比对 Virtual DOM 树，找出需要变动的节点，然后同步更新它们，这个过程 React 称为 Reconcilation（协调） 而 React 团队使用 Fiber 实现了自己的组件调用栈以后，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务，基本思路是将运算切割为多个步骤，分批完成，也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染，等浏览器忙完之后，再继续之前未完成的任务，所以使用 Fiber 架构的目的是让 Reconcilation 过程变成『可被中断』，适时地让出 CPU 执行权，让浏览器及时地响应用户的交互 如下就是优化后的效果，我们可以明显感觉到，示例运行起来会比之前看上去流畅许多 协调（Reconciliation）我们都知道，React 的核心是定义组件，渲染组件的方式则是由环境所决定（比如 React Native），定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，而这部分内容统一由 协调器（Reconciler） 处理，不同渲染器都会使用该模块，协调器主要作用就是在组件状态变更时，调用组件树各组件的 render 方法，渲染，卸载组件 Stack Reconciler我们知道浏览器渲染引擎是单线程的，在上面章节当中我们也提到过，在 React 之前的版本当中，计算组件树变更时将会阻塞整个线程，整个渲染过程是连续不中断完成的，而这时的其他任务都会被阻塞，如动画等，这可能会使用户感觉到明显卡顿，这个版本的协调器可以称为『栈协调器』（Stack Reconciler），其协调算法的大致实现过程可以参考官方文档中的 React Stack Reconciler Stack Reconcilier 的主要缺陷就是不能暂停渲染任务，也不能切分任务，无法有效平衡组件更新渲染与动画相关任务间的执行顺序，即不能划分任务优先级，有可能导致重要任务卡顿，动画掉帧等问题 Fiber Reconciler而 React 16 版本提出了一个更为先进的协调器，它允许渲染进程分段完成，而不必须一次性完成，中间可以返回至主进程控制执行其他任务，而这是通过计算部分组件树的变更，并暂停渲染更新，询问主进程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后才开始渲染 这一切的实现是在代码层引入了一个新的数据结构，也就是我们的 Fiber 对象，每一个组件实例对应有一个 Fiber 实例，此 Fiber 实例负责管理组件实例的更新，渲染任务及与其他 Fiber 实例的联系，这个新推出的协调器就叫做『纤维协调器』（Fiber Reconciler），它提供的新功能主要有下面这些 可切分，可中断任务 可重用各分阶段任务，且可以设置优先级 可以在父子组件任务间前进后退切换任务 render 方法可以返回多元素（即可以返回数组） 支持异常边界处理异常 下面就让我们来深入的了解一下，到底什么是 Fiber 什么是 Fiber那么什么是 Fiber 呢？其实 Fiber 是一种流程控制原语，它是一个非常底层的抽象描述，我们可以称其 协程 或者『纤程』，但是需要注意的是，协程和『线程』并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制，这里我们可以对比普通函数和 Generator 的运行方式，普通函数执行的过程中无法被中断和恢复，如下 12345678const tasks = []function run() { let task while (task = tasks.shift()) { execute(task) }} 而 Generator 却是可以的 1234567891011const tasks = []function* run() { let task while (task = tasks.shift()) { if (hasHighPriorityEvent()) { // 判断是否有高优先级事件需要处理，有的话让出控制权 yield } execute(task) // 处理完高优先级事件后，恢复函数调用栈，继续执行 }} 所以我们可以发现，其实 React Fiber 的思想和协程的概念是契合的，也就是说 React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染，那么这里你可能会有一个疑问，那就是 React 是如何将控制权交回浏览器的呢？其实浏览器并没有抢占的条件，通常来说是 React 主动让出机制，这是因为 一来浏览器中没有类似进程的概念，任务之间的界限很模糊，没有上下文，所以不具备中断或是恢复的条件 二则是没有抢占的机制，我们无法中断一个正在执行的程序，所以我们只能采用类似协程这样控制权让出机制 观察我们上面的代码，其实上面代码示例中的 hasHighPriorityEvent() 在目前浏览器中是无法实现的，因为我们没办法判断当前是否有更高优先级的任务等待被执行，从而让其让出机制，所以我们只能换一种思路，也就是通过『超时检查的机制』来让出控制权，即确定一个合理的运行时长，然后在合适的检查点检测是否超时（比如每执行一个小任务），如果超时就停止执行，将控制权交换给浏览器，而这个方式的实现主要依赖的是浏览器提供的 requestIdleCallback 这个 API 1234window.requestIdleCallback( callback: (dealine: IdleDeadline) =&gt; void, option?: {timeout: number}) IdleDeadline 的接口如下 1234interface IdleDealine { didTimeout: boolean // 表示任务执行是否超过约定时间 timeRemaining(): DOMHighResTimeStamp // 任务可供执行的剩余时间} 单从名字上理解的话，requestIdleCallback 的意思是让浏览器在有空的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行，为了不耽误事，我们最好在这个时间范围内执行完毕，现在我们知道了如何让出机制，那么浏览器什么时候有空呢？我们先来看一下浏览器在一帧（Frame，可以认为事件循环的一次循环）内可能会做什么事情，通常来说可能会做执行下列任务，而且它们的执行顺序基本是固定的 处理用户输入事件 JavaScript 执行 requestAnimation 调用 布局 Layout 绘制 Paint 通常，客户端线程执行任务时会以帧的形式划分，大部分设备控制在 30-60 帧是不会影响用户体验，在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback 可以在这个『空闲期』（Idle Period）调用『空闲期回调』（Idle Callback）执行一些任务 但是在浏览器繁忙的时候，可能不会有盈余时间，这时候 requestIdleCallback 回调可能就不会被执行，所以在这种情况下可以通过 requestIdleCallback 的第二个参数指定一个超时时间 另外不建议在 requestIdleCallback 中进行 DOM 操作，因为这可能导致样式重新计算或重新布局（比如操作 DOM 后马上调用 getBoundingClientRect()），这些时间很难预估的，很有可能导致回调执行超时，从而掉帧 但是这个超时时间不是死的，低优先级的可以慢慢等待，高优先级的任务应该率先被执行，目前 React 预定义了五个优先级 Immediate（-1），这个优先级的任务会同步执行，或者说要马上执行且不能中断 UserBlocking（250ms），这些任务一般是用户交互的结果，需要即时得到反馈 Normal（5s），应对哪些不需要立即感受到的任务，例如网络请求 Low（10s），这些任务可以放后，但是最终应该得到执行，例如分析通知 Idle（没有超时时间），一些没有必要做的任务（比如隐藏的内容） 但是目前 requestIdleCallback 只有 Chrome 支持，所以为了支持其它浏览器，React 干脆自己 实现 了一个，它是利用 MessageChannel 模拟将回调延迟到绘制操作之后执行，如下图 看到这里你可能会问，我们在上面提到过，使用 Generator 函数也是可以控制函数的执行流程，那么为什么官方不直接采用 Generator 的实现方式呢？关于这一点的原因，可以参考官方在 Fiber Principles: Contributing To Fiber 当中的回答，这里我们就不详细展开了 其实我们上面介绍那么多，如果简单的理解的话，我们可以把 Fiber 认为是一种数据结构或者说执行单元（会在下面进行介绍），我们将它视作一个执行单元，每次执行完一个执行单元，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，React 没有使用 Generator 这种让出机制，而是实现了自己的调度让出机制，这个机制就是基于 Fiber 这个执行单元的 简单总结一下就是 React 应用中的基础单元是组件，应用以组件树形式组织，渲染组件 Fiber 协调器基础单元则是协调单元（协调器算法组成单元），应用以 Fiber 树形式组织，应用 Fiber 算法 组件树和 Fiber 树结构对应，一个组件实例有一个对应的 Fiber 实例 Fiber 协调器算法负责整个应用层面的协调，而 Fiber 实例则负责对应组件的协调 下面我们就来看看从 React 元素到 Fiber 节点是如何转化的，也就是 React 为 Fiber 架构做了哪些改造 Fiber 节点我们都知道，React 元素并非真实的 DOM 节点或组件实例，而是一种描述方式，用于描述 DOM 元素的类型、拥有的属性以及包含的子元素，这也正是 React 的核心所在，React 将构建、渲染以及管理真实 DOM 树生命周期这些复杂的逻辑进行了抽象，从而避免了我们直接操作真实 DOM 而引起的巨大性能消耗 在协调期间，从 render 方法返回的每个 React 元素的数据都会被合并到 Fiber 节点树中，每个 React 元素都有一个相应的 Fiber 节点，与 React 元素不同，不会在每次渲染时重新创建这些 Fiber ，这些是持有组件状态和 DOM 的可变数据结构 因此，这意味着当我们调用 ReactDOM.render() 或 setState() 时，React 将执行协调，在 setState 的情况下，它执行遍历并通过将新树与已渲染的树进行区分来找出树中发生了什么变化，然后将这些更改应用于当前树，从而更新与 setState() 调用相关的 state 我们在之前提到过，旧版 React 是通过『递归』的方式进行渲染的，也就是说这是基于函数调用栈的协调算法，只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复，不利于异步处理，这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始，恢复到之前的调用栈，所以针对于这种情况就需要对 React 现有的数据结构进行调整，模拟函数调用栈，将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代 React 目前的做法是使用链表，每个 VirtualDOM 节点内部现在使用 Fiber 表示，它的结构大概如下 1234567export type Fiber = { type: any, // Fiber 类型信息 return: Fiber | null, // 链表结构，指向父节点，或者 render 该节点的组件 child: Fiber | null, // 指向第一个子节点 sibling: Fiber | null, // 指向下一个兄弟节点 // ...} 用图片来展示这种关系会更直观一些 因为 React 为每个 React 元素创建一个 Fiber 节点，并且因为我们有一个这些元素组成的树，所以我们可以得到一个 Fiber 节点树，所有 Fiber 节点都通过链表连接，具体是使用 Fiber 节点上的 child、sibling 和 return 属性，至于它为什么以这种方式工作，可以参考 如何以及为什么 React Fiber 使用链表遍历组件树 这篇文章，这里我们就不详细展开了 下面我们来深入的了解一下 Fiber 当中的节点类型，它们有以下这些 12345678910111213141516171819202122232425262728293031323334export type Fiber = { // 节点的类型信息 tag: WorkTag, // 标记 Fiber 类型，例如函数组件、类组件、宿主组件 type: any, // 节点元素类型，对应的 function/class/module 类型组件名 // 树结构相关信息 return: Fiber | null, // 处理完当前 fiber 后返回的 fiber，通常返回当前 fiber 所在 fiber 树的父级 fiber 实例 child: Fiber | null, sibling: Fiber | null, key: null | string, // 子节点的唯一键，即我们渲染列表传入的 key 属性 // 节点实例的状态 // 对于宿主组件，这里保存宿主组件的实例，例如 DOM 节点 // 对于类组件来说，这里保存类组件的实例 // 对于函数组件说，这里为空，因为函数组件没有实例 stateNode: any, // 所在组件树的根组件 FiberRoot 对象 pendingProps: any, // 当前处理过程中的组件 props 对象 memoizedProps: any, // 缓存的之前组件 props 对象 memoizedState: any, // 上一次渲染的组件状态 // 副作用 effectTag: SideEffectTag, // 当前节点的副作用类型，例如节点更新、删除、移动 nextEffect: Fiber | null, // 和节点关系一样，React 同样使用链表来将所有有副作用的 Fiber 连接起来 // fiber 的版本池，即记录 fiber 更新过程，便于恢复 alternate: Fiber | null, // 组件状态更新及对应回调函数的存储队列 updateQueue: UpdateQueue&lt;any&gt; | null, // 描述当前 fiber 实例及其子 fiber 树的数位，如 AsyncUpdates 特殊字表示默认以异步形式处理子树 // 一个 fiber 实例创建时，此属性继承自父级 fiber，在创建时也可以修改值，但随后将不可修改 internalContextTag: TypeOfInternalContext,} Fiber 包含的属性可以划分为五个部分 结构信息，上面已经介绍过，Fiber 使用链表的形式来表示节点在树中的定位 节点类型信息，tag 表示节点的分类、type 保存具体的类型值，如 div、MyComp 节点的状态，节点的组件实例 props、state 等，它们将影响组件的输出 副作用，在协调过程中发现的副作用就保存在节点的 effectTag 中（类似打上标记），这里也使用了链表结构，将本次渲染的所有副作用节点都收集起来，通过 nextEffect 连接起来 workInProgress（WIP）树，React 在协调过程中会构建一颗新的树，可以认为是一颗表示当前工作进度的树，还有一颗表示已渲染界面的旧树，React 就是一边和旧树比对，一边构建 WIP 树的， alternate 指向旧树的同等节点 下面我们就来简单的看看各个属性的作用 type 和 keyFiber 的 type 和 key 对 React 元素起着同样的作用（实际上，Fiber 从一个元素创建时，这两个属性直接被复制过来），type 描述了它对应的组件，对于合成组件来说 type 是一个函数或者类组件本身，对于原生元素（div，span 等），它是一个字符串，从概念上来说，type 是在执行时被栈帧追踪的函数（如在 v = f(d) 中） 而与 type 一起的 key，被用来在协调过程中决定 Fiber 是否可以再利用，也就是在协调阶段用来标识 Fiber，以检测是否可重用该 Fiber 实例 child 和 sibling表示当我们在组件上调用 render() 时返回的元素，例如 1234567const Name = (props) =&gt; { return ( &lt;div className=\"name\"&gt; {props.name} &lt;/div&gt; )} &lt;Name&gt; 的子元素是 &lt;div&gt;，因为它返回一个 &lt;div&gt; 元素，而 sibling 字段则对应 render 返回多个孩子节点的情况，如下 123const Name = (props) =&gt; { return ([&lt;Child1 /&gt;, &lt;Child2 /&gt;])} 在上述情况下，&lt;Child1&gt; 和 &lt;Child2&gt; 是父元素 &lt;Name&gt; 的子元素，这两个子元素组成一个单链表，head 指针指向第一个孩子节点，所以在上例中 Parent 的孩子节点是 Child1，Child1 的兄弟节点是 Child2，如果放到函数当中类比的话，可以认为一个子 Fiber 是一个尾调用函数 returnreturn 是当前 Fiber 处理完成后需要返回的 Fiber，从概念上来说它对应栈帧返回的地址，从逻辑上讲，它是返回到父 Fiber 节点，因此可以理解为父 Fiber，如果一个 Fiber 有多个子 Fiber，每个子 Fiber 返回的 Fiber 都是它的父 Fiber，在上面示例中的 Child1 和 Child2 的 return 就是 Parent pendingProps 和 memoizedProps分别表示组件当前传入的及之前的 props，memoizedProps 主要用来存储函数执行结果的值，以便以后可以使用它，从而避免重新计算，pendingProps 表示传递给组件的 props 当传入的 pendingProps 等于 memoizedProps 时，它表示 Fiber 之前的输出可以复用，从而避免不必要的工作 alternate可以理解为一个 Fiber 版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中 Fiber 的更新，因为在组件更新的各阶段，更新前及更新过程中 Fiber 状态并不一致，在需要恢复时（比如冲突），即可使用另一者直接回退至上一版本 Fiber 使用 alternate 属性双向连接一个当前 Fiber 和其 workInProgress，当前 Fiber 实例的 alternate 属性指向其 workInProgress， workInProgress 的 alternate 属性指向当前稳定 Fiber 当前 Fiber 的替换版本是其 workInProgress，workInProgress 的交替版本是当前 Fiber 当 workInProgress 更新一次后，将同步至当前 Fiber，然后继续处理，同步直至任务完成 workInProgress 指向处理过程中的 Fiber，而当前 Fiber 总是维护处理完成的最新版本的 Fiber tag我们先来看看如何创建 Fiber 实例，如下 1234567var createFiber = function ( tag: TypeOfWork, key: null | string, internalContextTag: TypeOfInternalContext,) { return new FiberNode(tag, key, internalContextTag)} 可以发现这里有一个 tag 属性，它主要用来标记 Fiber 类型，而 Fiber 实例是和组件对应的，所以其类型基本上对应于组件类型，主要有以下这些 12345678910111213export type TypeOfWork = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10export const IndeterminateComponent = 0 // 尚不知是类组件还是函数式组件export const FunctionalComponent = 1 // 函数式组件export const ClassComponent = 2 // Class 类组件export const HostRoot = 3 // 组件树根组件，可以嵌套export const HostPortal = 4 // 子树export const HostComponent = 5 // 标准组件，如 div/span 等export const HostText = 6 // 文本export const CallComponent = 7 // 组件调用export const CallHandlerPhase = 8 // 调用组件方法export const ReturnComponent = 9 // placeholder（占位符）export const Fragment = 10 // 片段 stateNode 和 FiberRootFiberRoot 对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的 DOM 容器相关信息 12345678export type FiberRoot = { containerInfo: any, // fiber 节点的容器元素相关信息，通常会直接传入容器元素 current: Fiber, // 当前 fiber 树中激活状态（正在处理）的 fiber 节点 remainingExpirationTime: ExpirationTime, // 此节点剩余的任务到期时间 isReadyForCommit: boolean, // 更新是否可以提交 finishedWork: Fiber | null, // 准备好提交的已处理完成的 workInProgress nextScheduledRoot: FiberRoot | null, // 多组件树 FirberRoot 对象以单链表存储链接，指向下一个需要调度的 FiberRoot} Fiber 架构本小节当中我们尝试来简单的梳理一下 Fiber 架构，但是不会过多的涉及源码，对源码感兴趣的话可以参考 官方仓库 来了解更多 优先级（ExpirationTime VS PriorityLevel）我们已经知道 Fiber 可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？主要有以下两种方式 ExpirationTime Fiber 切分任务并调用 requestIdleCallback 和 requestAnimationFrame，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个 Fiber 实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行 所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段，调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值 PriorityLevel 在 React 15.x 版本中就已经出现了对于任务的优先层级划分 12345678910export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5module.exports = { NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // Needs to complete before the next frame. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.} 相对于 PriorityLevel 的简单层级划分，在 React 16.x 版本中使用的则是 ExpirationTime 的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度 调度器（Scheduler）我们在之前介绍的协调器的主要作用就是在组件状态变更时，调用组件树各组件的 render 方法，渲染，卸载组件，而 Fiber 使得应用可以更好的协调不同任务的执行，协调器内关于高效协调的实现，我们可以称它为调度器（Scheduler） 顾名思义，调度器即调度资源以执行指定任务，React 应用中应用组件的更新与渲染，需要占用系统 CPU 资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成 CPU 这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题 在 React 15.x 版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本 Fiber 算法将在调度器方面进行全面改进，主要的关注点是 合并多次更新，没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费 任务优先级，不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高 推拉式调度，基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便 React 框架层直接进行全局自主调度 下面我们就来简单的了解一下调度器与优先级与任务调度相关内容 调度器与优先级 在 React 的协调算法中，任务由 Fiber 实例描述，所以要划分任务优先级，等效于设置 Fiber 的到期时间（expirationTime），调度器内提供了 computeExpirationForFiber 方法以计算某一个 Fiber 的到期时间 1234567891011121314151617181920212223242526272829function computeExpirationForFiber(fiber) { let expirationTime; if (isWorking) { if (isCommitting) { expirationTime = Sync // 若当前处于任务提交阶段（更新提交至 DOM 渲染）时，设置当前 fiber 到期时间为 Sync，即同步执行模式 } else { expirationTime = nextRenderExpirationTime // 若处于 DOM 渲染阶段时，则需要延迟此 fiber 任务，将 fiber 到期时间设置为下一次 DOM 渲染到期时间 } } else { // 若不在任务执行阶段，则需重新设置 fiber 到期时间 if ( // 若明确设置 useSyncScheduling 且 fiber.internalContextTag 值不等于 AsyncUpdates，则表明是同步模式，设置为 Sync useSyncScheduling &amp;&amp; !(fiber.internalContextTag &amp; AsyncUpdates) ) { expirationTime = Sync // 同步更新，设置为同步标记 } else { // 否则，调用computeAsyncExpiration方法重新计算此fiber的到期时间 expirationTime = computeAsyncExpiration() // 异步更新，计算异步到期时间 } } return expirationTime}// 计算异步任务的到期时间（得到 ExpirationTime 单位的当前时间）function computeAsyncExpiration() { const currentTime = recalculateCurrentTime() // 聚合相似的更新在一起，更新应该在 ~1000ms，最多 1200ms 内完成 const expirationMs = 1000 // 对于每个 fiber 的期望到期时间的增值，最大值为 1000ms const bucketSizeMs = 200 // 到期时间的可接受误差时间 200ms // 返回包含误差时间在内的到期时间 return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs)} 任务调度 React 应用更新时，Fiber 从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的 requestIdleCallback 等 API 执行更新处理，主要调度逻辑是通过 scheduleWork 来实现的 通过 fiber.return 属性，从当前 Fiber 实例层层遍历至组件树根组件 依次对每一个 Fiber 实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间 调用 requestWork 方法开始处理任务，并传入获取的组件树根组件 FiberRoot 对象和任务到期时间 12345678910111213141516171819202122232425262728293031// expirationTime 为期望的任务到期时间function scheduleWork(fiber, expirationTime: ExpirationTime) { return scheduleWorkImpl(fiber, expirationTime, false)}function scheduleWorkImpl(fiber, expirationTime) { let node = fiber while (node !== null) { if (node.expirationTime === NoWork || // 向上遍历至根组件 fiber 实例，并依次更新 expirationTime 到期时间 node.expirationTime &gt; expirationTime ) { node.expirationTime = expirationTime // 若 fiber 实例到期时间大于期望的任务到期时间，则更新 fiber 到期时间 } if (node.alternate !== null) { // 同时更新 alternate fiber 的到期时间 if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime &gt; expirationTime ) { node.alternate.expirationTime = expirationTime // 若 alternate fiber 到期时间大于期望的任务到期时间，则更新 fiber 到期时间 } } if (node.return === null) { // node.return 为空，说明到达组件树顶部 if (node.tag === HostRoot) { const root = node.stateNode // 确保是组件树根组件并获取 FiberRoot 实例 requestWork(root, expirationTime) // 请求处理任务 } else { return } } node = node.return // 获取父级组件 fiber 实例 }} 处理任务的 requestWork 方法实现如下 首先比较任务剩余到期时间和期望的任务到期时间，若大于，则更新值 判断任务期望到期时间（expirationTime），区分同步或异步执行任务 1234567891011121314// 当根节点发生更新时，调度器将调用 requestWork 方法开始任务处理过程function requestWork(root: FiberRoot, expirationTime) { const remainingExpirationTime = root.remainingExpirationTime if (remainingExpirationTime === NoWork || expirationTime &lt; remainingExpirationTime ) { root.remainingExpirationTime = expirationTime // 若任务剩余到期时间大于期望的任务到期时间，则需要更新 } if (expirationTime === Sync) { performWork(Sync, null) // 同步 } else { scheduleCallbackWithExpiration(expirationTime) // 异步 }} 更新队列（UpdateQueue）我们知道如果需要实现组件的异步更新，肯定需要在更新前将更新任务进行存储，然后异步任务开始的时候读取更新并实现组件更新，存储更新任务就需要一个数据结构，最常见的就是栈和队列，Fiber 的实现方式就是队列 Fiber 切分任务为多个任务单元（Work Unit）后，需要划分优先级然后存储在更新队列，随后按优先级进行调度执行，我们知道每一个组件都对应有一个 Fiber 实例，Fiber 实例即负责管理调度组件的任务单元，所以需要为每一个组件 Fiber 实例维护一个更新队列，Fiber 更新队列由 ReactFiberUpdateQueue 模块实现，主要涉及 创建更新队列 添加更新至更新队列 添加更新至 Fiber（即 Fiber 实例对应的更新队列） 处理更新队列中的更新并返回新状态对象 这里我们就简单的了解一下它的数据结构，具体的更新过程就不详细展开了 1234567891011121314151617181920212223242526272829303132// 一个更新对应的数据结构export type Update&lt;State&gt; = { expirationTime: ExpirationTime, partialState: PartialState&lt;any, any&gt;, callback: Callback | null, isReplace: boolean, isForced: boolean, next: Update&lt;State&gt; | null,}// 更新队列，以单链表形式表示并持久化// 调度一个更新任务时，将其添加至当前（current）fiber 和 workInProgress fiber 的更新队列中// 这两个更新队列相互独立但共享同一个持久化数据结构// workInProgress 更新队列通常是 current fiber 更新队列的子集// 发生协调时，更新任务从 workInProgress fiber 更新队列移除// current fiber 内的更新任务则保留，当 workInProgress 中断时可以从 current fiber 恢复// 提交完更新时，workInProgress fiber 就会变成 current fiberexport type UpdateQueue&lt;State&gt; = { // 若存在更早添加至队列的更新未被处理 // 则此已处理的更新并不会从队列中移除（先进先出原则） // 所以需要维护 baseState，代表第一个未处理的更新的基础状态 // 通常这就是队列中的第一个更新，因为在队列首部的已处理更新会被移除 baseState: State, // 同理，需要维护最近的未处理的更新的到期时间 // 即未处理更新中到期时间值最小的 expirationTime: ExpirationTime, first: Update&lt;State&gt; | null, last: Update&lt;State&gt; | null, callbackList: Array&lt;Update&lt;State&gt;&gt; | null, hasForceUpdate: boolean, isInitialized: boolean} 更新器（Updater）调度器协调，调度的任务主要就是执行组件或组件树更新，而这些任务则具体由更新器（Updater）完成，可以说调度器是在整个应用组件树层面掌控全局，而更新器则深入到个更具体的每一个组件内部执行，每一个组件实例化时都会被注入一个更新器，负责协调组件与 React 核心进程的通信，其职责主要可以概括为以下几点 找到组件实例对应的 Fiber 实例 询问调度器当前组件 Fiber 实例的优先级 将更新推入 Fiber 的更新队列 根据优先级调度更新任务 其主要实现以下几个功能 初始化组件实例并为其设置 fibre 实例和更新器 初始化或更新组件实例，根据更新队列计算得到新状态等 调用组件实例生命周期方法，并且调用更新器 API 更新 Fiber 实例等 主要流程有下面几个 获取 Fiber 实例 获取优先级，Fiber 实例的优先级是由调度器控制，所以需要询问调度器关于当前 Fiber 实例的优先级 将更新任务添加至更新队列，组件状态变更时，将对应的组件更新任务划分优先级并根据优先级从高到低依次推入 Fiber 实例的更新队列 调度更新任务 渲染阶段与提交阶段React 在两个主要阶段执行工作，它们是 render 和 commit 在第一个 render 阶段，React 通过 setUpdate 或 React.render 计划性的更新组件，并确定需要在 UI 中更新的内容，如果是初始渲染，React 会为 render 方法返回的每个元素创建一个新的 Fiber 节点，在后续更新中，现有 React 元素的 Fiber 节点将被重复使用和更新，这一阶段是为了得到标记了副作用的 Fiber 节点树，副作用描述了在下一个 commit 阶段需要完成的工作，在当前阶段，React 持有标记了副作用的 Fiber 树并将其应用于实例，它遍历副作用列表、执行 DOM 更新和用户可见的其他更改 这里需要我们注意的是，『第一个 render 阶段的工作是可以异步执行的』，即 React 可以根据可用时间片来处理一个或多个 Fiber 节点，然后停下来暂存已完成的工作，并转而去处理某些事件，接着它再从它停止的地方继续执行，但有时候，它可能需要丢弃完成的工作并再次从顶部开始，由于在此阶段执行的工作不会导致任何用户可见的更改（如 DOM 更新），因此暂停行为才有了意义，与之相反的是，后续 commit 阶段始终是同步的，这是因为在此阶段执行的工作会导致用户可见的变化，例如 DOM 更新，这就是为什么 React 需要在一次单一过程中完成这些更新 其实简单来说，渲染阶段可以认为是协调阶段，这个阶段可以被中断，处于这个阶段的时候 React 会找出所有节点变更，目的是得到标记了副作用的 Fiber 节点树，在这个过程当中以下生命周期钩子会在渲染阶段被调用 constructor UNSAFE_componentWillMount（弃用） UNSAFE_componentWillReceiveProps（弃用） getDerivedStateFromProps shouldComponentUpdate UNSAFE_componentWillUpdate（弃用） render 因为 render 阶段不会产生像 DOM 更新这样的副作用，所以 React 可以异步处理组件的异步更新（甚至可能在多个线程中执行），也就是说在渲染阶段如果时间片用完，React 就会选择让出控制权，因为渲染阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题，但是因为渲染阶段可能被中断、恢复，甚至重做，React 渲染阶段的生命周期钩子可能会被调用多次，例如 componentWillMount 可能会被调用两次，所以建议渲染阶段的生命周期钩子不要包含副作用，索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如 componentWillMount、componentWillUpdate 等（这也是新版 React 的生命周期有所调整的原因） 下面我们再来看看提交阶段涉及到的一些生命周期方法，它会将上一个阶段计算出来的需要处理的副作用（Effect）一次性执行了，这个阶段必须同步执行，不能被打断 getSnapshotBeforeUpdate()（严格来说这个是在进入 commit 阶段前调用） componentDidMount componentDidUpdate componentWillUnmount 现在我们应该知道为什么说在提交阶段必须同步执行，不能中断的吧？因为我们要正确地处理各种副作用，包括 DOM 变更、还有在 componentDidMount 中发起的异步请求、useEffect 中定义的副作用等，因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更，不容差池 至于为什么要拆分两个阶段，可以参考 What is meant within the README of create-subscription by async limitations? Can it be clarified? 这篇文章 因为关于 Fiber 架构的相关内容我们在上面已经简单介绍过了，所以下面我们就站在整体的角度上简单的回顾一下整个过程到底是什么样子的 渲染阶段协调算法始终使用 renderRoot 函数从最顶层的 HostRoot 节点开始，不过 React 会略过已经处理过的 Fiber 节点，直到找到未完成工作的节点，例如如果在组件树中的深层组件中调用 setState 方法，则 React 将从顶部开始，但会快速跳过各个父项，直到它到达调用了 setState 方法的组件 而且在第一次渲染之后，React 会得到一个 Fiber 树，这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表，它反映了用于渲染 UI 的应用程序的状态，这棵树通常被称为 current 树（当前树） 当 React 开始处理更新时，它会构建一个所谓的 workInProgress 树（工作过程树），它反映了要刷新到屏幕的未来状态，这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行，如果没有，则继续构建树的过程 workInProgress 树构建这种技术类似于图形化领域的双缓存（Double Buffering）技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能，放到 React 中，workInProgress 树就是一个缓冲，它在协调完毕后一次性提交给浏览器进行渲染，它可以减少内存分配和垃圾回收，workInProgress 的节点不完全是新的，比如某颗子树不需要变动，React 会克隆复用旧树中的子树，另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉 其中所有的 Fiber 节点都会在工作循环中进行处理，其中 workLoopSync() 是 React 开始构建树的地方，源码可见 workLoopSync 12345function workLoopSync() { while (workInProgress !== null) { performUnitOfWork(workInProgress); }} 当 React 遍历 current 树时，对于每个现有 Fiber 节点，React 会创建一个构成 workInProgress 树的备用节点，这一节点会使用 render 方法返回的 React 元素中的数据来创建，处理完更新并完成所有相关工作后，React 将准备好一个备用树以刷新到屏幕，一旦这个 workInProgress 树在屏幕上呈现，它就会变成 current 树，在处理完当前 Fiber 后，变量将持有树中下一个 Fiber 节点的引用或 null，在这种情况下，React 退出工作循环并准备好提交更改 其中遍历树、初始化或完成工作主要用到下面四个函数 performUnitOfWork() beginWork() completeUnitOfWork() completeWork() 我们首先来看看 performUnitOfWork 这个函数 12345678910function performUnitOfWork(unitOfWork: Fiber): void { // ... const current = unitOfWork.alternate; let next = beginWork(current, unitOfWork, subtreeRenderLanes) if (next === null) { completeUnitOfWork(unitOfWork); } else { workInProgress = next; }} 函数 performUnitOfWork 接收一个 Fiber 节点，并通过调用 beginWork 函数启动工作，这个函数将启动所有 Fiber 执行工作所需要的活动，函数 beginWork 的作用主要是从来节点比对，它始终返回指向要在循环中处理的下一个子节点的指针或 null，如果没有子节点，React 知道它到达了分支的末尾，因此它可以完成当前节点，『一旦节点完成，它将需要为同层的其他节点执行工作，并在完成后回溯到父节点』 下面来看看 completeUnitOfWork 函数执行的代码 1234567891011121314function completeUnitOfWork(unitOfWork: Fiber): void { // ... let completedWork = unitOfWork do { const current = completedWork.alternate if ((completedWork.effectTag &amp; Incomplete) === NoEffect) { let next = next = completeWork(current, completedWork, subtreeRenderLanes) if (next !== null) { workInProgress = next return } } } while (completedWork !== null)} 我们可以看到函数的核心就是一个大的 do-while 的循环，当 workInProgress 节点没有子节点时，React 会进入此函数，完成当前 Fiber 节点的工作后，它就会检查是否有同层节点，如果找的到，React 退出该函数并返回指向该同层节点的指针 这里我们需要注意的是，在当前节点上，React 只完成了前面的同层节点的工作，它尚未完成父节点的工作，只有在完成以子节点开始的所有分支后，才能完成父节点和回溯的工作 从实现中也可以看出 performUnitOfWork 和 completeUnitOfWork 主要用于迭代目的，而主要活动则在 beginWork 和 completeWork 函数中进行，也如我们所见，这四个函数一起执行工作单元的工作，并且还控制当前正在完成的工作，也就是下图当中所示这般 提交阶段渲染阶段完成后，React 进入提交阶段，这一阶段从函数 completeRoot 开始，在这个阶段 React 更新 DOM 并调用变更生命周期之前及之后方法的地方，当 React 进入这个阶段时，它有两棵树和副作用列表，第一个树表示当前在屏幕上渲染的状态，然后在 render 阶段会构建一个备用树，它在源代码中称为 finishedWork 或 workInProgress，表示需要映射到屏幕上的状态，此备用树会用类似的方法通过 child 和 sibling 指针链接到 current 树 然后在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息都保存在 Effect List 当中，也就是所谓的副作用列表，它是 finishedWork 树的节点子集，通过 nextEffect 指针进行链接，需要注意的是，副作用列表是运行 render 阶段的『结果』，渲染的重点就是确定需要插入、更新或删除的节点，以及哪些组件需要调用其生命周期方法，这就是副作用列表告诉我们的内容，它页正是在 commit 阶段迭代的节点集合 在 commit 阶段运行的主要函数是 commitRoot，它执行如下下操作 在标记为 Snapshot 副作用的节点上调用 getSnapshotBeforeUpdate 生命周期 在标记为 Deletion 副作用的节点上调用 componentWillUnmount 生命周期 执行所有 DOM 插入、更新、删除操作 将 finishedWork 树设置为 current 在标记为 Placement 副作用的节点上调用 componentDidMount 生命周期 在标记为 Update 副作用的节点上调用 componentDidUpdate 生命周期 在调用变更前方法 getSnapshotBeforeUpdate 之后，React 会在树中提交所有副作用，这会通过两波操作来完成 第一波执行所有 DOM（宿主）插入、更新、删除和 ref 卸载，然后 React 将 finishedWork 树赋值给 FiberRoot，将 workInProgress 树标记为 current 树，这是在提交阶段的第一波之后、第二波之前完成的，因此在 componentWillUnmount 中前一个树仍然是 current，在 componentDidMount/Update 期间已完成工作是 current 第二波，React 调用所有其他生命周期方法和引用回调，这些方法单独传递执行，从而保证整个树中的所有放置、更新和删除能够被触发执行 这里借用 Lin Clark 演讲当中的一张图（见 React Fiber），我们可以清晰的发现这种变化 上图是协调完成后的状态，左边是旧树，右边是 WIP 树，对于需要变更的节点，都打上了标签，在提交阶段 React 就会将这些打上标签的节点应用变更 以上关于 React Fiber 的相关内容我们就介绍到这里，在接下来的 Fiber 架构的简单实现 的章节当中我们会继续深入理解其原理，并且尝试手动的实现一个简易版本的 Fiber 参考 剖析 useState 的执行过程 Basic Theoretical Concepts React Fiber 架构 React Fiber 原理介绍 深入了解 React Fiber 内部实现 手写 React 的 Fiber 架构 React Fiber 架构解析 这可能是最通俗的 React Fiber 打开方式 React Fiber 初探","link":"/2020/12/06/React/18/"},{"title":"重温 TypeScript","text":"虽然之前一直项目当中使用 Angular 来进行业务开发，但是总感觉对于 TypeScript 这一块的内容还是只停留在比较浅的使用层面，而最近又开始涉及到 React 相关内容，发现 React + TypeScript 算是业界标配了，所以就打算抽些时间深入的学习一下 TypeScript，在这里记录记录，也算是查漏补缺吧 针对于相关内容会分为两篇文章来进行梳理，本文当中主要梳理一些基础内容，也算是回顾一下 TypeScript 的基本用法，而在下一章 深入 TypeScript 当中我们则会来看一些 TypeScript 当中的进阶内容 本文当中涉及到的内容可能比较零散，因为便于自己回顾，一些比较熟络的知识点可能会一笔带过，对于想了解整体流程的同学可以参考 官方文档 来了解更多 什么是 TypeScriptTypeScript 是 JavaScript 的一个超集，主要提供了『类型系统』和对 ES6 的支持，它与 JavaScript 的基本区别有以下这些 TypeScript JavaScript JavaScript 的超集用于解决大型项目的代码复杂性 一种脚本语言，用于创建动态网页 可以在编译期间发现并纠正错误 作为一种解释型语言，只能在运行时发现错误 强类型，支持静态和动态类型 弱类型，没有静态类型选项 最终被编译成 JavaScript 代码，使浏览器可以理解 可以直接在浏览器中使用 支持模块、泛型和接口 不支持模块，泛型或接口 社区的支持仍在增长，而且还不是很大 大量的社区支持以及大量文档和解决问题的支持 而函数之间的区别则有以下这些 TypeScript JavaScript 含有类型 无类型 箭头函数 箭头函数（ES2015） 函数类型 无函数类型 必填和可选参数 所有参数都是可选的 默认参数 默认参数 剩余参数 剩余参数 函数重载 无函数重载 当然任何事物都是有两面性的，通常来说 TypeScript 的一些弊端在于 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 另外，除了 TypeScript 还有一个 Flow 可供选择，Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行，所以还是根据团队和项目的情况判断是否需要使用 TypeScript 另外我们再来简单的了解一下 TypeScript 的工作流程，这有助于我们更好的理解 TypeScript，其实简单来说，典型的 TypeScript 工作流程是下面这样的 在上图当中包含了三个 TypeScript 文件，而这些文件将被 TypeScript 编译器，根据配置的编译选项编译成对应三个不同的 .js 文件，对于大多数使用 TypeScript 开发的 Web 项目来说，我们还会对编译生成的文件进行打包处理，然后在进行部署 下面我们就来看看 TypeScript 当中的常用类型和一些基本概念，主要包括 基础类型 内置对象 联合类型 对象的类型（接口） 数组的类型 函数的类型 另外需要注意一点，如果本文当中未特殊指明示例是错误示范的话，则默认是编译通过 TypeScript 基础类型我们先来看看 TypeScript 当中的一些基础类型，也是我们在平常经常见到的一些类型 布尔值在 TypeScript 中，使用 boolean 定义布尔值类型（注意区分大小写） 1let x: boolean = false 但是需要注意的是，如果使用的是构造函数 Boolean 创造的对象则不是布尔值 12// ❌let x: boolean = new Boolean(true) 事实上 new Boolean() 返回的是一个 Boolean 对象 12// ✅let x: Boolean = new Boolean(true) 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数，其他基本类型（除了 null 和 undefined）也是一样的 数值使用 number 可以来定义数值类型，并且二进制与八进制等均可以使用 123456let x: number = 6let x: number = 0xf00dlet x: number = 0b1010 // ES6 中的二进制表示法let x: number = 0o744 // ES6 中的八进制表示法let x: number = NaNlet x: number = Infinity 字符串使用 string 来定义字符串类型 1234let x: string = 'zhangsan'// 模板字符串let y: string = `hello ${x}` 可以发现，对于 ES6 当中的模板字符串同样适用 任意值任意值（Any）用来表示允许赋值为任意类型，与原始数据类型进行比对的话，如果是一个普通类型，在赋值过程中改变类型是不被允许的 123// ❌let x: string = 'zhangsan'x = 7 但如果是 any 类型，则允许被赋值为任意类型 123// ✅let x: any = 'lisi'x = 7 同时，在任意值上访问任何属性都是允许的 1234let x: any = 'zhangsan'console.log(x.name)console.log(x.name.firstName) 也允许调用任何方法 12345let x: any = 'lisi'x.setName('wangwu')x.setName('zhaoliu').sayHello()x.name.setFirstName('zhangsan') 可以认为，『声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值』，但是如果变量在声明的时候，未指定其类型，那么它会被识别为任意值类型，比如下面示例当中的 x 等价于 x: any 123456let xx = 'zhangsan'x = 7x.setName('lisi') 虽然 any 使用起来很方便，但是可想而知，如果我们大量使用 any 类型，就无法使用 TypeScript 所提供的大量的保护机制，为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型 Unknown就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown，这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any），下面我们来看一下 unknown 类型的使用示例 123456789101112let value: unknownvalue = true // ✅value = 42 // ✅value = 'hello world' // ✅value = [] // ✅value = {} // ✅value = Math.random // ✅value = null // ✅value = undefined // ✅value = new TypeError() // ✅value = Symbol('type') // ✅ 可以发现，我们对 value 变量的所有赋值都被认为是类型正确的，下面我们再来看看将类型为 unknown 的值赋值给其他类型的变量时会发生什么 12345678910let value: unknownlet value1: unknown = value // ✅let value2: any = value // ✅let value3: boolean = value // ❌let value4: number = value // ❌let value5: string = value // ❌let value6: object = value // ❌let value7: any[] = value // ❌let value8: Function = value // ❌ 通过上面的示例可以发现，unknown 类型只能被赋值给 any 类型和 unknown 类型本身，其实也能理解，那就是只有能够保存任意类型值的容器才能保存 unknown 类型的值，毕竟我们不知道变量 value 中存储了什么类型的值 我们下面再来看看对类型为 unknown 的值执行操作时会发生什么 1234567let value: unknownvalue.foo.bar // ❌value.trim() // ❌value() // ❌new value() // ❌value[0][1] // ❌ 将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的，通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改 空值某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void 123function alertName(): void { alert('zhangsan')} 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null，但是需要注意，在非严格模式下，变量的值可以为 undefined 或 null，而严格模式下，变量的值只能为 undefined，所以使用场景较多的还是针对于没有返回值的函数 1let x: void = undefined 但是这里有一个需要注意的地方，即当定义的函数返回值为空值 void 的时候，虽然在该函数内部写 return 时编译会报错，但是依然可以编译成功 Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型 12let u: undefined = undefinedlet n: null = null 与 void 的区别是，undefined 和 null 是所有类型的子类型，也就是说 undefined 类型的变量，可以赋值给 number 或 string 类型的变量 1234// ✅let x: undefinedlet n: number = xlet s: string = x 而 void 类型的变量不能赋值给 number 或 string 类型的变量 1234// ❌let x: voidlet n: number = xlet s: string = x 但是默认情况下像上面那样操作，编译器会提示错误，这是因为 tsconfig.json 里面有一个配置项是默认开启的 12345678910111213// tsconfig.json { /* Strict Type-Checking Options */ \"strict\": true, /* Enable all strict type-checking options. */ // \"noImplicitAny\": true, /* Raise error on expressions and declarations with an implied 'any' type. */ // 对 null 类型检查，设置为 false 就不会报错了 // \"strictNullChecks\": true, /* Enable strict null checks. */ // \"strictFunctionTypes\": true, /* Enable strict checking of function types. */ // \"strictBindCallApply\": true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ // \"strictPropertyInitialization\": true, /* Enable strict checking of property initialization in classes. */ // \"noImplicitThis\": true, /* Raise error on 'this' expressions with an implied 'any' type. */ // \"alwaysStrict\": true, /* Parse in strict mode and emit \"use strict\" for each source file. */} 其中 strictNullChecks 参数用于新的严格空检查模式，在严格空检查模式下，null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any object，Object 和 { }我们这里主要看看这三者之间的区别，注意区分前两者的大小写 object 类型 object 类型是 TypeScript 2.2 引入的新类型，它用于表示非原始类型 1234567891011121314// node_modules/typescript/lib/lib.es5.d.tsinterface ObjectConstructor { create(o: object | null): any // ...}const proto = {}Object.create(proto) // ✅Object.create(null) // ✅Object.create(undefined) // ❌ Object.create(1337) // ❌ Object.create(true) // ❌ Object.create(\"oops\") // ❌ Object 类型 Object 类型是所有 Object 类的实例的类型，它由以下两个接口来定义，其中 Object 接口定义了 Object.prototype 原型对象上的属性 12345678910// node_modules/typescript/lib/lib.es5.d.tsinterface Object { constructor: Function toString(): string toLocaleString(): string valueOf(): Object hasOwnProperty(v: PropertyKey): boolean isPrototypeOf(v: Object): boolean propertyIsEnumerable(v: PropertyKey): boolean} 而 ObjectConstructor 接口定义了 Object 类的属性 123456789101112// node_modules/typescript/lib/lib.es5.d.tsinterface ObjectConstructor { /** Invocation via `new` */ new(value?: any): Object /** Invocation via function calls */ (value?: any): any readonly prototype: Object getPrototypeOf(o: any): any // ...}declare var Object: ObjectConstructor 这里需要注意的是，Object 类的所有实例都继承了 Object 接口中的所有属性 { } 类型 { } 类型描述了一个没有成员的对象，当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误 1234const obj = { }// ❌ obj.prop = 'zhangsan' 但是我们仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用 1234const obj = { }// ✅obj.toString() Nevernever 类型表示的是那些永不存在的值的类型，例如 never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型（这个类型一般很少会用到，了解即可） 12345678// 返回 never 的函数必须存在无法达到的终点function error(message: string): never { throw new Error(message)}function infiniteLoop(): never { while (true) { }} 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下 123456789101112type Foo = string | numberfunction controlFlowAnalysisWithNever(foo: Foo) { if (typeof foo === 'string') { // 这里 foo 被收窄为 string 类型 } else if (typeof foo === 'number') { // 这里 foo 被收窄为 number 类型 } else { // foo 在这里是 never const check: never = foo }} 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量，如果一切逻辑正确，那么这里应该能够编译通过，但是如果我们修改了 Foo 的类型为 type Foo = string | number | boolean 但是忘记了修改 controlFlowAnalysisWithNever 方法中的控制流程 这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误，通过这个方式，我们可以确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型 通过这个示例，我们可以得出一个结论，即可以使用 never 来避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码，但是这里我们也需要注意区分 never 和 void 两者之间的区别 void 表示没有任何类型（可以被赋值为 null 和 undefined） never 表示一个不包含值的类型，即表示永远不存在的值 拥有 void 返回值类型的函数能正常运行，拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常 内置对象其实在上面介绍的一些原始数据类型，本质上它们都是 JavaScript 当中的 内置对象，它们已经在 TypeScript 中定义好了对应的类型，直接进行使用就行，内置对象是指根据标准在全局作用域（Global）上存在的对象，这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准 ECMAScript 标准提供的内置对象有 Boolean、Error、Date、RegExp 等，我们可以在 TypeScript 中将变量定义为这些类型 1234let b: Boolean = new Boolean(1)let e: Error = new Error('Err')let d: Date = new Date()let r: RegExp = /[a-z]/ 而常见的 DOM 和 BOM 提供的内置对象有 Document、HTMLElement、Event、NodeList 等，我们在开发过程当中也会经常用到这些类型 1234567let body: HTMLElement = document.bodylet allDiv: NodeList = document.querySelectorAll('div')document.addEventListener('click', function (e: MouseEvent) { // ...}) 而对于内置对象的定义文件，则在 TypeScript 核心库 的定义文件中，其中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的，当我们在使用一些常用的方法的时候，TypeScript 实际上已经帮我们做了很多类型判断的工作了，比如 12345// ✅Math.pow(10, 2)// ❌Math.pow(10, '2') 在上面的例子中，Math.pow() 必须接受两个 number 类型的参数，它的类型定义如下 12345678interface Math { /** * Returns the value of a base expression taken to a specified power. * @param x The base value of the expression. * @param y The exponent value of the expression. */ pow(x: number, y: number): number} 再来看一个 DOM 中的例子 1234// ❌document.addEventListener('click', function (e) { console.log(e.targetCurrent)}) 在上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的 123interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent { addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void} 所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了 此外我们还需要需要注意一点，那就是 TypeScript 核心库的定义中是不包含 Node.js 部分的，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件 1npm install @types/node --save-dev TypeScript 断言我们在有时候可能会遇到这种情况，那就是我们会比 TypeScript 更了解某个值的详细信息，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型，在这种情况下我们就可以通过类型断言这种方式可以告诉编译器，我知道自己在干什么，类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构，它没有运行时的影响，只是在编译阶段起作用 类型断言类型断言主要有两种形式，即 &lt;&gt; 和 as，我们先来看看 &lt;&gt; 的形式 123let x: any = 'abc'let l: number = (&lt;string&gt;x).length 等同于 123let x: any = 'abc'let l: number = (x as string).length 但是建议尽量使用 as 来替 &lt;&gt; 表示类型断言，因为 在 TypeScript 可以使用 &lt;&gt; 来表示类型断言，但是在结合 JSX 的语法时将带来解析上的困难，因此 TypeScript 在 .tsx 文件里禁用了使用 &lt;&gt; 的类型断言 另外，as 操作符在 .ts 文件和 .tsx 文件里都可以使用 非空断言如果在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型，简单来说比如 x! 就是将从 x 值域中排除 null 和 undefined，下面我们先来看几个非空断言操作符的一些使用场景 第一种情况，忽略 undefined 和 null 类型 123456function myFunc(maybeString: string | undefined | null) { // Type 'string | null | undefined' is not assignable to type 'string'. // Type 'undefined' is not assignable to type 'string'. const onlyString: string = maybeString // ❌ const ignoreUndefinedAndNull: string = maybeString! // ✅} 第二种情况，调用函数时忽略 undefined 类型 12345678type NumGenerator = () =&gt; numberfunction myFunc(numGenerator: NumGenerator | undefined) { // Object is possibly 'undefined'.(2532) // Cannot invoke an object which is possibly 'undefined'.(2722) const num1 = numGenerator() // ❌ const num2 = numGenerator!() // ✅} 因为 ! 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意，比如下面这个例子 1234const a: number | undefined = undefinedconst b: number = a!console.log(b) 以上 TypeScript 代码会编译生成以下 ES5 代码 12345'use strict'const a = undefinedconst b = aconsole.log(b) 虽然在 TypeScript 代码中，我们使用了非空断言，使得 const b: number = a! 语句可以通过 TypeScript 类型检查器的检查，但在生成的 ES5 代码中，因为 ! 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 undefined 确定赋值断言在 TypeScript 2.7 版本中引入了『确定赋值断言』，即允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值，来看下面这个示例 12345678910let x: numberinit()// Variable 'x' is used before being assigned.console.log(x * 2)function init() { x = 10} 运行后我们可以发现，错误提示显示说变量 x 在赋值前已经被使用了，为了解决这个问题，我们可以使用确定赋值断言 12345678910let x!: numberinit()// ✅console.log(x * 2)function init() { x = 10} 我们通过 let x!: number 来确定赋值断言，这样一来 TypeScript 编译器就会知道该属性会被明确地赋值 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种，使用 | 分隔每个类型 123456let x: string | numberx = 'zhangsan' // ✅x = 7 // ✅x = true // ❌ 上面示例当中的 let x: string | number 含义是允许 x 的类型是 string 或者 number，但是不能是其他类型 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法 1234// ❌function getLength(x: string | number): number { return x.length} 因为 length 不是 string 和 number 类型的共有属性，所以会报错，但是访问两者的的共有属性是没问题的，比如 toString() 方法 1234// ✅function getLength(x: string | number): string { return x.toString() } 并且联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型 1234567let x: string | numberx = 'zhangsan'console.log(x.length) // 8x = 7console.log(x.length) // ❌ 上例中，在赋值为 'zhangsan' 的时候，x 被推断成了 string，所以可以访问它的 length 属性，但是赋值为 7 的时候 x 被推断成了 number，所以访问它的 length 属性时就会报错 关于联合类型，这里我们来看一个它的相关应用场景，也就是『类型保护函数』，要自定义一个类型保护，只需要简单地为这个类型保护定义一个函数即可，这个函数的返回值是一个『类型谓词』 类型谓词的语法为 parameterName is Type 这种形式，其中 parameterName 必须是当前函数签名里的一个参数名，来看下面这个示例 1234567891011121314151617181920212223interface Bird { fly() layEggs()}interface Fish { swim() layEggs()}function getSmallPet(): Fish | Bird { return}let pet = getSmallPet()pet.layEggs()// ❌pet.swim()// ✅(pet as Fish).swim() 在上面示例当中，当我们使用联合类型时，如果不用类型断言，默认只会获取两者共有的部分，在这种情况下，我们就可以采用类型谓词 1234567891011121314151617181920212223242526interface Bird { fly() layEggs()}interface Fish { swim() layEggs()}function getSmallPet(): Fish | Bird { return}let pet = getSmallPet()// 使用类型谓词 function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined}if (isFish(pet)) { pet.swim()} else { pet.fly()} 另外，我们可以借住 never 来区分的联合类型，比如下面这个示例 123456789101112131415161718192021222324252627282930313233343536373839enum KindType { square = 'square', rectangle = 'rectangle', circle = 'circle',}interface Square { kind: KindType.square size: number}interface Rectangle { kind: KindType.rectangle width: number height: number}interface Circle { kind: KindType.circle radius: number}type Shape = Square | Rectangle | Circlefunction area(s: Shape) { // 如果联合类型中的多个类型，拥有共有的属性，那么就可以凭借这个属性来创建不同的类型保护区块 // 这里 kind 是共有的属性 switch (s.kind) { case KindType.square: return s.size * s.size case KindType.rectangle: return s.height * s.width default: return }}// 以上代码有隐患，如果后续新增类型时，TS 检查以上代码时，虽然缺失后续新增的类型，但不会报错area({ kind: KindType.circle, radius: 1 }) 所以这里可以利用 never 来进行完善 12345678910111213141516171819function area(s: Shape) { switch (s.kind) { case KindType.square: return s.size * s.size case KindType.rectangle: return s.height * s.width case KindType.circle: return Math.PI * s.radius ** 2 default: // 检查 s 是否是 never 类型 // 如果是 never 类型，那么上面的分支语句都被覆盖了，就永远都不会走到当前分支 // 如果不是 never 类型，就说明前面的分支语句有遗漏，需要补上 return ((e: never) =&gt; { throw new Error(e) })(s) }}area({ kind: KindType.circle, radius: 1 }) 更多可见 TypeScript 中的 never 类型具体有什么用？ 对象的类型（接口）在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型，接口（Interfaces）在面向对象语言中是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement），我们先来看一个简单的示例 123456789interface Person { name: string; age: number;}let user: Person = { name: 'zhangsan', age: 18} 我们定义了一个接口 Person，接着定义了一个变量 user，它的类型是 Person，这样我们就约束了 user 的结构必须和接口 Person 一致，但是需要注意的是，定义的变量比接口多一些或是少了一些属性都是不允许的 1234567891011// ❌let user: Person = { name: 'zhangsan'}// ❌let user: Person = { name: 'zhangsan', age: 18, sex: 0} 所以说，在赋值的时候，变量的结构必须和接口的结构保持一致 可选属性有时候我们又希望不要完全匹配一个接口，那么这种情况下可以使用可选属性 12345678910111213interface Person { name: string; age?: number;}let user1: Person = { name: 'zhangsan'}let user2: Person = { name: 'zhangsan', age: 18} 但是此时仍然不允许添加未定义的属性 1234567891011interface Person { name: string; age?: number;}// ❌let user: Person = { name: 'zhangsan', age: 18, sex: 0} 任意属性有时候我们希望一个接口允许有任意的属性，可以使用 [propName: type] 的方式来来进行定义 12345678910interface Person { name: string; age?: number; [propName: string]: any;}let user: Person = { name: 'zhangsan', age: 18} 但是这里有一个需要注意的地方，那就是『一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集』，比如下面这个示例就会报错 123456789101112// ❌interface Person { name: string; age?: number; [propName: string]: string;}let user: Person = { name: 'zhangsan', age: 18, sex: '0'} 这里我们将任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了，通常来说一个接口中只能定义一个任意属性，如果接口中有多个类型的属性，则可以采用联合类型的方式 1234567891011interface Person { name: string; age?: number; [propName: string]: string | number;}let user: Person = { name: 'zhangsan', age: 18, sex: 0} 另外需要注意的一点就是『索引签名』参数类型必须为 string 或 number』 123456// ❌interface Person { name: string; age?: number; [propName: any]: any;} 上面示例是会报错的，这是因为 TypeScript 只支持两种索引签名，那就是字符串和数字，虽然可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型，这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象，比如下面这个示例就不会报错 123456789101112// ✅interface Person { name: string; age?: number; [propName: string]: string | number;}let user: Person = { name: 'zhangsan', age: 18, 1: 1} 其实在上面示例当中和写成 '1': 1 是完全一样的，即使我们定义的是 [propName: number]，这是因为 JavaScript 中对象的数字索引，最终会转成字符串来取值的，比如使用 100（number）去索引等同于使用 '100'（string）去索引，因此两者需要保持一致 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性 123456789101112131415interface Person { readonly id: number; name: string; age?: number; [propName: number]: string | number;}let user: Person = { id: 123, name: 'zhangsan', age: 18}// ❌user.id = 456 在上面示例当中，我们使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了，但是这里特别需要注意的一点就是『只读的约束是存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候』，比如下面这个示例 123456789101112131415interface Person { readonly id: number; name: string; age?: number; [propName: number]: string | number;}// ❌let user: Person = { name: 'zhangsan', age: 18}// ❌user.id = 456 上例中有两处报错，第一处是在对 user 进行赋值的时候，没有给 id 赋值，第二处是在给 user.id 赋值的时候，由于它是只读属性，所以报错了 数组的类型在 TypeScript 中，数组类型有多种定义方式，比较灵活，最简单的方法是使用『类型 + 方括号』来表示数组 1let x: number[] = [1, 2, 3, 4, 5] 并且定义以后，数组的一些方法的参数也会根据数组在定义时约定的类型进行限制 1234567let x: number[] = [1, 2, 3, 4, 5]// ✅x.push(6)// ❌x.push('6') 在上面示例当中，由于 push 方法只允许传入 number 类型的参数，但是却传了一个字符串类型的 6，所以报错了，另外我们也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组 1let x: Array&lt;number&gt; = [1, 2, 3, 4, 5] 关于泛型的相关内容，我们会在后面章节当中详细来进行介绍，下面我们来看看如何使用接口来描述数组 12345interface NumberArray { [index: number]: number;}let x: NumberArray = [1, 2, 3, 4, 5] 虽然接口也可以用来描述数组，但是我们一般不会这么来使用，因为这种方式比前两种方式要复杂许多，不过有一种情况比较特殊，那就是它常用来表示类数组，类数组（Array-like Object）不是数组类型，比如 arguments 1234// ❌function sum() { let args: number[] = arguments} 由于 arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口 123456789interface Args { [index: number]: number; length: number; callee: Function;}function sum() { let args: Args = arguments} 在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性，事实上常用的类数组都有自己的接口定义，如 IArguments，NodeList，HTMLCollection 等 123function sum() { let args: IArguments = arguments} 其实也就是我们之前提到过的『内置对象』，其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是 12345interface IArguments { [index: number]: any; length: number; callee: Function;} 对于数组当中既存在数字又含有字符串的情况，我们可以考虑使用联合类型 1let x: (number | string)[] = [1, '2', 3] 另外还有一种比较复杂的情况，那就是对象类型的数组，偷懒的话当然可以直接使用 any，但是如若结构不算太过复杂的话可以使用下面这种方式 1const x: { name: string, age: number }[] = [{ name: 'zhangsan', age: 18 }] 还可以将上面的写法简化一下，利用类型别名的方式 123type User = { name: string, age: number }const x: User[] = [{ name: 'zhangsan', age: 18 }] 函数的类型在 JavaScript 中，有两种常见的定义函数的方式，即函数声明（Function Declaration）和函数表达式（Function Expression） 123456789// 函数声明（Function Declaration）function add(x, y) { return x + y}// 函数表达式（Function Expression）let add = function (x, y) { return x + y} 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单 123function add(x: number, y: number): number { return x + y} 但是输入多余的（或者少于要求的）参数，是不被允许的 123add(1, 2, 3) // ❌add(1) // ❌ 但是如果我们要对一个函数表达式（Function Expression）来定义的话，可能会写成这样 123let add = function (x: number, y: number): number { return x + y} 虽然是可以通过编译的，但是上面的代码其实只对等号右侧的匿名函数进行了类型定义，而等号左边的 add，是通过赋值操作进行类型推论而推断出来的，如果需要我们手动给 add 添加类型，则应该是这样 123let add: (x: number, y: number) =&gt; number = function (x: number, y: number): number { return x + y} 但是这里注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 当中的箭头函数（=&gt;），在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型 使用接口我们也可以使用接口的方式来定义一个函数需要符合的结构 1234567interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc = function (source: string, subString: string): boolean { return source.search(subString) !== -1} 采用函数表达式定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变 可选参数与接口中的可选属性类似，我们用 ? 来表示可选的参数 1234567891011function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + ' ' + lastName } else { return firstName }}let man1 = buildName('zhangsan', 'lisi')let man2 = buildName('zhangsan') 不过需要注意的是，可选参数必须接在必需参数后面，也就是说可选参数后面不允许再出现必需参数了 12345678// ❌function buildName(firstName?: string, lastName: string) { if (lastName) { return firstName + ' ' + lastName } else { return firstName }} 默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数 1234567function buildName(firstName: string, lastName: string = 'lisi') { return firstName + ' ' + lastName}let man1 = buildName('zhangsan', 'wangwu')let man2 = buildName('zhangsan') 但是需要注意一种情况，那就是我们在解构一个函数的时候，即给变量声明类型的同时又给变量设置默认值的情况，如下 1234// ❌function f({ x: number }) { console.log(x)} 如上，在这种情况下，编辑器会提示我们找不到名称 x，针对于这种情况，我们可以像下面这样来进行处理 1234// ✅function f({ x }: { x: number } = { x: 0 }) { console.log(x)} 剩余参数在 ES6 中，我们可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数） 123456789function push(array, ...items) { items.forEach(function (item) { array.push(item) })}let arr = []push(arr, 1, 2, 3) 事实上，items 是一个数组，所以我们可以用数组的类型来定义它 123456789function push(array: number[], ...items: number[]) { items.forEach(function (item) { array.push(item) })}let arr = []push(arr, 1, 2, 3) 这里需要注意的是，rest 参数同可选参数一样，只能是最后一个参数 重载在 Java 等面向对象语言当中的函数重载，指的是两个或者两个以上的同名函数，参数类型不同或者参数个数不同，它的好处是不需要为功能相似的函数起不同的名称，而在 TypeScript 当中，表现为给同一个函数提供多个函数类型定义，适用于接收不同的参数和返回不同结果的情况 TypeScript 在实现函数重载的时候，要求定义一系列的函数声明，在类型最宽泛的版本中实现重载（前面的是函数声明，目的是约束参数类型和个数，最后的函数实现是重载，表示要遵循前面的函数声明，一般在最后的函数实现时用 any 类型），不过函数重载在实际应用中使用的比较少，一般会用联合类型或泛型代替，并且函数重载的声明只用于类型检查阶段，在编译后会被删除 TypeScript 编译器在处理重载的时候，会去查询函数申明列表，从上至下直到匹配成功为止，所以要把最容易匹配的类型写到最前面 12345678910111213function attr(val: string): stringfunction attr(val: number): number// 前面两行是函数申明，这一行是实现函数重载function attr(val: any): any { if (typeof val === 'string') { return val } else if (typeof val === 'number') { return val }}attr('aaa')attr(666) 上面的写法声明完函数后，必须实现函数重载，也可以『只声明函数』 123456789101112131415161718192021222324252627282930// 后写的接口中的函数声明优先级高interface Cloner111 { clone(animal: Animal): Animal}interface Cloner111 { clone(animal: Sheep): Sheep}interface Cloner111 { clone(animal: Dog): Dog clone(animal: Cat): Cat}// ==&gt; 同名接口会合并// 后写的接口中的函数声明优先级高interface Cloner111 { clone(animal: Dog): Dog clone(animal: Cat): Cat clone(animal: Sheep): Sheep clone(animal: Animal): Animal}interface Cloner222 { // 接口内部按书写的顺序来排，先写的优先级高 clone(animal: Dog): Dog clone(animal: Cat): Cat clone(animal: Sheep): Sheep clone(animal: Animal): Animal} 声明合并这里既然提及到了同名接口合并，我们就再来扩展一些，其实这也就是所谓的『声明合并』，不光是函数，在接口当中也是可以进行合并的，如果定义了两个相同名字的函数、接口或类，那么它们将会合并成一个类型，如下 1234567interface Alarm { price: number;}interface Alarm { weight: number;} 上面的示例相当于 1234interface Alarm { price: number; weight: number;} 但是需要注意的是，合并的属性的类型必须是唯一的 12345678interface Alarm { price: number;}interface Alarm { price: number; weight: number;} 上面示例当中虽然字段 price 重复了，但是类型都是 number，所以不会报错，而下面这个示例则会编译错误 12345678interface Alarm { price: number;}interface Alarm { price: string; // ❌ weight: number;} 因为上面示例当中需要合并的类型不一致，所以报错了，另外接口中方法的合并，与函数的合并一样 123456789interface Alarm { price: number; alert(s: string): string;}interface Alarm { weight: number; alert(s: string, n: number): string;} 相当于 123456interface Alarm { price: number; weight: number; alert(s: string): string; alert(s: string, n: number): string;} 重载与重写最后我们再来看一个可能会与重载（overload）弄混淆的概念，那就是重写（override），这里需要注意区分两者之间的差异 重写是指子类重写『继承』自父类中的方法，虽然 TypeScript 和 Java 相似，但是 TypeScript 中的继承本质上还是 JavaScript 中的『继承』机制（也就是原型链机制） 而重载是指为同一个函数提供多个类型定义 123456789101112131415class Animal { speak(word: string): string { return '动作叫' + word }}class Cat extends Animal { speak(word: string): string { return '猫叫' + word }}let cat = new Cat()cat.speak('hello') 123456789101112function double(val: number): numberfunction double(val: string): stringfunction double(val: any): any { if (typeof val == 'number') { return val * 2 } return val + val}let r = double(1)console.log(r) 继承与多态既然提到了继承，那我们就再来看一个与其十分类似的概念，那就是多态 继承，子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态，由继承而产生了相关的不同的类，对同一个方法可以有不同的响应 1234567891011121314151617181920212223class Animal { speak(word: string): string { return 'Animal: ' + word }}class Cat extends Animal { speak(word: string): string { return 'Cat:' + word }}class Dog extends Animal { speak(word: string): string { return 'Dog:' + word }}let cat = new Cat()cat.speak('hello')let dog = new Dog()dog.speak('hello') 运算符我们在上面的章节当中已经简单介绍过了可选属性和可选参数相关内容，在本小节当中我们再来稍微深入一些，来了解一些 TypeScript 当中的运算符 ?. 运算符TypeScript 3.7 实现了『可选链』（Optional Chaining）的功能，有了可选链后，我们编写代码时如果遇到 null 或 undefined 就可以立即停止某些表达式的运行，可选链的核心是新的 ?. 运算符 123456789101112a?.b// 相当于 a == null ? undefined : a.b// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a.b 的值a?.[x]// 相当于 a == null ? undefined : a[x]// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a[x] 的值a?.b()// 相当于a == null ? undefined : a.b()// 如果 a 是 null/undefined，那么返回 undefined// 如果 a.b 不是函数的话，会抛类型错误异常，否则计算 a.b() 的结果 下面我们通过一个可选的属性访问的详细示例例子来进行了解 1const val = a?.b 为了更好的理解，我们可以看一下上面示例对应编译生成的 ES5 代码 1var val = a === null || a === void 0 ? void 0 : a.b 上述的代码会自动检查对象 a 是否为 null 或 undefined，如果是的话就立即返回 undefined，这样就可以立即停止某些表达式的运行，所以我们可以利用 ?. 来替代很多使用 &amp;&amp; 执行的空检查代码 12345if (a &amp;&amp; a.b) { }// 等同于 ==&gt;if (a?.b) { } 而 if (a?.b) { } 编译后的 ES 代码是下面这样的 1234if ( a === null || a === void 0 ? void 0 : a.b) {} 但需要注意的是，?. 与 &amp;&amp; 运算符行为略有不同，&amp;&amp; 专门用于检测 falsy 值，比如空字符串、0、NaN、null 和 false 等，而 ?. 只会验证对象是否为 null 或 undefined，对于 0 或空字符串来说，并不会出现所谓的『短路』 可选链除了支持可选属性的访问之外，它还支持可选元素的访问，它的行为类似于可选属性的访问，只是可选元素的访问允许我们访问非标识符的属性，比如任意字符串、数字索引和 Symbol 123function tryGetArrayElement&lt;T&gt;(arr?: T[], index: number = 0) { return arr?.[index]} 以上代码经过编译后会生成以下 ES5 代码 12345'use strict'function tryGetArrayElement(arr, index) { if (index === void 0) { index = 0 } return arr === null || arr === void 0 ? void 0 : arr[index]} 通过观察生成的 ES5 代码，很明显在 tryGetArrayElement 方法中会自动检测输入参数 arr 的值是否为 null 或 undefined，从而保证了我们代码的健壮性 另外，当我们尝试调用一个可能不存在的方法时也可以使用可选链，使用可选链可以使表达式自动返回 undefined 而不是抛出一个异常，比如 1let result = obj.customMethod?.() 该 TypeScript 代码编译生成的 ES5 代码如下 12var result = (_a = obj.customMethod) === null || _a === void 0 ? void 0 : _a.call(obj) 另外在使用可选调用的时候，我们要注意以下两个注意事项 如果存在一个属性名且该属性名对应的值不是函数类型使用 ?. 仍然会产生一个 TypeError 异常 可选链的运算行为被局限在属性的访问、调用以及元素的访问，因为它不会沿伸到后续的表达式中，也就是说可选调用不会阻止 a?.b / someMethod() 表达式中的除法运算或 someMethod 的方法调用 ?? 运算符在 TypeScript 3.7 版本中除了引入了前面介绍的可选链 ?. 之外，也引入了一个新的逻辑运算符，那就是『空值合并运算符（??）』，当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数 与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数，也就是说如果你使用 || 来为某些变量设置默认的值时，你可能会遇到意料之外的行为，比如为 falsy 值（''、NaN 或 0）时，下面来看一个具体的示例 12345const foo = null ?? 'default string'console.log(foo) // =&gt; default stringconst baz = 0 ?? 42console.log(baz) // =&gt; 0 以上 TypeScript 代码经过编译后，会生成以下 ES5 代码 1234567'use strict'var _a, _bvar foo = (_a = null) !== null &amp;&amp; _a !== void 0 ? _a : 'default string'console.log(foo) // =&gt; default stringvar baz = (_b = 0) !== null &amp;&amp; _b !== void 0 ? _b : 42console.log(baz) // =&gt; 0 通过观察以上代码，我们更加直观的了解到，空值合并运算符是如何解决前面 || 运算符存在的潜在问题，下面我们来看看空值合并运算符的特性和使用时的一些注意事项 短路 当空值合并运算符的左表达式不为 null 或 undefined 时，不会对右表达式进行求值 1234567891011121314151617function A() { console.log('A was called') return undefined}function B() { console.log('B was called') return false}function C() { console.log('C was called') return 'foo'}A() ?? C()B() ?? C() 上述代码运行后，控制台会输出以下结果 12345A was called C was called foo B was called false 不能与 &amp;&amp; 或 || 操作符共用 若空值合并运算符 ?? 直接与 AND（&amp;&amp;）和 OR（||）操作符组合使用 ?? 是不行的，这种情况下会抛出 SyntaxError 12345// '||' and '??' operations cannot be mixed without parentheses.(5076)null || undefined ?? 'foo' // raises a SyntaxError// '&amp;&amp;' and '??' operations cannot be mixed without parentheses.(5076)true &amp;&amp; undefined ?? 'foo' // raises a SyntaxError 但当使用括号来显式表明优先级时是可行的 1(null || undefined) ?? 'foo' // =&gt; foo 与可选链操作符 ?. 的关系 空值合并运算符针对 undefined 与 null 这两个值，可选链式操作符 ?. 也是如此，可选链式操作符对于访问属性可能为 undefined 与 null 的对象时非常有用 123456789101112interface Customer { name: string city?: string}let customer: Customer = { name: 'zhangsan'}let customerCity = customer?.city ?? 'Unknown city'customerCity // =&gt; Unknown city 前面我们已经介绍了空值合并运算符的应用场景和使用时的一些注意事项，该运算符不仅可以在 TypeScript 3.7 以上版本中使用，当然也可以借助 Babel 来在 JavaScript 的环境中使用它，Babel 7.8.0 版本开始支持空值合并运算符 总结以上就是我们梳理的一些 TypeScript 当中的基础内容，在下一章 深入 TypeScript 当中我们会接着来了解一些 TypeScript 当中的进阶内容，比如元祖，枚举，类等 参考 深入理解 TypeScript 官方手册 TypeScript 中文 TypeScript","link":"/2020/12/26/JavaScript/56/"},{"title":"jQuery 源码梳理","text":"因为最近在项目当中使用 jQuery 比较多，所以打算抽点时间深入学习一下 jQuery 源码的相关内容，也算是学习笔记记录吧，主要参考的是 jQuery 技术内幕 这本书籍，下面我们就先从总体架构部分开始看起 源码的总体架构jQuery 整体的架构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445 16 (function (window, undefined) { // 构造 jQuery 对象 22 var jQuery = (function() { 25 var jQuery = function(selector, context) { 27 return new jQuery.fn.init(selector, context, rootjQuery) 28 }, // 一堆局部变量声明 97 jQuery.fn = jQuery.prototype = { 98 constructor: jQuery, 99 init: function(selector, context, rootjQuery) { ... }, // 一堆原型属性和方法319 };322 jQuery.fn.init.prototype = jQuery.fn;324 jQuery.extend = jQuery.fn.extend = function() { ... }388 jQuery.extend({ // 一堆静态属性和方法892 });955 return jQuery957 })(); // 省略其他模块的代码，主要是功能性代码，列表如下 // 工具函数 Utilities // 异步队列 Deferred // 浏览器测试 Support // 数据缓存 Data // 队列 queue // 属性操作 Attribute // 事件处理 Event // 选择器 Sizzle // DOM 遍历 // DOM 操作 // CSS 操作 // 异步请求 Ajax // 动画 FX // 坐标和大小9246 window.jQuery = window.$ = jQuery9266 })(window) jQuery 的最外层是一个自调用匿名函数，通过定义一个匿名函数，创建了一个私有的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间，参数中传入 window 变量，使得 window 由全局变量变为局部变量，当在 jQuery 代码块中访问 window 时，不需要将作用域链回退到顶层作用域，这样可以更快的访问 window 更重要的是将 window 作为参数传入，可以在压缩代码时进行优化，传入 undefined 是因为在自调用匿名函数的作用域内，确保 undefined 是真的未定义，因为 undefined 在某些浏览器下是能够被重写或是被赋予新的值 下面我们就先来看看它最为重要的一个方法，也就是构造函数 jQuery()，它一共有七种用法，如下 jQuery(selector, context)接收一个 CSS 选择器表达式（selector）和可选的选择器上下文（Context），返回一个包含了匹配的 DOM 元素的 jQuery 对象，例如，在一个事件监听函数中，可以像下面这样限制查找范围 1234$('div.foo').click(function() { // 限定查找范围 $('span', this).addClass('bar')}); 如果选择器表达式 selector 是简单的 &quot;#id&quot; ，且没有指定上下文 Context，则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素 如果是比 &quot;#id&quot; 复杂的选择器表达式或指定了上下文，则通过 jQuery 方法 .find() 查找，因此 $('span', this) 等价于 $(this).find('span') jQuery(html, ownerDocument) 和 jQuery(html, props)用所提供的 HTML 代码创建 DOM 元素 12345678/* * 两种方式都可以往 body 中插入 div * 1，$('&lt;div&gt;').appendTo('body') * 2，$('&lt;div&gt;&lt;/div&gt;').appendTo('body') */// 多标签嵌套$('&lt;div&gt;&lt;span&gt;foo&lt;/span&gt;&lt;/div&gt;').appendTo('body') jQuery(element or elementsArray)如果传入一个 DOM 元素或 DOM 元素数组，则把 DOM 元素封装到 jQuery 对象中并返回 123456789101112131415161718// 传入 DOM 元素$('li').each(function (index, ele) { $(ele).on('click', function () { // 这里的 DOM 元素就是 this $(this).css('background', 'red') })})// 传入 DOM 数组var aLi = document.getElementsByTagName('li')// 集合转数组aLi = [].slice.call(aLi)var $aLi = $(aLi)// 所有的 li 的内容都变成 `我是 jQuery 对象`$aLi.html(`我是 jQuery 对象`) jQuery(object)如果传入一个普通 JavaScript 对象，则把该对象封装到 jQuery 对象中并返回 12345678910111213// 定义一个普通 JavaScript 对象var foo = { foo: 'bar', hello: 'world' }// 封装成 jQuery 对象var $foo = $(foo)// 绑定一个事件$foo.on('custom', function () { console.log(`custom event was called`)});// 触发这个事件$foo.trigger('custom') // 在控制台打印 `custom event was called` jQuery(callback)当传进去的参数是函数的时候，则在 document 对象上绑定一个 ready 事件监听函数，当 DOM 结构加载完成的时候执行 123456$(function() { })// 以上代码和下面的效果是一样的$(document).ready(function () { // ...}) jQuery(jQuery object)如果传入一个 jQuery 对象，则创建该 jQuery 对象的一个副本并返回，副本与传入的 jQuery 对象引用完全相同的 DOM 元素 jQuery()如果不传入任何的参数，则返回一个空的 jQuery 对象，属性 length 为 0，这个功能可以用来复用 jQuery 对象，例如，创建一个空的 jQuery 对象，然后在需要时先手动修改其中的元素，再调用 jQuery 方法，从而避免重复创建 jQuery 对象 jQuery.fn.init()在了解完 jQuery 的总体架构以后，我们下面再来深入的了解一下初始化方法 jQuery.fn.init() 的构成，具体源码如下 1234567891011121314151617 16 (function (window, undefined) { // 构造 jQuery 对象 22 var jQuery = (function() { 25 var jQuery = function(selector, context) { 27 return new jQuery.fn.init(selector, context, rootjQuery) 28 }, // 省略 // 这一步操作我们下面会进行介绍，所以写在这里 322 jQuery.fn.init.prototype = jQuery.fn955 return jQuery957 })()9266 })(window) 我们可以发现，这里有一个 return new jQuery.fn.init() 操作，那么为什么要这样操作呢？其实在 JavaScript 当中我们知道，如果构造函数有返回值，运算符 new 所创建的对象会被丢弃，返回值将作为 new 表达式的值，所以 jQuery 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例，省去了构造函数 jQuery() 前面的运算符 new，即创建 jQuery 对象时，可以省略运算符 new 直接写 jQuery() 或者 $() 下面我们就来具体看看 jQuery.fn.init() 方法的构成 jQuery.fn.init() 和 jQuery.fn.init.prototype = jQuery.fn源码如下 1234567891011(function (window, undefined) { // ... jQuery.fn.init.prototype = jQuery.fn // 省略其他模块的代码 window.jQuery = window.$ = jQuery})(window) 当我们在调用 jQuery 构造函数时，实际返回的是 jQuery.fn.init() 的实例，在执行 jQuery.fn.init.prototype = jQuery.fn 时，用构造函数 jQuery() 的原型对象覆盖了构造函数 jQuery.fn.init() 的原型对象，从而使构造函数 jQuery.fn.init() 的实例也可以访问构造函数 jQuery() 的原型方法和属性，那么这里就存在一个问题了 为什么要覆盖构造函数 jQuery() 的原型对象 jQuery.prototype 因为在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，这样可以有效减少每个 jQuery 对象所需的内存，下面我们就正式来看一下 jQuery.fn.init() 这个方法 jQuery.fn.init(selector, context, rootjQuery)构造函数 jQuery.fn.init() 负责解析参数 selector 和 Context 的类型，并执行相应的逻辑，最后返回 jQuery.fn.init() 的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// （1）定义构造函数 jQuery.fn.init(selector, context, rootjQuery) 它接受 3 个参数// 参数 selector，可以是任意类型的值，但只有 undefined，DOM 元素，字符串，函数，jQuery 对象，普通 JavaScript 对象这几种类型是有效的// 参数 context，可以不传入，或者传入 DOM 元素，jQuery 对象，普通 JavaScript 对象之一// 参数 rootjQuery，包含了 document 的 jQuery 对象，用于 document.getElementById() 查找失败，selector 是选择器表达式且未指定 context，selector 是函数的情况init: function(selector, context, rootjQuery) { var match, elem, ret, doc // （2）参数 selector 可以转换为 false，例如是 undefined，空字符串，null 等则直接返回 this，此时 this 是空 jQuery 对象，其属性 length 等于 0 // 如果 selector 为空，比如 $(''), $(null), or $(undefined)，则返回空的 jQuery 对象 if (!selector) { // 此时 this 为空 jQuery 对象 return this } // （3）如果参数 selector 有属性 nodeType，则认为 selector 是 DOM 元素，比如 $(DOMElement) if (selector.nodeType) { // 将第一个元素和属性 context 指向 selector this.context = this[0] = selector this.length = 1 return this } // （4）如果参数 selector 是字符串 'body'，手动设置属性 context 指向 document 对象，第一个元素指向 body 元素，最后返回包含了 body 元素引用的 jQuery 对象 // 如果选中的是 body，则利用 !context 进行优化（因为 body 只会出现一次） if (selector === 'body' &amp;&amp; !context &amp;&amp; document.body) { // context 指向 document 对象 this.context = document this[0] = document.body this.selector = selector this.length = 1 return this } // （5）如果参数 selector 是其他字符串，则先检测 selector 是 HTML 代码还是类似 #id 这样的选择符 if (typeof selector === 'string') { // 如果是以 '&lt;' 开头 以 '&gt;' 结尾，且长度大于等于 3 if (selector.charAt(0) === \"&lt;\" &amp;&amp; selector.charAt(selector.length - 1) === \"&gt;\" &amp;&amp; selector.length &gt;= 3) { // 则跳过 queckExpr 正则检查，这里假设为 HTML 片段，比如 '&lt;div&gt;&lt;/p&gt;' match = [null, selector, null] } else { // 否则，用正则 quickExpr 检测参数 selector 是否是稍微复杂 // 一些的 HTML 代码（如'abc&lt;div&gt;' ）或 #id，匹配结果存放在数组 match 中 match = quickExpr.exec(selector) } // （6）如果参数 selector 是单独标签 // 根据上面正则返回的结果，调用 document.createElement() 创建标签对应的 DOM 元素 // 如果 match[1] 不是 undefined，即参数 selector 是 HTML 代码 // 或者 match[2] 不是 undefined，即参数 selector 是 #id，并且未传入参数 context // 所以就省略了对 match[2] 的判断，完整的表达式为 if (match &amp;&amp; (match[1] || match[2] &amp;&amp; !context)) if (match &amp;&amp; (match[1] || !context)) { // HANDLE: $(html) -&gt; $(array) // 开始处理参数 selector 是 HTML 代码的情况 if (match[1]) { // 先修正 context 和 doc context = context instanceof jQuery ? context[0] : context doc = (context ? context.ownerDocument || context : document) // 正则 rsingleTag 检测 HTML 代码是否是单独标签，匹配结果存放在数组 ret 中 // rsingleTag = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;)?$/ ret = rsingleTag.exec(selector) // 如果数组 ret 不是 null，则是单独标签，调用 document.createElement() 创建标签对应的 DOM 元素 if (ret) { // 如果 context 是普通对象，则调用 jQuery 方法 .attr() 并传入参数 context // 同时把参数 context 中的属性、事件设置到新创建的 DOM 元素上 if (jQuery.isPlainObject(context)) { // 之所以放在数组中，是方便后面的 jQuery.merge() 方法调用 selector = [document.createElement(ret[1])] // 调用 attr 方法，传入参数 context jQuery.fn.attr.call(selector, context, true) } else { selector = [doc.createElement(ret[1])] } // （7）如果参数 selector 是复杂 HTML 代码，则利用浏览器的 innerHTML 机制创建 DOM 元素 } else { ret = jQuery.buildFragment([match[1]], [doc]) selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes } return jQuery.merge(this, selector) // （8）参数 selector 是 '#id'，且未指定参数 context } else { elem = document.getElementById(match[2]) if (elem &amp;&amp; elem.parentNode) { // 即使是 documen.getElementById 这样核心的方法也要考虑到浏览器兼容问题，可能找到的是 name 而不是 id if (elem.id !== match[2]) { return rootjQuery.find(selector) } // 如果所找到元素的属性 id 值与传入的值相等，则设置第一个元素 // 属性 length、context、selector，并返回当前 jQuery 对象 this.length = 1 this[0] = elem } this.context = document this.selector = selector return this } // HANDLE: $(expr, $()) // （9）参数 selector 是选择器表达式 // 没有指定上下文，执行 rootjQuery.find()，指定了上下文且上下文是 jQuery 对象，执行 context.find() } else if (!context || context.jquery) { return (context || rootjQuery).find(selector) // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) // 如果指定了上下文，且上下文不是 jQuery 对象 } else { // 先创建一个包含 context 的 jQuery 对象，然后调用 find 方法 return this.constructor(context).find(selector) } // HANDLE: $(function) // （10）参数 selector 是函数 } else if (jQuery.isFunction(selector)) { return rootjQuery.ready(selector) } // selector 是 jquery 对象 // 如果参数 selector 含有属性 selector，则认为它是 jQuery 对象，将会复制它的属性 selector 和 context if (selector.selector !== undefined) { this.selector = selector.selector this.context = selector.context } // 参数 selector 是任意其他值，最后（合并）返回当前 jQuery 对象 return jQuery.makeArray(selector, this)}, 辅助方法关于架构方面的内容我们暂时就介绍这么多，下面我们再来看看 jQuery 当中的一些辅助方法，而这些辅助方法的实现方式也是我们在平时开发过程中可以去借鉴使用的，下面我们就先来看一些在源码当中经常可以看到的辅助方法 jQuery.noConflict([removeAll]) jQuery.isFunction(obj) jQuery.isArray(obj) jQuery.type(obj) jQuery.isWindow(obj) jQuery.isNumeric(value) jQuery.isPlainObject(object) jQuery.makeArray(obj) jQuery.inArray(value, array[, fromIndex]) jQuery.merge(first, second) jQuery.grep(array, function(elementOfArray, indexInArray)[, invert]) jQuery.noConflict([removeAll])方法 jQuery.noConflict([removeAll]) 用于释放 jQuery 对全局变量 $ 的控制权，可选参数 removeAll 表示是否释放对全局变量 jQuery 的控制权，$ 仅仅是 jQuery 的别名，没有 $ ，其余功能也是可以正常使用的（使用 jQuery），如果需要使用另一个 JavaScript 库，可以调用 $.noConflict() 返回 $ 给其他库 123456789101112131415161718192021222324// 先把可能存在的 window.jQuery 和 $ 备份到局部变量 _jQuery 和 _$ 上_jQuery = window.jQuery,_$ = window.$,jQuery.extend({ noConflict: function (deep) { // 只有当前 jQuery 库持有全局变量 $ 的情况下，才会释放 $ 的控制权给前一个 JavaScript 库 if (window.$ === jQuery) { window.$ = _$ } // 只有在当前 jQuery 库持有全局变量 jQuery 的情况下，才会释放 jQuery 的控制权给前一个 JavaScript 库 if (deep &amp;&amp; window.jQuery === jQuery) { window.jQuery = _jQuery } return jQuery }}),// ...略window.jQuery = window.$ = jQuery 如果有必要（例如，在一个页面中使用多个版本的 jQuery 库，但很少有这样的必要），也可以释放全局变量 jQuery 的控制权，只需要给这个方法传入参数 true 即可，从 jQuery 1.6 开始增加了对 window.$ === jQuery 的检测，如果不检测，则每次调用 jQuery.noConflict() 时都会释放 $ 给前一个 JavaScript 库，不过建议页面当中还是只保持一个对于 $ 的引用，因为当页面中有两个以上定义了 $ 的 JavaScript 库时，对 $ 的管理将会变得混乱 jQuery.isFunction(obj)， jQuery.isArray(obj)这两个方法主要用于判断传入的参数是否是函数（数组），这两个方法的实现依赖方法 jQuery.type(obj)，通过返回值是否是 function 或者 Array 来进行判断 1234567isFunction: function(obj) { return jQuery.type(obj) === 'function'},isArray: Array.isArray || function (obj) { return jQuery.type(obj) === 'array'}, jQuery.type(obj)这个方法主要用于判断参数的 JavaScript 类型，在平常的开发当中也是经常会遇到的，如果参数是 undefined 或 null，返回 'undefined' 或 'null'（注意是字符串类型），如果参数是内部对象，则返回对应的字符串名称，其他一律返回 Object 12345678910111213type: function (obj) { // 若为 undefined/null ==&gt; 转换为字符串 'undefined'/'null' return obj == null ? String(obj) // 以上的返回值形式为 [object class]，其中 class 是内部对象类 // 例如 Object.prototype.toString.call(true) 会返回 [object Boolean] // 然后从对象 class2type 中取出 [object class] 对应的小写字符串并返回 : class2type[toString.call(obj)] // 如果未取到则一律返回 object || 'object'}, 下面是原型方法 toString() 和 class2type 的定义及初始化 123456789101112131415161718192021toString = Object.prototype.toString,// [[Class]] ==&gt; type pairsclass2type = {}// class2type 的定义jQuery.each('Boolean Number String Function Array Date RegExp Object').split(' '), function (i, name) { class2type['[object' + name + ']'] = name.toLowerCase()}// 对象 class2type 初始化后的结构为{ '[object Array]': 'array' '[object Boolean]': 'boolean' '[object Date]': 'date' '[object Function]': 'function' '[object Number]': 'number' '[object Object]': 'object' '[object RegExp]': 'regexp' '[object String]': 'string'} jQuery.isWindow(obj)这个方法主要用于用于判断传入的参数是否是 window 对象，通过检测是否存在特征属性 setInterval 来实现 123456789// 1.7.2 之前isWindow: function (obj) { return obj &amp;&amp; typeof obj === 'object' &amp;&amp; 'setInterval' in obj},// 1.7.2 之后，该方法修改为检测特征属性 window, 该属性是对窗口自身的引用isWindow: function (obj) { return obj != null &amp;&amp; obj == obj.window} jQuery.isNumeric(value)这个方法主要用于用于判断传入的参数是否是数字，或者看起来是否像数字 123isNumeric: function (obj) { return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj)}, 先用 parseFloat(obj) 尝试把参数解析为数字，然后判断其是否合法，然后在使用 isFinite(obj) 判断其是否是有限的，均通过验证则返回 true jQuery.isPlainObject(object)用于判断传入的参数是否为纯粹的对象，即 {} 或 new Object() 创建的对象（使用 Object.create(null) 创建的空对象也是属于纯粹的对象） 123456789101112131415161718192021isPlainObject: function (obj) { if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) { return false } try { if (obj.constructor &amp;&amp; !hasOwn.call(obj, 'constructor') &amp;&amp; !hasOwn.call(obj.constructor.property, 'isPrototypeOf')) { return false } } catch (e) { return false } var key for (key in obj) { } return key === undefined || hasOwn.call(obj, key)}, 如果参数 obj 满足下列条件之一，则返回 false 参数 obj 可以转换为 false Object.prototype.toString.call(obj) 返回的不是 [object, Object] 参数 obj 是 DOM 元素 参数 obj 是 window 对象 如果不满足以上所有条件，则至少可以确定参数 obj 是对象，然后使用 try-catch 来检查对象 obj 是否由构造函数 Object() 创建，如果对象 obj 满足以下所有条件，则认为不是由构造函数 Object() 创建，而是由自定义构造函数创建，返回 false 对象 obj 含有属性 constructor，由构造函数创建的对象都有一个 constructor 属性，默认引用了该对象的构造函数，如果对象 obj 没有属性 constructor，则说明该对象必然是通过对象字面量 {} 创建的 对象 obj 的属性 constructor 是非继承属性，默认情况下，属性 constructor 继承自构造函数的原型对象，如果属性 constructor 是非继承属性，说明该属性已经在自定义构造函数中被覆盖 对象 obj 的原型对象中没有属性 isPrototypeOf，属性 isPrototypeOf 是 Object 原型对象的特有属性，如果对象 obj 的原型对象中没有，说明不是由构造函数 Object() 创建，而是由自定义构造函数创建 执行以上检测时抛出了异常，在 IE 8/9 中，在某些浏览器对象上执行以上检测时会抛出异常，也应该返回 false 函数 hasOwn() 指向 Object.prototype.hasOwnProperty(property)，用于检查对象是否含有执行名称的非继承属性，而最后的 for-in 则是检查对象 obj 的属性是否都是非继承属性，如果没有属性，或者所有属性都是非继承属性，则返回 true，如果含有继承属性，则返回 false，执行 for-in 循环时，JavaScript 会先枚举非继承属性，再枚举从原型对象继承的属性 最后，如果对象 obj 的最后一个属性是非继承属性，则认为所有属性都是非继承属性，返回 true，如果最后一个属性是继承属性，即含有继承属性，则返回 false jQuery.makeArray(obj)可以将一个类数组对象转换为真正的数组（类似于方法 Array.from()），在 jQuery 内部，还可以为方法 jQuery.makeArray() 传入第二个参数，这样一来，第一个参数中的元素被合并入第二个参数，最后会返回第二个参数，此时返回值的类型不一定是真正的数组 1234567891011121314151617181920212223242526272829303132333435push = Array.prototype.push,// 定义方法 makeArray() 接收两个参数// array 待转换的对象，可以是任何类型// results 仅在 jQuery 内部使用，如果传入参数 results，则在该参数上添加元素makeArray: function (array, results) { // 定义返回值，如果传入了参数 results 则把该参数作为返回值，否则新建一个空数组返回 var ret = results || [] // 过滤掉 null undefined if (array != null) { var type = jQuery.type(array) if (array.length == null || type === 'string' || type === 'function' || type === 'regexp' || jQuery.isWindow(array)) { // 之所以不是 ret.push(array) 是因为 ret 不一定是真正的数组，如果只传入 array，则返回值 // ret 是真正的数组，如果还传入了第二个参数，则返回值 ret 取决于该参数的类型 push.call(ret, array) } else { // 否则认为 array 是数组或类数组对象，执行合并 jQuery.merge(ret, array) } } // 返回 return ret} jQuery.inArray(value, array[, fromIndex])在数组中查找指定的元素并返回其下标，未找到则返回 -1 1234567891011121314151617181920212223242526272829303132333435// 定义方法 inArray 接收三个参数// elem 需要查找的值// array 数组，将遍历这个数组来查找参数 value 在其中的下标// i 指定开始的位置，默认是 0（即查找整个数组）inArray: function (elem, array, i) { var len // 过滤掉可以转换为 false 的情况 if (array) { // 如果支持 indexOf 这调用 indexOf 返回下标 if (indexOf) { return indexOf.call(array, elem, i) } len = array.length // 修正参数 i，如果未指定 i，则初始化为 0，表示从头开始 // 如果 i &lt; 0，则加上数组长度 len，即从末尾开始计算 // 调用 Math.max() 在 0 和 len + i 之间取最大值，如果 len + i 依然 &lt; 0 ，则修正为 0 ，从头开始 i = i ? i &lt; 0 ? Math.max(0, len + i) : i : 0 // 开始遍历，查找与指定值 elem 相等的元素，并返回其下标 for (; i &lt; len; i++) { // 如果 i in array 返回 false，则说明 array 的下标是不连续的，无需比较 if (i in array &amp;&amp; array[i] === elem) { return i } } } return -1} 通常我们会比较 jQuery.inArray() 的返回值是否大于 0 来判断某个元素是否是数组张的元素 123if (jQuery.inArray(elem, array) &gt; 0) { // elem 是 array 中的元素} 但是这种写法比较繁琐，可以利用按位非运算符（~）简化上面的代码 123if (~jQuery.inArray(elem, aray)) { // elem 是 array 中的元素} 按位非运算符（~）会将运算数的所有位取反，相当于改变它的符号并且减 1 1234~-1 == 0 // true~0 == -1 // true~1 == -2 // true~2 == -3 // true 更进一步，可以结合使用按位非运算符（~）和逻辑非运算符（!）把 jQuery.inArray() 的返回值转换为布尔类型 123// 如果 elem 可以匹配 array 中的某个元素，则该表达式的值为 true// 如果 elem 匹配不到 array 中的某个元素，则该表达式的值为 false!!~jQuery.inArray(elem, array) jQuery.merge(first, second)方法 jQuery.merge() 用于合并两个数组的元素到第一个数组中，事实上，第一个参数可以是数组或类数组对象，即必须含有整型（或可以转换为整型）属性 length，第二个参数则可以是数组，类数组对象或任何含有连续整型的对象，合并行为是不可逆的，即将第二个数组合并到第一个以后，第一个数组就改变了，如果不希望如此，则可以在调用 jQuery.merge() 之前创建一份数组的备份 1var newArray = $.merge([], oldArray) 方法 jQuery.merge() 的定义如下 123456789101112131415161718192021222324252627// 定义方法 jQuery.merge() 接收两个参数// first 数组或类对象，必须含有整型（或可以转换为整型）属性 length// second 数组，类数组对象或任何含有连续整型的对象，合并至 firstmerge: function (first, second) { // first.length 必须是整型或者可以转换为整型，否则后面 i++ 返回 NaN var i = first.length, j = 0 // 如果是数值类型，则当数组处理，添加至 first if (typeof second.length === 'number') { for (var l = second.length; j &lt; l; j++) { first[i++] = second[j] } // 如果没有 length，则当作含有连续整型属性的对象，例如 {0: 'a', 1: 'b'} // 把其中的非 undefined 元素逐个插入参数 first 中 } else { while (second[j] !== undefined) { first[i++] = second[j++] } } // 修正 length 因为 first 可能不是真正的数组 first.length = i // 返回参数 return first} jQuery.grep(array, function(elementOfArray, indexInArray)[, invert])用于查找数组当中满足过滤函数的元素，原数组不会受影响，如果参数 invert 没有传入或者为 false 元素只有在过滤函数返回 true，或者返回值可以转换为 true 的时候，才会被保存在最终的结果数组中，即返回一个满足回调函数的元素数组，如果参数 invert 为 true，则反之 1234567891011121314// 定义方法 jQuery.grep() 接收三个参数// array 待遍历查找的数组// callback 过滤每个元素的函数，执行的时候传入两个参数，当前元素和它的下标，返回一个布尔值// inv 如果参数 inv 是 false 或者没有传入，jQuery.grep() 会返回一个满足回调函数的元素数组，如果为 true，则返回一个不满足回调函数的元素数组grep: function (elems, callback, inv) { var ret = [], retVal, inv = !!inv for (var i = 0; length = elems.length, i &lt; length; i++) { retVal = !!callback(elems[i], i) if (inv !== retVal) { ret.push(elems[i]) } } return ret} 其他方法我们在上面介绍了源码当中的辅助函数，下面我们再来看看构造 jQuery 对象模块的原型属性和方法，因为它们当中某些方法都是依赖于其他的方法来进行实现的 123456789101112131415161718192021jQuery.fn = jQuery.prototype // 原型属性和方法 .constructor // 指向构造函数 jQuery().init(selector, context, rootjQuery) // 构造函数，解析参数 selector 和 context 的类型，并执行相应的逻辑，最后返回 jQuery.fn.init() 的实例.selector // 记录 jQuery 査找和过滤 DOM 元素时的选择器表达式.jquery // 正在使用的 jQuery 版本号.length // jQuery 对象中元素的个数.size() // 返回当前 jQuery 对象中元素的个数.toArray() // 将当前 jQuery 对象转换为真正的数组.get([index]) // 返回当前 jQuery 对象中指定位置的元素或包含了全部元素的数组.pushStack(elements, name, arguments) // 创建一个新的空 jQuery 对象，然后把 DOM 元素集合放入这个jQuery 对象中，并保留对当前 jQuery 对象的引用.each(function(index, Element)) // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数.ready(handler) // 绑定 ready 事件.eq(index) // 将匹配元素集合缩减为位于指定位置的新元素.first() // 将匹配元素集合缩减为集合中的第一个元素.last() // 将匹配元素集合缩减为集合中的最后一个元素.slice() // 将匹配元素集合缩减为指定范围的子集.map(callback(index, domElement)) // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数， 将回调函数的返回值放入一个新的 jQuery 对象中.end() // 结束当前链条中最近的筛选操作，并将匹配元素集合还原为之前的状态.push() // Array.prototype.push.sort() // [].sort.splice() // [].splice createSafeFragment(document)该方法的主要作用是用于处理兼容问题 12345678910111213function createSafeFragment(document) { var list = nodeNames.split('|') safeFrag = document.createDocumentFragment() if (safeFrag.createElement) { while (list.length) { safeFrag.createElement(list.pop()) } } return safeFrag}var nodeNames = 'abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video' 变量 nodeNames 中存放了所有的 html5 标签，createSafeFragment() 在传入的文档对象 document 上创建一个新的文档片段，然后在该文档片段上逐个创建 html5 元素，从而兼容不支持 html5 的浏览器，使之正确的解析和渲染 fixDefaultChecked(elem)主要用于修正复选框和单选按钮的选中状态 1234567891011121314151617// Used in clean, fixes the defaultChecked propertyfunction fixDefaultChecked(elem) { if (elem.type === 'checkbox' || elem.type === 'radio') { elem.defaultChecked = elem.checked }}// Finds all inputs and passes them to fixDefaultCheckedfunction findInputs(elem) { var nodeName = (elem.nodeName || '').toLowerCase() if (nodeName === 'input') { fixDefaultChecked(elem) // Skip scripts, get other children } else if (nodeName !== 'script' &amp;&amp; typeof elem.getElementsByTagName !== 'undefined') { jQuery.grep(elem.getElementsByTagName('input'), fixDefaultChecked) }} 遍历转换后的 DOM 元素集合，在每个元素上调用函数 findInputs(elem)，函数 findInputs(elem) 会找出其中的复选框和单选按钮，并调用函数 fixDefaultChecked(elem) 把属性 checked 的值赋值给属性 defaultChecked .pushStack(elements, name, arguments)原型方法 .pushStack() 创建一个新的空 jQuery 对象，然后把 DOM 元素集合放进这个 jQuery 对象中，并保留对当前 jQuery 对象的引用，它对 jQuery 对象遍历，DOM 查找，DOM 遍历，DOM 插入等方法提供支持 12345678910111213141516171819202122232425262728293031323334// 定义方法 .pushStack() 接收三个参数（即构建一个新的 jQuery 对象并入栈，新对象位于栈顶）// elems 将放入新 jQuery 对象的元素数组（或类数组）// name 产生元素数组 elems 的 jQuery 方法名// selector 传给 jQuery 方法的参数，用于修正原型属性 .selectorpushStack: function (elems, name, selector) { // 创建一个空的 jQuery 对象，this.constructor 指向构造函数 jQuery var ret = this.constructor() // 合并参数 elems if (jQuery.isArray(elems)) { // 如果是数组 push.apply(ret, elems) } else { // 不是数组的情况 jQuery.merge(ret, elems) } // 设置属性 prevObject， 指向当前 jQuery 对象，从而形成一个链式栈 ret.prevObject = this // 指向当前 jQuery 的上下文 ret.context = this.context // 在 ret 上设置属性 selector，方便调试 if (name === 'find') { ret.selector = this.selector + (this.selector ? ' ' : '') + selector } else if (name) { ret.selector = this.selector + '.' + name + '(' + selector + ')' } // 返回 ret return ret } .end()结束当前链中最近的筛选操作，并将匹配元素集合还原为之前的状态 123end: function() { return this.prevObject || this.constructor(null)} 返回一个 jQuery 对象，如果属性 prevObject 不存在，则构建一个空的 jQuery 对象返回，简单来说就是方法 pushStach() 用于入栈，而 end() 则用于出栈，比如 1234$('ul li').find('div').css('backgroundColor','red') .end() .find('span')css('backgroundColor','blue') .end() .eq(index)，.first()，.last()，.slice(start[, end])方法 .first() 和 .last() 通过调用 .eq(index) 实现，.eq(index) 主要通过 .slice(start[, end]) 来实现，而 .slice(start[, end]) 则是通过调用 .pushStack(elements, name, arguments) 实现，方法调用链为依次如下 .first()/last() ==&gt; .eq(index) ==&gt; .slice(start[, end]) ==&gt; .pushStack(elements, name, arguments) 12345678910111213141516171819eq: function(i) { // 如果 i 是字符串，就通过 '+i' 转换为数值 i = +i return i === -1 ? this.slice(i) : this.slice(i, i + 1)},first: function() { return this.eq(0)},last: function() { return this.eq(-1)},slice: function() { // 先借用数组方法 slice() 从当前 jQuery 对象中获取指定范围的子集（数组） // 再调用方法 .pushStack() 把子集转换为 jQuery 对象，同时通过其中的 prevObject 属性来保留对当前 jQuery 对象的引用 return this.pushStack(slice.apply(this, arguments), 'slice', slice.call(arguments).join(','))} .push(value, …), .sort([orderfunc]), .splice(start,deleteCount, value, …)方法 .push(value, ...) 向当前 jQuery 对象的末尾添加新元素，并返回新长度 12var foo = $(document)foo.push(document.body) // 2 方法 .sort([orderfunc]) 对当前 jQuery 对象中的元素进行排序，可以传入一个比较函数来指定排序方式 12345678var foo = $([33, 4, 1111, 222])foo.sort() // [1111, 222, 33, 4]foo.sort(function (a, b) { return a - b})// [4, 33, 222, 1111] 方法 .splice(start, deleteCount, value, ...) 向当前 jQuery 对象中插入, 删除或替换元素，如果从当前 jQuery 对象中删除了元素，则返回含有被删除元素的数组 12345var foo = $('&lt;div id=\"d1\" /&gt;&lt;div id=\"d2\" /&gt;&lt;div id=\"d3\" /&gt;')// [&lt;div id=\"d1\"&gt;&lt;/div&gt;, &lt;div id=\"d2\"&gt;&lt;/div&gt;, &lt;div id=\"d3\"&gt;&lt;/div&gt;]foo.splice(1, 2)// [&lt;div id=\"d2\"&gt;&lt;/div&gt;, &lt;div id=\"d3\"&gt;&lt;/div&gt;] 以上三个方法仅在内部使用，都指向同名的数组方法，因此它们的参数，功能和返回值与数组方法完全一致 123push: push,sort: [].sort,splice: [].splice jQuery.each(object, callback, args)关于 each() 方法有一个需要注意的地方，那就是要区分 $.each() 和 $(selector).each() 两者之间的区别，$(selector).each() 一般用于 jQuery 对象的遍历，它会为每个匹配元素规定要运行的函数 123$('ul li').each(function(){ alert($(this).text())}) 通过源码可知，each 方法实际上调用的就是 jQuery.each() 方法 1234567// ...each: function(callback, args) { return jQuery.each(this, callback, args)}// ... 而 $.each() 使用的范围就很广了，可用于遍历任何的集合（无论是数组或对象），下面是几个例子 1234567891011121314151617181920// 参数 i 为遍历索引值，n 为当前的遍历对象var arr = [{ name: 'zhangsan', email: 'zhangsan@gmail.com' }, { name: 'lisi', email: 'lisi@gmail.com' }]$.each(arr, function (i, n) { console.log(`索引: ${i} 对应值为：${n.name}`)})var arr1 = ['one', 'two', 'three', 'four', 'five']$.each(arr1, function () { console.log(this)})var arr2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]$.each(arr2, function (i, item) { console.log(item[0]) // 1 4 7})var obj = { one: 1, two: 2, three: 3, four: 4, five: 5 }$.each(obj, function (key, val) { console.log(obj[key]) // 1 2 3 4 5}) 方法 each() 遍历当前 jQuery 对象，并在每个元素上执行回调函数，每当回调函数执行时，会传递当前循环次数作为参数，循环次数从 0 开始计数，更重要的是，回调函数是在当前元素为上下文的语境中触发的，即关键字 this 总是指向当前元素，在回调函数中返回 false 可以终止遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// jQuery.each 方法用于遍历一个数组或对象,并对当前遍历的元素进行处理 // jQuery.each 方法可以为处理函数增加附带的参数（带参数与不带参数的回调使用方法不完全一致） // 静态方法 jQuery.each() 是一个通用的遍历迭代方法，用于无缝地遍历对象和数组// 对于数组和含有 length 属性的类数组对象（如函数参数对象 arguments），该方法通过下标遍历，从 0 到 length - 1// 对于其他对象则通过属性名遍历（for-in）// 在遍历过程中，如果回调函数返回 false，则终止遍历// ------------------------------------------// 总的来说就是：// 1. 对于对象，通过 for-in 循环遍历属性名，对于数组或类数组对象，则通过 for 循环遍历下标// 2. 如果传入了参数 args，使用 apply，执行回调函数时只传入一个参数 args// 3. 如果未传入参数 args，使用 call，执行回调函数时传入两个参数：下标或属性名，对应的元素或属性值// ------------------------------------------// 关于参数 args：传给回调函数 callback 的参数数组，可选// 如果没有传入参数 args，则执行回调函数时会传入两个参数（下标或属性名，对应的元素或属性值）// 如果传入了参数 args，则只把该参数传给回调函数each: function (object, callback, args) { // 当需要遍历的是一个对象时, name 变量用于记录对象的属性名 var name, // 当需要遍历的是一个数组时, i 变量用于记录循环的数组下标 i = 0, // 遍历数组长度,当需要遍历的对象是一个数组时存储数组长度 // 如果需要遍历的是一个对象, 则 length === undefined length = object.length, // 变量 isObj 表示参数 object 是对象还是数组，以便决定遍历方式 // 如果 object.length 是 undefined 或 object 是函数，则认为 object 是对象，设置变量 isObj 为 true，将通过属性名遍历 // 否则认为是数组或类数组对象，设置变量 isObj 为 false，将通过下标遍历 isObj = length === undefined || jQuery.isFunction(object) // 回调函数具有附加参数时, 执行第一个分支 // if(!!args) { if (args) { // 需要遍历的是一个对象 if (isObj) { // 遍历对象属性, name 是对象的属性名,再函数顶部已声明 for (name in object) { // 调用 callback 回调函数, 且回调函数的作用域表示为当前属性的值 if (callback.apply(object[name], args) === false) { // 如果在 callback 回调函数中使用 return false 则不执行下一次循环 break } } // 需要遍历的是一个数组 } else { // 循环变量的自增在循环内部执行 for (; i &lt; length;) { // 调用 callback 函数, 与上面的 callback 调用一致 // 此处 callback 函数中的 this 指向当前数组元素 // 根据下标 i 依次执行 if (callback.apply(object[i++], args) === false) { break } } } // 回调函数没有附加参数时,执行第二个分支 } else { // 需要遍历的是一个对象 if (isObj) { for (name in object) { // 调用 callback 回调函数 // 在不带参数的对象遍历中, 作用域表示为当前属性的值 // 且回调函数包含两个参数, 第一个数当前属性名, 第二个是当前属性值 if (callback.call(object[name], name, object[name]) === false) { // 作用同上 break } } // 需要遍历的是一个数组 } else { for (var value = object[0]; i &lt; length &amp;&amp; callback.call(value, i, value) !== false; value = object[++i]) { } } } // jQuery 并没有把以上两段很相似的代码合并，这是因为在合并后需要反复判断变量 isObj 的值，避免性能下降 // 返回 object ，方法 .each 调用 jQuery.each() 的时候，把当前的 jQuery 对象作为参数 object 传入 // 在这里返回该参数，以支持链式语法 return object} jQuery.extend([deep], target, object1[, objectN])先来看看怎么使用 1234$.extend(target [, object1 ] [, objectN ])// 可以添加参数来指示是否深度合并$.extend([deep ], target, object1 [, objectN ]) 需要注意的是，第一个参数不支持传递 false 取值 释义 deep 可选，布尔类型，指示是否深度合并对象，默认为 false，如果该值为 true，且多个对象的某个同名属性也都是对象，则该对象的属性也将进行合并 target Object 类型，目标对象，其他对象的成员属性将被附加到该对象上 object1 可选，Object 类型，第一个被合并的对象 objectN 可选，Object 类型，第 N 个被合并的对象 简单来说，该方法的作用是用一个或多个其他对象来扩展一个对象，返回扩展后的对象，如果不指定 target，则是给 jQuery 命名空间本身进行扩展（有利于为 jQuery 增加新方法），如果第一个参数设置为 true，则 jQuery 返回一个深层次的副本，递归的复制找到的任何对象，否则的话副本会与原对象共享结构 未定义的属性不会被复制，然而从对象的原型继承的属性将会被复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283jQuery.extend = jQuery.fn.extend = function () { // 定义局部变量，参数介绍如下 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false // options 指向某个源对象 // name 表示某个源对象的某个属性名 // src 表示目标对象的某个属性的原始值 // copy 表示某个源对象的某个属性的值 // copyIsArray 指示变量 copy 是否是数组 // clone 表示深度复制时原始值的修正值 // target 指向目标对象 // i 表示源对象的起始下标 // length 表示参数的个数，用于修正变量 target // deep 指示是否执行深度复制，默认为 false // 修正目标对象 target、源对象起始下标 i // 如果第一个参数是布尔，则修正为第一个为 deep，第二个为 target，期望对象从第三个元素开始 // 若第一个不是布尔，则是期望第二个元素开始（i 初始为 1） if (typeof target === \"boolean\") { deep = target target = arguments[1] || {} i = 2 } // 如果 target 不是对象，函数，统一替换为 {} （因为在基本类型上设置非原生属性是无效的） if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) { target = {} } // 如果两者相等，表示期望的源对象没有传入，则把 jQuery 和 jQuery.fn 作为目标，并且把源对象开始下标减一 // 从而使得传入的对象被当作源对象，相等有两种情况 // 1. extend(object) 只传入了一个参数 // 2. extend(deep, object) 第一个参数为布尔 if (length === i) { target = this --i } // 逐个遍历源对象 for (; i &lt; length; i++) { // 遍历源对象的属性 if ((options = arguments[i]) !== null) { for (name in options) { // 覆盖目标对象的同名属性 src = target[name] copy = options[name] // 避免 src（原始值）与 copy（复制值）相等进入死循环 if (target === copy) { continue } // 如果原始值 src 不是数组 ==&gt; 修正为空数组 // 复制值是普通 javaScript 对象，如果原始值 src 不是普通 javaScript 对象 ==&gt; 修正为 {}，修正后的 src 赋值给原始值的副本 clone // 调用 jQuery.isPlainObject(copy) 判断复制值 copy 是否为纯粹的 javaScript 对象 // 只有通过对象直接量 {} 或 new Object() 创建的对象，才会返回 true if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) { if (copyIsArray) { copyIsArray = false clone = src &amp;&amp; jQuery.isArray(src) ? src : [] } else { clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : [] } // 递归合并 copy 到 clone 中，然后覆盖对象的同名属性 target[name] = jQuery.extend(deep, clone, copy) // 如果不是深度合并，且不为 undefined，则直接覆盖目标的对象的同名属性 } else if (copy !== undefined) { target[name] = copy } } } }} jQuery.buildFragment(args, nodes, scripts)jQuery.buildFragment() 是一个私有函数，用来构建一个包含子节点 fragment 对象，但是关于 jQuery.buildFragment(args, nodes, scripts) 方法有一些需要注意的地方 如果 HTML 代码符合缓存条件，则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素 创建文档片段 DocumentFragment 调用方法 jQuery.clean(elems, context, fragment, scripts) 将 HTML 代码转换为 DOM 元素，并存储在创建的文档片段中 如果 HTML 代码符合缓存条件，则把转换后的 DOM 元素放入缓存对象 jQuery.fragments 最后返回文档片段和缓存状态 {fragment: fragment, cacheable: cacheable} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// （1）定义函数 buildFragmentjQuery.buildFragment = function (args, nodes, scripts) { // （2）定义局部变量，修正文档对象 doc // 变量 fragment 指向稍后可能创建的文档片段 Document Fragment // 变量 cacheable 表示 HTML 代码是否符合缓存条件 // 变量 cacheresults 指向从缓存对象jQuery.fragments 中取到的文档片段，其中包含了缓存的 DOM 元素 // 变量 doc 表示创建文档片段的文档对象 var fragment, cacheable, cacheresults, doc, first = args[0] if (nodes &amp;&amp; nodes[0]) { // ownerDocument 表示 DOM 元素所在的文档对象，如果 ownerDocument 不存在，则假定 nodes[0] 为文档对象 doc = nodes[0].ownerDocument || nodes[0] } // 然后再次检查 doc.createDocumentFragment 是否存在 if (!doc.createDocumentFragment) { doc = document } // （3）尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素 // html 代码需要满足下列所有条件，才认为符合缓存条件 if (args.length === 1 &amp;&amp; typeof first === \"string\" &amp;&amp; first.length &lt; 512 &amp;&amp; doc === document &amp;&amp; first.charAt(0) === \"&lt;\" &amp;&amp; // 使用的正则方法如下 // rnocache = /&lt;(?:script|object|embed|option|style)/i, // checked = \"checked\" or checked // rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, !rnocache.test(first) &amp;&amp; (jQuery.support.checkClone || !rchecked.test(first)) &amp;&amp; // var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + // \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\" // var rnoshimcache = new RegExp(\"&lt;(?:\" + nodeNames + \")[\\\\s/&gt;]\", \"i\") (jQuery.support.html5Clone || !rnoshimcache.test(first))) { // 如果为 true，则必须先复制一份再使用，否则可以直接使用 cacheable = true // 读取缓存 cacheresults = jQuery.fragments[first] if (cacheresults &amp;&amp; cacheresults !== 1) { fragment = cacheresults } } jQuery.fragments = {} // （4）转换 HTML 代码为 DOM 元素 // 创建文档片段 // 如果 !fragment 为 true，表示需要执行转换过程，有三种可能 // 1） html 代码不符合缓存条件 // 2） html 代码符合，但是是第一次转换，没有对应的缓存 // 3） html 代码符合，但是是第二次转换，对应的缓存值为 1 if (!fragment) { fragment = doc.createDocumentFragment() jQuery.clean(args, doc, fragment, scripts) } // （5）转换后的dom元素放入 jQuery.fragments if (cacheable) { jQuery.fragments[first] = cacheresults ? fragment : 1 } // 返回文档片段和缓存状态 {fragment: fragment, cacheable: cacheable} // fragment 中包含转换后的 dom 元素，cacheable 表示缓存状态 return { fragment: fragment, cacheable: cacheable }} jQuery.buildFragment() 的用法总结为 如果 HTML 代码不符合缓存条件，则总是会执行转换过程 如果 HTML 代码符合缓存条件，第一次转换后设置缓存值为 1，第二次转换后设置为文档片段，从第三次开始则从缓存中读取 jQuery.clean(elems, context, fragment, scripts)方法 jQuery.clean(elems, context, fragment, scripts) 负责把 HTML 代码转换成 DOM 元素，并提取其中的 script 元素 创建一个临时 div 元素，并插入一个安全文档片段中 为 HTML 代码包裹必要的父标签，然后用 innerHTML 赋值给临时 div ，从而将 HTML 代码转换为 DOM 元素，之后再层层剥去包裹的父元素，得到转换后的 DOM 元素 移除 IE 6/7 自动插入的空 tbody 元素，插入 IE 6/7/8 自动剔除的前导空白符 取到转换后的 DOM 元素集合 在 IE 6/7 中修正复选框和单选按钮的选中状态 合并转换后的 DOM 元素 如果传入了文档片段 fragment，则提取所有合法的 script 元素存入数组 scripts，并把其他元素插入文档片段 fragment 最后返回转换后的 DOM 元素数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// （1）定义函数// elems 数组，包含了待转换的 html 代码// context 文档对象，被 buildFragment() 修正（doc），用于创建文本节点和临时 div// fragment 文档片段，用于存放转换后的 dom 元素// scripts 数组，用于存放转换后的 dom 元素中的 script 元素clean: function(elems, context, fragment, scripts) { var checkScriptType // （2）修正（再次修正是是为了方便直接调用 jQuery.clean() 转换 HTML 代码为 DOM 元素） context = context || document if (typeof context.createElement === 'undefined') { context = context.ownerDocument || context[0] &amp;&amp; context[0].ownerDocument || document } // （3）遍历待转换的 HTML 代码数组 elems // ret用于存放转换后的 dom 元素 var ret = [], j // 在 for 语句的第 2 部分取出 elems[i] 赋值给 elem，并判断 elem 的有效性，传统的做法可能是比较循环变 // 量 i 与 elems.length，然后在 for 循环体中把 elems[i] 赋值给elem，再判断 elem 的有效性 // 另外，判断 elem 的有效性时使用的是 '!='，这样可以同时过滤 null 和 undefined，却又不会过滤整型数字 0 for (var i = 0, elem; (elem = elems[i]) != null; i++) { // 如果是数值型，加上一个空字符串，即把 elem 转换为字符串 if (typeof elem === 'number') { elem += '' } // 用于过滤空字符串，如果是数字 0，前面已经被转换为字符串 '0' 了，elem 为 false 则跳过本次循环 if (!elem) { continue } // 若是 html 代码 if (typeof elem === 'string') { // 创建文本节点 // 使用正则如下，作用是检测代码中是否含有标签，字符代码，数字代码 // rhtml = /&lt;|&amp;#?\\w+;/ // 调用 document.cerateTextNode() 创建文本节点 if (!rhtml.test(elem)) { elem = context.createTextNode(elem) // 修正自关闭标签，使用正则如下 // rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig } else { elem = elem.replace(rxhtmlTag, '&lt;$1&gt;&lt;/$2&gt;') // 创建临时 div 元素 // 使用正则如下 // rtagName = /&lt;([\\w:]+)/ // 提取 html 中标签，删除前导空白符和左尖括号 var tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, deoth = wrap[0], div = context.createElement('div') // 如果传入的文档对象 context 是当前文档对象，则把临时 div 插入 safeFragment 中 // 否则调用 createSafeFragment() 新建一个安全文档碎片（低版本浏览器也能识别的）在插入 if (context === document) { safeFragment.appendChild(div) } else { createSafeFragment(context).appendChild(div) } // 包裹必要父元素，赋给临时 div div.innerHTML = wrap[1] + elem + wrap[2] // 用 while 循环层层剥去包裹的父元素，最终变量 div 将指向 HTML代码对应的 DOM 元素的父元素 while (depth--) { div = div.lastChild } // 省略 // 移除 IE 6/7 自动插入的空 tbody 元素 ... // 插入 IE 6/7/8 自动剔除的前导空白符 ... // 取到转换后的 DOM 元素集合 elem = div.childNodes // 省略 // 在 IE 6/7 中修正复选框和单选按钮的选中状态 ... if (elem.nodeType) { ret.push(elem) } else { ret = jQuery.merge(ret, elem) } } } } // 如果传入文档片段 fragment 的情况 // 遍历数组 ret，提取 script 存入 [scripts]，将其他元素插入文档片段 fragment if (fragment) { // 初始化函数 checkScriptType，用于检测 script 元素是否是可执行 // 使用正则如下 // rscriptType = /\\/(java|ecma)script/i checkScriptType = function (elem) { return !elem.type || rscriptType.test(elem.type) } for (i = 0; ret[i]; i++) { if (scripts &amp;&amp; jQuery.nodeName(ret[i], 'script') &amp;&amp; (!ret[i].type || ret[i].type.toLowerCase() === 'text/javascript')) { scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]) } else { if (ret[i].nodeType === 1) { var jsTags = jQuery.grep(ret[i].getElementsByTagName('script'), checkScriptType) ret.splice.apply(ret, [i + 1, 0].concat(jsTags)) } fragment.appendChild(ret[i]) } } } // 返回数组 ret // 但是要注意，如果传入了文档片段 fragment 和数组 scripts // 那么调用 jQuery.clean() 的代码应该从文档片段 fragment 中读取转换后的 DOM 元素，并从数组 scripts 中读取合法的 script 元素 // 如果未传入，则只能使用返回值 ret return ret}","link":"/2017/06/23/JavaScript/15/"},{"title":"HTTP 查漏补缺","text":"本章记录的是一些 HTTP 相关内容的补充，偏向于查漏补缺，主要是一些平常遇到或是看到过的知识点，面试题之类的，在这里简单的整理汇总一下，一方面补充些专业知识，另一方面也是方便以后查询或是复习，更多相关内容可以参考 前端知识体系整理 HTTP 协议优缺点 HTTP 特点 灵活可扩展，一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等，另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据 请求/响应 模式，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等 可靠传输，HTTP 是基于 TCP/IP，TCP 提供可靠的字节流服务，IP 协议的作用是把各种数据传送给对方 HTTP 缺点 无连接，限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接 无状态，对于事务处理没有记忆能力，即服务器不知道客户端是什么状态 明文传输，协议里的报文不使用二进制数据，而是文本形式，这让 HTTP 的报文信息暴露给了外界，给攻击者带来了便利 队头阻塞，当 HTTP 开启长连接时，共用一个 TCP 连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题 HTTP 协议各版本差异 HTTP/0.9 1991 年发布的原型版本，功能简陋，只有一个命令 GET，只支持纯文本内容 HTTP/1.0 任何格式的内容都可以发送，另外还引入了 POST 命令和 HEAD 命令 HTTP 请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息，用来描述一些元数据 只使用请求头中的 If-Modified-Since 和 Expires 字段作为缓存失效的标准 不支持断点续传，也就是说，每次都会传送全部的页面和数据 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名 HTTP/1.1 引入了持久连接 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive，长连接的连接时长可以通过请求头中的 keep-alive 来设置 引入了管线机制（Pipelining） 在同一个 TCP 连接里，客户端可以同时发送多个请求 新增缓存控制标头 添加了 E-tag，If-Unmodified-Since，If-Match，If-None-Match 等缓存控制标头来控制缓存失效 支持断点续传 通过使用请求头中的 Range 来实现 使用了虚拟网络 在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址 新增方法 PUT、PATCH、OPTIONS、DELETE HTTP/2 二进制分帧 采用二进制格式，这样报文格式就被拆分为一个个乱序的二进制帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据等，因为不需要排队等待，一定程度上解决了队头阻塞问题 头部压缩 HTTP/1.1 版本会出现 User-Agent/Cookie/Accept/Server/Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，导致头部偏重，HTTP/2 使用 HPACK 算法进行压缩 多路复用 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，一定程度上解决了队头阻塞的问题 服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送 请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验 HTTP/3 QUIC 协议 运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3，QUIC 协议基于 UDP 实现，同时也整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化 零 RTT 建立连接 首次连接只需要 1 RTT，后面的连接更是只需 0 RTT，意味着客户端发给服务端的第一个包就带有请求数据 连接迁移 QUIC 连接不以四元组（源 IP、源端口、目的 IP、目的端口）作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持 多路复用 QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题 QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理 改进的拥塞控制 热插拔，TCP 中如果要修改拥塞控制策略，需要在系统层面进行操作，QUIC 修改拥塞控制策略只需要在应用层操作，并且 QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法 前向纠错 FEC，使用前向纠错（FEC，Forward Error Correction）技术增加协议的容错性，一段数据被切分为 10 个包后，依次对每个包进行异或运算，运算结果会作为 FEC 包与数据包一起被传输，如果不幸在传输过程中有一个数据包丢失，那么就可以根据剩余 9 个包以及 FEC 包推算出丢失的那个包的数据 单调递增的 Packet Number，与 TCP 的 Sequence Number 不同的是，Packet Number 严格单调递增，如果 Packet N 丢失了，那么重传时 Packet 的标识不会是 N，而是比 N 大的数字，比如 N + M，这样发送方接收到确认消息时就能方便地知道 ACK 对应的是原始请求还是重传请求 更多的 ACK 块，QUIC 最多可以捎带 256 个 ACK block，在丢包率比较严重的网络下，更多的 ACK block 可以减少重传量，提升网络效率 流量控制 TCP 会对每个 TCP 连接进行流量控制，而 QUIC 只需要建立一条连接，在这条连接上同时传输多条 Stream 队头阻塞问题关于队头阻塞问题，其实在整理 HTTP/1.1，HTTP/2 和 HTTP/3 相关内容的时候都有所涉及，但是可能是东一点西一点分散在各处，所以在这里就简单的汇总和梳理一下 什么是队头阻塞？对于每一个 HTTP 请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是 HTTP 队头阻塞问题，队头阻塞会导致带宽无法被充分利用，以及后续健康请求被阻塞，假设有五个请求同时发出，如下图 在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求 2，3，4，5 只能等待请求 1 的响应回来之后才能逐个发出，网络通畅的时候性能影响不大，一旦请求 1 因为什么原因没有抵达服务器，或者响应因为网络阻塞没有及时返回，影响的就是所有后续请求 如何解决在 HTTP/1.1 当中，为了解决队头阻塞带来的延迟，协议设计者设计了一种新的 HTTP 管线化机制（pipelining），管线化的流程图可以用下图表示 和之前相比最大的差别是，请求 2，3，4，5 不需要等待请求 1 的响应返回之后才发出，而是几乎在同一时间就把请求发向了服务器，2，3，4，5 及所有后续共用该连接的请求节约了等待的时间，极大的降低了整体延迟，下图可以清晰的看出这种新机制对延迟的改变 不过管线化并不是完美的，它也存在不少缺陷 管线化只能适用于 HTTP/1.1 ，一般来说，支持 HTTP/1.1 的服务端都要求支持管线化 只有幂等的请求（GET，HEAD）能使用管线化，非幂等请求比如 POST 不能使用，因为请求之间可能会存在先后依赖关系 队头阻塞并没有完全得到解决，服务端的响应还是要求依次返回，遵循 FIFO（first in first out）原则，也就是说如果请求 1 的响应没有回来，2，3，4，5 的响应也不会被送回来 绝大部分的 HTTP 代理服务器不支持管线化 正是因为有这么多的问题，各大浏览器厂商要么是根本就不支持管线化，要么就是默认关掉了管线化机制，而且启用的条件十分苛刻，可以参考 Chrome 对于管线化的 问题描述 接下来，在 HTTP/2 当中提出了多路复用（multiplexing）的解决方案（源自 SPDY），多路复用允许同时通过单一的 HTTP/2 连接发起多重的 请求/响应 消息，众所周知在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞，也就是如果想并发多个请求，必须使用多个 TCP 链接 这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题，而 HTTP/2 的多路复用（Multiplexing）则允许同时通过单一的 HTTP/2 连接发起多重的 请求/响应 消息 因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个 TCP 连接上双向交换消息 HTTP/2 虽然可以解决请求这个粒度的阻塞，但 HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题，HTTP/2 的每个请求都会被拆分成多个 Frame，不同请求的 Frame 组合成 Stream，Stream 是 TCP 上的逻辑传输单元，这样 HTTP/2 就达到了一条连接同时发送多条请求的目标，这就是多路复用的原理 我们看一个例子，在一条 TCP 连接上同时发送 4 个 Stream，其中 Stream1 已正确送达，Stream2 中的第 3 个 Frame 丢失，TCP 处理数据时有严格的前后顺序，先发送的 Frame 要先被处理，这样就会要求发送方重新发送第 3 个 Frame，Stream3 和 Stream4 虽然已到达但却不能被处理，那么这时整条连接都被阻塞 不仅如此，由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题，TLS 基于 Record 组织数据，将一堆数据放在一起（即一个 Record）加密，加密完后又拆分成多个 TCP 包传输，一般每个 Record 有 16K 左右，包含 12 个 TCP 包，这样如果 12 个 TCP 包中有任何一个包丢失，那么整个 Record 都无法解密 队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢，所以就有了 HTTP/3 当中的 QUIC 协议，那么 QUIC 是如何解决队头阻塞问题的呢？主要有两点 QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题 QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理 HTTP 数据传输这里主要分为定长数据与不定长数据的处理，我们一个一个来看 定长数据对于定长的数据包而言，发送端在发送数据的过程中，需要设置 Content-Length，来指明发送数据的长度，当然如果采用 Gzip 压缩的话，Content-Length 设置的就是压缩后的传输长度，另外 Content-Length 如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时 如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度 那么在 HTTP/1.0 之前的版本中，Content-Length 字段可有可无，因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了 在 HTTP/1.1 版本中，如果是 keep-alive 的话，chunked 优先级高于 Content-Length，若是非 keep-alive，则跟前面情况一样，Content-Length 可有可无 下面我们来看看如何设置 Content-Length，代码如下 1234567891011121314const server = require('http').createServer()server.on('request', (req, res) =&gt; { if (req.url === '/index') { // 设置数据类型 res.setHeader('Content-Type', 'text/plain') res.setHeader('Content-Length', 10) res.write(`使用 Content-Length 设置传输数据形式`) }})server.listen(3000, _ =&gt; { console.log(`app is running at port 3000`)}) 不定长数据现在采用最多的就是 HTTP/1.1 版本来完成传输数据，在保存 keep-alive 状态下，当数据是不定长的时候，我们需要设置新的头部字段 Transfer-Encoding: chunked，通过 chunked 机制，可以完成对不定长数据的处理，但是也有需要注意的地方 如果头部信息中有 Transfer-Encoding，优先采用 Transfer-Encoding 里面的方法来找到对应的长度 如果设置了 Transfer-Encoding，那么 Content-Length 将被忽视 使用长连接的话，会持续的推送动态内容 1234567891011121314151617181920212223const server = require('http').createServer()server.on('request', (req, res) =&gt; { if (req.url === '/index') { // 设置数据类型 res.setHeader('Content-Type', 'text/html; charset=utf8') res.setHeader('Content-Length', 10) res.setHeader('Transfer-Encoding', 'chunked') res.write(`使用 Content-Length 设置传输数据形式`) setTimeout(() =&gt; { res.write(`第一次的数据`) }, 1000) res.write(`----`) setTimeout(() =&gt; { res.write(`第二次的数据`) res.end() }, 3000) }})server.listen(3000, _ =&gt; { console.log(`app is running at port 3000`)}) SSL 连接断开后如何恢复一共有两种方法来恢复断开的 SSL 连接，一种是使用 Session ID，一种是 Session Ticket 通过 Session ID使用 Session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把，目前所有的浏览器都支持这一种方法，但是这种方法有一个缺点是，Session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话 通过 Session Ticket另一种方式是 Session Ticket 的方式，Session Ticket 是服务器在上一次对话中发送给客户的，这个 Ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等，这样不管我们的请求是否转移到其他的服务器上，当服务器将 Ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了 短轮询、长轮询和 WebSocket 间的区别 短轮询 短轮询的基本思路是，浏览器每隔一段时间向浏览器发送 HTTP 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应，这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化 优缺点 优点是比较简单，易于理解 缺点是这种方式由于需要不断的建立 HTTP 连接，严重浪费了服务器端和客户端的资源，当用户增加时，服务器端的压力就会变大，这是很不合理的 长轮询 长轮询的基本思路，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新，如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回，客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接 优缺点 长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 HTTP 请求次数，相比之下节约了资源 长轮询的缺点在于，连接挂起也会导致资源的浪费 WebSocket WebSocket 是 HTML5 定义的一个新协议，与传统的 HTTP 协议不同，该协议允许由服务器主动的向客户端推送信息 优缺点 优点是 WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息 缺点在于如果需要使用 WebSocket 协议，服务器端的配置比较复杂 至于什么是单工、半双工、全双工，区别如下表所示 类型 能力 单工 信息单向传送 半双工 信息能双向传送，但不能同时双向传送 全双工 信息能够同时双向传送 正向代理和反向代理 正向代理，我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求 反向代理，这种代理模式下，它隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现负载平衡 负载平衡的两种实现方式 一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡 另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡，因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址，当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求，以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡 但是 DNS 的方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题 HTTP 缓存策略关于缓存策略，我们之前在 浏览器缓存机制 一节当中已经详细整理过，这里我们在简单梳理一下，总的分为两种策略，即强缓存和协商缓存，下面我们一个一个来看 强缓存简单总结一下 强缓存有两个相关字段，Expires 和 Cache-Control 分为两种情况，一种是发送 HTTP 请求，一种不需要发送 首先检查强缓存，这个阶段不需要发送 HTTP 请求，通过查找不同的字段来进行，不同的 HTTP 版本所以不同 HTTP/1.0 版本，使用的是 Expires，HTTP/1.1 使用的是 Cache-Control ExpiresExpires 即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求，比如下面这样 1Expires: Mon, 29 Jun 2019 11:10:23 GMT 表示该资源在 2019 年 7 月 29 日 11:10:23 过期，过期时就会重新向服务器发起请求，但是这种方式是存在一些问题的，比如服务器的时间和浏览器的时间可能并不一致，所以 HTTP/1.1 提出新的字段代替它 Cache-ControlHTTP/1.1 版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是 max-age 1Cache-Control: max-age = 6000 上面代表该资源返回后 6000 秒，可以直接使用缓存，还有其他一些相关指令，使用方式可以参考上文链接，这里需要注意的几点 当 Expires 和 Cache-Control 同时存在时，优先考虑 Cache-Control 当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存 协商缓存强缓存失效后，浏览器在请求头中携带响应的缓存 Tag 来向服务器发送请求，服务器根据对应的 Tag，来决定是否使用缓存 缓存分为两种，Last-Modified 和 ETag，两者各有优势，并不存在谁对谁有绝对的优势，这点与上面所讲的强缓存当中的两个 Tag 有所不同 Last-Modified这个字段表示的是最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段，浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间，服务器拿到请求头中的 If-Modified-Since 的字段后，其实会和这个服务器中该资源的最后修改时间对比 如果请求头中的这个值小于最后修改时间，说明是时候更新了，返回新的资源，跟常规的 HTTP 请求响应的流程一样 否则返回 304，告诉浏览器直接使用缓存 ETagETag 是服务器根据当前文件的内容，对文件生成唯一的标识，比如 MD5 算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器，浏览器接收到 ETag 值，会在下次请求的时候，将这个值作为 If-None-Match 这个字段的内容，发给服务器 服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对 如果两者一样的话，直接返回 304，告诉浏览器直接使用缓存 如果不一样的话，说明内容更新了，返回新的资源，跟常规的 HTTP 请求响应的流程一样 两者对比 性能上，Last-Modified 优于 ETag，Last-Modified 记录的是时间点，而 Etag 需要根据文件的 MD5 算法生成对应的 Hash 值 精度上，ETag 优于 Last-Modified，ETag 按照内容给资源带上标识，能准确感知资源变化，Last-Modified 在某些场景并不能准确感知变化，比如 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效 Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了 最后，如果两种方式都支持的话，服务器会优先考虑 ETag 缓存位置下面我们来看看，如果考虑使用缓存的话，那么缓存的位置在哪里呢？其实浏览器缓存的位置的话，可以分为四种，优先级从高到低排列分别 Service Worker Memory Cache Disk Cache Push Cache Service WorkerService Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的 PWA 的实现也是和这个有关，它借鉴了 Web Worker 思路，由于它脱离了浏览器的窗体，因此无法直接访问 DOM，它能完成的功能比如离线缓存、消息推送和网络代理，其中离线缓存就是 Service Worker Cache Memory Cache指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了 Disk Cache存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长，与 Memory Cache 对比的话，主要的策略如下 内容使用率高的话，文件优先进入磁盘 比较大的 JavaScript，CSS 文件会直接放入磁盘，反之放入内存 Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有五分钟左右 更多 Push Cache 更多内容可以参考 HTTP/2 push is tougher than I thought 总结 首先检查 Cache-Control，看强缓存是否可用如果可用的话，直接使用 否则进入协商缓存，发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 字段检查资源是否更新资源更新，返回资源和 200 状态码 否则返回 304，直接告诉浏览器直接从缓存中去资源 TCP 如何保证可靠传输TCP 协议保证数据传输可靠性的方式主要有以下几种方式 校验和，TCP 在发送报文之前，发送方要计算校验和，收到数据后，接收方也要计算校验和，如果校验和不相等则丢弃 序列号与确认应答 序列号，TCP 传输时将每个字节的数据都进行了编号，这就是序列号 确认应答，TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发 序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据，这也是 TCP 传输可靠性的保证之一 超时重传，在 TCP 传输过程中，我们在发送一部分数据后，都会等待对方的 ACK 确认报文，如果中间出现差错，没有收到 ACK 报文，这时候需要启动超时重传机制，这种超时重传机制保证了 TCP 在网络延迟或者报文丢失下的可靠传输，超时的原因主要有以下两点 接收方没有收到 TCP 报文段，网络延迟或者丢包 发送方没有收到 ACK 报文段，网络延迟或者 ACK 报文丢失 连接管理，连接管理就是三次握手与四次挥手的过程 流量控制，流量控制的目的是让接收方来得及接收数据，这样避免了数据丢包以及网络拥塞等情况 拥塞控制，拥塞控制就是防止过多的数据注入到网络中，这样使网络中的路由器或者链路不至于过载（四个核心算法，慢启动、拥塞避免、快速重传和快速恢复） TCP 和 UDP 的区别UDP 协议的特点有以下这些 面向无连接 首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作，具体来说就是 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能 UDP 是面向报文的 发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此，应用程序必须选择合适大小的报文 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠，并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP 头部开销小，传输数据报文时是很高效的 UDP 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 TCP 协议的特点有以下这些 面向连接 面向连接，是指发送数据之前必须在两端建立连接，建立连接的方法是三次握手，这样能建立可靠的连接，建立连接，是为数据的可靠传输打下了基础 仅支持单播传输 每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式 面向字节流 TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输 可靠传输 对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号，TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收，然后接收端实体对已成功收到的字节发回一个相应的确认（ACK），如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据（假设丢失了）将会被重传 提供拥塞控制 当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞 TCP 提供全双工通信 TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据，当然 TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS） 这里我们简单介绍一下 MSS，其实简单来说，就是一个网络包的最大长度，计算每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断，MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节 MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS 下面我们再来看看 TCP 和 UDP 两者的区别，如下表 区别 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（IP 电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 简单总结就是 TCP 向上层提供面向连接的可靠服务，UDP 向上层提供无连接不可靠服务 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP 我们在上面也介绍了负责域名解析的 DNS 服务，那么 DNS 为什么使用 UDP 协议作为传输层协议而不是 TCP 呢？其实简单来说，DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长 下表是使用 UDP 和 TCP 协议的各种应用和应用层协议 应用 应用层协议 运输层协议 名字转换 DNS（域名系统） UDP 文件传送 TFTP（简单文件传送协议） UDP 路由选择协议 RIP（路由信息协议） UDP IP 地址配置 DHCP（动态主机配置协议） UDP 网络管理 SNMP（简单网络管理协议） UDP 远程文件服务器 NFS（网络文件系统） UDP IP 电话 专用协议 UDP 流式多媒体通信 专用协议 UDP 多播 IGMP（网际组管理协议） UDP 电子邮件 SMTP（简单邮件传送协议） TCP 远程终端接入 TELNET（远程终端协议） TCP 万维网 HTTP（超文本传送协议） TCP 文件传送 FTP（文件传送协议） TCP 三次握手TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段，也叫三报文握手，之所以会有三次握手的过程，是因为需要确认双方的两样能力，即『发送的能力』和『接收的能力』 A 主动打开连接，B 被动打开连接，B 先进入收听状态（LISTEN），A 打算建立 TCP 连接时，先向 B 发送连接请求报文段，其中同步位 SYN = 1，初始序号 seq = x，这个报文段不能携带数据，但是要消耗一个序号，接着 A 进入同步已发送状态 B 收到请求报文段，如果同意建立连接，则向 A 发送 ACK 确认报文段，其中同步位 SYN = 1，确认号 ACK = 1，初始序号 seq = y，确认号 ack = x + 1（请求报文段消耗了一个序号），这个 ACK 报文段也不能携带数据，但是要消耗一个序号，与此同时 B 进入到同步收到的状态 A 收到 B 的确认报文后，还要给 B 发送确认报文，其中 ACK = 1， seq = x + 1（上一个报文段的 ack），ack = y + 1（上一个报文段的 seq + 1，因为消耗了一个序号），这个 ACK 报文段可以携带数据，但是如果不携带数据则不会消耗序号，下一次 A 给 B 发送报文段的初始序号 seq = 1，此时 A 进入已建立连接的状态，B 收到确认后也进入已建立连接的状态 从上图可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1，那么为什么会这样呢？这里只需要记住一个规则 凡是需要对端确认的，一定消耗 TCP 报文的序列号（SYN 需要对端的确认，而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要） 为什么不是两次握手其实也就是为什么需要最后一次确认？ 其实简单来说，这是防止已失效的连接请求报文段突然又传送到了 B 而引发错误，但是有可能出现异常情况，即 A 发送的连接请求并没有丢失，而是滞留了在网络中，如果在传输数据完成之后，这个请求又发到 B ，B 误以为 A 还要发送数据，因此发送确认报文，但是 A 没有运输需求，因此不予理睬，如果没有最后一次确认，B 一直等待 A 的确认，这样会造成的浪费 采用三报文握手，如果 B 没有收到 A 的确认，则可以知道 A 没有建立连接的需求，就可以避免上述这种情况 所谓的失效的连接请求就是 A 第一次先发送了一个请求，但是丢失了，于是 A 再发送一个连接请求，重新建立连接，发送数据并释放连接 为什么不是四次握手三次握手的目的是确认双方『发送』和『接收』的能力，当然四次握手也是可以的，甚至 100 次都可以，但为了解决问题，三次就已经足够了，再多用处就不大了 三次握手过程中可以携带数据么第三次握手的时候，可以携带，前两次握手不能携带数据 如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险 第三次握手的时候，客户端已经处于 ESTABLISHED 状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据 如果同时打开会怎样如果双方同时发 SYN 报文，这是一个可能会发生的情况，状态变迁如下 在发送方给接收方发 SYN 报文的同时，接收方也给发送方发 SYN 报文，此时发完 SYN，两者的状态都变为 SYN-SENT，在各自收到对方的 SYN 后，两者状态都变为 SYN-REVD 接着会回复对应的 ACK + SYN，这个报文在对方接收之后，两者状态一起变为 ESTABLISHED，这就是同时打开情况下的状态变迁 四次挥手所谓的四次挥手其实也就是 TCP 的连接释放的过程 A 和 B 目前都处于已建立连接的状态，A 的应用进程向其 TCP 发出连接释放报文段，并停止发送数据，主动关闭 TCP 连接，此时 FIN = 1，seq = u，u 等于前面已发送的最后一个字节的序号加 1，这时 A 进入到 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认，FIN 报文段即使不携带数据，也要消耗一个序号 B 收到释放连接后立即发出确认，此时，ACK = 1，确认号是 ack = u + 1（前面的 seq + 1，因为消耗了一个序号），序号 seq = v，v 等于 B 前面所有已传送数据的最后一个字节的序号加 1，B 进入到 CLOSE-WAIT（关闭等待）状态，TCP 服务器进程向 B 的高层应用进程告知，此时 A 到 B 的连接已经释放，TCP 连接处于半关闭状态，但是，B 到 A 这个方向的连接尚未关闭 A 收到 B 的确认后，就进入到 FIN-WAIT-2（终止等待 2）的状态，等待 B 发送连接释放报文段 若 B 已经没有数据需要发送，则应用进程通知 TCP 释放连接，这时 B 发送的报文段 FIN = 1，ACK = 1，seq = w（可能后面又发送了一些数据），ack = u + 1，并且这个报文消耗一个序号，B 进入到 LAST-ACK（最后确认）的状态，等待 A 的确认 A 收到 B 的确认后，必须对此发送确认报文，该报文中 ACK = 1，seq = u + 1，ack = w + 1，然后进入到 TIME-WAIT（时间等待）状态 但是需要注意的是，此时 TCP 连接并没有完全释放，必须经过时间等待计时器设置的时间 2MSL 之后，A 才进入 CLOSED 状态，时间 MSL 叫做最大报文段寿命 那么问题来了，为什么要等待 2MSL 的时间呢？主要原因有两点 保证 A 最后发送的 ACK 报文段能够到达 B，因为这个报文可能丢失，因此 B 会重传最后一个确认报文段，A 再重新发送确认报文，并且重启计时器，直到 A ，B 都能正常进入到 CLOSED 状态 防止上面提到的已失效的连接请求报文，这段时间内，这些连接请求报文就可能在网络中消失 简单来说就是 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义，此外 B 要比 A 先进入 CLOSED 状态 为什么是四次挥手而不是三次因为服务端在接收到 FIN，往往不会立即返回 FIN，必须等到服务端所有的报文都发送完毕了，才能发 FIN，因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN，这就造成了四次挥手，那么如果是三次挥手会有什么问题？ 如果是三次挥手，这就等于说服务端将 ACK 和 FIN 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 FIN 没有到达客户端，从而让客户端不断的重发 FIN 同时关闭会怎样如果客户端和服务端同时发送 FIN，状态如下图所示 半连接队列与 SYN Flood 攻击三次握手前，服务端的状态从 CLOSED 变为 LISTEN，同时在内部创建了两个队列『半连接队列』和『全连接队列』，即 SYN 队列和 ACCEPT（Accept Queue） 队列 半连接队列，当客户端发送 SYN 到服务端，服务端收到以后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，也就是半连接队列 全连接队列，当客户端返回 ACK，服务端接收后，三次握手完成，这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列 SYN Flood 攻击原理SYN Flood 属于典型的 DoS/DDoS 攻击，其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 SYN，对于服务端而言，会产生两个危险的后果 处理大量的 SYN 包并返回对应 ACK，势必有大量连接处于 SYN_RCVD 状态，从而占满整个半连接队列，无法处理正常的请求 由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据，直到耗尽服务端的资源 如何应对 SYN Flood 攻击 增加 SYN 连接，也就是增加半连接队列的容量 减少 SYN + ACK 重试次数，避免大量的超时重发 利用 SYN Cookie 技术，在服务端接收到 SYN 后不立即分配连接资源，而是根据这个 SYN 计算出一个 Cookie，连同第二次握手回复给客户端，在客户端回复 ACK 的时候带上这个 Cookie 值，服务端验证 Cookie 合法之后才分配连接资源 报文头部的字段主要分为 IP 数据报格式、UDP 数据报格式、TCP 报文段格式和以太网 MAC 帧格式 IP 数据报格式 IP 数据报首部可以分为固定长度（20 字节）和可选长度，固定长度是所有 IP 数据报所必须的，固定部分个字段的意义如下 版本，占 4 位，指 IP 协议的版本，通信双方的协议版本必须一致 首部长度，占 4 位，可表示的最大十进制数是15（1111），它的单位是 4 字节（也就是 32 位），因此首部长度最小值为 5（固定长度部分），可选长度最长为 40 字节 区分服务，占 8 位，用来获得更好的服务 总长度，占 16 位，首部和数据部分的总长度，单位为字节，因此 IP 数据报的最大长度为 2^16 - 1 标识，占 16 位，当数据报的长度超过网络的最大传送单元使，就给该数据报的所有分片赋值相同的标识，相同的标识字段的值使分片后的各数据报片能正确的重装成原来的数据报 标志，占 3位，但是只有两位具有意义 标记字段中的最低位记为 MF，MF = 1 表示后面还有分片，MF = 0 表示这是最后一个分片 标志字段中间的一位记为 DF，意思是能否分片，只有 DF = 0 时才能分片 片偏移，占 13 位，较长的分组在分片后，某片在原分组中的相对位置，也就是说，数据片相对于初始位置的距离，单位是 8 字节，因此除去最后一个数据片，每个数据片的长度都是 8 字节的倍数 生存时间，占 8位，TTL（Time To Live），单位为跳数，跳数表明该数据报至多能在互联网中经过多少个路由器，每经过一个路由器就减 1 协议，占 8位，协议字段指出该数据报携带的数据是使用哪种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理 协议名 ICMP IGMP IP TCP EGP IGP UDP IPv6 ESP OSPF 协议字段值 1 2 4 6 8 9 17 41 50 89 源地址，占 32 位 目的地址，占 32 位 首部校验和，占 16 位，这个字段只检验数据报的首部，但是不包括数据部分 在发送方，先把数据报划分为许多 16 位的字的序列，并把校验和字段置为 0 用反码算术运算（从低位到高位计算，0 + 0 等于 0，0 + 1 等于 1，1 + 1 等于 0，但是要进 1）把所有的 16 位字相加后，将得到的反码写入校验和字段 接收方接收到数据报之后，将首部的所有 16 位字再使用反码运算相加一次，将得到的和取反码，即得出接收方的检验和的计算结果，如果结果全为 0，则代表首部未发生变化，保留该数据报，反之则丢弃 UDP 数据报格式UDP 用户数据报分为 = 首部字段 （8个字节，4个字段，每个字段 2 个字节）+ 数字字段，首部字段分为 源端口，源端口号，在需要对方回信的时候选用，不需要填 0 目的端口，目的端口号，必填 长度，UDP 用户数据报的长度，最小为 8 检验和，检测 UDP 用户数据报传输过程中是否有错，有错就丢弃 TCP 报文段格式TCP 虽然是面向字节流的，但是 TCP 传输的数据单元却是报文段，一个报文段可以分为首部和数据两部分，TCP 报文段的首部的前 20 个字节是固定的，后面的 4n 字节是需要增加的选项，因此 TCP 首部的最小长度是 20 字节 首部部分字段的意义如下 源端口和目的端口，各占 2 个字节，分别写入源端口号和目的端口号，TCP 的分用功能也是通过端口号实现的 那么如何标识唯一一个连接呢？答案是 TCP 连接的四元组，源 IP、源端口、目标 IP 和目标端口，但是 TCP 报文当中为何没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP，TCP 只需要记录两者的端口即可 序号，占 4 字节，在 TCP 连接中传送的字节流中的每一个字节都按照顺序编号，首部中的序号字段值则代表本报文段所发送的数据的第一个字节的序号，作用有两个 在 SYN 报文中交换彼此的初始序列号 保证数据包按正确的顺序组装 确认号，占 4 字节，代表期望收到对方下一个报文段的第一个数据字节的序号，需要注意若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到 数据偏移，占 4 位，他指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，一般情况下为 20 字节，但是首部中还有不确定的选项字段，它的单位是 4 字节，而它的最大值是 15，因此数据偏移最大值为 60 字节，也就是说选项不能超过 40 字节 保留，占 6 位，以防后续使用 下面是 6 个控制位（标记位），每个占一位 紧急 URG，当 URG = 1 时，表明紧急字段有效，它告诉系统此报文中有紧急数据，应该尽快传送 确认 ACK，仅当 ACK = 1 时确认号字段才有效 推送 PSH，当两个应用进程进行交互式的通信时，有时一端的应用进程希望在键入一个命令后立即就能收到对方的相应，这时设置 PSH = 1 复位 RST，当 RST = 1 时，表明 TCP 连接中出现严重错误，必须释放连接，再重新建立运输连接，RST = 1 还可以用来拒绝一个非法的报文段或拒绝打开一个连接 同步 SYN，在建立连接时用来同步序号，当 SYN = 1 ，ACK = 0 时代表是连接请求报文段，若对方同意建立连接，则应在相应报文段中使 SYN = 1 ，ACK = 1 ，也就是说，SYN = 1 代表连接请求或者连接接受报文 终止 FIN，用于释放一个连接，当 FIN = 1 时，代表此报文段的发送方的数据已发送完毕，并且请求释放运输连接 控制位至此结束 窗口，占 2 字节，窗口值告诉对方，从本报文段中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位），之所以设置这个限制，是因为接收方的数据缓存空间是有限的，总之窗口值作为接收方让发送方设置其窗口大小的依据 检验和，占 2 字节，检验的范围包括首部字段和数据字段，和 UDP 检验的方法一样，只不过把伪首部第四个字段的 17 改成 6 紧急指针，占 2 字节，只有在紧急 URG = 1 时才有效，它指出本报文段中的紧急数据的字节数 选项，长度可变，最大 40 字节，注意，TCP 最初只规定了一种选项，即最大报文长度 MSS，MSS 是每一个 TCP 报文段中的数据字段的最大长度，而并不是整个 TCP 报文段的长度 这里补充一些 ISN 相关内容，即 Initial Sequence Number（初始序列号） 在三次握手的过程当中，双方会用过 SYN 报文来交换彼此的 ISN，ISN 并不是一个固定的值，而是每 4ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难，那么为什么要这么做呢？ 如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的，而动态增长的 ISN 大大提高了猜测 ISN 的难度 以太网 MAC 帧格式 以太网 MAC 帧较为简单，由五个字段组成，前两个字段分别为 6 字节长的目的地址和源地址，第三个字段是 2 字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议，第四个字段是数据字段，其长度为 46 ~ 1500 字节（46 字节是因为最小长度 64 字节减去 18 字节的首部和尾部），最后一个字段是 4 字节的帧检测序列 FCS（使用 CRC 检测） TFO 原理TFO 即 TCP 快速打开（TCP Fast Open），是对计算机网络中传输控制协议（TCP）连接的一种简化握手手续的拓展，用于提高两端点间连接的打开速度，在上面 SYN Flood 部分当中我们曾提到 SYN Cookie，这个 Cookie 可不是浏览器的 Cookie，用它同样可以实现 TFO，下面我们就来看看 TFO 的流程 首轮三次握手首先客户端发送 SYN 给服务端，服务端接收到，但是需要注意，现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个 SYN Cookie，将这个 Cookie 放到 TCP 报文的 Fast Open 选项中，然后才给客户端返回，客户端拿到这个 Cookie 的值缓存下来，后面正常完成三次握手 首轮三次握手就是这样的流程，但是后面的三次握手则不一样 后面的三次握手在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和 HTTP 请求发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃，如果是合法的，那么就正常返回 SYN + ACK 重点来了，现在服务端能向客户端发 HTTP 响应了，这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了，当然客户端的 ACK 还得正常传过来，流程如下 注意，客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系 TFO 的优势TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了 1 个 RTT 的时间提前进行数据传输，积累起来还是一个比较大的优势 TCP 的超时重传时间是如何计算的TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包，这个重传间隔也叫做超时重传时间（Retransmission TimeOut，简称 RTO），那么这个重传间隔是如何来计算的呢？主要有两种方式，一个是经典方法，一个是标准方法 经典方法经典方法引入了一个新的概念 SRTT（Smoothed round trip time，即平滑往返时间），没产生一次新的 RTT，就根据一定的算法对 SRTT 进行更新，具体而言计算方式如下（SRTT 初始值为 0） 1SRTT = (α * SRTT) + ((1 - α) * RTT) 其中 α 是平滑因子，建议值是 0.8，范围是 0.8 ~ 0.9，拿到 SRTT 我们就可以计算 RTO 的值了 1RTO = min(ubound, max(lbound, β * SRTT)) β 是加权因子，一般为 1.3 ~ 2.0，lbound 是下界，ubound 是上界，其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是 0.8 ~ 0.9，RTT 对于 RTO 的影响太小 标准方法为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫 Jacobson/Karels 算法，一共有三步 第一步，计算 SRTT，公式如下 1SRTT = (1 - α) * SRTT + α * RTT 注意这个时候的 α 跟经典方法中的 α 取值不一样了，建议值是 1/8，也就是 0.125 第二步，计算 RTTVAR（round-trip time variation）这个中间变量 1RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) β 建议值为 0.25，这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手 第三步，计算最终的 RTO 1RTO = µ * SRTT + ∂ * RTTVAR µ 建议值取 1，∂ 建议值取 4，这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下 RTO 与 RTT 变化的差值关系更加密切 TCP 的流量控制是如何实现的我们之前在 HTTP 协议 和 TCP/IP 协议 的章节当中简单介绍过 TCP 的流量控制，在这里就汇总整理一下，但是需要注意的是，HTTP/3 当中 QUIC 实现的流量控制与 TCP 当中有所区别，这里我们主要介绍的是 TCP 当中的流量控制，所以关于 HTTP/3 当中 QUIC 的实现方法就不详细展开了，详细可见 HTTP/3 流量控制 对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区，将接收的数据放到接收缓存区，而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送，如果对方的接收缓存区满了，就不能再继续发送了，所以要具体理解流量控制，我们要从滑动窗口的概念开始了解 TCP 滑动窗口TCP 滑动窗口分为两种，发送窗口和接收窗口，发送端的滑动窗口结构如下 其中包含四大部分 已发送且已确认 已发送但未确认 未发送但可以发送 未发送也不可以发送 发送窗口就是图中被框住的范围，SND 即 send，WND 即 window，UNA 即 unacknowledged，表示未被确认，NXT 即 next，表示下一个发送的位置，接收端的窗口结构如下 REV 即 receive，NXT 表示下一个接收的位置，WND 表示接收窗口大小 流量控制过程这里我们用一个简单的例子来模拟一下流量控制的过程 首先双方三次握手，初始化各自的窗口大小，均为 200 个字节 假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节 现在这 100 个到达了接收端，被放到接收端的缓冲队列中，不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中 此时接收端的情况是处理能力不够用，所以此时接收端的接收窗口应该缩小，具体来说缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走 因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节，此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节 这也就是流量控制的过程，尽管回合再多，整个控制的过程和原理是一样的 TCP 的拥塞控制和上面流量控制部分类似，这里我们主要介绍的是 TCP 当中的拥塞控制，关于 HTTP/3 当中拥塞控制的热插拔和前向纠错等相关内容可见 HTTP/3 拥塞控制 上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了，而这也正是拥塞控制需要处理的问题，对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态 拥塞窗口（Congestion Window，cwnd） 慢启动阈值（Slow Start Threshold，ssthresh） 涉及到的算法有这几个 慢启动 拥塞避免 快速重传 快速恢复 接下来，我们就来一一来梳理这些状态和算法，首先从拥塞窗口说起 拥塞窗口拥塞窗口是指目前自己还能传输的数据量大小，那么之前介绍了接收窗口的概念，两者有什么区别呢？ 接收窗口（rwnd）是接收端给的限制 拥塞窗口（cwnd）是发送端的限制 限制谁呢？其实是限制的是发送窗口的大小，在有了这两个窗口以后，我们来看看如何来计算发送窗口？ 1发送窗口大小 = min(rwnd, cwnd) 简单来说就是取两者的较小值，而拥塞控制，就是来控制 cwnd 变化的 慢启动刚开始进入传输数据的时候，我们是不知道现在的网络情况到底是稳定还是拥堵的，如果发包太急，那么可能会疯狂丢包，造成雪崩式的网络灾难，因此拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网络，这种算法叫慢启动，运作过程如下 首先，三次握手，双方宣告自己的接收窗口大小 双方初始化自己的拥塞窗口（cwnd）大小 在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说每经过一个 RTT，cwnd 翻倍，如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推 当然不会无止境地翻倍下去，它的阈值叫做慢启动阈值，超出阈值则会导致网络拥塞，那么当 cwnd 到达这个阈值之后，如何来控制 cwnd 的大小呢？而这就是拥塞避免做的事情了 拥塞避免其实简单来说，原理就是在到达某个限制（慢启动阈值）之后，指数增长变为线性增长，比如原来每收到一个 ACK，cwnd 加 1，现在到达阈值后，cwnd 只增加 1 / cwnd，所以一轮 RTT 下来，收到 cwnd 个 ACK，那最后拥塞窗口的大小 cwnd 总共才增加 1 也就是说，以前一个 RTT 下来，cwnd 翻倍，现在 cwnd 只是增加 1 而已，当然慢启动和拥塞避免是一起作用的，是一体的 快速重传在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK，比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK，当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO（Retransmission Timeout，重传超时） 的时间到了才重传，这就是快速重传，它解决的是是否需要重传的问题 选择性重传既然要重传，那么是只重传第 5 个包还是第 5、6、7 个包都重传呢？当然如果第 6、7 个都已经到达了的话，则会记录一下哪些包到了，哪些没到，针对性地重传 在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上 SACK 这个属性，通过 left edge 和 right edge 告知发送端已经收到了哪些区间的数据报，因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了，剩下第 5 个包没到，就重传这个包，这个过程也叫做选择性重传（Selective Acknowledgment，SACK），它解决的是如何重传的问题 快速恢复当然，发送端收到三次重复 ACK之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段，在这个阶段，发送端如下改变 拥塞阈值降低为 cwnd 的一半 cwnd 的大小变为拥塞阈值 cwnd 线性增加 总结TCP 拥塞控制由 4 个核心算法组成，即『慢启动』、『拥塞避免』、『快速重传』和『快速恢复』 慢启动，发送方向接收方发送 1 个单位的数据，收到对方确认后会发送 2 个单位的数据，然后依次是 4 个、8 个呈指数级增长，这个过程就是在不断试探网络的拥塞程度，超出阈值则会导致网络拥塞 拥塞避免，指数增长不可能是无限的，到达某个限制（慢启动阈值）之后，指数增长变为线性增长 快速重传，发送方每一次发送时都会设置一个超时计时器，超时后即认为丢失，需要重发 快速恢复，在上面快速重传的基础上，发送方重新发送数据时，也会启动一个超时定时器，如果收到确认消息则进入拥塞避免阶段，如果仍然超时，则回到慢启动阶段 Nagle 算法和延迟确认这里首先需要明确的是，前者意味着延迟发，后者意味着延迟接收，如果两者一起使用会造成更大的延迟，产生性能问题，所以需要小心 Nagle 算法试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次，这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延，而避免小包的频繁发送，这就是 Nagle 算法要做的事情，Nagle 算法的规则如下 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送 后面发送满足下面条件之一就可以发了 数据包大小达到最大段大小（Max Segment Size，即 MSS） 之前所有包的 ACK 都已接收到 延迟确认试想这样一个场景，当我们收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？ 延迟确认（delayed ack）所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端，TCP 要求这个延迟的时延必须小于 500ms，一般操作系统实现都不会超过 200ms，不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复 接收到了大于一个 frame 的报文，且需要调整窗口大小 TCP 处于 quickack 模式（通过 tcp_in_quickack_mode 设置） 发现了乱序包 TCP 的 keep-alive大家都听说过 HTTP 的 keep-alive，不过 TCP 层面也是有 keep-alive 机制，而且跟应用层不太一样，试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的，这个时候就出现了 keep-alive，它的作用就是探测对端的连接有没有失效，在 Linux 下，可以这样查看相关的配置 12345678910sudo sysctl -a | grep keepalive// 每隔 7200 s 检测一次net.ipv4.tcp_keepalive_time = 7200// 一次最多重传 9 个包net.ipv4.tcp_keepalive_probes = 9// 每个包的间隔重传间隔 75 snet.ipv4.tcp_keepalive_intvl = 75 不过，现状是大部分的应用并没有默认开启 TCP 的 keep-alive 选项，这是因为如果我们站在应用的角度来看的话，会发现这是一个比较尴尬的设计，原因主要有下面两点 7200s 也就是两个小时检测一次，时间太长 时间再短一些，也难以体现其设计的初衷，即检测长时间的死连接 参考 深入理解 TCP 协议 趣谈网络协议 Web 协议详解与抓包实战","link":"/2020/09/19/HTTP/13/"},{"title":"TCP/IP 协议","text":"在之前的章节当中，我们梳理了 HTTP 协议，HTTPS，HTTP/2 和 HTTP/3 的一些相关内容，本章我们再来看看姑且算是最后一部分内容，也就是 TCP/IP 协议相关内容，因为这部分内容在平常的工作之中接触有限，所以在这里简单记录一下也就当做是扩展知识了，内容主要参考的是 图解 TCP/IP，更多相关内容可以参考 前端知识体系整理 协议TCP/IP 是通信协议的统称，不过在此之前，我们有必要先来理清协议的概念，在计算机网络与信息通信领城里，人们经常提及协议一词，互联网中常用的具有代表性的协议有 IP、TCP、 HTTP 等，而 LAN（局域网）中常用的协议有 IPX/SPX 等，计算机网络体系结构将这些网络协议进行了系统的归纳，TCP/IP 就是 IP、TCP、HTTP 等协议的集合 网絡体系结构 协议 主要用途 TCP/IP IP/ICMP/TCP/UDP/HTTP/TELNET/SNMP/SMTP 等 互联网、局城网 IPX/SPX（NetWare） IPX/SPX/NPC 等 个人电脑局域网 AplcTalk DDP/RTMP/AEP/ATP/ZIP 等 苹果公司现有产品的局城网 DECnet DPR/NSP/SCP 等 前 DEC 小型机 OSI FTAM/MOTIS/VT/CMIS/CMIP,CLNP/CONP - XNS IDP/SPP/PEP 等 施乐公司网络 协议的必要性简单来说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种约定，这种约定使那些由不同厂商的设备、不同的 CPU 以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信，反之如果所使用的协议不同，就无法实现通信，但是在计算机通信诞生之初，系统化与标准化并未得到足够的重视，每家计算机厂商都出产各自的网络产品来实现计算机通信，对于协议的系统化、分层化等事宜没有特别强烈的意识 为了解决上述问题，ISO 制定了一个国际标准 OSI，对通信系统进行了标准化，现在 OSI 所定义的协议虽然并没有得到普及，但是在 OSI 协议设计之初作为其指导方针的 OSI 参考模型却常被用于网络协议的制定当中 但是我们在本章当中介绍的 TCP/IP 并非 ISO 所制定的某种国际标准，而是由 IETF 所建议的、致力于推进其标准化作业的一种协议，在当时大学等研究机构和计算机行业作为中心力量，推动了 TCP/IP 的标准化进程，TCP/IP 作为互联网之上的一种标准，也作为业界标准，俨然已成为全世界所广泛应用的通信协议，那些础知识支持互联网的设备及软件，也正着力遵循由 IETF 标准化的 TCP/IP 协议 协议得以标准化也使所有遵循标准协议的设备不再因计算机硬件或操作系统的差异而无法通信，因此协议的标准化也推动了计算机网络的普及 OSI 参考模型IS0 在制定标准化 OSI 之前，对网络体系结构相关的问题进行了充分的讨论，最终提出了作为通信协议设计指标的 OSI 参考模型，这一模型将通信协议中必要的功能分成了七层，通过这些分层，使得那些比较复杂的网络协议更加简单化，在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务 上下层之间进行交互时所遵循的约定叫做接口 同一层之间的交互所遵循的约定叫做协议 协议分层就如同计算机软件中的模块化开发，OSI 参考模型的建议是比较理想化的，它希望实现从第一层到第七层的所有模块，并将它们组合起来实现网络通信，分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及整个系统，因此可以构造一个扩展性和灵活性都较强的系统 此外通过层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务，这些都属于分层的优点 而分层的劣势，可能就在于过分模块化、使处理变得更加沉重以及每个模块都不得不实现相似的处理:逻辑等问题 OSI 参考模型如下图所示 不过，OSI 参考模型终究只是一个模型，它也只是对各层的作用做了一系列粗略的界定，并没有对协议和接口进行详细的定义，它对学习和设计协议只能起到一个引导的作用，许多通信协议，都对应了 OSI 参考模型七个分层中的某层，通过这一点，可以大致了解该协议在整个通信功能中的位置和作用 这里需要区分开来 OSI 协议与 OSI 参考模型 OSI 协议是为了让异构的计算机之间能够相互通信的、由 ISO 和 ITU-T 推进其标准化的一种网絡体系结构，OST（参考模型）将通信功能划分为七个分层，称作 OSI 参考模型 而 OSI 协议以 OSI 参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准，遵循 OSI 协议的产品叫 OSI 产品，而它们所遵循的通信则被称为 OSI 通信 TCP/IP 基础从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议，实际生活当中有时也确实就是指这两种协议，然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称，具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议，他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分，TCP/IP 一词泛指这些协议 因此，有时也称 TCP/IP 为网际协议群，互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族，因此互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议 TCP/IP 协议分层模型 .tg {border-collapse:collapse;border-spacing:0;} .tg tr:nth-child(odd) td {background-color: transparent !important;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} .tg .tg-nrix{text-align:center;vertical-align:middle} OSI 七层模型 TCP/IP 概念层模型 功能 TCP/IP 协议族 应用层 应用层 文件传输，电子邮件,文件服务，虛拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化,代码转换，数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 传输层 提供端对端的接口 TCP，UDP 网络层 网络层 为数据包选择路由 IP，ICIP，RIP，0SPF，BGP，IGMP 数据链路层 链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 不难看出，TCP/IP 与 OSI 在分层模块上稍有区别，OSI 参考模型注重『通信协议必要的功能是什么』，而 TCP/IP 则更强调『在计算机上实现协议应该开发哪种程序』 数据包包、帧、数据包、段、消息以上五个术语都用来表述数据的单位，大致区分如下 包可以说是全能性术语 帧用于表示数据链路层中包的单位 数据包是 IP 和 UDP 等网络层以上的分层中包的单位 段则表示 TCP 数据流中的信息 消息是指应用协议中数据的单位 每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息，通常为协议提供的信息为包首部，所要发送的内容为数据 如上图，在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据，网络中传输的数据包由两部分组成 一部分是协议所要用到的首部 另一部分是上一层传过来的数据 首部的结构由协议的具体规范详细定义，在数据包的首部，明确标明了协议应该如何读取数据，反过来说，看到首部也就能够了解该协议必要的信息以及所要处理的数据，『包首部就像协议的脸』 数据处理流程我们以一个发送邮件的流程为例，如下图 应用程序处理首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能，编码转化后邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能 TCP 模块的处理，TCP 根据应用的指示，负责建立连接、发送数据以及断开连接，TCP 提供将应用层发来的数据顺利发送至对端的可靠传输，为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部 IP 模块的处理，IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部，IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机 网络接口（以太网驱动）的处理从 IP 传过来的 IP 包对于以太网来说就是数据，给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据，如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等，这里的例子则是 IP IP 模块的处理IP 模块接收到 数据后也做类似的处理，从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP，这里的例子则是 TCP，另外对于有路由器的情况，接收端地址往往不是自己的地址，此时需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据 TCP 模块的处理在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏，然后检查是否在按照序号接收数据，最后检查端口号，确定具体的应用程序，数据被完整地接收以后，会传给由端口号识别的应用程序 应用程序的处理接收端应用程序会直接接收发送端发送的数据，通过解析数据，展示相应的内容 IP 协议IP（IPv4、IPv6）相当于 OSI 参考模型中的第三层（网络层），网络层的主要作用是『实现终端节点之间的通信』，这种终端节点之间的通信也叫『点对点通信』，而网络的下一层（数据链路层）的主要作用是在互连同一种数据链路的节点之间进行包传递，而一旦跨越多种数据链路，就需要借助网络层，网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输 IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包，下面我们就一个一个来介绍 IP 地址在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识，在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码，作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址，IP 地址用于在『连接到网络中的所有主机中识别出进行通信的目标地址』，因此在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址，但是不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变 IP 地址的定义在用 TCP/IP 通信时，用 IP 地址识别主机和路由器，为了保证正常通信，有必要为每个设备配置正确的 IP 地址，在互联网通信中，全世界都必须设定正确的 IP 地址，否则，根本无法实现正常的通信，因此 IP 地址就像是 TCP/IP 通信的一块基石 IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机内部以二进制方式被处理，然而由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 .（点号）隔开，再将每组数转换成十进制数，如下 2^8 2^8 2^8 2^8 &nbsp; 10101100 00010100 00000001 00000001 二进制 10101100. 00010100. 00000001. 00000001 二进制 172. 20. 1. 1 十进制 组成IP 地址由网络和主机两部分标识组成，如下图，网络标识在数据链路的每个段配置不同的值，网络标识必须保证相互连接的每个段的地址不相重复，而相同段内相连的主机必须有相同的网络地址，IP 地址的『主机标识』则不允许在同一个网段内重复出现，由此可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠，即 IP 地址具有了唯一性 IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由，因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机 分类IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类，它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分 A 类 IP 地址是首位以 0 开头的地址，从第 1 位到第 8 位是它的网络标识，用十进制表示的话，0.0.0.0 ~ 127.0.0.0 是 A 类的网络地址，A 类地址的后 24 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 16777214 个 B 类 IP 地址是前两位 10 的地址，从第 1 位到第 16 位是它的网络标识，用十进制表示的话，128.0.0.0 ~ 191.255.0.0 是 B 类的网络地址，B 类地址的后 16 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 65534 个 C 类 IP 地址是前三位为 110 的地址，从第 1 位到第 24 位是它的网络标识，用十进制表示的话，192.0.0.0 ~ 223.255.255.0 是 C 类的网络地址，C 类地址的后 8 位相当于主机标识，因此一个网段内可容纳的主机地址上限为 254 个 D 类 IP 地址是前四位为 1110 的地址，从第 1 位到第 32 位是它的网络标识，用十进制表示的话，224.0.0.0 ~ 239.255.255.255 是 D 类的网络地址，D 类地址没有主机标识，常用于多播 在分配 IP 地址时关于主机标识有一点需要注意，即要用比特位表示主机地址时，不可以全部为 0 或全部为 1，因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用，而全部为 1 的主机通常作为广播地址，因此在分配过程中，应该去掉这两种情况，这也是为什么 C 类地址每个网段最多只能有 254（2^8 - 2 = 254）个主机地址的原因 广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据包，将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址 广播分为本地广播和直接广播两种，在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播 IP 多播 多播用于将包发送给特定组内的所有主机，由于其直接使用 IP 地址，因此也不存在可靠传输 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包 多播使用 D 类地址，因此如果从首位开始到第 4 位是 1110，就可以认为是多播地址，而剩下的 28 位可以成为多播的组编号，此外对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组 子网掩码一个 IP 地址只要确定了其分类，也就确定了它的网络标识和主机标识，例如以下各类各自的网络标识部分 A 类地址前 8 位（除首位 0 还有 7 位） B 类地址前 16 位（除首位 10 还有 14 位） C 类地址前 24 位（除首位 110 还有 21 位） 但是直接使用 A 类或 B 类地址，确实有些浪费，随着互联网的覆盖范围逐渐增大，网络地址会越来越不足以应对需求，直接使用 A 类、B 类、C 类地址就更加显得浪费资源，为此人们已经开始一种新的组合方式以减少这种浪费 现在，一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做『子网掩码』的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络，这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制 子网掩码用二进制方式表示的话，也是一个 32 位的数字，它对应 IP 地址网络标识部分的位全部为 1，对应 IP 地址主机标识的部分则全部为 0，由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度，当然子网掩码必须是 IP 地址的首位开始连续的 1 对于子网掩码，目前有两种表示方式，第一种是，将 IP 地址与子网掩码的地址分别用两行来表示，以 172.20.100.52 的前 26 位是网络地址的情况为例，如下 地址 &nbsp; &nbsp; &nbsp; &nbsp; IP 地址 172. 20. 100. 52 子网掩码 255. 255. 255. 192 网络地址 172. 20. 100. 0 子网掩码 255. 255. 255. 192 广播地址 172. 20. 100. 63 子网掩码 255. 255. 255. 192 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 / 隔开，如下 地址 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IP 地址 172. 20. 100. 52 /26 网络地址 172. 20. 100. 0 /26 广播地址 172. 20. 100. 63 /26 路由控制发送数据包时所使用的地址是网络层的地址，即 IP 地址，然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于『指明路由器或主机』的信息，以便真正发往目标地址，保存这种信息的就是路由控制表，该路由控制表的形成方式有两种 一种是管理员手动设置（静态路由控制） 另一种是路由器与其他路由器相互交换信息时自动刷新（动态路由控制） IP 协议始终认为路由表是正确的，IP 本身并没有定义制作路由控制表的协议，即 IP 没有制作路由控制表的机制，该表示由一个叫做『路由协议』的协议制作而成 IP 地址与路由控制IP 地址的网络地址部分用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址，在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器，如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址 默认路由 如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费，这时默认路由是不错的选择，默认路由是指路由表中任何一个地址都能与之匹配的记录 默认路由一般标记为 0.0.0.0/0 或 default，这里的 0.0.0.0/0 并不是指 IP 地址是 0.0.0.0，由于后面是 /0，所以并没有标识 IP 地址，它只是为了避免人们误以为 0.0.0.0 是 IP 地址，有时默认路由也被标记为 default，但是在计算机内部和路由协议的发送过程中还是以 0.0.0.0/0 进行处理 主机路由 /32 也被称为主机路由（Host Route），例如 192.168.153.15/32 就是一种主机路由，它的意思是整个 IP 地址的所有位都将参与路由，进行主机路由，意昧着要基于主机上网卡上配置的 IP 地址本身，而不是基于该地址的网络地址部分进行路由 主机路由多被用于不希望通过网络地址路由的情况 环回地址 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址，计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址，与该地址具有相同意义的是一个叫做 localhost 的主机名，使用这个 IP 或主机名时，数据包不会流向网络 IP 报文的分片与重组 每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同，使用目的不同，可承载的 MTU 也就不同 任何一台主机都有必要对 IP 分片进行相应的处理，分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器虽然做分片但不会进行重组 路径 MTU 发现 分片机制也有它的不足，如路由器的处理负荷加重之类，因此只要允许，是不希望由路由器进行 IP 数据包的分片处理的 为了应对分片机制的不足，路径 MTU 发现技术应运而生，路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小，即路径中存在的所有数据链路中最小的 MTU 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包 IPv6IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议，IPv4 的地址长度为 4 个 8 位字节，即 32 比特，而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节 IPv6 的特点 IP 得知的扩大与路由控制表的聚合 性能提升，包首部长度采用固定的值（40 字节），不再采用首部检验码，简化首部结构，减轻路由器负担，路由器不再做分片处理 支持即插即用功能，即使没有 DHCP 服务器也可以实现自动分配 IP 地址 采用认证与加密功能，应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能 多播、Mobile IP 成为扩展功能 IPv6 中 IP 地址的标记方法 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（:）隔开进行标记 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（::）隔开，但是一个 IP 地址中只允许出现一次两个连续的冒号 IPv6 的 IP 地址标记举例 用二进制数表示 1111111011011100: 1011101010011000: 0111011001010100:0011001000010000: 1111111011011100: 1011101010011000: 0111011001010100: 0011001000010000 用十六进制数表示 FEDC: BA98: 7654: 3210: FEDC: BA98: 7654: 3210 IPv6 的 IP 地址省略举例 用二进制数表示 0001000010000000: 0000000000000000: 0000000000000000: 0000000000000000: 0000000000000000: 0000100000000000: 0010000000001100: 0100000101111010 用十六进制数表示 1080: 0: 0: 0: 8: 800: 200C: 417A 省略后为 1080:: 8: 800: 200C: 417A IPv6 地址的结构 IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类 在互联网通信中，使用一种全局的单播地址，它是互联网中唯一的一个地址，不需要正式分配 IP 地址 结构 &nbsp; &nbsp; 未定义 0000 ... 0000（128 比特） :: /128 环回地址 0000 ... 0001（128 比特） :: 1/128 唯一本地地址 1111 110 FC00:: /7 链路本地单播地址 1111 1110 10 FE80:: /10 多播地址 1111 1111 FF00:: /8 全局单播地址 （其他） （其他） 全局单播地址 全局单播地址是指世界上唯一的一个地址，它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64，即前 64 比特为网络标识，后 64 比特为主机标识 链路本地单播地址链路本地单播地址是指在同一个数据链路内唯一的地址，它用于不经过路由器，在同一个链路中的通信，通常接口 ID 保存 64 比特版的 MAC 地址 唯一本地地址 唯一本地地址是不进行互联网通信时所用的地址 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID L 通常被置为 1 全局 ID 的值随机决定 子网 ID 是指该域子网地址 接口 ID 即为接口的 ID IPv6 分段处理 IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片 IPv6 中最小 MTU 为 1280 字节，因此在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行路径 MTU 发现，而是在发送 IP 包时直接以 1280 字节为单位分片送出 IPv4 首部通过 IP 进行通信时，需要在数据的前面加入 IP 首部信息，IP 首部中包含着用于 IP 协议进行发包控制时所有的必要信息，了解 IP 首部的结构，也就能够对 IP 所提供的功能有一个详细的把握 版本（Version） 由 4 比特构成，表示标识IP首部的版本号，IPv4 的版本号即为 4，因此在这个字段上的值也是 4 图首部长度（Internet Header Length，IHL） 由 4 比特构成，表明 IP 首部的大小，单位为 4 字节（32 比特），对于没有可选项的 IP 包，首部长度则设置为 5，也就是说当没有可选项时，IP 首部的长度为 20 字节（ 4 x 5 = 20） 区分服务（Type Of Service，TOS） 由 8 比特构成，用来表明服务质量，每一位的具体含义如下 比特 含义 0 1 2 优先度 3 最低延迟 4 最大吞吐 5 最大可靠性 6 最小代价 （3 ~ 6） 最大安全 7 未定义 DSCP 段与 ECN 段 DSCP（Differential Services Codepoint，差分服务代码点）是 TOS（Type OfService）的一部分，现在统称为 DiflServY，用来进行质量控制 ECN（Explicit Congestion Notification，显式拥塞通告）用来报告网络拥堵情况，由两个比特构成 比特 简称 含义 6 ECT ECN-Capable Transport 7 CE Congenstion Experienced 总长度（Total Length） 表示 IP 首部与数据部分合起来的总字节数，该字段长 16 比特，因此 IP 包的最大长度为 65535（2^16）字节 标识（Identification） 由 16 比特构成，用于分片重组，同一个分片的标识值相同，不同分片的标识值不同，通常每发送一个 IP 包，它的值也逐渐递增，此外即使 ID 相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片 标志（Flags） 由 3 比特构成，表示包被分片的相关信息，每一位的具体含义请参考下表 比特 含义 0 未使用，现在必须是 0 1 指示是否进行分片，0 表示可以分片，1 表示不能分片 2 包被分片的情况下，表示是否为最后一个包，0 表示最后一个分片的包，1 表示分片中段的包 片偏移（Fragment Offset） 由 13 比特构成，用来标识被分片的每一个分段相对于原始数据的位置 生存时间（Time To Live） 由 8 比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限，然而在实际中它是指可以中转多少个路由器的意思，每经过一个路由器，TTL 会减少 1，直到变成 0 则丢弃该包 协议（Protocol） 由 8 比特构成，表示 IP 首部的下一个首部隶属于哪个协议 首部校验和（Header Checksum） 由 16 比特（2 个字节）构成，也叫 IP 首部校验和，该字段只校验数据报的首部，不校验数据部分，它主要用来确保 IP 数据报不被破坏 源地址（Source Address） 由 32 比特（4 个字节）构成，表示发送端 IP 地址 目标地址（Destination Address） 由 32 比特（4 个字节）构成，表示接收端 IP 地址 可选项（Options） 长度可变，通常只在进行实验或诊断时使用，该字段包含 安全级别/源路径/路径记录/时间戳 等信息 填充（Padding） 也称作填补物，在有可选项的情况下，首部长度可能不是 32 比特的整数倍，为此通过向字段填充 0，调整为 32 比特的整数倍 数据（Data） 存入数据，将 IP 上层协议的首部也作为数据进行处理 IPv6 首部格式IPv6 中为了减轻路由器的负担，省略了首部校验和字段，因此路由器不再需要计算校验和，从而也提高了包的转发效率，此外分片处理所用的识别码成为可选项，为了让 64 位 CPU 的计算机处理起来更方便，IPv6 的首部及可选项都由 8 字节构成 版本（Version） 与 IPv4 一样，由 4 比特构成，IPv6 其版本号为 6，因此在这个字段上的值为 6 通信量类（Traffic Class） 相当于 IPv4 的 TOS（Type Of Service）字段，也由 8 比特构成 流标号（Flow Label） 由 20 比特构成，用于服务质量控制 此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流 有效载荷长度（Payload Length） 有效载荷是指包的数据部分， IPv4 的 TL（Total Length）是指包括首部在内的所有长度，然而 IPv6 中的这个 Playload Length 不包括首部，只表示数据部分的长度，由于 IPv6 的可选项是指连接 IPv6 首部的数据，因此当有可选项时，此处包含可选项数据的所有长度就是 Playload Length 下一个首部（Next Header） 相当于 IPv4 中的协议字段，由 8 比特构成，通常表示 IP 的上一层协议是 TCP 或 UDP，不过在有 IPv6 扩展首部的情况下，该字段表示后面第一个扩展首部的协议类型 跳数限制（Hop Limit） 由 8 比特构成，与 IPv4 中的 TTL 意思相同，为了强调『可通过路由器个数』这个概念，数据每经过一次路由器就减 1，减到 0 则丟弃数据 源地址（Source Address） 由 128 比特（8 个 16 位字节）构成，表示发送端 IP 地址 目标地址（Destination Address） 由 128 比特（8 个 16 位字节）构成，表示接收端 IP 地址 IPv6 扩展首部IPv6 的首部长度固定，无法将可选项加入其中，取而代之的是通过扩展首部对功能进行了有效扩展，扩展首部通常介于 IPv6 首部与 TCP/UDP 首部中间，在 IPv4 中可选项长度固定为 40 字节，但是在 IPv6 中没有这样的限制，也就是说 IPv6 的扩展首部可以是任意长度，扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段 IPv6 首部中没有标识以及标志字段，在需要对 IP 数据报进行分片时，可以使用扩展首部 IP 协议相关技术IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的，必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能 DNS 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串，而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址，能够这样做是因为有了 DNS（Domain Name System）功能的支持，DNS 可以将那串字符串自动转换为具体的 IP 地址 这种 DNS 不仅适用于 IPv4，还适用于 IPv6 ARP 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报，然而在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址 ARP 是一种解决地址问题的协议，以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址，不过 ARP 只适用于 IPv4，不能用于 IPv6，IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息 RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议， ICMP ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等 IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4，也就是说在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信，然而在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信 DHCP 如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情，特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址 于是为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议，有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信，也就是说 DHCP 让即插即用变得可能 DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用 NAT NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信 NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术，不过在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT IP 隧道 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能 IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C 一般情况下紧接着 IP 首部的是 TCP 或 UDP 的首部，然而现在的应用当中 IP 首部的后面还是 IP 首部或者 IP 首部的后面是 IPv6 的首部等情况与日俱增，这种在网络层的首部后面追加网络层首部的通信方法就叫做 IP 隧道 TCP 和 UDPTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，它们的区别如下 TCP 是面向连接的、可靠的流协议，流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端，TCP 为提供可靠性传输，实行『顺序控制』或『重发控制』机制，此外还具备『流控制（流量控制）』、『拥塞控制』等提高网络利用率等众多功能 UDP 是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成，在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达，因此应用有时会根据自己的需要进行重发处理， TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况，而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，TCP 和 UDP 应该根据应用的目的按需使用 端口号数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址，前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器，在传输层也有这种类似于地址的概念，那就是端口号，端口号用来识别同一台计算机中进行通信的不同应用程序，因此它也被称为程序地址 根据端口号识别应用一台计算机上同时可以运行多个程序，传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输 通过 IP 地址、端口号、协议号进行通信识别仅凭目标端口号识别某一个通信是远远不够的 一和二的通信是在两台计算机上进行的，它们的目标端口号相同，都是 80，这里可以根据源端口号加以区分 三和一的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同 此外当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP） 端口号的确定 标准既定的端口号，这种方法也叫静态方法，它是指每个应用程序都有其指定的端口号，但并不是说可以随意使用任何一个端口号，例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的，这些端口号被称为知名端口号，分布在 0 ~ 1023 之间，除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024 ~ 49151 之间，不过这些端口号可用于任何通信用途 时序分配法，服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号，在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配，动态分配的端口号范围在 49152 ~ 65535 之间 端口号与协议 端口号由其使用的传输层协议决定，因此不同的传输层协议可以使用相同的端口号 此外，那些知名端口号与传输层协议并无关系，只要端口一致都将分配同一种应用程序进行处理 UDP UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制，即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为 此外传输途中出现丢包，UDP 也不负责重发 甚至当包的到达顺序出现乱序时也没有纠正的功能 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理 UDP 常用于以下几个方面 包总量较少的通信（DNS、SNMP 等） 视频、音频等多媒体通信（即时通信） 限定于 LAN 等特定网络中的应用通信 广播通信（广播、多播） TCP TCP 与 UDP 的区别相当大，它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制，而这些在 UDP 中都没有 此外 TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现） 三次握手（重点） TCP 提供面向有连接的通信传输，面向有连接是指在数据通信开始之前先做好两端之间的准备工作 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立，在 Socket 编程中，这一过程由客户端执行 Connect 来触发 第一次握手，客户端将标志位 SYN 置为 1，随机产生一个值 seq = J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认 第二次握手，服务器端收到数据包后由标志位 SYN = 1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack = J + 1，随机产生一个值 seq = K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态 第三次握手，客户端收到确认后，检查 ack 是否为 J + 1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = K + 1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K + 1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 四次挥手（重点） 四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开，在 Socket 编程中，这一过程由客户端或服务端任一方执行 Close 来触发 由于 TCP 连接是全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭 中断连接端可以是客户端，也可以是服务器端 第一次挥手，客户端发送一个 FIN = M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态，意思是说『客户端没有数据要发给你了』，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据 第二次挥手，服务器端收到 FIN 后，先发送 ack = M + 1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息，这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文 第三次挥手，当服务器端确定数据已发送完成，则向客户端发送 FIN = N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了，服务器端进入 LAST_ACK 状态 第四次挥手，客户端收到 FIN = N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack = N + 1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传，服务器端收到 ACK 后，就知道可以断开连接了，客户端等待了 2MSL（最大报文段寿命） 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了，最终完成了四次握手 上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图 通过序列号与确认应答提高可靠性 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（ACK），当发送端将数据发出之后会等待对端的确认应答，如果有确认应答，说明数据已经成功到达对端，反之则数据丢失的可能性很大 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发，由此即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输 未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到，只是返回的确认应答在途中丢失，这种情况也会导致发送端误以为数据没有到达目的地而重发数据 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜，此时源主机只要按照机制重发数据即可，对于目标主机来说，反复收到相同的数据是不可取的，为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包，为此我们引入了序列号 序列号是按照顺序给发送数据的每一个字节（8 位字节）都标上号码的编号，接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去，通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输 重发超时的确定 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发，最理想的是，找到一个最小时间，它能保证『确认应答一定能在这个时间内返回』 TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性，为此它在每次发包时都会计算往返时间及其偏差，将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值 在 BSD 的 Unix 以及 Windows 系统中，超时都以 0.5 秒为单位进行控制，因此重发超时都是 0.5 秒的整数倍，不过最初其重发超时的默认值一般设置为 6 秒左右 数据被重发之后若还是收不到确认应答，则进行再次发送，此时等待确认应答的时间将会以 2 倍、4 倍的指数函数延长 此外，数据也不会被无限、反复地重发，达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止 以段为单位发送数据 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为『最大消息长度』（MSS），最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度 TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送，进行重发时也是以 MSS 为单位 MSS 在三次握手的时候，在两端主机之间被计算得出，两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小，然后会在两者之间选择一个较小的值投入使用 利用窗口控制提高速度 TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理，这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低 为解决这个问题，TCP 引入了窗口这个概念，确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短，也就是说发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送，如下图所示 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图中窗口大小为 4 个段，这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能 滑动窗口控制 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去，不过在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传，为此发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据，当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置，这样可以顺序地将多个段同时发送提高通信性能，这种机制也别称为滑动窗口控制 窗口控制中的重发控制在使用窗口控制中， 出现丢包一般分为两种情况 确认应答未能返回的情况，在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图 某个报文段丢失的情况，接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答，如下图所示，当某一报文段丢失后，发送端会一直收到序号为 1001 的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回，而发送端主机如果连续三次收到同一个确认应答，就会将其对应的数据进行重发，这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制 应用层协议在上面我们介绍了 IP 协议、TCP 协议以及 UDP 协议相关内容，它们是通信最基本的部分，也是属于 OSI 参考模型中的下半部分，本小节我们所要介绍的应用协议主要是指 OSI 参考模型中第 5 层、第 6 层、第 7 层上半部分的协议 应用协议的定义利用网络的应用程序有很多，包括 Web 浏览器、电子邮件、远程登录、文件传输、网络管理等，能够让这些应用进行特定通信处理的正是应用协议，TCP 和 IP 等下层协议是不依赖于上层应用类型、适用性非常广的协议，而应用协议则是为了实现某种应用而设计和创造的协议 应用协议与协议的分层网络应用由不同的用户和软件供应商开发而成，为了实现网络应用的功能，在应用之间进行通信时将其连接的网络协议是非常重要的，设计师和开发人员根据所开发模块的功能和目的，可以利用现有的应用协议，也可以自己定义一个新的应用协议 应用可以直接享用传输层以下的基础部分，因为开发者只要关心选用哪种应用协议、如何开发即可，而不必担心应用中的数据该以何种方式发送到目标主机等问题，这也是得益于网络层的功劳 远程登陆远程登录是为了实现 TSS（Time Sharing System）环境，是将主机和终端的关系应用到计算机网络上的一个结果，TSS 中通常由一个处理能力非常强的主机，围绕这台主机有诸多性能较弱的终端机器，这些终端通过专线于主机连接 类似地，实现从自己的本地计算机登录到网络另一端计算功能的应用就叫做远程登录，远程登录主要使用 TELNET 和 SSH 两种协议 TELNET TELNET 利用 TCP 的一条连接，通过这一条连接向 主机发送文字命令并在主机上执行，本地用户好像直接与远端主机内部的 Shell 相连着似的，直接在本地进行操作，TELNET 可以分为两类基本服务，一是仿真终端功能，二是协商选项机制 TELNET 经常用于登录路由器或高性能交换机等网络设备进行相应的设置，通过 TELNET 登录主机或路由器等设备时需要将自己的登录用户名和密码注册到服务端 SSH SSH 是加密的远程登录系统，TELNET 中登录时无需输人密码就可以发送，容易造成通信窃听和非法入侵的危险，使用 SSH 后可以加密通信内容，即使信息被窃听也无法破解所发送的密码、具体命令以及命令返回的结果是什么，SSH 还包括很多非常方便的功能 可以使用更强的认证机制 可以转发文件 可以使用端口转发功能 端口转发是指将特定端口号所收到的消息转发到特定的IP地址和端口号码的一种机制，由于经过 SSH 连接的那部分内容被加密，确保了信息安全，提供了更为灵活的通信 文件传输FTP 是在两个相连的计算机之间进行文件传输所用的协议，FTP 也需要登录了对方计算机才能操作，FTP 有两条 TCP 连接，一条用来控制，一条用于数据文件传输 用于控制的 TCP 的工作包括登录用户和密码的验证、发送文件的名称、发送方式设置等，该连接使用 TCP 21 号端口，在进行 GET、PUT、LIST 等操作，都会建立一个用于数据传输的 TCP 连接，数据传送完毕则断开该连接，然后在控制连接上继续通信 一般数据连接的建立要于控制连接的方向相反，因此在用 NAT 连接外部 FTP 无法直接建立传输数据时使用的 TCP 连接，必须使用 PASV 命令修改连接的方向，数据连接的端口一般使用 20，出于安全考虑也可以用随机端口 电子邮件提供电子邮件的协议叫做 SMTP（Simple Mail Transfer Protocol），为了实现高效发送，在其传输层使用了 TCP 协议 传统方式的邮件发送必须在两者都联网的情况进行，当有一方离线则无法完成，为此在技术上改变了这种方式，引进了一个一直会联网的邮件服务器，发送和接收端通过邮件服务器进行收发邮件，接收端从邮件服务器接收邮件时使用 POP3（Post Office Protocol）协议 WWWWWW（World Wide Web，万维网）是将互联网信息以超文本形式展现的系统，也叫 Web 系统，其客户端叫 Web 浏览器，WWW 有三个重要概念 访问信息的手段与位置 URI（Uniform Resource Identifier，统一资源定位符） 信息的表现形式 HTML（HyperText Markup Language，超文本语言） 信息转发 HTTP（HyperText Transfer Protocol，超文本传输协议） 其他应用层协议互联网一直以来作为数据通信网络得到了蓬勃的发展，不仅用于实时收发音频、图像、视频等多媒体数据领城，还被用于电视电话会议、现场转播等即时性、双向性的领域 多媒体通信实现技术由于 TCP 具有流控制、拥塞控制、重发机制等功能，有时应用所发出去的数据可能无法迅速到达对端目标主机，然而在互联网电话和电视会议当中，即使有少许丢包，也希望系统延时少一点，非常注重系统的即时性，因此，在实时多媒体通信当中采用 UDP 然而只使用 UDP 还不足以达到进行实时多媒体通信的目的，例如在互联网电视电话议会中需要提供查询对方号码、模拟电话机的拨号以及以什么形式交互数据等功能，为此需要一个叫做『呼叫控制』的支持，呼叫控制主要采用 H.323 与 SIP 协议，此外还需要 RTP 协议（结合多媒体数据本身的特性进行传输的一种协议）和压缩技术（在网络上传输音频、视频等大型多媒体数据时进行压缩）的支持 H.323H.323 是由 ITU 开发用于在 IP 网上传输音频、视频的一种协议，起初它主要是作为接人 ISDN 网和 IP 网之上的电话网为目的的一种规范而被提出的，H.323 定义了 4 个主要组件，它们分别是终端（用户终端）、网关（吸收用户数据压缩顺序的不-致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用） SIP与 H.323 相对的 TCP/IP 协议即是 SIP（Session Initiation Protocol）协议，SIP 的提出要晚于 H.323，但是被普遍认为更适用于互联网，H.323 的规范内容较多、对应起来比较复杂，而相比之下 SIP 的构成则简单了许多 终端之间进行多媒体通信时，需要具备事先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能，此外还需要具备中断会话和数据转发的功能，这些功能（呼叫控制与信令）都被统一于 SIP 协议中，它相当于 OSI 参考模型中的会话层 RTPUDP 不是一种可靠性传输协议，因此有可能发生丢包或乱序等现象，因此采用 UDP 实现实时的多媒体通信需要附加一个表示报文顺序的序列号字段，还需要对报文发送时间进行管理，这些正是 RTP（Real-Time Protocol）的主要职责 RTP 为每个报文附加时间戳和序列号，接收报文的应用，根据时间戳决定数据重构的时机，序列号则根据每发出一次报文加一的原则进行累加，RTP 使用这个序列号对同一时间戳的数据进行排序，掌握是否有丢包的情况发生，RTCP（RTP Control Protocol）是辅助 RTP 的一种协议，通过丢包率等线路质量的管理，对 RTP 的数据传送率进行控制 P2P互联网上电子邮件的通信，普遍属于一台服务器对应多个客户端的 C/S 模式，即 1 对 N 的通信形态，与之不同，网络上的终端或主机不经服务器直接 1 对 1 相互通信的情况叫做 P2P（Peer To Peer），这就好比使用无线收发器进行一对一通话，P2P 中主机具备客户端和服务端两方面的功能，以对等的关系相互提供服务 不过也有不支持 P2P 的环境，例如在服务器与客户端分离型的环境中，服务器要在一个可以由互联网直接访问的地方，而客户端即使是在 NAT 内侧也不会有问题，然而在 P2P 中这个结构却行不通，它必须具备从互联网越过 NAT 令双方终端能够访问的功能 LDAPLDAP（Lighweight Directory Aces Protocol）是访问目录服务的一种协议，也叫轻量级目录访问协议，所谓『目录服务』是指网络上存在的一种提供相关资源的数据库的服务，这里的目录也有地址簿的意思，可以认为目录服务就是管理网络上资源的一种服务 网络安全最后我们再来看看互联网中网络安全的重要性及其相关的实现技术 TCP/IP 与网络安全起初，TCP/IP 只用于一个相对封闭的环境，之后才发展为并无太多限制、可以从远程访问更多资源的形式，因此安全这个概念并没有引起人们太多的关注，然而随着互联网的日益普及，发生了很多非法访问、恶意攻击等问题，着实影响了企业和个人的利益，由此网络安全逐渐成为人们不可忽视一个重要内容 互联网向人们提供了很多便利的服务，为了让人们能够更好、更安全的利用互联网，只有牺牲一些便利性来确保网络的安全，因此『便利性』和『安全性』作为两个对立的特性兼容并存，产生了很多新的技术，随着恶意使用网络的技术不断翻新，网络安全的技术也在不断进步，今后除了基本的网络技术外，通过正确理解安全相关的技术、制定合理的安全策略、按照制定的策略进行网络管理及运维成为一个重要的课题 网络安全构成要素随着互联网的发展，对网络的依赖程度越高就越应该重视网络安全，尤其是现在，对系统的攻击手段愈加多样化，某种特定程度的技术远不足以确保一个系统的安全，网络安全最基本的要领是要有预备方案，即不是在遇到问题的时候才去处理，而是通过对可能发生的问题进行预测，在可行的最大范围内为系统制定安保对策，进行日常运维，这才是重中之重 TCP/IP 相关的安全要素如下图所示 防火墙组织机构内部的网络与互联网相连时，为了避免域内受到非法访问的威胁，往往会设置防火墙，防火墙的种类和形态有很多种，例如专门过滤（或不过滤）特定数据包的包过滤防火墙、数据到达应用以后由应用处理并拒绝非法访问的应用网关，这些防火墙都有基本相同的设计思路，那就是『暴露给危险的主机和路由器的个数要有限』 IDS（入侵检测系统）数据包符合安全策略，防火墙才会让其通过，即只要与策略相符，就无法判断当前访问是否为非法访问，所以全部允许通过，而 IDS 正是检查这种已经侵人内部网络进行非法访问的情况，并及时通知给网络管理员的系统，IDS 根据不同的用途可以提供各种不同的功能 从设置形式上看，一般在防火墙或 DMZ 等边界设备上进行设置，有了这样监控、检测边界的功能，就可以设置在网络内部、全网或个别特殊的服务器上进行监控 从功能上看，IDS 有定期采集日志、长期监控、通知异常等功能，它可以监控网络上流动的所有数据包，为了确保各种不同系统的安全，IDS 可以与防火墙相辅相成，实现更为安全的网络环境 反病毒/个人防火墙反病毒和个人防火墙是继 IDS 和防火墙之后的另外两种安全对策，它们往往是用户使用的计算机或服务器上运行的软件，既可以监控计算机中进出的所有包、数据和文件，也可以防止对计算机的异常操作和病毒人侵 安全协议主要有三部分 IPsec 与 VPN以前，为了防止信息泄露，对机密数据的传输一般不使用互联网等公共网络（Public Network），而是使用由专线连接的私有网络（Private Network），从而在物理上杜绝了窃听和篡改数据的可能，然而专线的造价太高是一个不可回避的问题 为了解决此类问题，人们想出了在互联网上构造一个虚拟的私有网络，即 VPN（Virtual Private Network，虚拟专用网），互联网中采用加密和认证技术可以达到『即使读取到数据也无法读懂』、『检查是否被篡改』等功效，VPN 正是一种利用这两种技术打造的网络 在构建 VPN 时，最常被使用的是 IPsec，它是指在 IP 首部的后面追加『封装安全有效载荷』和『认证首部』，从而对此后的数据进行加密，不被盗取者轻易解读，在发包的时候附加上述两个首部，可以在收包时根据首部对数据进行解密，恢复成原始数据，由此加密后的数据不再被轻易破解，即使在途中被篡改，也能够被及时检测 基于这些功能，VPN 的使用者就可以不必设防地使用一个安全的网络环境 TLS/SSL 与 HTTPS现在有很多互联网应用已经逐渐进人人们的生活，例如网上购物、网上订车票、订飞机票或预订演出票等，在这些系统的支付过程中经常会涉及信用卡网上支付，而网上银行系统还需要用户直接在网上输人账号和密码 而信用卡卡号、银行账号、密码都属于个人的机密信息，因此在网络上传输这些信息时有必要对它们进行加密处理，Web 中可以通过 TlS/SSL 对 HTTP 通信进行加密，使用 TLS/SSL 的 HTTP 通信叫做 HTTPS 通信，HTTPS 中采用对称加密方式，而在发送其公共密钥时采用的则是公钥加密方式 IEEE802.1XIEEE802.1X 是为了能够接人 LAN 交换机和无线 LAN 接人点而对用户进行认证的技术，并且它只允许被认可的设备才能访问网络，虽然它是一个提供数据链路层控制的规范，但是与 TCP/IP 关系紧密，一般由客户端终端、AP（无线基站）或 2 层交换机以及认证服务器组成","link":"/2020/09/20/HTTP/14/"},{"title":"HTTP/2","text":"最近在梳理 HTTP 协议相关内容，当梳理到追加协议相关内容的时候发现 HTTP/2 所涉及到的内容篇幅还是有些多的，所以就单独提取出来，更多相关内容可以参考 HTTP 协议 和 前端知识体系整理 这里推荐 HTTP/2 这篇文章，个人认为是目前看到的资料里介绍的最全面和详细的，HTTP/2 的二进制帧，多路复用，请求优先级，流量控制，服务器端推送以及首部压缩等新改进都涉及到了，还可以感受一下 https://http2.akamai.com/demo 这个地址，它主要用来比较 HTTP/2 与 HTTP/1.1 在性能上的差异 HTTP/2 的前身HTTP/2 的前身是 HTTP/1.0 和 HTTP/1.1，虽然之前仅仅只有两个版本，但这两个版本所包含的协议规范之庞大，足以让任何一个有经验的工程师为之头疼，HTTP/1.0 诞生于 1996 年，协议文档足足 60 页，之后第三年，HTTP/1.1 也随之出生，协议文档膨胀到了 176 页，但是网络协议新版本并不会马上取代旧版本，实际上 HTTP/1.0 和 HTTP/1.1 在之后很长的一段时间内一直并存，这是由于网络基础设施更新缓慢所决定的，今天的 HTTP/2 也是一样，新版协议再好也需要业界的产品锤炼，需要基础设施逐年累月的升级换代才能普及 HTTP 站在 TCP 之上理解 HTTP 协议之前一定要对 TCP 有一定的了解，HTTP 是建立在 TCP 协议之上，TCP 协议作为传输层协议其实离应用层并不远，HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，比如 TCP 建立连接时三次握手有 1.5 个 RTT（来回时间）的延迟，为了避免每次请求的都经历握手带来的延迟，应用层会选择不同策略的 HTTP 长链接方案，又比如 TCP 在建立连接的初期有慢启动（slow start）的特性，所以连接的重用总是比新建连接性能要好 HTTP 应用场景HTTP 诞生之初主要是应用于 Web 端内容获取，对于早些时期简单的获取网页内容的场景，HTTP 表现得还算不错，但随着互联网的发展和 Web 2.0 的诞生，更多的内容开始被展示（比如更多的的图片文件，CSS，JavaScript 等），用户打开一个网站首页所加载的数据总量和请求的个数也在不断增加，今天绝大部分的门户网站首页大小都会超过 2M，请求数量可以多达 100 个，另一个广泛的应用场景就是在移动端，比如对于电商类 App，加载首页的请求也可能多达几十个 带宽和延迟影响一个网络请求的因素主要有两个，带宽和延迟，今天的网络基础建设已经使得带宽得到极大的提升，大部分时候都是延迟在影响响应速度，HTTP/1.0 被抱怨最多的就是连接无法复用，和队头阻塞这两个问题，理解这两个问题有一个十分重要的前提就是客户端是依据域名来向服务器建立连接，一般浏览器会针对单个域名的服务器同时建立六到八个连接，而移动端的连接数则一般控制在四到六个，显然连接数并不是越多越好，资源开销和整体延迟都会随之增大 连接无法复用会导致每次请求都经历三次握手和慢启动，三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大，队头阻塞会导致带宽无法被充分利用，以及后续健康请求被阻塞，假设有五个请求同时发出，如下图 对于 HTTP/1.1 的实现，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求 2，3，4，5 只能等待请求 1 的响应回来之后才能逐个发出，网络通畅的时候性能影响不大，一旦请求 1 因为什么原因没有抵达服务器，或者响应因为网络阻塞没有及时返回，影响的就是所有后续请求 解决连接无法复用HTTP/1.0 协议头里可以设置 Connection: keep-alive，在 Header 里设置 keep-alive 可以在一定时间内复用连接，具体复用时间的长短可以由服务器控制，一般在 15s 左右，到 HTTP/1.1 之后，Connection 的默认值就是 keep-alive，如果要关闭连接复用需要显式的设置 Connection: close，一段时间内的连接复用对电脑端的浏览器体验帮助很大，因为大部分的请求在集中在一小段时间以内，但对与移动端来说，成效不大，因为移动端的请求比较分散且时间跨度相对较大，所以移动端一般会从应用层寻求其它解决方案，比如长连接方案或者伪长连接方案 基于 TCP 的长链接这种方式是建立一条自己的长链接通道，通道的实现是基于 TCP 协议，基于 TCP 的 Socket 编程技术难度相对复杂很多，而且需要自己制定协议，但带来的回报也很大，信息的上报和推送变得更及时，在请求量爆发的时间点还能减轻服务器压力（HTTP 短连接模式会频繁的创建和销毁连接） 长轮询HTTP 长轮询可以用下图表示 客户端在初始状态就会发送一个轮询请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回，所以连接会一直被保持，一旦结束马上又会发起一个新的轮询请求，如此反复，所以一直会有一个连接被保持，服务器有新的内容产生的时候，并不需要等待客户端建立一个新的连接，使用长轮询的好处以及需要注意的地方有以下这些 和传统的 HTTP 短链接相比，长连接会在用户增长的时候极大的增加服务器压力 移动端网络环境复杂，像 Wi-Fi 和 4G 之类的网络切换，进电梯导致网络临时断掉等，这些场景都需要考虑怎么重建健康的连接通道 这种轮询的方式稳定性并不好，需要做好数据可靠性的保证，比如重发和 ACk 机制（消息确认机制） 轮询的响应有可能会被中间代理缓存，要处理好业务数据的过期机制 长轮询方式还有一些缺点是无法克服的，比如每次新的请求都会带上重复的 Header 信息，还有数据通道是单向的，主动权掌握在服务端这边，客户端有新的业务请求的时候无法及时传送 流HTTP 流的过程大致是下面这样的 同长轮询不同的是，服务端并不会结束初始的流请求，而是持续的通过这个通道返回最新的业务数据，显然这个数据通道也是单向的，流是通过在服务端响应的头部里增加 Transfer Encoding: chunked 来告诉客户端后续还会有新的数据到来，除了和长轮询相同的难点之外，流还有几个缺陷 有些代理服务器会等待服务器的响应结束之后才会将结果推送到请求客户端，对于流这种永远不会结束的方式来说，客户端就会一直处于等待响应的过程中 业务数据无法按照请求来做分割，所以客户端没收到一块数据都需要自己做协议解析，也就是说要做自己的协议定制 关于 HTTP 流的更为详细的内容，我们会在下面的 HTTP/2 章节当中进行介绍 WebSocketWebSocket 和传统的 TCP Socket 连接相似，也是基于 TCP 协议，提供双向的数据通道，比基于字节流的 TCP Socket 使用更简单，同时又提供了传统的 HTTP 所缺少的长连接功能 解决队头阻塞队头阻塞是 HTTP/2 之前网络体验的最大祸源，正如上面带宽和延迟章节当中的图片所示，健康的请求会被不健康的请求影响，而且这种体验的损耗受网络环境影响，出现随机且难以监控，为了解决队头阻塞带来的延迟，协议设计者设计了一种新的 HTTP 管线化机制（pipelining），管线化的流程图可以用下图表示 和之前相比最大的差别是，请求 2，3，4，5 不需要等待请求 1 的响应返回之后才发出，而是几乎在同一时间就把请求发向了服务器，2，3，4，5 及所有后续共用该连接的请求节约了等待的时间，极大的降低了整体延迟，下图可以清晰的看出这种新机制对延迟的改变 不过管线化并不是完美的，它也存在不少缺陷 管线化只能适用于 HTTP/1.1 ，一般来说，支持 HTTP/1.1 的服务端都要求支持管线化 只有幂等的请求（GET，HEAD）能使用管线化，非幂等请求比如 POST 不能使用，因为请求之间可能会存在先后依赖关系 队头阻塞并没有完全得到解决，服务端的响应还是要求依次返回，遵循 FIFO（first in first out）原则，也就是说如果请求 1 的响应没有回来，2，3，4，5 的响应也不会被送回来 绝大部分的 HTTP 代理服务器不支持管线化 正是因为有这么多的问题，各大浏览器厂商要么是根本就不支持管线化，要么就是默认关掉了管线化机制，而且启用的条件十分苛刻，可以参考 Chrome 对于管线化的 问题描述 开拓者 SPDYHTTP/1.0 和 HTTP/1.1 虽然存在这么多问题，业界也想出了各种优化的手段，但这些方法手段都是在尝试绕开协议本身的缺陷，直到 2012 年 Google 提出了 SPDY 的方案，大家才开始从正面看待和解决老版本 HTTP 协议本身的问题，这也直接加速了 HTTP/2 的诞生，实际上 HTTP/2 是以 SPDY 为原型进行讨论和标准化的 SPDY 的目标SPDY 的目标在一开始就是瞄准老版本所存在的一些痛点，即延迟和安全性，关于延迟我们在上面已经介绍过了，至于安全性，由于 HTTP 是明文协议，其安全性也一直被业界诟病，如果以降低延迟为目标，应用层的 HTTP 和传输层的 TCP 都是都有调整的空间，不过 TCP 作为更底层协议存在已达数十年之久，其实现已深植全球的网络基础设施当中，所以 SPDY 的瞄准的就是 HTTP，主要有以下几点 降低延迟，客户端的单连接单请求，服务端的 FIFO 响应队列都是延迟的大头 HTTP 最初设计都是客户端发起请求，然后服务端响应，所以服务端无法主动推送内容到客户端 头部压缩，Cookie 和 User-Agent 很容易让 Header 的大小增加，而且由于 HTTP 的无状态特性，Header 必须每次请求都重复携带，很浪费流量 为了增加业界响应的可能性，聪明的 Google 一开始就避开了从传输层动手，对于协议使用者来说，也只需要在请求的 Header 里设置 User-Agent，然后在服务端端做好支持即可，极大的降低了部署的难度， SPDY 的设计如下 SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议，同时可以使用已有的 SSL 功能，SPDY 的功能可以分为基础功能和高级功能两部分，基础功能默认启用，高级功能需要手动启用，它们有以下这些 基础功能 多路复用（multiplexing），多路复用通过多个请求流共享一个 TCP 连接的方式，解决了队头阻塞的问题，降低了延迟同时提高了带宽的利用率 请求优先级（request prioritization），多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞，SPDY 允许给每个请求设置优先级，这样重要的请求就会优先得到响应，比如浏览器加载首页，首页的 HTML 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容 Header 压缩，选择合适的压缩算法可以减小包的大小和数量，SPDY 对 Header 的压缩率可以达到 80% 以上，低带宽环境下效果很大 高级功能 服务端推送，最初只能由客户端发起请求，然后服务器被动的发送响应，开启服务端推送之后，服务端通过在 Header 中添加 X-Associated-Content 头域（X 开头的 Header 都属于非标准的，自定义 Header ）告知客户端会有新的内容推送过来，在用户第一次打开网站首页的时候，服务端将资源主动推送过来可以极大的提升用户体验 服务端暗示，和服务端推送不同的是，服务端暗示并不会主动推送内容，只是告诉有新的内容产生，内容的下载还是需要客户端主动发起请求，服务端暗示通过在 Header 中添加 X-Subresources 头域来通知，一般应用场景是客户端需要先查询服务端状态，然后再下载资源，可以节约一次查询请求 SPDY 的效果SPDY 的成绩可以用 Google 官方的一个数字来说明，页面加载时间减少了 64%，Google 的官网也给出了他们自己做的一份测试数据，测试对象是 25 个访问量排名靠前的网站首页，每个网站测试 10 次取平均值，结果如下 不开启 SSL 的时候提升在 27% ~ 60%，开启之后为 39% ~ 55%， 这份测试结果有两点值得特别注意 连接数的选择，连接到底是基于域名来建立，还是不做区分所有子域名都共享一个连接，这个策略选择上值得商榷，Google 的测试结果测试了两种方案，看结果似乎是单一连接性能高于多域名连接方式，之所以出现这种情况是由于网页所有的资源请求并不是同一时间发出，后续发出的子域名请求如果能复用之前的 TCP 连接当然性能更好，实际应用场景下应该也是单连接共享模式表现好 带宽的影响，测试基于两种带宽环境，一慢一快，网速快的环境下对减小延迟的提升更大，单连接模式下可以提升至 60%，原因也比较简单，带宽越大，复用连接的请求完成越快，由于三次握手和慢启动导致的延迟损耗就变得更明显 除了连接模式和带宽之外，丢包率和 RTT 也是需要测试的参数，SPDY 对 Header 的压缩有 80% 以上，整体包大小能减少大概 40%，发送的包越少，自然受丢包率影响也就越小，所以丢包率大的恶劣环境下 SPDY 反而更能提升体验，下图是受丢包率影响的测试结果，丢包率超过 2.5% 之后就没有提升了 RTT 越大，延迟会越大，在高 RTT 的场景下，由于 SPDY 的请求是并发进行的，所有对包的利用率更高，反而能更明显的减小总体延迟，测试结果如下 不过 SPDY 从 2012 年诞生到 2016 停止维护，只有短短的四年，时间跨度对于网络协议来说其实非常之短，但 SPDY 也在某种意义上算是完成了自己的使命 HTTP/2SPDY 的诞生和表现说明了两件事情，一是在现有互联网设施基础和 HTTP 协议广泛使用的前提下，是可以通过修改协议层来优化的，二是修改确实效果明显而且业界反馈很好，正是这两点让 IETF（Internet Enginerring Task Force）开始正式考虑制定 HTTP/2 的计划，最后决定以 SPDY/3 为蓝图起草 HTTP/2，SPDY 的部分设计人员也被邀请参与了 HTTP/2 的设计 HTTP/2 需要考虑的问题HTTP/1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP/1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP/1.1 也是当前使用最为广泛的 HTTP 协议 HTTP/0.9，只支持 GET 方法，不支持多媒体内容的 MIME 类型、各种 HTTP 首部，或者版本号，只是为了获取 HTML 对象 HTTP/1.0，添加了版本号、各种 HTTP 首部、一些额外的方法，以及对多媒体对象的处理 HTTP/1.0+，keep-alive 连接、虚拟主机支持，以及代理连接支持都被加入到 HTTP 之中等等 HTTP/1.1，主要有下面几个部分 缓存处理，在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match 等更多可供选择的缓存头来控制缓存策略 在请求头引入了 Range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content） 错误通知的管理，新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除等 Host 头处理，HTTP/1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request） 长连接，HTTP/1.1 支持长连接和管线化处理，也就是 Connection: keep-alive 而 HTTP/2 在此基础之上被寄予了如下期望，希望能够 相比于使用 TCP 的 HTTP/1.1，最终用户可感知的多数延迟都有能够量化的显著改善 解决 HTTP 中的队头阻塞问题 并行的实现机制不依赖与服务器建立多个连接，从而提升 TCP 连接的利用率，特别是在拥塞控制方面 保留 HTTP/1.1 的语义，可以利用已有的文档资源，包括 HTTP 方法、状态码、URI 和首部字段等 连接连接是所有 HTTP/2 会话的基础元素，其定义是客户端初始化的一个 TCP/IP Socket，客户端是指发送 HTTP 请求的实体，这和 HTTP/1.1 是一样的，不过与完全无状态的 HTTP/1.1 不同的是，HTTP/2 把它所承载的帧（frame）和流（stream）共同依赖的连接层元素捆绑在一起，其中既包含连接层设置也包含首部表 为了向服务器双重确认客户端支持 HTTP/2，客户端会发送一个叫作 Connection Preface 字节流，作为连接的第一份数据，这主要是为了应对客户端通过纯文本的 HTTP/1.1 升级上来的情况，该字节流用十六进制表示如下 10x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a 解码为 ASCII 是 1PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n 这个字节流的用处是，如果服务器（或者中间网络设备）不支持 HTTP/2，就会产生一个显式错误，这个消息特意设计成 HTTP/1.1 消息的样式，如果运行良好的 HTTP/1.1 服务器收到这个字节流，它会阻塞这个方法，并返回错误，可以让 HTTP/2 客户端明确地知道发生了什么错误 这个字节流会有一个 SETTINGS 帧紧随其后，服务器为了确认它可以支持 HTTP/2，会声明收到客户端的 SETTINGS 帧，并返回一个它自己的 SETTINGS 帧（反过来也需要确认），然后确认环境正常，可以开始使用 HTTP/2（关于 SETTINGS 帧相关概念，我们会在下面进行介绍） 帧HTTP/2 是基于帧的协议，采用分帧是为了将重要信息都封装起来，让协议的解析方可以轻松阅读、解析并还原信息， 相比之下，HTTP/1.1 不是基于帧的，而是以文本分隔，看看下面的简单例子 12345678GET / HTTP/1.1 &lt;crlf&gt;Host: www.example.com &lt;crlf&gt;Connection: keep-alive &lt;crlf&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9... &lt;crlf&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4)... &lt;crlf&gt;Accept-Encoding: gzip, deflate, sdch &lt;crlf&gt;Accept-Language: en-US,en;q=0.8 &lt;crlf&gt;Cookie: pfy_cbc_lb=p-browse-w; customerZipCode=99912|N; ltc=%20;...&lt;crlf&gt; 解析这种数据往往速度慢且容易出错，需要不断读入字节，直到遇到分隔符为止，同时还要考虑一些并不是按照规矩来进行发送的客户端，所以解析 HTTP/1.1 的请求或响应可能出现下列问题 一次只能处理一个请求或响应，完成之前不能停止解析 无法预判解析需要多少内存，这会带来一系列问题，例如需要把一行读到多大的缓冲区里，如果行太长会应该增加并重新分配内存，还是返回 400 错误？ 为了解决这些问题，保持内存处理的效率和速度可不简单，从另一方面来说，有了帧，处理协议的程序就能预先知道会收到什么，基于帧的协议，特别是 HTTP/2，开始有固定长度的字节，其中包含表示整帧长度的字段 下面我们就稍微深入的来了解一下 HTTP/2 当中帧的概念，这里主要涉及到帧大小，帧格式和帧定义 帧大小帧载荷的大小受接收者在 SETTINGS_MAX_FRAME_SIZE 设定的最大大小限制，值的范围为 2^14 至 2^24 - 1，包含所有的实现要必须能够接收并最低限度地处理长度最大在 2^14 字节的帧，外加 9 个字节的帧首部，当描述帧大小时，帧首部的大小不会被包含在内 这里需要注意，某些帧类型，比如 ING，会对允许的载荷数据的大小强加额外的限制 如果一个帧超出了 SETTINGS_MAX_FRAME_SIZE 定义的大小，超出了为帧类型定义的任何限制，或者太小以至于无法包含必要的帧数据，终端必须发送一个错误码 FRAME_SIZE_ERROR，可能改变整个连接状态的帧中的帧大小错误必须被当作一个连接错误，这包括所有携带首部块的帧（即 HEADERS，PUSH_PROMISE，CONTINUATION，SETTINGS 和所有流标识符为 0 的帧） 终端没有义务用完帧中的所有的可用空间，响应能力可以通过使用比允许的最大大小小的帧来提升，在发送时间敏感的帧时发送大帧可能导致延时（比如 RST_STREAM，WINDOW_UPDATE 或 PRIORITY），如果传输由于一个大的帧而阻塞，则可能会影响性能 帧格式所有的帧都以一个固定的 9 字节首部开始，其后紧跟一个可变长度的载荷，如下 也可以简化为下面这样 123456789+-----------------------------------------------+| Length (24) |+---------------+---------------+---------------+| Type (8) | Flags (8) |+-+-------------+---------------+-------------------------------+|R| Stream Identifier (31) |+=+=============================================================+| Frame Payload (0...) ...+---------------------------------------------------------------+ 下面我们来看看它们各部分之间的含义 名称 字节数 释义 Length 3 字节 帧载荷的长度，以一个无符号 24 位整数表示，2^14 字节是默认的最大帧大小，如果需要更大的帧，必须在 SETTINGS 帧中设置 Type 1 字节 当前帧类型，帧类型决定了帧的格式和语义，HTTP/2 实现必须忽略并丢弃未知类型的帧 Flags 1 字节 具体帧类型的标识，一个特定于帧类型的 8 位 boolean 标记保留字段 R 1 位 保留位，无需设置，否则可能带来严重后果 Stream Identifier 31 位 流标识符，被表示为一个 31 位无符号整型值 Frame Payload 可变 真实的帧内容，长度是在 Length 字段中设置的 HTTP/1.1 有个特性叫管线化，允许一次发送一组请求，但是只能按照发送顺序依次接收响应，而且管线化备受互操作性和部署的各种问题的困扰，在请求应答过程中，如果出现任何状况，剩下所有的工作都会被阻塞在那次请求应答之后，这就是队头阻塞，它会阻碍网络传输和 Web 页面渲染，直至失去响应，但是由于 HTTP/2 是分帧的，请求和响应可以交错甚至多路复用，多路复用有助于解决类似队头阻塞的问题 帧定义HTTP/2 中定义了多种帧类型，每种都有一个唯一的 8 位类型码标识，每种帧类型都有不同的目的，特定帧类型的传输可能改变连接的状态，如果终端不能维护连接状态视图的一致性，连接内成功的通信将是不可能的，因此终端之间，关于特定帧的使用对状态所产生的影响具有相同的理解就变得非常重要 DATA 帧DATA 帧（type = 0x0）传送与一个流关联的任意的可变长度的字节序列，一个或多个 DATA 帧被用于携带 HTTP 请求或响应载荷，DATA 帧也可以包含填充字节，填充字节可以被加进 DATA 帧来掩盖消息的大小，填充字节是一个安全性的功能 1234567+---------------+|Pad Length? (8)|+---------------+-----------------------------------------------+| Data (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ 名称 解释 含义 Pad Length 填充长度 一个 8 位的字段，包含了以字节为单位的帧的填充的长度，这个字段是有条件的，只有在 PADDED 标记设置时才出现 Data 数据 应用数据，数据的大小是帧载荷减去出现的其它字段的长度剩余的大小 Padding 填充 填充字节包含了无应用语义的值，当填充时填充字节必须被设置为 0，接收者没有义务去验证填充可以将非零的填充当做一个类型为 PROTOCOL_ERROR 的连接错误 标志 DATA 帧定义了如下的标记 END_STREAM（0x1），当设置了这个标记时，位 0 表示这个帧是终端将为标识的流发送的最后一帧，设置这个标记使得流进入某种 Half-Closed 状态或 Closed 状态 PADDED（0x8），当设置了这个标记时，位 3 表示上面描述的填充长度字段及填充存在 流 DATA 帧必须与一个流关联，如果收到了一个流标识符为 0x0 的 DATA 帧，接收者必须以一个类型为 PROTOCOL_ERROR 的连接错误来响应 DATA 帧受控于 flow control，而且只能在流处于 open 或 Half-Closed (remote) 状态时发送，整个的 DATA 帧载荷被包含在 flow control 中，可能包括填充长度和填充字段，如果收到 DATA 帧的流不处于 open 或 Half-Closed (remote) 状态，则接收者必须以一个类型为 STREAM_CLOSED 的流错误来响应 填充字节的总大小由填充长度字段决定，如果填充的长度是帧载荷的长度或更大，则接收者必须将这作为一个类型为 PROTOCOL_ERROR 的连接错误来处理应 这里需要注意的是，一个帧可以通过包含一个值为零的填充长度字段来使帧长度只增加一个字节 HEADERS 帧HEADERS 帧（type = 0x1）用于打开一个流，此外还携带一个 Header 块片段，HEADERS 帧可以在状态为 idle，Reserverd (local)，open，或 Half-Closed (remote) 的流上发送 1234567891011+---------------+|Pad Length? (8)|+-+-------------+-----------------------------------------------+|E| Stream Dependency? (31) |+-+-------------+-----------------------------------------------+| Weight? (8) |+-+-------------+-----------------------------------------------+| Header Block Fragment (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ HEADERS 帧具有如下的字段 名称 解释 含义 Pad Length 填充长度 一个 8 位的字段，包含了以字节为单位的帧的填充的长度，只有在 PADDED 标记设置时才出现 E 单 bit 的标记 指示流依赖是独占的，这个字段只有在 PRIORITY 标记设置时才会出现 Stream Dependency 流依赖 31 位的流标识符，标识这个流依赖的流，这个字段只有在 PRIORITY 标记设置时才会出现 Weight 权重 无符号 8 位整型值，表示流的优先级权重，将值加 1 以获得介于 1 和 256 之间的权重这个字段只有在 PRIORITY 标记设置时才会出现 Header Block Fragment 请求头片段 - Padding 填充 - 标志 HEADERS 帧定义了如下的标记 END_STREAM（0x1），当设置时，位 0 表示这个 Header 块是终端将是被标识的流发送的最后一个块，HEADERS 帧可以携带 END_STREAM 标记，标明流的结束，然而在相同的流上，一个设置了 END_STREAM 标记的 HEADERS 帧后面可以跟着 CONTINUATION 帧，逻辑上来说 CONTINUATION 帧是 HEADERS 帧的一部分 END_HEADERS（0x4）若设置，位 2 指示该帧包含整个头部块，并且没有任何 CONTINUATION 帧，没有 END_HEADERS 标记集的 HEADERS 帧必须跟随同一个流的 CONTINUATION 帧，接收方必须将接收到的任何其他类型的帧或不同流上的帧视为 PROTOCOL_ERROR 类型的连接错误 PADDED（0x8）若设置，位 3 指示 Pad Length 字段及其描述的填充符存在 PRIORITY（0x20）若设置，位 5 指示存在专用标志（E），流依赖性和权重字段 载荷 HEADERS 帧的载荷包含一个 Header 块片段，不适合放在 HEADERS 帧中的 Header 块在 CONTINUATION 帧中继续，HEADERS 帧必须与流关联，如果收到的流标识符字段为 0x0 的 HEADERS 帧，收件人必须响应 PROTOCOL_ERROR 类型的连接错误 HEADERS 帧可以包含填充，填充字段和标志与为 DATA 帧定义的填充字段和标志相同，填充超过 Header 分段的剩余大小必须被视为 PROTOCOL_ERROR HEADERS 帧中的优先级信息在逻辑上等同于单独的 PRIORITY 帧，但包含在 HEADERS 中可避免在创建新流时在流优先级中进行流失的可能性，流之后的 HEADERS 帧中的优先级字段重新设置流的优先顺序 PRIORITY 帧PRIORITY 帧（type = 0x2）指定了流发送者建议的优先级，它可以以任何流状态发送，包括空闲或封闭的流 12345+-+-------------------------------------------------------------+|E| Stream Dependency (31) |+-+-------------+-----------------------------------------------+| Weight (8) |+-+-------------+ PRIORITY 帧的有效载荷包含以下字段 名称 解释 含义 Pad Length 填充长度 一个 8 位的字段，包含了以字节为单位的帧的填充的长度，只有在 PADDED 标记设置时才出现 E 单 bit 的标记 表示流依赖性是唯一的单比特标志 Stream Dependency 流依赖 该数据流依赖的流的 31 位流标识符 Weight 权重 一个无符号的 8 位整数，表示流的优先级权重，将值加 1 以获得介于 1 和 256 之间的权重 标志 PRIORITY 帧不定义任何标志 负载 PRIORITY 帧始终标识一个流，如果接收到一个流标识符为 0x0 的 PRIORITY 帧，接收方必须响应 PROTOCOL_ERROR 类型的连接错误 PRIORITY 帧可以在任何状态下的流上发送，尽管它不能在构成单个 Header 块的连续帧之间发送，请注意，此帧可能在处理完成或帧发送完成后到达，这会导致它对已识别的流没有任何影响，对于处于 Half-Closed (remote) 或 Closed 状态的流，此帧只能影响对已识别流及其依赖流的处理，它不会影响该流上的帧传输 PRIORITY 帧可以从处于 idle 或 Closed 状态的流中发送，这允许通过改变未使用或已关闭的父流的优先级来重新设置一组从属流的优先级，长度不是 5 个字节的 PRIORITY 帧必须被视为类型为 FRAME_SIZE_ERROR 的流错误 RST_STREAM 帧RST_STREAM 帧（type = 0x3）允许立即终止一个流，发送 RST_STREAM 以请求取消流或指示发生了错误情况 123+---------------------------------------------------------------+| Error Code (32) |+---------------------------------------------------------------+ RST_STREAM 帧包含标识错误代码的单个无符号的 32 位整数，错误代码指示流被终止的原因 标志 RST_STREAM 帧不定义任何标志 说明 RST_STREAM 帧完全终止流并使其进入 close 状态，在流上接收到 RST_STREAM 之后，接收者不得为该流发送额外的帧，但 PRIORITY 除外，但是在发送 RST_STREAM 之后，发送端点务必准备好接收和处理在 RST_STREAM 到达之前可能已经由对端在流上发送的帧 RST_STREAM 帧必须与一个流相关联，如果接收到 RST_STREAM 帧且流标识符为 0x0，则接收方必须将其视为 PROTOCOL_ERROR 类型的连接错误 RST_STREAM 帧不得在 idle 状态下发送流，如果接收到标识空闲流的 RST_STREAM 帧，接收者必须将其视为类型为 PROTOCOL_ERROR 的连接错误 长度不是 4 个字节的 RST_STREAM 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误 SETTINGS 帧SETTINGS 帧（type = 0x4）的有效载荷由零个或多个参数组成，每个参数由一个无符号的 16 位设置标识符和一个无符号的 32 位值组成 12345+-------------------------------+| Identifier (16) |+-------------------------------+-------------------------------+| Value (32) |+---------------------------------------------------------------+ 如下参数定义 名称 含义 SETTINGS_HEADER_TABLE_SIZE（0x1） 允许发送者以字节的形式通知远程端点用于解码 Header 块的 Header 压缩表的最大尺寸，编码器可以通过使用特定于 Header 块内头部压缩格式的信令来选择等于或小于此值的任何大小 SETTINGS_ENABLE_PUSH（0x2） 此设置可用于禁用服务器推送，如果一个端点接收到这个参数设置为 0 的值，它不应该发送一个 PUSH_PROMISE 帧，一个端点既将这个参数设置为 0，并且确认它也必须将 PUSH_PROMISE 帧的接收视为类型为 PROTOCOL_ERROR 的连接错误，初始值为 1，表示允许服务器推送，除 0 或 1 以外的任何值必须视为 PROTOCOL_ERROR 类型的连接错误 SETTINGS_MAX_CONCURRENT_STREAMS（0x3） 表示发件人允许的最大并发流数，这个限制是有方向性的，它适用于发送者允许接收者创建的数据流，最初这个值没有限制，建议此值不小于 100，以免不必要地限制并行性，值为 0 的 SETTINGS_MAX_CONCURRENT_STREAMS 不应被视为特殊的端点，零值确实会阻止创建新的流，然而这也可能发生在活动流所耗尽的任何限制上，服务器应该只在短时间内设置一个零值，如果服务器不希望接受请求，关闭连接更合适 SETTINGS_INITIAL_WINDOW_SIZE（0x4） 指示发送者的流级别流控制的初始窗口大小（以八位字节为单位），初始值是 2^16 - 1 个八位组，该设置会影响所有流的窗口大小，高于最大流量控制窗口大小 2^31 - 1 的值必须视为 FLOW_CONTROL_ERROR 类型的连接错误 SETTINGS_MAX_FRAME_SIZE（0x5） 指示发送者愿意接收的最大帧有效载荷的大小，以八位字节为单位，初始值是 2^14 个八位字节，端点通告的值必须在该初始值和最大允许帧大小之间，包括在内，此范围之外的值务必视为 PROTOCOL_ERROR 类型的连接错误 SETTINGS_MAX_HEADER_LIST_SIZE（0x6） 此通报设置以八位字节的形式通知对等方发送方准备接受的header列表的最大大小，该值基于header字段的未压缩大小，包括名称和八位字节的值的长度，以及每个 Header 字段的开销 32 个字节，对于任何给定的请求，可能会强制实施一个比所宣传的更低的限制，此设置的初始值是无限的，接收到带有任何未知或不支持标识符的 SETTINGS 帧的端点必须忽略该设置 说明 SETTINGS 帧传达影响端点通信方式的配置参数，例如对对等行为的偏好和约束，SETTINGS 帧也用于确认收到这些参数，SETTINGS 参数不协商，它们描述了发送端的特征，被接收端使用，每个对等体可以通告相同参数的不同值，例如客户端可能会设置较高的初始流量控制窗口，而服务器可能会设置较低的值以节省资源 设置帧必须在连接开始时由两个端点发送，并且可以在连接的整个生命周期内由任一端点在任何其他时间发送，实现必须支持本规范定义的所有参数 SETTINGS 帧中的每个参数都会替换该参数的任何现有值，参数按它们出现的顺序进行处理，并且 SETTINGS 帧的接收者不需要保持除参数当前值以外的任何状态，因此 SETTINGS 参数的值是接收器看到的最后一个值 SETTINGS 参数由接收方确认，为了实现这一点，SETTINGS 帧定义了 ACK（0x1）标志，若设置，位 0 表示该帧确认接收和应用对等设备帧，当该位设置时，SETTINGS 帧的有效载荷必须为空，收到一个设置了 ACK 标志并且长度字段值不为 0 的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误 SETTINGS 帧始终适用于连接，而不是单个流，设置帧的流标识必须为零（0x0），如果端点收到 SETTINGS 帧，其流标识符字段不是 0x0，那么端点必须响应一个类型为 PROTOCOL_ERROR 的连接错误 SETTINGS 帧影响连接状态，错误格式或不完整的 SETTINGS 帧必须被视为类型为 PROTOCOL_ERROR 的连接错误 长度不是 6 个字节倍数的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误 Settings 同步 SETTINGS 中的大部分值受益于或需要了解对等体何时接收并应用更改的参数值，为了提供这样的同步时间点，其中未设置 ACK 标志的 SETTINGS 帧的接收方必须在收到后尽快应用更新的参数 SETTINGS 帧中的值必须按照它们出现的顺序进行处理，值之间没有其他帧处理，不支持的参数必须被忽略，一旦所有值都被处理完毕，接收者必须立即发出一个设置了 ACK 标志的 SETTINGS 帧， 一旦接收到设置了 ACK 标志的 SETTINGS 帧，改变参数的发送者就可以依赖已经应用的设置 如果SETTINGS 帧的发送者在合理的时间内没有收到确认，它可能会发出SETTINGS_TIMEOUT 类型的连接错误 PUSH_PROMISE 帧PUSH_PROMISE 帧（type = 0x5）用于在发送者打算初始化流之前通知对端，PUSH_PROMISE 帧包括端点计划创建的流的无符号 31 位标识符以及为流提供附加上下文的一组 Header 123456789+---------------+|Pad Length? (8)|+-+-------------+-----------------------------------------------+|R| Promised Stream ID (31) |+-+-----------------------------+-------------------------------+| Header Block Fragment (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ 名称 解释 Pad Length 填充长度 R 一个保留位 Promised Stream ID 一个无符号的31位整数，用于标识由PUSH_PROMISE 保留的流，承诺流标识符必须是发送方发送的下一个流的有效选择 Header Block Fragment 包含请求头部字段的 Header 块片段 Padding 填充字节 标志 END_HEADERS（0x4），置位时，位 2 指示该帧包含整个 Header 块，并且没有任何 CONTINUATION 帧，没有设置 END_HEADERS 标志的 PUSH_PROMISE 帧必须跟着同一个流的 CONTINUATION 帧，接收方必须将接收到的任何其他类型的帧或不同流上的帧视为类型为 PROTOCOL_ERROR 的连接错误 PADDED（0x8），置位时，位 3 指示 Pad Length 字段及其描述的填充符存在 说明 PUSH_PROMISE 帧必须只能在处于 open 或 Half-Closed (remote) 状态的已对端初始化的流上发送，PUSH_PROMISE 帧的流标识符指示与其关联的流，如果流标识符字段指定值 0x0，则接收方必须响应类型为 PROTOCOL_ERROR 的连接错误 承诺的流不需要按照承诺的顺序使用， PUSH_PROMISE 仅保留流标识符供以后使用 如果对端端点的 SETTINGS_ENABLE_PUSH 设置被设置为 0，则不应发送 PUSH_PROMISE，已设置此设置并已收到确认的端点务必将 PUSH_PROMISE 帧的接收视为类型为 PROTOCOL_ERROR 的连接错误 PUSH_PROMISE 帧的接受者可以选择拒绝承诺的流，通过发送带有承诺的流标识符的 RST_STREAM 返回给 PUSH_PROMISE 的发送者来 PING 帧PING 帧（type = 0x6）是一种机制，用于测量来自发送方的最小往返时间，以及确定空闲连接是否仍然有效，PING 帧可以从任何端点发送 12345+---------------------------------------------------------------+| || Opaque Data (64) || |+---------------------------------------------------------------+ 除帧头外，PING 帧必须在有效载荷中包含 8 个不透明数据字节，发送者可以包含它选择的任何值，并以任何方式使用这些八位字节，不包括 ACK 标记的 PING 帧的接收者务必发送一个 PING 帧，并在响应中设置 ACK 标志，并使用相同的有效载荷，PING 响应应该被赋予比任何其他帧更高的优先级 标志 ACK（0x1），置位时，位 0 表示该 PING 帧是 PING 响应，端点必须在 PING 响应中设置这个标志，端点不能响应包含这个标志的 PING 帧 说明 PING 帧不与任何独立的流关联，如果接收到流标识符字段不是 0 的PING 帧，接收者必须以类型是 PROTOCOL_ERROR 的连接错误来响应，接收到长度字段的值不是 8 的 PING 帧，则必须被作为类型是 FRAME_SIZE_ERROR 的连接错误 GOAWAY 帧GOAWAY 帧（type = 0x7）用于启动连接关闭或发出严重错误状态信号，GOAWAY 允许端点正常停止接受新的流，同时仍然完成对先前建立的流的处理，这可以实现管理操作，例如服务器维护，在端点开始新流和端点远程发送 GOAWAY 帧之间存在固有的竞争条件，为了处理这种情况，GOAWAY 包含在此连接中的发送端点上已处理或可能处理的最后一个 Peer-initiated 流的流标识符，例如，如果服务器发送 GOAWAY 帧，则标识的流是由客户端发起的编号最大的流 一旦发送，如果流的标识符高于包含的最后流标识符，则发送方将忽略由接收方发起的流上发送的帧，GOAWAY 帧的接收者不能在连接上打开额外的流，尽管可以为新的流建立新的连接，如果 GOAWAY 的接收者已经发送了具有比 GOAWAY 帧更高的流标识符的流的数据，那么这些流不被处理或将不被处理，GOAWAY 帧的接收者可以将这些流视为从未被创建，从而允许这些流稍后在新连接上重试 端点应该总是在关闭连接之前发送一个 GOAWAY 帧，以便远程节点可以知道流是否已被部分处理，例如，如果 HTTP 客户端在服务器关闭连接的同时发送 POST，则客户端无法知道服务器是否开始处理该 POST 请求，如果服务器未发送 GOAWAY 帧来指示它可能具有哪些流采取行动，对于行为不当的对端，端点可以选择关闭连接而不发送 GOAWAY GOAWAY 帧可能不会立即关闭连接之前，GOAWAY 的接收器不再用于连接应该在终止连接之前仍然发送 GOAWAY 帧 1234567+-+-------------------------------------------------------------+|R| Last-Stream-ID (31) |+-+-------------------------------------------------------------+| Error Code (32) |+---------------------------------------------------------------+| Additional Debug Data (*) |+---------------------------------------------------------------+ 标志 GOAWAY 帧不定义任何标记 说明 GOAWAY 帧适用于连接，而不是特定的流，端点必须将带有 0x0 以外的流标识符的 GOAWAY 帧视为类型为 PROTOCOL_ERROR 的连接错误 GOAWAY 帧还包含一个 32 位错误代码，其中包含关闭连接的原因，端点可以将不透明数据附加到任何GOAWAY 帧的有效载荷，额外的调试数据仅用于诊断目的，并没有语义值，调试信息可能包含安全或隐私敏感数据，记录或以其他方式持久存储的调试数据必须有足够的安全措施以防止未经授权的访问， CONTINUATION 帧CONTINUATION 帧（type = 0x9）被用于继续发送 Header 块片段的序列，只要相同流上的前导帧是没有设置 END_HEADERS 标记的 HEADERS，PUSH_PROMISE 或 CONTINUATION 帧，就可以发送任意数量的 CONTINUATION 帧 123+---------------------------------------------------------------+| Header Block Fragment (*) ...+---------------------------------------------------------------+ CONTINUATION 帧有效载荷包含一个 Header 块片段 标志 CONTINUATION 帧定义了以下标志 END_HEADERS（0x4），置位时，位 2 表示该帧结束 Header 块，如果未设置 END_HEADERS 位，则该帧必须紧跟着另一个 CONTINUATION 帧，接收方必须将接收到的任何其他类型的帧或不同流上的帧视为 PROTOCOL_ERROR 类型的连接错误 说明 CONTINUATION 帧必须与流相关联，如果收到其流标识符字段为 0x0 的 CONTINUATION 帧，接收方必须响应 PROTOCOL_ERROR 类型的连接错误 CONTINUATION 帧必须在前面加上 HEADERS，PUSH_PROMISE 或 CONTINUATION 帧，而不要设置 END_HEADERS 标志，观察到违反此规则的接受者必须响应 PROTOCOL_ERROR 类型的连接错误 流 HTTP/2 规范对流的定义是，HTTP/2 连接上独立的、双向的帧序列交换，因为在客户端与服务器之间，双方都可以互相发送二进制帧，这样的双向传输的序列就可以称为流，你也可以将流看作在连接上的一系列帧，它们构成了单独的 HTTP 请求和响应，如果客户端想要发出请求，它会开启一个新的流，然后服务器将在这个流上回复，这与 请求/响应 的流程很类似，重要的区别在于，因为有分帧，所以多个请求和响应可以交错，而不会互相阻塞 流具有一些重要的特性 单个的 HTTP/2 连接可以包含多个并发打开的流，各个终端多个流的帧可以交叉 流可以单方面地建立和使用，或由客户端或服务器共享 流可以被任何一端关闭 流中帧的发送顺序是值得注意的，接收者以它们收到帧的顺序处理，特别的，HEADERS 帧和 DATA 帧在语义上是非常重要的 流由一个整数标识，流标识符由发起流的终端来赋值 这里也存在一个问题，那就是乱序的二进制帧，是如何组装成对于的报文呢？ 所谓的乱序，指的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是按顺序传输的 接收方收到二进制帧后，将相同的 Stream ID 组装成完整的请求报文和响应报文 二进制帧中有一些字段，控制着优先级和流量控制等功能，这样就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验 流的生命周期流的生命周期如下所示 123456789101112131415161718192021222324252627282930313233343536 +--------+ send PP | | recv PP ,--------| idle |--------. / | | \\ v +--------+ v +----------+ | +----------+ | | | send H / | |,------| Reserved | | recv H | Reserved |------.| | (local) | | | (remote) | || +----------+ v +----------+ || | +--------+ | || | recv ES | | send ES | || send H | ,-------| open |-------. | recv H || | / | | \\ | || v v +--------+ v v || +----------+ | +----------+ || | Half | | | Half | || | Closed | | send R / | Closed | || | (remote) | | recv R | (local) | || +----------+ | +----------+ || | | | || | send ES / | recv ES / | || | send R / v send R / | || | recv R +--------+ recv R | || send R / `-----------&gt;| |&lt;-----------' send R / || recv R | Closed | recv R |`-----------------------&gt;| |&lt;----------------------' +--------+ send: endpoint sends this frame recv: endpoint receives this frame H: HEADERS frame (with implied CONTINUATIONs) PP: PUSH_PROMISE frame (with implied CONTINUATIONs) ES: END_STREAM flag R: RST_STREAM frame 这里需要注意的是，此图显示了流状态转换以及会影响这些转换的帧和标志，在这方面，CONTINUATION 帧不会导致状态转换，实际上是它们跟随的 HEADERS 或 PUSH_PROMISE 的一部分，出于状态转换的目的，END_STREAM 标志作为单独的事件处理到承载它的帧，具有 END_STREAM 标志设置的 HEADERS 帧可以导致两个状态转换 两个端点都有流状态的主观视图，当帧在传输过程中可能会有所不同，端点不协调创建流，它们是由任一端点单方面创建的，在发送 RST_STREAM 之后，状态不匹配的负面影响仅限于 Closed 状态，在关闭后帧可能会被接收一段时间 流的状态数据流具有以下状态 idle所有的流都以 idle 状态开始，以下转换在此状态下有效 发送或接收 HEADERS 帧会导致流成为 open，同样 HEADERS 帧也可以使流立即变成 Half-Closed 在另一个流上发送 PUSH_PROMISE 帧将保留标识的空闲流为以后使用，保留流的流状态转换为 Reserved (local) 在另一个流上接收 PUSH_PROMISE 帧将保留标识的空闲流为以后使用，保留流的流状态转换为 Reserved (remote) 特别注意，PUSH_PROMISE 帧不在空闲流上发送，而是在 Promised Stream ID 字段中引用新保留的流 在 idle 状态下，在流上接收除 HEADERS 或 PRIORITY 之外的任何帧必须被视为类型为 PROTOCOL_ERROR 的连接错误 Reserved (local)处于 Reserved (local) 状态的流是通过发送 PUSH_PROMISE 帧来承诺的流，PUSH_PROMISE 帧通过将流与远程对等端发起的开放流关联来保留 idle 流，在这种状态下，只有以下转换是可能的 端点可以发送 HEADERS 帧，这会导致流开启为 Half-Closed (remote) 状态 任一端点都可以发送 RST_STREAM 帧，以使流成为 Closed，这将释放流预留 在此状态下，端点不得发送除 HEADERS，RST_STREAM 或 PRIORITY 之外的任何类型的帧，可以在此状态下接收 PRIORITY 或 WINDOW_UPDATE 帧，在此状态的流上接收除 RST_STREAM，PRIORITY 或 WINDOW_UPDATE 以外的任何类型的帧必须视为 PROTOCOL_ERROR 类型的连接错误 Reserved (remote)处于 Reserved (remote) 状态的流已被远程对端保留，在这种状态下，只有以下转换是可能的 接收 HEADERS 帧会导致数据流转换为 Half-Closed (local) 任一端点都可以发送 RST_STREAM 帧，以使流成为 Closed，这将释放流预留 端点可以在这种状态下发送 PRIORITY 帧来重新设置保留流的优先级，在此状态下，端点不得发送除 RST_STREAM，WINDOW_UPDATE 或 PRIORITY 以外的任何类型的帧，在这种状态下，在流上接收除 HEADERS，RST_STREAM 或 PRIORITY 以外的任何类型的帧必须被视为类型为 PROTOCOL_ERROR 的连接错误 open处于open状态的流可以被两个对端用来发送任何类型的帧，在这种状态下，发送对等方遵守流级别的流量控制限制， 在这种状态下，任何端点都可以发送带有 END_STREAM 标志的帧，这会导致流转换到 Half-Closed 状态之一，发送 END_STREAM 标志的端点导致流状态变为 Half-Closed (local)，接收 END_STREAM 标志的端点将导致流状态变为 half-close (remote)，每个端点都可以从此状态发送 RST_STREAM 帧，使其立即转换为Closed Half-Closed (local)处于 Half-Closed (local) 状态的流不能用于发送 WINDOW_UPDATE，PRIORITY 和 RST_STREAM 以外的帧，当接收到包含 END_STREAM 标志的帧或任一对端发送 RST_STREAM 帧时，流将从此状态转换为 Closed 状态 端点可以在这种状态下接收任何类型的帧，使用 WINDOW_UPDATE 帧提供流量控制信用是继续接收流量控制帧所必需的，在这种状态下，接收方可以忽略 WINDOW_UPDATE 帧，因为带有 END_STREAM 标志的帧可能会在短时间内到达，在此状态下收到的优先级帧用于重新确定依赖于已识别流的流的优先级 Half-Closed (remote)Half-Closed (remote) 的流不再被对端用来发送帧，在这种状态下，端点不再需要维护接收器流量控制窗口，如果端点接收到除 WINDOW_UPDATE，PRIORITY 或 RST_STREAM 之外的其他帧，则对于处于此状态的流，它必须响应类型为 STREAM_CLOSED 的流错误 Half-Closed (remote) 的流可以被端点用来发送任何类型的帧，在这种状态下，端点会继续观察流级别的流量控制限制，通过发送一个包含 END_STREAM 标志的帧或任一对端发送 RST_STREAM 帧，流可以从此状态转换为 Closed 状态 ClosedClosed 状态是终结状态，端点不得在封闭流上发送 PRIORITY 以外的帧，在接收到 RST_STREAM 后接收除 PRIORITY 以外的任何帧的端点必须将其视为类型 STREAM_CLOSED 的流错误，类似地，在接收到设置了 END_STREAM 标志的帧后接收任何帧的端点必须将其视为 STREAM_CLOSED 类型的连接错误，除非该帧是允许的，如下所述 WINDOW_UPDATE 或 RST_STREAM 帧可以在包含 END_STREAM 标志的 DATA 或 HEADERS 帧发送后的短时间内在此状态下接收，在远程节点接收并处理 RST_STREAM 或带有 END_STREAM 标志的帧之前，它可能会发送这些类型的帧，终端必须忽略在这种状态下接收到的 WINDOW_UPDATE 或 RST_STREAM 帧，当然终端也可以选择将在发送 END_STREAM 相当长时间之后到达的帧作为类型为 PROTOCOL_ERROR 的连接错误 PRIORITY 帧可以在 Closed 流上发送，以设置依赖于这个 Closed 流的其他流的优先级，端点应该处理 PRIORITY 帧，当然如果流已经从依赖关系树中移除，则它们可以被忽略 如果由于发送 RST_STREAM 帧而达到此状态，那么接收 RST_STREAM 的对端可能已经在流上发送或已排队发送帧而无法取消，端点必须在发送 RST_STREAM 帧后忽略它在 Closed 流上接收到的帧，端点可以选择限制它忽略帧的时间段，并将在此时间后到达的帧视为错误 在发送 RST_STREAM 之后接收的适用于流量控制的帧（即 DATA）被计数到连接流量控制窗口，即使这些帧可能被忽略，因为它们是在发送者收到 RST_STREAM 之前发送的，发送者会认为这些帧是针对流量控制窗口进行计数的 端点在发送 RST_STREAM 后可能会收到一个 PUSH_PROMISE 帧，即使关联的流已重置，PUSH_PROMISE 也会使流成为 Reserved，因此，需要 RST_STREAM 来关闭不需要的承诺流 补充实现应该将描述中没有明确表示允许的帧的状态的接收作为一个类型为 PROTOCOL_ERROR 的连接错误，注意任何状态下的流都可以发送和接收 PRIORITY，类型未知的帧被忽略 流的标识符流用无符号的 31 位整数标识 客户端发起的流必须使用『奇数』流标识符 由服务器发起的必须使用『偶数』流标识符 连接控制消息使用零（0x0）的流标识符，零流标识符不能用于建立新的流，被升级到 HTTP/2 的 HTTP/1.1 请求以流标识符（0x1）响应，升级完成后，对于客户端来说流 0x1 是 Half-Closed (local)，因此，流 0x1 不能被从 HTTP/1.1 升级的客户端选择为新的流标识符 新建立的流的标识符必须在数字上大于发起端点已经打开或保留的所有流，这将控制使用 HEADERS 帧打开的流和使用 PUSH_PROMISE 保留的流，接收到意外流标识符的端点必须响应 PROTOCOL_ERROR 类型的连接错误 新流的标识符的第一次使用隐式地关闭了所有由该对端以低值流标识符发起的处于 idle 状态的流，例如如果客户端在流 7 上发送 HEADERS 帧而没有在流 5 上发送帧，则当流 7 的第一帧被发送或接收时，流 5 转换到 Closed 状态 流标识符不能被重用，长时间连接会导致端点耗尽流标识符的可用范围，无法建立新流标识符的客户端可以为新流建立新连接，无法建立新流标识符的服务器可以发送 GOAWAY 帧，以便强制客户端为新流打开新连接 连接、流和帧的关系关系如下 一个连接同时被多个流复用 一个流代表一次完整的 请求/响应 过程，包含多个帧 一个消息被拆分封装成多个帧进行传输 消息HTTP 消息泛指 HTTP 请求或响应，流是用来传输一对 请求/响应消息的，一个消息至少由 HEADERS 帧（初始化流）组成，并且可以另外包含 CONTINUATION 和 DATA 帧，以及其他的 HEADERS 帧 HTTP/1.1 的请求和响应都分成消息首部和消息体两部分，与之类似 HTTP/2 的请求和响应分成 HEADERS 帧和 DATA 帧，HTTP/1.1 把消息分成两部分 请求/状态行 与 首部，HTTP/2 取消了这种区分，并把这些行变成了伪首部，举个例子，HTTP/1.1 的请求和响应可能是这样的 1234567GET / HTTP/1.1Host: www.example.comUser-agent: Next-Great-h2-browser-1.0.0Accept-Encoding: compress, gzipHTTP/1.1 200 OKContent-type: text/plainContent-length: 2 ... 在 HTTP/2 中，它等价于 1234567:scheme: https:method: GET:path: /:authority: www.example.comUser-agent: Next-Great-h2-browser-1.0.0Accept-Encoding: compress, gzip :status: 200 content-type: text/plain 请注意，请求和状态行在这里拆分成了多个首部，即 :scheme、:method、:path 和 :status，同时要注意的是，HTTP/2 的这种表示方式跟数据传输时不同，主要有以下两点 没有分块编码（chunked encoding），在基于帧的世界里，只有在无法预先知道数据长度的情况下向对方发送数据时，才会用到分块，在使用帧作为核心协议的 HTTP/2 里，就不再需要它了 不再有 101 的响应，Switching Protocol 响应是 HTTP/1.1 的边缘应用，它如今最常见的应用可能就是用以升级到 WebSocket 连接，ALPN 提供了更明确的协议协商路径，往返的开销也更小 流量控制HTTP/2 的新特性之一是基于流的流量控制，不同于 HTTP/1.1 的世界，只要客户端可以处理，服务端就会尽可能快地发送数据，HTTP/2 提供了客户端调整传输速度的能力，WINDOW_UPDATE 帧用来指示流量控制信息，每个帧告诉对方，发送方想要接收多少字节 客户端有很多理由使用流量控制，一个很现实的原因可能是，确保某个流不会阻塞其他流，也可能客户端可用的带宽和内存比较有限，强制数据以可处理的分块来加载反而可以提升效率，尽管流量控制不能关闭，把窗口最大值设定为设置 2^31 - 1 就等效于禁用它，至少对小于 2GB 的文件来说是如此 另一个需要注意的是中间代理，通常情况下，网络内容通过代理或者 CDN 来传输，也许它们就是传输的起点或终点，由于代理两端的吞吐能力可能不同，有了流量控制，代理的两端就可以密切同步，把代理的压力降到最低 请求优先级流的最后一个重要特性是依赖关系，现代浏览器都经过了精心设计，首先请求网页上最重要的元素，以最优的顺序获取资源，由此来优化页面性能，拿到了 HTML 之后，在渲染页面之前，浏览器通常还需要 CSS 和 JavaScript 这样的东西，在没有多路复用的时候，在它可以发出对新对象的请求之前，需要等待前一个响应完成 有了 HTTP/2，客户端就可以一次发出所有资源的请求，服务端也可以立即着手处理这些请求，由此带来的问题是，浏览器失去了在 HTTP/1.1 时代默认的资源请求优先级策略，假设服务器同时接收到了 100 个请求，也没有标识哪个更重要，那么它将几乎同时发送每个资源，次要元素就会影响到关键元素的传输 HTTP/2 通过流的依赖关系来解决这个问题，通过 HEADERS 帧和 PRIORITY 帧，客户端可以明确地和服务端沟通它需要什么，以及它需要这些资源的顺序，这是通过声明依赖关系树 和树里的相对权重实现的 依赖关系为客户端提供了一种能力，通过指明某些对象对另一些对象有依赖，告知服务器这些对象应该优先传输 权重让客户端告诉服务器如何确定具有共同依赖关系的对象的请求优先级 我们来看看这个简单的网站 1234567index.html – header.jpg – critical.js – less_critical.js – style.css – ad.js – photo.jpg 在收到主体 HTML 文件之后，客户端会解析它，并生成依赖树，然后给树里的元素分配权重，这时这棵树可能是这样的 1234567index.html – style.css – critical.js – less_critical.js (weight 20) – photo.jpg (weight 8) – header.jpg (weight 8) – ad.js (weight 4) 在这个依赖树里，客户端表明它最需要的是 style.css，其次是 critical.js，没有这两个文件，它就不能接着渲染页面，等它收到了 critical.js，就可以给出其余对象的相对权重，权重表示服务一个对象时所需要花费时间的重要程度 HTTP/2 主要改动HTTP/2 作为新版协议，改动细节必然很多，不过对应用开发者和服务提供商来说，影响较大的有以下这些 多路复用多路复用允许同时通过单一的 HTTP/2 连接发起多重的 请求/响应 消息，众所周知在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞，也就是如果想并发多个请求，必须使用多个 TCP 链接 这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题，而 HTTP/2 的多路复用（Multiplexing）则允许同时通过单一的 HTTP/2 连接发起多重的 请求/响应 消息 因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个 TCP 连接上双向交换消息 关于多路复用的特点与好处，简单总结就是 同域名下所有通信都在单个连接上完成，单个连接可以承载任意数量的双向数据流 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是 Stream ID，流标识符，有了它，接收方就能从乱序的二进制帧中选择 ID 相同的帧，按照顺序组装成请求/响应报文 减少服务端连接压力，减少占用内存，提升连接吞吐量 连接数的减少改善了网络拥塞状况，慢启动时间减少，拥塞和丢包恢复速度更快 避免连接频繁创建和关闭（三次连接、四次挥手） 首部压缩（Header Compression） 现代网页平均包含 140 个请求，每个 HTTP 请求平均有 460 字节，总数据量达到 63KB，即使在最好的环境下，这也会造成相当长的延时，如果考虑到拥挤的 Wi-Fi 或连接不畅的蜂窝网络，那可是非常痛苦的，这些请求之间通常几乎没有新的或不同的内容，这才是真正的浪费，所以大家迫切渴望某种类型的压缩 HTTP/1.1 并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生，SPDY 使用的是通用的 DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法 比如下面这两个请求 123456789:authority: www.example.com:method: GET:path: /:scheme: httpsaccept: text/html,application/xhtml+xmlaccept-language: en-US,en;q=0.8cookie: last_page=286A7F3DEupgrade-insecure-requests: 1user-agent: Awesome H2/1.0 12345678:authority: www.example.com:method: GET:path: /style.css:scheme: httpsaccept: text/html,application/xhtml+xml accept-language: en-US,en;q=0.8cookie: last_page=*398AB8E8Fupgrade-insecure-requests: 1user-agent: Awesome H2/1.0 可以看到，后者的很多数据与前者重复了，第一个请求约有 220 字节，第二个约有 230 字节，但二者只有 36 字节是不同的，如果仅仅发送这 36 字节，就可以节省约 85% 的字节数，简而言之，HPACK 的原理就是这样，下面我们简单的来看看 HPACK 算法是什么样的，如下图所示 从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为 2 对应头部中的 Method 头部信息，这样的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把索引传给对方，对方拿到索引查表即可 这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用，其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率 最后我们再来看一个问题，那就是为什么不使用 GZIP 压缩，而去使用专门为首部压缩而设计的 HPACK 算法呢？ GZIP 也有泄漏加密信息的风险（CRIME 攻击），CRIME 的原理是这样的，攻击者在请求中添加数据，观察压缩加密后的数据量是否会小于预期，如果变小了，攻击者就知道注入的文本和请求中的其他内容（比如私有的会话 Cookie）有重复，在很短的时间内，经过加密的数据内容就可以全部搞清楚，因此大家放弃了已有的压缩方案，研发出 HPACK 服务端推送（Server Push） 提升单个对象性能的最佳方式，就是在它被用到之前就放到浏览器的缓存里面，这正是 HTTP/2 的服务端推送的目的，推送使服务器能够主动将对象发给客户端，这可能是因为它知道客户端不久将用到该对象 如果服务器决定要推送一个对象（RFC 中称为推送响应），会构造一个 PUSH_PROMISE 帧，它的用处有很多 PUSH_PROMISE 帧首部中的流 ID 用来响应相关联的请求，推送的响应一定会对应到客户端已发送的某个请求，如果浏览器请求一个主体 HTML 页面，如果要推送此页面使用的某个 JavaScript 对象，服务器将使用请求对应的流 ID 构造 PUSH_PROMISE 帧 PUSH_PROMISE 帧的首部块与客户端请求推送对象时发送的首部块是相似的，所以客户端有办法放心检查将要发送的请求 被发送的对象必须确保是可缓存的 Method 首部的值必须确保安全，安全的方法就是幂等的那些方法，这是一种不改变任何状态的好办法，例如 GET 请求被认为是幂等的，因为它通常只是获取对象，而 POST 请求被认为是非幂等的，因为它可能会改变服务器端的状态 理想情况下 PUSH_PROMISE 帧应该更早发送，应当早于客户端接收到可能承载着推送对象的 DATA 帧，假设服务器要在发送 PUSH_PROMISE 之前发送完整的 HTML，那客户端可能在接收到 PUSH_PROMISE 之前已经发出了对这个资源的请求，HTTP/2 足够健壮，可以优雅地解决这类问题，但还是会有些浪费 PUSH_PROMISE 帧会指示将要发送的响应所使用的流 ID 其实简单来说就是客户端会从 1 开始设置流 ID，之后每新开启一个流，就会增加 2，之后一直使用奇数，服务器开启在 PUSH_PROMISE 中标明的流时，设置的流 ID 从 2 开始，之后一直使用偶数，这种设计避免了客户端和服务器之间的流 ID 冲突，也可以轻松地判断哪些对象是由服务端推送的，0 是保留数字，用于连接级控制消息，不能用于创建新的流 如果客户端对 PUSH_PROMISE 的任何元素不满意，就可以按照拒收原因选择重置这个流（使用 RST_STREAM），或者发送 PROTOCOL_ERROR（在 GOAWAY 帧中），常见的情况是缓存中已经有了这个对象，而 PROTOCOL_ERROR 是专门留给 PUSH_PROMISE 涉及的协议层面问题的，比如方法不安全，或者当客户端已经在 SETTINGS 帧中表明自己不接受推送时，仍然进行了推送，值得注意的是，服务器可以在 PUSH_PROMISE 发送后立即启动推送流，因此拒收正在进行的推送可能仍然无法避免推送大量资源，推送正确的资源是不够的，还需要保证只推送正确的资源，这是重要的性能优化手段 所以到底如何选择要推送的资源？决策的过程需要考虑到如下方面 资源已经在浏览器缓存中的概率 从客户端看来，这些资源的优先级 可用的带宽，以及其他类似的会影响客户端接收推送的资源 如果用户第一次访问页面时，就能向客户端推送页面渲染所需的关键 CSS 和 JavaScript 资源，那么服务端推送的真正价值就实现了，不过这要求服务器端实现足够智能，以避免推送承诺（push promise）与主体 HTML 页面传输竞争带宽 相比较 HTTP/1.1 的优势 推送资源可以由不同页面共享 服务器可以按照优先级推送资源 客户端可以缓存推送的资源 客户端可以拒收推送过来的资源 关于服务端推送，有一个常见的问题，那就是如果客户端早已在缓存中有了一份副本该怎么办？ 因为 Push 本身具有投机性，所以肯定会出现推送过去的东西浏览器不需要的情况，这种情况下 HTTP/2 允许客户端通过 RESET_STREAM 主动取消 Push，然而这样的话，原本可以用于更好方向的 Push 就白白的浪费掉数据往返的价值 对此，一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的，因为 Cache Digest 使用的是 Golumb Compressed Sets，浏览器客户端可以通过一个连接发送少于 1K 字节的 Packets 给服务端，通知哪些是已经在缓存中存在的 Cache Digests 只是其中一个提案之一， 在 HTTP 社区有着更多其他的解决方案，我们也希望在不久的将来看到他们的身影 HTTP/2 反模式HTTP/1.1 下的一些性能调优办法在 HTTP/2 下会起到反作用 域名拆分域名拆分是为了利用浏览器对每个域名开启多个连接的能力，以便实现资源的并行下载，绕过 HTTP/1.1 的串行化下载的限制，对于包含大量小型资源的网站，普遍的做法是拆分域名，以利用现代浏览器针能对每个域名开启 6 个连接的特性，这样实际上做到了让浏览器并行发送多个请求，以及充分利用可用带宽的效果，因为 HTTP/2 采取多路复用，所以域名拆分就不是必要的了，并且反而会让协议力图实现的目标落空 资源内联资源内联包括把 JavaScript、样式，甚至图片插入到 HTML 页面中，目的是省掉加载外部资源所需的新连接以及请求响应的时间，然而有些 Web 性能的最佳实践不推荐使用内联，因为这样会损失更有价值的特性，比如缓存，如果有同一个页面上的重复访问，缓存通常可以减少请求数（而且能够加速页面渲染），尽管如此，对那些渲染滚动条以上区域所需的微小资源进行内联处理仍是值得的 事实上有证据表明，在性能较弱的设备上，缓存对象的好处不够多，把内联资源拆分出来并不划算，使用 HTTP/2 时的一般原则是避免内联，但是内联也并不一定毫无价值 资源合并资源合并意味着把几个小文件合并成一个大文件，它与内联很相似，旨在省掉那些加载外部资源的请求响应时间，以及 解码/执行 那些资源所消耗的 CPU 资源，之前针对资源内联的规则同样适用于资源合并，我们可以使用它来合并非常小的文件（1KB 或更小），以及对初始渲染很关键的最简化 JavaScript/CSS 资源 禁用 Cookie 的域名通过禁用 Cookie 的域名来提供静态资源是一项标准的性能优化最佳实践，尤其是使用 HTTP/1.1 时，你无法压缩首部，而且有些网站使用的 Cookie 大小常常超过单个 TCP 数据包的限度，不过在 HTTP/2 下请求首部使用 HPACK 算法被压缩，会显著减少巨型 Cookie 的字节数（尤其是当它们在先后请求之间保持不变），与此同时禁用 Cookie 的域名需要额外的主机名称，这意味着将开启更多的连接 如果你正在使用禁用 Cookie 的域名，以后有机会你可能得考虑消灭它，如果你确实不需要那些域名，最好删掉它们，省一个字节就是一个字节 生成精灵图目前，生成精灵图仍是一种避免小资源请求过多的技术（你能看到人们乐意做什么来优化 HTTP/1.1），为了生成精灵图，开发者把较小的图片拼合成较大的图片，然后用 CSS 选择图片中某个部分展示出来，依据设备及其硬件图形处理能力的不同，精灵图要么非常高效，要么非常低效，如果用 HTTP/2，最佳实践就是避免生成精灵图，主要原因在于，多路复用和首部压缩去掉了大量的请求开销，即便如此，还是有些场景适合使用精灵图 参考 HTTP/2 HTTP/2 for Front-End Developers HTTP 2.0 协议详解 Web 性能权威指南 使用 HTTP/2 提升性能的 7 个建议 HTTP/2 资料汇总","link":"/2020/09/06/HTTP/11/"},{"title":"JavaScript 中一些常用方法的实现","text":"算是一些手写 API，常用方法的一些汇总，反正就是面试可能涉及到的一些手写功能可能都会有所涉及，不仅仅只是为了面试所用，也算是在这里做下汇总记录，方便以后可以快速查询（可以直接参考左边目录） once/debounce/thorttleonce 方法实现比较简单，一般来说有两种实现方式，方法一，利用闭包的特性，传递参数，执行完一次以后就自动解除绑定 1234567function once(dom, event, callback) { var handle = function () { callback() dom.removeEventListener(event, handle) } dom.addEventListener(event, handle)} 第二种方式是定义一个局部变量，用来标记函数是否已经调用 123456const once = (fn) =&gt; { let done = false return function () { done ? undefined : ((done = true), fn.apply(this, arguments)) }} 防抖和节流可以使用一个现实中常见的例子来进行举例，比如使用电梯运送策略来说明这两个方法，比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 throttle 和 debounce ，超时设定为 15 秒，不考虑容量限制 throttle 策略的电梯，保证如果电梯第一个人进来后，15 秒后准时运送一次，不等待，如果没有人，则待机 debounce 策略的电梯，如果电梯里有人进来，等待 15 秒，如果有人进来，15 秒等待重新计时，直到 15 秒超时，开始运送 下面的实现方式只是两者最为基本的实现方式，这里我们只为展示其原理，关于它们两者更为完善的实现以及一些内部的原理可以参考我们之前整理过的 函数防抖和节流 123456789101112131415function debounce(fn, wait) { var timer return function () { var that = this, args = arguments clearTimeout(timer) timer = setTimeout(function () { fn.apply(that, args) }, wait) }}// 使用window.onscroll = debounce(function () { console.log('debounce')}, 1000) 1234567891011121314151617function throttle(fn, wait) { var prev = 0 return function () { var now = +new Date() if (now - prev &gt;= wait) { fn.apply(this, arguments) prev = now } }}// 使用var throtteScroll = throttle(function () { console.log('throtte')}, 1000)window.onscroll = throtteScroll call/apply/bindcall 和 apply 更为具体的应用可以参考 JavaScript 中的 call 和 apply，主要包括 两者的区别 call 和 apply 的第一个参数 原理 实现 call 和 apply 哪个速度更快一些 实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Function.prototype.call = function (context, ...args) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = context[fn](...args) delete context[fn] return result}Function.prototype.apply = function (context) { if (context === null || context === undefined) { context = window } else { context = Object(context) } let fn = Symbol() context[fn] = this let result = arguments[1] ? context[fn](...arguments[1]) : context[fn]() delete context[fn] return result}// 如果为了更为完善的话，可以针对 apply 的第二个参数（类数组对象）来进行判断一下const args = arguments[1]let resultif (args) { if (!Array.isArray(args) &amp;&amp; !isArrayLike(args)) { throw new TypeError(`second parameter needs to be an array or class array object`) } else { args = Array.from(args) result = context[fn](...args) }} else { result = context[fn]()}function isArrayLike(o) { if (o &amp;&amp; // o 不是 null、undefined 等 typeof o === 'object' &amp;&amp; // o 是对象 isFinite(o.length) &amp;&amp; // o.length 是有限数值 o.length &gt;= 0 &amp;&amp; // o.length 为非负值 o.length === Math.floor(o.length) &amp;&amp; // o.length 是整数 o.length &lt; 4294967296) // o.length &lt; 2^32 return true else return false} bind 更为详细的实现可见 Function.prototype.bind()，主要包括 基本语法 使用 bind 绑定参数表 理解 bind bind 与 currying bind 与 new bind 实现 ES5 当中实现 12345678910111213141516if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== 'function') { throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable') } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { }, fBound = function () { return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments))) } fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound }} ES6 当中实现 123456789Function.prototype.myBind = function (oThis, ...args) { const thisFn = this let fToBind = function (...params) { const context = this instanceof fToBind ? this : Object(oThis) return thisFn.apply(context, ...args, ...params) } fToBind.prototype = Object.create(thisFn.prototype) return fToBind} 原生 APInew要想手动实现 new 操作符，首先我们需要知道 new 的过程当中发生了什么，主要有以下几步 创建一个全新的对象，并继承其构造函数的 prototype，这一步是为了继承构造函数原型上的属性和方法 执行构造函数，方法内的 this 被指定为该新实例，也就是使 this 指向新创建的对象，这一步是为了执行构造函数内的赋值操作 通过 new 创建的每个对象将最终被 Prototype 链接到这个函数的 prototype 对象上 返回新实例（如果函数没有返回对象类型 Object（包含 Functoin，Array，Date，RegExg，Error），那么 new 表达式中的函数调用将返回该对象引用） 12345678/* new Constructor */function new (f) { var n = { '__prop__': f.prototype } /* step1 */ return function () { f.apply(n, arguments) /* step2 */ return n /* step3 */ }} 但是 __proto__ 这个属性是一个非标准属性，所以我们也可以采用下面这种方式 1234567function myNew(foo, ...args) { let obj = Object.create(foo.prototype) // 创建对象，相当于 o.__proto__ = func.prototype let result = foo.apply(obj, args) // 改变 this 指向，把结果付给 result return result &amp;&amp; result instanceof Object // 判断 result 的类型是不是对象 ? result // 如果是，则返回 result : obj // 否则返回构造函数的执行结果} 我们可以来测试一下 1234567function Foo(name) { this.name = name}const newObj = myNew(Foo, 'zhangsan')console.log(newObj) // Foo {name: 'zhangsan'}console.log(newObj instanceof Foo) // true Promise具体实现过程可以参考 JavaScript 中 Promise 的实现，这里只展示最终代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195const isFunction = variable =&gt; typeof variable === 'function'// 定义 Promise 的三种状态常量const PENDING = 'PENDING'const FULFILLED = 'FULFILLED'const REJECTED = 'REJECTED'class MyPromise { constructor(handle) { if (!isFunction(handle)) throw new Error('MyPromise must accept a function as a parameter') this._status = PENDING // 添加状态 this._value = undefined // 添加状态 this._fulfilledQueues = [] // 添加成功回调函数队列 this._rejectedQueues = [] // 添加失败回调函数队列 try { handle(this._resolve.bind(this), this._reject.bind(this)) } catch (err) { this._reject(err) } } _resolve(val) { const run = () =&gt; { if (this._status !== PENDING) return // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; { let cb while (cb = this._fulfilledQueues.shift()) { cb(value) } } // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; { let cb while (cb = this._rejectedQueues.shift()) { cb(error) } } // 如果 resolve 的参数为 Promise 对象，则必须等待该 Promise 对象状态改变后 // 当前 Promsie 的状态才会改变，且状态取决于参数 Promsie 对象的状态 if (val instanceof MyPromise) { val.then(value =&gt; { this._value = value this._status = FULFILLED runFulfilled(value) }, err =&gt; { this._value = err this._status = REJECTED runRejected(err) }) } else { this._value = val this._status = FULFILLED runFulfilled(val) } } // 为了支持同步的 Promise，这里采用异步调用 setTimeout(run, 0) } _reject(err) { if (this._status !== PENDING) return // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; { this._status = REJECTED this._value = err let cb while (cb = this._rejectedQueues.shift()) { cb(err) } } // 为了支持同步的 Promise，这里采用异步调用 setTimeout(run, 0) } then(onFulfilled, onRejected) { const { _value, _status } = this // 返回一个新的 Promise 对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { // 封装一个成功时执行的函数 let fulfilled = value =&gt; { try { if (!isFunction(onFulfilled)) { onFulfilledNext(value) } else { let res = onFulfilled(value) if (res instanceof MyPromise) { // 如果当前回调函数返回 MyPromise 对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) } else { // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数 onFulfilledNext(res) } } } catch (err) { // 如果函数执行出错，新的 Promise 对象的状态为失败 onRejectedNext(err) } } // 封装一个失败时执行的函数 let rejected = error =&gt; { try { if (!isFunction(onRejected)) { onRejectedNext(error) } else { let res = onRejected(error) if (res instanceof MyPromise) { // 如果当前回调函数返回 MyPromise 对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) } else { // 否则会将返回结果直接作为参数，传入下一个 then 的回调函数，并立即执行下一个 then 的回调函数 onFulfilledNext(res) } } } catch (err) { // 如果函数执行出错，新的 Promise 对象的状态为失败 onRejectedNext(err) } } switch (_status) { // 当状态为 pending 时，将 then 方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break } }) } catch(onRejected) { return this.then(undefined, onRejected) } static resolve(value) { // 如果参数是 MyPromise 实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value)) } static reject(value) { return new MyPromise((resolve, reject) =&gt; reject(value)) } static all(list) { return new MyPromise((resolve, reject) =&gt; { // 返回值的集合 let values = [] let count = 0 for (let [i, p] of list.entries()) { // 数组参数如果不是 MyPromise 实例，先调用 MyPromise.resolve this.resolve(p).then(res =&gt; { values[i] = res count++ // 所有状态都变成 fulfilled 时返回的 MyPromise 状态就变成 fulfilled if (count === list.length) resolve(values) }, err =&gt; { // 有一个被 rejected 时返回的 MyPromise 状态就变成 rejected reject(err) }) } }) } static race(list) { return new MyPromise((resolve, reject) =&gt; { for (let p of list) { // 只要有一个实例率先改变状态，新的 MyPromise 的状态就跟着改变 this.resolve(p).then(res =&gt; { resolve(res) }, err =&gt; { reject(err) }) } }) } finally(cb) { return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; { throw reason }) ) }} Object.create()关于 Object.create() 的详细用法可以参考 Object.create()，在了解过它的具体原理后，我们不难可以手动的来进行实现 1234567if (!Object.create) { Object.create = function (o) { function F() { } F.prototype = o return new F() }} instanceof核心原理就是原型链的向上查找，比如我们有 left 和 right 两个变量，首先判断 left 的 __proto__ 是不是等于 right.prototype，如果不等于再往上寻找 left.__proto__.__proto__ 直到 __proto__ 为 null 123456789101112131415function myInstanceof(left, right) { if (typeof left !== 'object' || left === null) return false // 基本数据类型直接返回 false let proto = Object.getPrototypeOf(left) // 获取参数的原型对象 while (true) { if (proto == null) return false // 查找到尽头，还没找到，返回 false if (proto == right.prototype) return true // 找到相同的原型对象，返回 true proto = Object.getPrototypeOf(proto) }}'111' instanceof String // falsenew String('111') instanceof String // truemyInstanceof('111', String) // falsemyInstanceof(new String('111'), String) // true getOwnPropertyNames需要注意的是，获取不到不可枚举的属性 123456789101112if (typeof Object.getOwnPropertyNames !== 'function') { Object.getOwnPropertyNames = function (o) { if (o !== Object(o)) throw TypeError('Object.getOwnPropertyNames called on non-object') var props = [], p for (p in o) { if (Object.prototype.hasOwnProperty.call(o, p)) { props.push(p) } } return props }} map这里我们根据规范当中的 Array.prototype.map(callbackfn[, thisArg]) 来模拟进行实现，如下图所示 1234567891011121314151617181920212223242526Array.prototype.map = function (callbackFn, thisArg) { // 处理数组类型异常 if (this === null || this === undefined) { throw new TypeError(`Cannot read property 'map' of null or undefined`) } // 处理回调类型异常 if (Object.prototype.toString.call(callbackfn) != '[object Function]') { throw new TypeError(callbackfn + ' is not a function') } let O = Object(this) // 先转换为对象 let T = thisArg let len = O.length &gt;&gt;&gt; 0 let A = new Array(len) for (let k = 0; k &lt; len; k++) { if (k in O) { // 如果没有找到就不处理，这样可以有效处理稀疏数组的情况 let kValue = O[k] let mappedValue = callbackfn.call(T, KValue, k, O) // 依次传入 this，当前项，当前索引，整个数组 A[k] = mappedValue } } return A} 关于上面的 length &gt;&gt;&gt; 0，字面上的意思是指『右移 0 位』，但实际上是把前面的空位用 0 填充，这里的作用是保证 len 为数字且为整数，下面是 V8 源码当中的实现，可以对比一下 12345678910111213141516function ArrayMap(f, receiver) { CHECK_OBJECT_COERCIBLE(this, 'Array.prototype.map') // Pull out the length so that modifications to the length in the // loop will not affect the looping and side effects are visible. var array = TO_OBJECT(this) var length = TO_LENGTH(array.length) if (!IS_CALLABLE(f)) throw %make_type_error(kCalledNonCallable, f) var result = ArraySpeciesCreate(array, length) for (var i = 0; i &lt; length; i++) { if (i in array) { var element = array[i] %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array)) } } return result} reduce这里我们根据规范当中的 Array.prototype.reduce(callbackfn[, initialValue]) 来模拟进行实现，如下图所示 这里有两个比较重要的地方需要注意 初始值不传怎么处理 回调函数的参数有哪些，返回值如何处理 12345678910111213141516171819202122232425262728293031Array.prototype.reduce = function (callbackfn, initialValue) { if (this === null || this === undefined) { throw new TypeError(`Cannot read property 'reduce' of null or undefined`) } if (Object.prototype.toString.call(callbackfn) != '[object Function]') { throw new TypeError(callbackfn + ' is not a function') } let O = Object(this) let len = O.length &gt;&gt;&gt; 0 let k = 0 let accumulator = initialValue if (accumulator === undefined) { for (; k &lt; len; k++) { // 通过原型链查找跳过空项 if (k in O) { accumulator = O[k] k++ break } } } // 表示数组全为空 if (k === len &amp;&amp; accumulator === undefined) throw new Error(`Each element of the array is empty`) for (; k &lt; len; k++) { if (k in O) { // 这里是核心 accumulator = callbackfn.call(undefined, accumulator, O[k], k, O) } } return accumulator} 下面是 V8 源码当中的实现，可以对比一下 12345678910111213141516171819202122232425262728293031function ArrayReduce(callback, current) { CHECK_OBJECT_COERCIBLE(this, 'Array.prototype.reduce') // Pull out the length so that modifications to the length in the // loop will not affect the looping and side effects are visible. var array = TO_OBJECT(this) var length = TO_LENGTH(array.length) return InnerArrayReduce(callback, current, array, length, arguments.length)}function InnerArrayReduce(callback, current, array, length, argumentsLength) { if (!IS_CALLABLE(callback)) { throw %make_type_error(kCalledNonCallable, callback) } var i = 0 find_initial: if (argumentsLength &lt; 2) { for (; i &lt; length; i++) { if (i in array) { current = array[i++] break find_initial } } throw %make_type_error(kReduceNoInitial) } for (; i &lt; length; i++) { if (i in array) { var element = array[i] current = callback(current, element, i, array) } } return current} push 和 pop因为这两个方法的实现十分类似，所以我们放到一起来进行介绍，还是和上面一样，我们先来看看规范当中的定义，见 Array.prototype.push() 和 Array.prototype.pop()，如下图所示 我们先来看看 push 的实现，其中的 2 ** 53 - 1 为 JavaScript 当中能表示的最大正整数 1234567891011121314Array.prototype.push = function (...items) { let O = Object(this) let len = this.length &gt;&gt;&gt; 0 let argCount = items.length &gt;&gt;&gt; 0 if (len + argCount &gt; 2 ** 53 - 1) { throw new TypeError(`The number of array is over the max value restricted`) } for (let i = 0; i &lt; argCount; i++) { O[len + i] = items[i] } let newLength = len + argCount O.length = newLength return newLength} 下面再来看看 pop 方法 12345678910111213Array.prototype.pop = function () { let O = Object(this) let len = this.length &gt;&gt;&gt; 0 if (len === 0) { O.length = 0 return undefined } len-- let value = O[len] delete O[len] O.length = len return value} filteArray.prototype.filter(callbackfn[, thisArg]) 在规范当中的定义如下图所示 实现如下 123456789101112131415161718192021Array.prototype.filter = function (callbackfn, thisArg) { if (this === null || this === undefined) { throw new TypeError(`Cannot read property 'filter' of null or undefined`) } if (Object.prototype.toString.call(callbackfn) != '[object Function]') { throw new TypeError(callbackfn + ' is not a function') } let O = Object(this) let len = O.length &gt;&gt;&gt; 0 let resLen = 0 let res = [] for (let i = 0; i &lt; len; i++) { if (i in O) { let element = O[i] if (callbackfn.call(thisArg, O[i], i, O)) { res[resLen++] = element } } } return res} 数组原生 API这部分内容主要是源自于平时收集整理以及参考了一些 这篇文章 当中的内容整合而成，而且在实现方式上我们也不再去扩展 Array 构造函数上的方法了，直接使用函数的形式来进行实现，主要目的也是为了简单的了解其内部实现原理，当然只是功能上的实现，对于一些边界条件并没有考虑的十分完善，比较完善的方式可以参考上文当中依据规范所整理的相关方法的实现 forEach这里需要注意的一点是，forEach 方法默认返回 undefined 123456789function forEach(array, callback) { for (let i = 0; i &lt; array.length; i++) { const value = array[i] callback(value, i, array) }}// 1 2 3forEach([1, 2, 3], res =&gt; console.log(res)) map与 forEach 方法不同的是，map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数，callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组 1234567891011function map(array, callback) { const result = [] for (let i = 0; i &lt; array.length; i++) { result[i] = callback(array[i], i, array) } return result}// [1, 4, 9]map([1, 2, 3], res =&gt; res ** 2) filter过滤回调返回为 false 的值，每个值都保存在一个新的数组中，然后返回，这里用到了我们在下面将会介绍的 push 方法 12345678910111213141516171819202122function push(array, ...values) { const { length: arrayLength } = array const { length: valuesLength } = values for (let i = 0; i &lt; valuesLength; i++) { array[arrayLength + i] = values[i] } return array.length}function filter(array, callback) { const result = [] for (let i = 0; i &lt; array.length; i++) { const value = array[i] if (callback(value, i, array)) { push(result, value) } } return result}// [2, 3]filter([1, 2, 3], res =&gt; res &gt;= 2) reducereduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值，该方法接受四个参数 初始值（或者上一次回调函数的返回值） 当前元素值 当前索引 调用 reduce() 的数组 1234567891011121314151617181920212223242526function reduce(array, callback, initValue) { if (array.length === 0) throw new Error(`Uncaught TypeError: Reduce of empty array`) for (let i = 0; i &lt; array.length; i++) { if (typeof initValue === 'undefined') { initValue = callback(array[i], array[i + 1], i + 1, array) ++i } else { initValue = callback(initValue, array[i], i, array) } } return initValue}// 10reduce([1, 2, 3, 4], (prev, next) =&gt; prev += next)// 20reduce([1, 2, 3, 4], (prev, next) =&gt; prev += next, 10)// 5reduce([1, 2, 3, 4], (prev, next, i, array) =&gt; { if (i === array.length - 1) { return (prev + next) / 2 } return prev + next}) 每次迭代，reduce 方法都将回调的结果保存在我们的累加器（initValue）中，然后在下一个迭代中使用 这里有几个需要注意的地方，一个是 ++i 这一步操作，因为当没有传递初始值的时候，当我们手动赋予初始值的时候，为了不重复计算初始元素，将 i 指向下一步，另外就是如果数组为空，是会抛出 TypeError findIndexfindIndex 方法对数组中的每个数组索引执行一次 callback 函数，直到找到第一个 callback 函数返回真实值（强制为 true）的值，如果找到这样的元素，findIndex 会立即返回该元素的索引，如果回调从不返回真值，或者数组的 length 为 0，则返回 -1 1234567891011function findIndex(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (callback(array[i], i, array)) { return i } } return -1}// 1findIndex(['a', 'b', 'c'], res =&gt; res === 'b') find其实 find 与 findIndex 的唯一区别在于它返回的是实际值，而不是索引，而我们之前已经实现了 findIndex 方法，所以稍微调整一下就行，注意现在的返回值是 undefined 了 1234567891011121314function find(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (callback(array[i], i, array)) { return array[i] } } return undefined}// bfind(['a', 'b', 'c'], res =&gt; res === 'b')// undefinedfind(['a', 'b', 'c'], res =&gt; res === 'd') indexOfindexOf 是获取给定值索引的另一种方法，这里我们可以直接使用前面实现的 findIndex 1234567891011121314function findIndex(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (callback(array[i], i, array)) { return i } } return -1}function indexOf(array, searchedValue) { return findIndex(array, value =&gt; value === searchedValue)}indexOf([1, 2, 3], 2) lastIndexOflastIndexOf 的工作方式与 indexOf 相同，只是 lastIndexOf 方法返回的是指定元素在数组中的最后一个的索引，如果不存在同样返回 -1 1234567891011function lastIndexOf(array, searchedValue) { for (let i = array.length - 1; i &gt; -1; i--) { if (array[i] === searchedValue) { return i } } return -1}// 2lastIndexOf([2, 3, 2], 2) everyevery() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，它返回一个布尔值 1234567891011121314function every(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (!callback(array[i], i, array)) { return false } } return true}// falseevery([1, 2, 3], res =&gt; res === 2)// trueevery([1, 2, 3], res =&gt; res &gt; 0) 我们为数组当中的每个值都执行回调，如果在任何时候返回 false，则退出循环，并且整个方法返回false，如果循环终止而没有进入到 if 语句里面，则说明条件都成立，返回 true somesome 方法与 every 刚好相反，即只要其中一个为 true 就会返回 true 1234567891011function some(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (callback(array[i], i, array)) { return true } } return false}// truesome([1, 2, 3], res =&gt; res === 2) includesincludes 方法的工作方式类似于 some 方法，但是 includes 不使用回调，而是提供一个参数值来比较元素，所以我们可以借住上面实现的 some 方法来进行实现 123456789101112131415161718function some(array, callback) { for (let i = 0; i &lt; array.length; i++) { if (callback(array[i], i, array)) { return true } } return false}function includes(array, searchedValue) { return some(array, val =&gt; val === searchedValue)}// trueincludes([1, 2, 3], 2)// falseincludes([1, 2, 3], 4) concatconcat() 方法用于合并两个或多个数组，此方法不会更改现有数组，而是返回一个新数组，同样这里我们也使用到了 push 方法 1234567891011121314151617181920212223242526function push(array, ...values) { const { length: arrayLength } = array const { length: valuesLength } = values for (let i = 0; i &lt; valuesLength; i++) { array[arrayLength + i] = values[i] } return array.length}function concat(array, ...values) { const result = [...array] for (let i = 0; i &lt; values.length; i++) { if (Array.isArray(values[i])) { push(result, ...values[i]) } else { push(result, values[i]) } } return result}// [1, 2, 3, 4]concat([1, 2, 3], 4)// [1, 2, 3, 4, 5, 6]concat([1, 2, 3], [4, 5, 6]) concat 将数组作为第一个参数，并将未指定个数的值作为第二个参数，首先通过复制传入的数组创建 result 数组，然后遍历 values 检查需要添加的值是否是数组，如果是，则使用展开操作符将其值附加到结果数组中，否则就直接添加 joinjoin() 方法可以将数组转化为一个字符串，而元素是通过指定的分隔符进行分隔的 1234567891011121314151617function join(array, joinWith) { if (array.length &lt;= 1) return array[0] ? ('' + array[0]) : '' let result = array[0] for (let i = 1; i &lt; array.length; i++) { result += joinWith + array[i] } return result}// '1-2-3'join([1, 2, 3], '-')// '1'join([1], '-')// ''join([], '-') reversereverse() 方法将数组中元素的位置颠倒，并返回该数组，该方法会改变原数组 1234567891011function reverse(array) { const result = [] const lastIndex = array.length - 1 for (let i = lastIndex; i &gt; -1; i--) { result[lastIndex - i] = array[i] } return result}// [3, 2, 1]reverse([1, 2, 3]) 我们首先定义一个空数组，并将数组的最后一个索引保存为变量（lastIndex），接着反向遍历数组，将每个值保存在结果 result 中的 [lastIndex - i] 的位置，然后返回 result 数组 如果不想计算保存位置的话也可以在反向遍历的过程当中将当前值 push 到 result 数组当中 push这个方法我们在上面曾多次用到，它的实现方式很简单，只需要将要添加的元素依次放到数组的最后即可，不会改变原有数组元素的索引，返回值为当中数组的长度，这里需要注意的是，数组的长度每次都需要从新获取 12345678910function push(array, ...values) { const { length: arrayLength } = array const { length: valuesLength } = values for (let i = 0; i &lt; valuesLength; i++) { array[arrayLength + i] = values[i] } return array.length}push([1, 2, 3], 4, 5) unshiftunshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组 123456789function unshift(array, ...values) { const newArray = [...values, ...array] for (let i = 0; i &lt; newArray.length; i++) { array[i] = newArray[i] } return newArray.length}unshift([1, 2, 3], 4) shiftshift() 方法从数组中删除第一个元素，并返回该元素的值，此方法更改数组的长度 1234567891011function shift(array) { const firstValue = array[0] for (let i = 1; i &lt; array.length; i++) { array[i - 1] = array[i] } array.length = array.length - 1 return firstValue}// 1shift([1, 2, 3]) 我们首先保存需要返回的第一个值，然后从位置 1 开始遍历数组，并且将遍历得到的值从 0 开始覆盖到原数组当中，完成遍历后，更新数组的长度并返回初始值 poppop() 方法会从数组中删除最后一个元素，并返回该元素的值，此方法更改数组的长度，这个方法实现起来比较容易，我们只需将元数组的长度减少 1，从而删除最后一个值 12345678function pop(array) { const returnValue = array[array.length - 1] array.length = array.length - 1 return returnValue}// 3pop([1, 2, 3]) fillfill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，但是不包括终止索引，所以这里的 last 为 array.length 而不是 array.length - 1 123456789101112function fill(array, value, start = 0, last = array.length) { for (let i = start; i &lt; last; i++) { array[i] = value } return array}// [5, 5, 5, 5]fill([1, 2, 3, 4], 5)// [1, 5, 3, 4]fill([1, 2, 3, 4], 5, 1, 2) 节点遍历prev1234567891011121314// 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点function getRealPrev(elem) { var o = elem // 循环遍历，将循环的结果再次赋予 o，依次向上查询 while (o = o.previousSibling) { if (o.nodeType == 1) { return o } return null }}// [1, 2, 3, 4, 5, 6, 7]flatten([1, [2, 3, [4, [5, 6, 7]]]]) next1234567891011121314// 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点function getRealNext(elem) { var o = elem // 循环遍历，将循环的结果再次赋予 o，依次向下查询 while (o = o.nextSibling) { if (o.nodeType == 1) { return o } return null }}// [1, 2, 3, 4, 5, 6, 7][...flatten([1, [2, 3, [4, [5, 6, 7]]]])] prevAll123456789101112// 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点function getRealprevAll(elem) { var o = elem var result = [] // 循环遍历，将循环的结果再次赋予 o，依次向上查询，如果不存在上一个节点，则会返回 null，便自动停止循环 while (o = o.previousSibling) { if (o.nodeType == 1) { result.unshift(o) } return result }} nextAll123456789101112// 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点function getRealnextAll(elem) { var o = elem var result = [] // 循环遍历，将循环的结果再次赋予 o，依次向下查询，如果不存在下一个节点，则会返回 null，便自动停止循环 while (o = o.nextSibling) { if (o.nodeType == 1) { result.push(o) } return result }} 常见工具函数短横变驼峰12345678var f = function (s) { return s.replace(/-\\w/g, function (x) { console.log(x) return x.slice(1).toUpperCase() })}f('border-right-color') 千位分隔符12345678910function commafy(num) { return num &amp;&amp; num .toString() // 也可以使用 /\\B(?=(\\d{3})+$)/g .replace(/(\\d)(?=(\\d{3})+\\.)/g, function ($0, $1) { return $1 + ',' })}commafy(1234567.90) 解析 URL1234567const getURLParameters = url =&gt; (url.match(/([^?=&amp;]+)(=([^&amp;]*))/g) || []).reduce( (a, v) =&gt; ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a), {} )getURLParameters('https://www.baidu.com?id=123&amp;name=zhangsan') 上面这个示例可以应对大多正常使用的情况，但是当然也会存在一些比较特殊的情况，比如下面这个 url 1let url = 'http://www.example.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled' 要求输出的结果是下面这样的 123456{ user: 'anonymous', id: [123, 456], city: '北京', enabled: true,} 具体规则为 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 中文需解码 未指定值的 key 约定为 true 下面我们来看如何实现 1234567891011121314151617181920function parseParam(url) { const paramsStr = /.+\\?(.+)$/.exec(url)[1] // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split('&amp;') // 将字符串以 &amp; 分割后存到数组中 let paramsObj = {} paramsArr.forEach(param =&gt; { // 将 params 存到对象中 if (/=/.test(param)) { // 处理有 value 的参数 let [key, val] = param.split('=') // 分割 key 和 value val = decodeURIComponent(val) // 解码 val = /^\\d+$/.test(val) ? parseFloat(val) : val // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val) } else { // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val } } else { // 处理没有 value 的参数 paramsObj[param] = true } }) return paramsObj // 返回最终结果} 数组去重 这里需要注意的是，我们默认传递的参数都是数组对象，所以也就省掉了针对入参的判断，在这里我们只关心核心实现部分 第一种，也是我们可能想到的最为直白的方式，那就是使用双层循环（while 也可），其缺点是其复杂度为 O(n^2)，如果数组过大，将会影响性能，但是它也有好处，就是兼容性好，原理是先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组 12345678910111213141516function unique(arr) { let res = [arr[0]] for (let i = 1; i &lt; arr.length; i++) { let flag = true for (let j = 0; j &lt; res.length; j++) { if (arr[i] === res[j]) { flag = false break } } if (flag) { res.push(arr[i]) } } return res} 第二种方法，使用 indexOf 或者 includes，因为原理是一样的，这里我们就以 indexOf 为例来进行介绍了，indexOf 的用法有两种 一种是首先定义一个空数组，然后调用 indexOf 方法对原来的数组进行遍历判断，如果元素不在新定义的数组中，则将其添加进去，最后将数组返回 第二种就是检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素 123456789101112131415161718// 第一种方式function unique(arr) { let res = [] for (let i = 0; i &lt; arr.length; i++) { // 或者使用 if (!res.includes(arr[i])) { } if (res.indexOf(arr[i]) === -1) { res.push(arr[i]) } } return res}// 第二种方式function unique(arr) { return Array.prototype.filter.call(arr, function (item, index) { return arr.indexOf(item) === index })} 第三种方法，使用 reduce，原理是利用 reduce 的累加原理，因为初始值为 []，所以在添加前先行判断，如果当前数组中没有该元素，再将其放入其中 12345function unique(arr) { return arr.reduce(function (pre, cur) { return pre.includes(cur) ? pre : [...pre, cur] }, [])} 第四种方法，相邻元素去重，这种方法首先调用了数组的排序方法 sort()，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，但是这个方法存在缺陷，即 sort() 排序的结果并非十分准确 12345678910function unique(arr) { arr = arr.sort() let res = [] for (let i = 0; i &lt; arr.length; i++) { if (arr[i] !== arr[i - 1]) { res.push(arr[i]) } } return res} 第五种方法，利用对象属性去重，也就是所谓的对象键值对法，原理是遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值 1，每出现一次，对应的属性值增加 1，这样属性值对应的就是该元素出现的次数了（这个方法也可以用来统计字符串出现的次数） 123456789101112131415161718192021// 方式一function unique(arr) { let res = [], obj = {} for (let i = 0; i &lt; arr.length; i++) { if (!obj[arr[i]]) { res.push(arr[i]) obj[arr[i]] = 1 } else { obj[arr[i]]++ } } return res}// 方式二，针对处理 [1, 2, 1, 1, '1'] 这样的数组，可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题function unique(arr) { var obj = {} return arr.filter(function (item, index, array) { return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) })} 第六种方法，解构赋值去重，ES6 提供了新的数据结构 Set，它类似于数组，但是成员的值都是唯一的 12345678// 利用 Setvar unique = arr =&gt; [...new Set(arr)]// 也可以使用 Map，原理也是利用对象属性function unique(arr) { const map = new Map() return arr.filter((a) =&gt; !map.has(a) &amp;&amp; map.set(a, 1))} 最后我们再来通过一个特殊的数组依次来看看上面各种方法处理后的结果，做一个简单的对比 1var array = [1, 1, '1', '1', null, null, undefined, undefined, new String('1'), new String('1'), /a/, /a/, NaN, NaN] 针对上面的数组，上述去重方法结果如下，可以根据实际场景选择使用 方法 结果 说明 双重 for 循环 [1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN] 对象和 NaN 不去重 单纯的 indexOf [1, '1', null, undefined, String, String, /a/, /a/, NaN, NaN] 对象和 NaN 不去重 reduce [1, '1', null, undefined, String, String, /a/, /a/, NaN] 对象不去重 NaN 去重 filter + indexOf [1, '1', null, undefined, String, String, /a/, /a/] 对象不去重 NaN 会被忽略掉 相邻元素去重（sort） [/a/, /a/, '1', 1, String, 1, String, NaN, NaN, null, undefined] 对象和 NaN 不去重 数字 1 也不去重 对象键值对法 [1, null, undefined, /a/, NaN] 无法区分数字 1 和 '1' 优化后的对象键值对法 [1, '1', null, undefined, String, /a/, NaN] 全部去重 Set 和 Map [1, '1', null, undefined, String, String, /a/, /a/, NaN] 对象不去重 NaN 去重 最后一种特殊情况，如果不是单纯的数组，而是数组对象的话，则可以使用 reduce 来进行处理 12345678910function unique(arr, initialValue, id) { let hash = {} return arr.reduce((item, next) =&gt; { hash[next.id] ? '' : hash[next.id] = true &amp;&amp; item.push(next) return item }, initialValue)}let arr = [{ 'id': 1 }, { 'id': 2 }, { 'id': 2 }, { 'id': 3 }]newArr = unique(arr, [], 'id') 数组扁平化其实这个功能在 ES6 当中已经实现了，也就是 flat() 方法，它会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，先来看看如何使用 1234567891011// [1, 2, 3, 4][1, 2, [3, 4]].flat()// [1, 2, 3, 4, [5, 6]][1, 2, [3, 4, [5, 6]]].flat()// [1, 2, 3, 4, 5, 6][1, 2, [3, 4, [5, 6]]].flat(2)// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]].flat(Infinity) 同时需要注意的是，flat() 方法会移除数组中的空项 12// [1, 2, 4, 5][1, 2, , 4, 5].flat() 我们先来看看带参数模式的如何实现，一种比较常见的方式是使用 reduce + concat 1234567891011function flatten(arr, depth = 1) { return depth &gt; 0 ? arr.reduce((acc, val) =&gt; acc.concat(Array.isArray(val) ? flatten(val, depth - 1) : val), []) : arr}// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]flatten([1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]], Infinity)// [1, 2, 3, 1, 2, 3, 4, [2, 3, 4]]flatten([1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]], 1) 首先我们检查 depth 参数是否大于 0，如果不是，则直接返回该数组，否则调用 reduce 函数，利用 concat 方法将数组的每个值扁平，如果扁平一次后还是数组的话继续递归调用，这里需要注意的是我们每次递归都会递减 depth 参数，以免造成无限循环 另外还可以使用 forEach 和 for-of，不过原理是类似的，都是利用递归来进行扁平化处理 1234567891011121314151617181920212223242526272829// forEach 遍历数组会自动跳过空元素const eachFlat = (arr = [], depth = 1) =&gt; { const result = [] // 缓存递归结果 (function flat(arr, depth) { // 开始递归 arr.forEach((item) =&gt; { // forEach 会自动去除数组空位 if (Array.isArray(item) &amp;&amp; depth &gt; 0) { // 控制递归深度 flat(item, depth - 1) // 递归数组 } else { result.push(item) // 缓存元素 } }) })(arr, depth) return result // 返回递归结果}// for-of 循环不能去除数组空位，需要手动去除const forFlat = (arr = [], depth = 1) =&gt; { const result = [] (function flat(arr, depth) { for (let item of arr) { if (Array.isArray(item) &amp;&amp; depth &gt; 0) { flat(item, depth - 1) } else { item !== void 0 &amp;&amp; result.push(item) // 去除空元素，添加非 undefined 元素 } } })(arr, depth) return result} 不过在平常开发过程当中，更为常见的用法是直接将多维数组降维至一维数组，通常不会去考虑第二个参数，在这种情况下我们可以考虑使用下面几种比较简单的方式，首先来看一个比较局限的方法，如果数组当中的元素都是纯数字的话，那么我们可以考虑使用 toString() 方法，但是如果数组是 [1, '1', 2, '2'] 的话，这种方法就会产生错误的结果，所以使用的场景有限 123456function flatten(arr) { return arr.toString().split(',').map(item =&gt; Number(item))}// [1, 2, 3, 4, 5, 6, 7]flatten([1, [2, 3, [4, [5, 6, 7]]]]) 另外也可以使用和上面一样的递归方式，不过可以省略 reduce 而是借用 Array.some() 方法，代码十分简单 123456789function flatten(arr) { while (arr.some(Array.isArray)) { arr = [].concat(...arr) } return arr}// [1, 2, 3, 4, 5, 6, 7]flatten([1, [2, 3, [4, [5, 6, 7]]]]) 第三种方式，可以使用使用堆栈达到无递归数组扁平化，但是需要注意的是深度的控制比较低效，因为需要检查每一个值的深度 12345678910111213141516function flatten(array) { const stack = [...array] const res = [] while (stack.length) { const next = stack.pop() // 使用 pop 从 stack 中取出并移除值 if (Array.isArray(next)) { stack.push(...next) // 使用 push 送回内层数组中的元素，不会改动原始输入 } else { res.push(next) } } return res.reverse() // 反转恢复原数组的顺序}// [1, 2, 3, 4, 5, 6, 7]flatten([1, [2, 3, [4, [5, 6, 7]]]]) 另外还可以使用 Generator 函数来进行实现，如下 123456789101112function* flatten(array) { for (const item of array) { if (Array.isArray(item)) { yield* flatten(item) } else { yield item } }}// [1, 2, 3, 4, 5, 6, 7][...flatten([1, [2, 3, [4, [5, 6, 7]]]])] 最后我们再来看一种比较另类的方式，那就是使用正则进行匹配，原理就是将 [ 和 ] 替换成 ''，然后在还原为数组 1234const arr = [1, [2, 3, [4, [5, 6, 7]]]]// [1, 2, 3, 4, 5, 6, 7]JSON.parse(`[${JSON.stringify(arr).replace(/(\\[|\\])/g, '')}]`) 对象扁平化目的是实现以键的路径扁平化对象，常见的解决方式是使用『递归』，主要步骤有以下几步 利用 Object.keys(obj) 联合 Array.prototype.reduce()，以每片叶子节点转换为扁平的路径节点 如果键的值是一个对象，则函数使用调用适当的自身 prefix 以创建路径 Object.assign() 否则，它将适当的前缀键值对添加到累加器对象 prefix 除非希望每个键都有一个前缀，否则应始终省略第二个参数 12345678910const flattenObject = (obj, prefix = '') =&gt; Object.keys(obj).reduce((acc, k) =&gt; { const pre = prefix.length ? prefix + '.' : '' if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k)) else acc[pre + k] = obj[k] return acc }, {})// {a.b.c: 1, d: 1}flattenObject({ a: { b: { c: 1 } }, d: 1 }) 我们也可以以键的路径展开对象，也就是与上面执行相反的操作，通常用在 Tree 组件或复杂表单时取值比较方便 12345678910111213141516171819const unflattenObject = obj =&gt; Object.keys(obj).reduce((acc, k) =&gt; { if (k.indexOf('.') !== -1) { const keys = k.split('.') Object.assign( acc, JSON.parse( '{' + keys.map((v, i) =&gt; (i !== keys.length - 1 ? `\"${v}\":{` : `\"${v}\":`)).join('') + obj[k] + '}'.repeat(keys.length) ) ) } else acc[k] = obj[k] return acc }, {})// { a: { b: { c: 1 } }, d: 1 }unflattenObject({ 'a.b.c': 1, d: 1 }) 字符串去重第一种方式，常规的 for 遍历 123456789101112131415function unique1(str) { var newStr = '' var flag for (var i = 0; i &lt; str.length; i++) { flag = 1 for (var j = 0; j &lt; newStr.length; j++) { if (str[i] == newStr[j]) { flag = 0 break } } if (flag) newStr += str[i] } return newStr} 第二种，使用 indexOf 123456789function unique2(str) { var newStr = '' for (var i = 0; i &lt; str.length; i++) { if (newStr.indexOf(str[i]) == -1) { newStr += str[i] } } return newStr} 第三种，与上面第二种类似，不过判断方式换成了 search 123456789function unique3(str) { var newStr = '' for (var i = 0; i &lt; str.length; i++) { if (newStr.search(str[i]) == -1) newStr += str[i] } return newStr} 第四种方式，利用对象属性，推荐使用这种方式 1234567891011function unique4(str) { var obj = {} var newStr = '' for (var i = 0; i &lt; str.length; i++) { if (!obj[str[i]]) { newStr += str[i] obj[str[i]] = 1 } } return newStr} 生成区间随机数，并排序123456789101112131415var arr = []var randomNum = function (n, m) { return parseInt(Math.random() * (m - n) + n)}for (var i = 0; i &lt; 20; i++) { arr.push(randomNum(40, 80))}// 排序console.log(arr.sort(function (a, b) { return a - b }))// 乱序console.log(arr.sort(function () { return 0.5 - Math.random() })) 这里关于乱序需要说明一下，因为这里涉及到了 sort() 方法，所以上面的结果是存在一定误差的，我们可以来测试一下，比如下面这里例子，将 [1, 2, 3, 4, 5] 乱序 10 万次，计算乱序后的数组的最后一个元素是 1、2、3、4、5 的次数分别是多少 123456789var times = [0, 0, 0, 0, 0]for (var i = 0; i &lt; 100000; i++) { let arr = [1, 2, 3, 4, 5] arr.sort(() =&gt; Math.random() - 0.5) times[arr[4] - 1]++}console.log(times) // [25028, 6975, 21233, 18538, 28226] 根据结果我们可以发现，排序后的各元素明显分布不平均，所以说这样的算法是存在一定问题的，而具体原因就是因为 sort() 方法而导致的，但是在这里关于为什么会产生这样结果的原因我们就不详细展开了，具体可以参考 JavaScript 专题之解读 V8 排序源码 这篇文章，在这里我们只来看看如何解决这样的问题 针对于乱序的问题，通常我们可以采用 Fisher-Yates 的算法来对数组中的元素进行随机选择，主要有以下两种方式 sampleSize，在指定数组中获取指定长度的随机数，它的原理是随机抽选对换位置（余下的只在剩余位置交换） 1234567891011const sampleSize = ([...arr], n = 1) =&gt; { let m = arr.length while (m) { const i = Math.floor(Math.random() * m--); [arr[m], arr[i]] = [arr[i], arr[m]] } return arr.slice(0, n)}sampleSize([1, 2, 3], 2) // [3, 1]sampleSize([1, 2, 3], 4) // [2, 3, 1] shuffle，洗牌数组，它的原理是随机抽选，抽到一个出列一个 1234567891011const shuffle = ([...arr]) =&gt; { let m = arr.length while (m) { const i = Math.floor(Math.random() * m--); [arr[m], arr[i]] = [arr[i], arr[m]] } return arr}// [2, 3, 1]shuffle([1, 2, 3]) 我们可以来测试一下 1234567891011121314151617181920212223var times = 10000var res = {}for (var i = 0; i &lt; times; i++) { var arr = shuffle([1, 2, 3]) var key = JSON.stringify(arr) res[key] ? res[key]++ : res[key] = 1}// 转换成百分比for (var key in res) { res[key] = res[key] / times * 100 + '%'}console.log(res)// {// [1,2,3]: '16.12%',// [1,3,2]: '16.76%',// [2,1,3]: '16.78%',// [2,3,1]: '16.61%',// [3,1,2]: '16.57%',// [3,2,1]: '17.16%',// } 取数组的并集，交集和差集12345678910111213141516171819202122232425262728293031323334353637383940// 这里有一些需要注意的地方// 如果两个数组 A 和 B 当中没有重复的元素，以下三种都是可以正常实现的// 如果数组当中有重复的元素，需要使用 ES6 当中的 Set 数据结构// 如果数组当中包含 NaN，可以考虑在结尾处添加 .filter(v =&gt; !isNaN(v)) 过滤掉即可let a = [1, 2, 3, 4]let b = [2, 3, 4, 5, 6]// ES7 并集a.concat(b.filter(v =&gt; !a.includes(v))) // [1, 2, 3, 4]// ES7 交集a.filter(v =&gt; b.includes(v)) // [2, 3]// ES7 差集a.concat(b).filter(v =&gt; !a.includes(v) || !b.includes(v)) // [1, 4]// ------------let aSet = new Set(a)let bSet = new Set(b)// ES6 并集Array.from(new Set(a.concat(b))) // [1, 2, 3, 4]// ES6 交集Array.from(new Set(a.filter(v =&gt; bSet.has(v)))) // [2, 3]// ES6 差集Array.from(new Set(a.concat(b).filter(v =&gt; !aSet.has(v) || !bSet.has(v)))) // [1, 4]// ------------// ES5 并集a.concat(b.filter(v =&gt; a.indexOf(v) === -1)) // [1, 2, 3, 4]// ES5 交集a.filter(v =&gt; b.indexOf(v) !== -1) // [2, 3]// ES5 差集a.filter(v =&gt; b.indexOf(v) === -1).concat(b.filter(v =&gt; a.indexOf(v) === -1)) // [1, 4] 字符串包含查找虽然有 API 可以实现，但是我们这里使用最基本的遍历来实现，要求是判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置，如果找不到则返回 -1 123456789101112131415161718192021function isContain(a, b) { for (let i in b) { if (a[0] === b[i]) { let tmp = true for (let j in a) { if (a[j] !== b[~~i + ~~j]) { tmp = false } } if (tmp) { return i } } } return - 1}var a = '355', b = '12354355'// 5isContain(a, b) 这里有一个需要注意的地方就是其中的 i 和 j 是字符串，所以需要我们将其转换为数字 统计数组中每一项出现的次数1[5, 5, 4, 3, 2, 1, 4, 5, 5, 4, 3, 2, 2, 1].reduce((ad, ap) =&gt; (ad[ap] = ++ad[ap] || 1, ad), {}) 寻找字符串中出现最多的字符和个数1234567891011function findLength(str, num = 0, char = '') { str.split('').sort().join('').replace(/(\\w)\\1+/g, ($0, $1) =&gt; { if (num &lt; $0.length) { num = $0.length char = $1 } }) console.log(`字符最多的是${char}，出现了${num}次`)}findLength('abcabcabcbbccccc') 寻找字符串中出现次数最少的、并且首次出现位置最前的字符要求实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 cbaacfdeaebb，方法有很多种，我们一个一个来看 方法一，利用 hash table，缺点是 Object.keys() 不能保证顺序，所以存在风险 123456789var o = [].reduce.call('cbaacfdeaebb', function (p, n) { return p[n] = (p[n] || 0) + 1, p}, {})var s = Object.keys(o).reduce(function (p, n) { return o[p] &lt;= o[n] ? p : n})console.log(s, o[s]) 方法二，引入了 index 来解决顺序问题 1234567891011121314const all = 'cbaacfdeaebb'.split('') .reduce((all, ch, i) =&gt; { const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 }) m.count++ return all }, {})const theOne = Object.keys(all) .map(ch =&gt; all[ch]) .reduce((min, t) =&gt; min.count === t.count ? (min.index &gt; t.index ? t : min) : (min.count &gt; t.count ? t : min))console.log(`${theOne.ch}: ${theOne.count}`) 方法三，利用数组代替 hash table，解决了顺序问题，但是 Array.sort() 并不一定是稳定的，风险可能更大 12345678910function findFirstChar(string) { const desc = [] [...string].forEach((char, index) =&gt; { const item = desc.find(item =&gt; item.char === char) item ? item.count++ : desc.push({ char, index, count: 1 }) }) return desc.sort((a, b) =&gt; a.count - b.count)[0]} 方法四，使用 Object.values，但是目前还是草案 123456789101112const less = (x, y) =&gt; (x.count &lt;= y.count &amp;&amp; x.first &lt; y.first) ? x : yfunction firstSingle(string) { let map = {} string.split('') .forEach((char, index) =&gt; { map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char } }) return Object.values(map).reduce(less).char} 方法五，代码简短，但是执行效率不是很高 123456var str = 'cbaacfdeaebb'var result = [...new Set(str)] .map(el =&gt; ({ el, len: str.split(el).length })) .reduce((a, e) =&gt; (a.len &gt; e.len ? e : a)) .el 生成指定长度数组比如生成指定内容为 [0, 1, 2, 3 ... N - 1] 的数组 12345678910111213141516171819202122232425262728293031323334353637// 方法一，ES5Array.apply(null, { length: N }).map(function (value, index) { return index})// 方法二，ES6Array.from(new Array(N), (v, i) =&gt; i)// 方法三Array.from(Array(N).keys())// 方法四[...Array(N).keys()]// 方法五Object.keys(Array(N).join().split(',')).map(v =&gt; Number(v))// 方法六Object.keys(Array(N).fill()).map(v =&gt; Number(v))// 方法七Object.keys(Array.apply(null, { length: 100 })).map(v =&gt; Number(v))// 方法八Array(N).fill().map((v, i) =&gt; i)// 方法九Array.prototype.recursion = function (length) { if (this.length === length) { return this } this.push(this.length) this.recursion(length)}arr = []arr.recursion(100) 动态规划『动态规划』的特点就是通过全局规划，将大问题分割成小问题来取最优解，来看一个最少硬币找零的经典示例，在美国总共有以下面额的硬币，d1 = 1，d2 = 5，d3 = 10，d4 = 25，而如果我们需要找 36 美分的零钱的话，就可以用 1 个 25 美分、1 个 10 美分和 1 个便士（1 美分） 1234567891011121314151617181920212223242526272829class MinCoinChange { constructor(coins) { this.coins = coins this.cache = {} } makeChange(amount) { if (!amount) return [] if (this.cache[amount]) return this.cache[amount] let min = [], newMin, newAmount this.coins.forEach(coin =&gt; { newAmount = amount - coin if (newAmount &gt;= 0) { newMin = this.makeChange(newAmount) } if (newAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length) &amp;&amp; (newMin.length || !newAmount)) { min = [coin].concat(newMin) } }) return (this.cache[amount] = min) }}const rninCoinChange = new MinCoinChange([1, 5, 10, 25])rninCoinChange.makeChange(36) // [1, 10, 25]const minCoinChange2 = new MinCoinChange([1, 3, 4])minCoinChange2.makeChange(6) // [3, 3] 贪心算法我们下面再来看看使用『贪心算法』来解决上面的找硬币问题 1234567891011121314151617181920function MinCoinChange(coins) { var coins = coins this.makeChange = function (amount) { var change = [], total = 0 for (var i = coins.length; i &gt;= 0; i--) { var coin = coins[i] while (total + coin &lt;= amount) { change.push(coin) total += coin } } return change }}var minCoinChange = new MinCoinChange([1, 5, 10, 25])minCoinChange.makeChange(36) // [25, 10, 1]minCoinChange.makeChange(34) // [25, 5, 1, 1, 1, 1]minCoinChange.makeChange(6) // [5, 1] 计算最长递增子序列所谓的最长递增子序列就是给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续，比如给定的序列是 [0, 8, 4, 12, 2, 10]，那么它的最长递增子序列就是 [0, 2, 10]（也可以是 [0, 8, 10] 或 [0, 4, 12] 等，并不是唯一） 针对于这种情况，我们就可以利用上面提到的『动态规划』思想来进行求解，可以参考下表，我们以该格子所对应的数字为开头的递增子序列的最大长度，至于如何计算一个格子中的值，规则很简单（假定从右往左），如下 1、拿该格子对应的数字 a 与其后面的所有格子对应的数字 b 进行比较，如果条件 a &lt; b 成立，则用数字 b 对应格子中的值加 1，并将结果填充到数字 a 对应的格子中 2、只有当计算出来的值大于数字 a 所对应的格子中的值时，才需要更新格子中的数值 0 8 4 12 2 10 3 2 2 1 2 1 实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const seq = [0, 8, 4, 12, 2, 10]function lis(seq) { // 构建索引表 const valueToMax = {} let len = seq.length for (let i = 0; i &lt; len; i++) { valueToMax[seq[i]] = 1 } let i = len - 1 let last = seq[i] let prev = seq[i - 1] while (typeof prev !== 'undefined') { let j = i while (j &lt; len) { last = seq[j] if (prev &lt; last) { const currentMax = valueToMax[last] + 1 valueToMax[prev] = valueToMax[prev] !== 1 ? (valueToMax[prev] &gt; currentMax ? valueToMax[prev] : currentMax) : currentMax } j++ } i-- last = seq[i] prev = seq[i - 1] } const lis = [] i = 1 while (--len &gt;= 0) { const n = seq[len] if (valueToMax[n] === i) { i++ lis.unshift(len) } } return lis}// 注意，结果是序列中的位置索引，比如下列输出结果是 [0, 4, 5]，对应到 seq 当中则为 [0, 2, 10]console.log(lis(seq)) BF 和 KMP 算法这两个算法也是数据结构当中涉及比较多的算法，更为具体的原理跟实现方式可见 BF 和 KMP 算法，我们在这里简单的总结一下，两者的区别如下 BF 算法，即暴力（Brute Force）算法，是普通的模式匹配算法，BF 算法的思想就是将目标串 S 的第一个字符与模式串 T 的第一个字符进行匹配 若相等，则继续比较 S 的第二个字符和 T 的第二个字符 若不相等，则比较 S 的第二个字符和 T 的第一个字符，依次比较下去，直到得出最后的匹配结果 123456789101112131415161718192021function indexOf(str, key) { let i = 0, j = 0 // 为了简洁，没有判断当 str 剩余的字符少于 key 应该终止循环，因为这样会用到 length // 原理和上方是一样的，即 str[j] 和 key[i] 对比，如果一样那么 i 和 j 都加 1，否则 j 恢复到匹配时的下一个，i 恢复到 0 while (key[i] !== undefined &amp;&amp; str[j] !== undefined) { if (key[i] === str[j]) { i++ j++ } else { j = j - i + 1 i = 0 } } if (i === 0) return -1; return j - i}s = 'ABCDABCDABDE't = 'ABCDABD'indexOf(s, t) 相较于 BF 算法，KMP 算法的主旨是尽量的减少指针的回溯从而使得性能得到提高（主要是文本串的指针，下面可以发现），我们先来看一下 KMP 算法 的操作流程 假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j] ），都令 i++ 和 j++，然后继续匹配下一个字符 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j] ），则令 i 不变，j = next[j]（此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next[j] 位） 换言之，将模式串 P 失配位置的 next 数组的值对应的模式串 P 的索引位置移动到失配处 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function getNext(p) { let k = -1 let j = 0 let next = [-1] let pLen = p.length while (j &lt; pLen - 1) { // p[k] 表示前缀，p[j] 表示后缀 if (k == -1 || p[j] == p[k]) { ++j ++k // 在这里直接进行赋值操作也是可以的，但是保持一致，还是同 C 语言版本，在这里进行一下优化 if (p[j] != p[k]) { next[j] = k } else { // 因为不能出现 p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k] } } else { k = next[k] } } return next}function KMP(s, p) { let i = 0 let j = 0 let sLen = s.length let pLen = p.length let next = getNext(p) while (i &lt; sLen &amp;&amp; j &lt; pLen) { // 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++ if (j === -1 || s[i] === p[j]) { i++ j++ } else { // 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j] // 这里就是与 BF 算法不同的地方，这里仅仅只用回退 j，而不用回退 i j = next[j] } } return j === pLen ? i - j : -1}s = 'ABCDABCDABDE't = 'ABCDABD'KMP(s, t) // 4 随机十六进制颜色1234567const randomHexColorCode = () =&gt; { let n = (Math.random() * 0xfffff * 1000000).toString(16) return '#' + n.slice(0, 6)}// \"#e34155\"randomHexColorCode() 获取当前页面的滚动位置1234567const getScrollPosition = (el = window) =&gt; ({ x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft, y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop})// { x: 0, y: 200 }getScrollPosition() 平滑滚动至顶部（回到顶部）123456789const scrollToTop = () =&gt; { const c = document.documentElement.scrollTop || document.body.scrollTop if (c &gt; 0) { window.requestAnimationFrame(scrollToTop) window.scrollTo(0, c - c / 8) }}scrollToTop() 将表单元素转化为对象1234567891011const formToObject = form =&gt; Array.from(new FormData(form)).reduce( (acc, [key, value]) =&gt; ({ ...acc, [key]: value }), {} )// { email: 'test@email.com', name: 'zhangsan' }formToObject(document.querySelector('#form')) 获取对象指定的属性12345678910111213const get = (from, ...selectors) =&gt; [...selectors].map(s =&gt; s .replace(/\\[([^\\[\\]]*)\\]/g, '.$1.') .split('.') .filter(t =&gt; t !== '') .reduce((prev, cur) =&gt; prev &amp;&amp; prev[cur], from) )const obj = { selector: { to: { val: 'val to select' } }, target: [1, 2, { a: 'test' }] }// ['val to select', 1, 'test']get(obj, 'selector.to.val', 'target[0]', 'target[2].a') 获取两个日期之间的差异（以天为单位）12345const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; Math.abs((dateFinal - dateInitial) / (1000 * 3600 * 24))// 52getDaysDiffBetweenDates(new Date('2020-12-13'), new Date('2020-10-22')) 将字符串复制到剪贴板12345678910111213141516171819const copyToClipboard = (str) =&gt; { const el = document.createElement('textarea') el.value = str el.setAttribute('readonly', '') el.style.position = 'absolute' el.style.left = '-9999px' document.body.appendChild(el) const selected = document.getSelection().rangeCount &gt; 0 ? document.getSelection().getRangeAt(0) : false el.select() document.execCommand('copy') document.body.removeChild(el) if (selected) { document.getSelection().removeAllRanges() document.getSelection().addRange(selected) }}copyToClipboard('test') 设计模式工厂模式又名静态工厂方法，就是创建对象，并赋予属性和方法，主要应用是抽取类相同的属性和方法封装到对象上 1234567891011121314151617181920let UserFactory = function (role) { function User(opt) { this.name = opt.name this.viewPage = opt.viewPage } switch (role) { case 'superAdmin': return new User(superAdmin) case 'admin': return new User(admin) case 'user': return new User(user) default: throw new Error(`参数错误，可选参数为 superAdmin、admin、user`) }}let superAdmin = UserFactory('superAdmin')let admin = UserFactory('admin')let normalUser = UserFactory('user') 工厂方法模式主要用于对产品类的抽象使其创建业务主要负责用于创建多类产品的实例，主要用于创建实例，也算是上面工厂方法的另外一种方式 1234567891011121314151617181920212223var Factory = function (type, content) { if (this instanceof Factory) { var s = new this[type](content) return s } else { return new Factory(type, content) }}// 工厂原型中设置创建类型数据对象的属性Factory.prototype = { test1: function (content) { console.log(content) }, test2: function (content) { console.log(content) }, test3: function (content) { console.log(content) },}Factory('test1', 'test1') 原型模式主要用于设置函数的原型属性，通常用来实现继承 1234567891011121314151617181920212223function Animal(name) { this.name = name || 'Animal' this.sleep = function () { console.log(this.name + '正在睡觉') }}Animal.prototype.eat = function (food) { console.log(this.name + '正在吃 ' + food)}function Cat() { }Cat.prototype = new Animal()Cat.prototype.name = 'cat'var cat = new Cat()cat.name // catcat.eat('fish') // cat 正在吃 fishcat.sleep() // cat 正在睡觉cat instanceof Animal // truecat instanceof Cat // true 单例模式其实简单来说，任意对象都是单例，无须特别处理，但是比较通用的用法是一个只允许被实例化一次的类，通常提供一个命名空间 1234567891011121314151617181920let singleCase = function (name) { this.name = name}singleCase.prototype.getName = function () { return this.name}let getInstance = (function () { var instance = null return function (name) { if (!instance) { instance = new singleCase(name) } return instance }})()// truegetInstance('one') === getInstance('two') 下面这个则是一个更为通用的惰性单例 123456var getSingle = function (fn) { var result return function () { return result || (result = fn.apply(this, arguments)) }} 外观模式也可译为门面模式，它为子系统中的一组接口提供一个一致的界面，比如在家要看电影，需要打开音响，再打开投影仪等，引入外观角色之后，只需要调用打开电影设备方法就可以了，它的作用是简化复杂接口和解耦和，屏蔽使用者对子系统的直接访问 这种方式其实我们在平常开发过程中经常使用，只是我们没有察觉而已，在形式上，外观模式在 JavaScript 中就类似于下面这样的 1234567891011function a(x) { // do something}function b(y) { // do something}function ab(x, y) { a(x) b(y)} 适配器模式适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题 123456789101112131415161718class Adaptee { test() { return '旧接口' }}class Target { constructor() { this.adaptee = new Adaptee() } test() { let info = this.adaptee.test() return `适配${info}` }}let target = new Target()console.log(target.test()) 装饰者模式装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7 的装饰器语法以及 React 中的高阶组件（HOC）都是这一模式的实现，React-Redux 的 connect() 也运用了装饰器模式，这里以 ES7 的装饰器为例 12345678910function info(target) { target.prototype.name = '张三' target.prototype.age = 10}@infoclass Man { }let man = new Man()man.name 桥接模式桥接模式（Bridge）主要是将抽象部分与它的实现部分分离，使它们都可以独立地变化，通常用在事件监控上，我们先来看一段代码 123456789addEvent(element, 'click', getBeerById)function getBeerById(e) { var id = this.id asyncRequest('GET', 'beer.uri?id=' + id, function (resp) { // Callback response console.log('Requested Beer: ' + resp.responseText) })} 上述代码，有个问题就是 getBeerById 必须要有浏览器的上下文才能使用，因为其内部使用了 this.id 这个属性，通常情况下，我们会将程序改造成如下形式 1234567function getBeerById(id, callback) { // 通过 id 发送请求，然后返回数据 asyncRequest('GET', 'beer.uri?id=' + id, function (resp) { // callback response callback(resp.responseText) })} 现在看上去是不是实用多了，首先 id 可以随意传入，而且还提供了一个 callback 函数用于自定义处理函数，但是这个和桥接有什么关系呢？这就是下段代码所要体现的了 1234567addEvent(element, 'click', getBeerByIdBridge)function getBeerByIdBridge(e) { getBeerById(this.id, function (beer) { console.log('Requested Beer: ' + beer) })} 这里的 getBeerByIdBridge 就是我们定义的桥，用于将抽象的 click 事件和 getBeerById 连接起来，同时将事件源的 id，以及自定义的 callback 函数作为参数传入到 getBeerById 函数当中 模版方法模式简单来说，所谓的模版方法模式（Template Method）就是在父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤 123456789101112131415161718192021(function (window, undefined) { var logger = { log: function () { console.log(`log`) }, init: function () { this.log() } } window.logger = logger})(window)var one = function () { logger.log = function () { console.log(`test`) } logger.init()}// testone() 状态模式状态模式是解决某些需求场景的最好方法，状态模式的关键是区分事物内部的状态，事物内部的状态的改变往往会带来事物的行为的改变，比如下面这个示例，在简单的多个状态之间切换的时候，这样的模式是非常清晰的 1234567if (this.state === 'off') { console.log('开灯') this.state = 'on'} else if (this.state === 'on') { console.log('关灯') this.state = 'off'} 两个状态之间的切换，我们可以使用 if-else 的形式来进行切换，但是如果有多个状态的时候，这样的切换就会嵌套很多的条件判断语句，修改起来也是比较困难，所以这里我们就可以采用状态模式来对其进行一定程度上的重构 简单来说，就是把事物的每种状态都封装成单独的类，跟此状态相关的行为都被封装在这个类的内部，只要有交互行为，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为，首先我们先来封装状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var OffLightState = function (light) { this.light = light}OffLightState.prototype.buttonWasPressed = function () { console.log('offLightState') // offLightState 对应的行为 this.light.setState(this.light.weakLightState) // 切换状态到 weakLightState}// WeakLightStatevar WeakLightState = function (light) { this.light = light}WeakLightState.prototype.buttonWasPressed = function () { console.log('weakLightState') // weakLightState 对应的行为 this.light.setState(this.light.strongLightState) // 切换状态到 strongLightState}// StrongLightStatevar StrongLightState = function (light) { this.light = light}StrongLightState.prototype.buttonWasPressed = function () { console.log('strongLightState') // strongLightState 对应的行为 this.light.setState(this.light.offLightState) // 切换状态到 offLightState}var Light = function () { this.offLightState = new OffLightState(this) this.weakLightState = new WeakLightState(this) this.strongLightState = new StrongLightState(this) this.button = null}Light.prototype.init = function () { var button = document.createElement('button'), self = this this.button = document.body.appendChild(button) this.button.innerHTML = '开关' // 设置当前状态 this.currState = this.offLightState this.button.onclick = function () { self.currState.buttonWasPressed() }}Light.prototype.setState = function (newState) { // 设置下一个状态 this.currState = newState}var light = new Light()light.init() 我们在 Light 类中为每个状态类都创建一个状态对象，这样一来就可以很明显的看到电灯一共有多少个状态，当我们在使用的时候，也就是点击 button 的时候，通过 self.currState.buttonWasPressed() 将请求委托为当前的状态去执行 最后提供一个 setState 的方法，状态对象通过这个方法来切换 Light 对象的状态，状态对象的切换规律被定义在各个状态类中 策略模式简单来说，策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们 1234567891011121314151617var obj = { 'A': function (salary) { return salary * 4 }, 'B': function (salary) { return salary * 3 }, 'C': function (salary) { return salary * 2 }}var calculateBouns = function (level, salary) { return obj[level](salary)}// 40000calculateBouns('A', 10000) 访问模式访问者模式（Visitor Pattern）模式是行为型（Behavioral）设计模式，提供一个作用于某种对象结构上的各元素的操作方式，可以使我们在不改变元素结构的前提下，定义作用于元素的新操作，简单来说，如果系统的数据结构是比较稳定的，但其操作（算法）是易于变化的，那么使用访问者模式是个不错的选择，但是如果数据结构是易于变化的，则不适合使用访问者模式 访问者模式一共有五种角色 Vistor（抽象访问者），为该对象结构中具体元素角色声明一个访问操作接口 ConcreteVisitor（具体访问者），每个具体访问者都实现了 Vistor 中定义的操作 Element（抽象元素），定义了一个 accept 操作，以 Visitor 作为参数 ConcreteElement（具体元素），实现了 Element 中的 accept() 方法，调用 Vistor 的访问方法以便完成对一个元素的操作 ObjectStructure（对象结构），可以是组合模式，也可以是集合，一般能够枚举它包含的元素，通常会提供一个接口，允许 Vistor 访问它的元素 12345678910111213141516171819202122// 访问者function Visitor() { this.visit = function (concreteElement) { concreteElement.doSomething() }}// 元素类function ConceteElement() { this.doSomething = function () { console.log(`这是一个具体元素`) } this.accept = function (visitor) { visitor.visit(this) }}// Clientvar ele = new ConceteElement()var v = new Visitor()ele.accept(v) 中介者模式中介者是协调多个对象之间的交互（逻辑和行为）的对象，它根据其他对象和输入的动作（或不动作）来决定何时调用哪些对象，比如下面这个示例，其中的 publish() 和 subscribe() 方法都被暴露出来使用 123456789101112131415161718192021222324252627282930var mediator = (function () { var topics = {} var subscribe = function (topic, fn) { if (!topics[topic]) { topics[topic] = [] } topics[topic].push({ context: this, callback: fn }) return this } var publish = function (topic) { var args if (!topics[topic]) { return false } args = Array.prototype.slice.call(arguments, 1) for (var i = 0, l = topics[topic].length; i &lt; l; i++) { var subscription = topics[topic][i] subscription.callback.apply(subscription.context, args) } return this } return { publish: publish, subscribe: subscribe, installTo: function (obj) { obj.subscribe = subscribe obj.publish = publish } }}()) 代理模式简单来说，就是新建个类调用老类的接口，包装一下，在 ES6 之前我们可以采用下面这种方式 12345678910111213141516171819202122232425function Person() { }Person.prototype.sayName = function () { console.log('zhangsan')}Person.prototype.sayAge = function () { console.log(20)}function PersonProxy() { this.person = new Person() var that = this this.callMethod = function (functionName) { console.log('before proxy:', functionName) // 代理 that.person[functionName]() console.log('after proxy:', functionName) }}var p = new PersonProxy()p.callMethod('sayName') // 代理调用 Person 的方法 sayName()p.callMethod('sayAge') // 代理调用 Person 的方法 sayAge() 另外在 ES6 当中提供了 Proxy 对象也可以用来实现代理，基本语法为 1let x = new Proxy(target, handler) target 是你要代理的对象，它可以是任何合法对象(数组，对象，函数等等) handler 是你要自定义操作方法的一个集合 x 是一个被代理后的新对象，它拥有 target 的一切属性和方法，只不过其行为和结果是在 handler 中自定义的 所以在 ES6 之后，我们就可以考虑使用 Proxy 12345678910111213141516171819202122232425262728293031323334353637383940let obj = { a: 1, b: 2,}const p = new Proxy(obj, { get(target, key, value) { if (key === 'c') { return '我是自定义的一个结果' } else { return target[key] } }, set(target, key, value) { if (value === 4) { target[key] = '我是自定义的一个结果' } else { target[key] = value } }})console.log(obj.a) // 1console.log(obj.c) // undefinedconsole.log(p.a) // 1console.log(p.c) // 我是自定义的一个结果obj.name = 'zhangsan'console.log(obj.name) // zhangsanobj.age = 4console.log(obj.age) // 4p.name = 'zhangsan'console.log(p.name) // zhangsanp.age = 4console.log(p.age) // 我是自定义的一个结果 观察者模式本质上也就是事件模式 1234567891011121314151617181920212223242526272829303132333435// 被观察者class Subject { constructor() { this.list = [] } addListener(target) { this.list.push(target) } notify() { this.list.forEach(el =&gt; { el.say() }) }}// 观察者class Observer { constructor(name) { this.name = name } say() { console.log(this.name) }}const target = new Subject()const person1 = new Observer('zhangsan')const person2 = new Observer('lisi')target.addListener(person1)target.addListener(person2)target.notify() 发布订阅模式12345678910111213141516171819202122232425// 支持同步、异步管道化var msghub = (function () { var listener = [] return { on: function (type, cb, option) { listener[type] = listener[type] || [] option = option || {} listener[type].push({ cb: cb, priority: option.priority || 0 }) }, fire: function (type, dataObj) { if (listener[type]) { let listenerArr = listener[type].sort((a, b) =&gt; b.priority - a.priority) (async function iter() { let val = dataObj for (const item of listenerArr) { val = await item.cb.call(null, val) } })() } } }})() 常用方法 &amp;&amp; 函数事件模型（EventBus）这个通常在面试的时候被问到的比较多，下面我们就来看看如何实现，先从最为基本的实现方式开始看起 12345678910111213141516171819class EventEmitter { constructor() { // 存储事件 this.events = this.events || new Map() } // 监听事件 addListener(type, fn) { if (!this.events.get(type)) { this.events.set(type, fn) } } // 触发事件 emit(type) { let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) }} 以上就是一个最为基本的架子，虽然实现了主要功能，但是没有处理异常场景和事件移除的相关处理，下面我们来看看如何完善它们 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class EventEmitter { constructor() { if (this._events === undefined) { // 定义事件对象 this._events = Object.create(null) this._eventsCount = 0 } } emit(type, ...args) { const events = this._events const handler = events[type] // 判断相应 type 的执行函数是否为一个函数还是一个数组 if (typeof handler === 'function') { Reflect.apply(handler, this, args) } else { const len = handler.length for (var i = 0; li &lt; len; i++) { Reflect.apply(handler[i], this, args) } } return true } on(type, listener, prepend) { var events var existing events = this._events // 添加事件 if (events.newListener !== undefined) { this.emit('namelessListener', type, listener) events = target._events } existing = events[type] // 判断相应的 type 的方法是否存在 if (existing === undefined) { // 如果相应的 type 的方法不存在，则新增一个相应 type 的事件 existing = events[type] = listener ++this._eventsCount } else { // 如果存在相应的 type 的方法，判断相应的 type 的方法是一个数组还是仅仅只是一个方法 if (typeof existing === 'function') { // 如果仅仅是一个方法，则添加 existing = events[type] = prepend ? [listener, existing] : [existing, listener] } else if (prepend) { existing.unshift(listener) } else { existing.push(listener) } } // 保证链式调用 return this } removeListener(type, listener) { var list, events, position, i events = this._events list = events[type] // 如果相应的事件对象的属性值是一个函数，也就是说事件只被一个函数监听 if (list === listener) { if (--this._eventsCount === 0) { this._events = Object.create(null) } else { delete events[type] // 如果存在对移除事件 removeListener 的监听函数，则触发 removeListener if (events.removeListener) this.emit('removeListener', type, listener) } } else if (typeof list !== 'function') { // 如果相应的事件对象属性值是一个函数数组 // 遍历这个数组，找出 listener 对应的那个函数，在数组中的位置 for (i = list.length - 1; i &gt;= 0; i--) { if (list[i] === listener) { position = i break } } // 没有找到这个函数，则返回不做任何改动的对象 if (position) { return this } // 如果数组的第一个函数才是所需要删除的对应 listener 函数，则直接移除 if (position === 0) { list.shift() } else { list.splice(position, 1) } if (list.length === 1) events[type] = list[0] if (events.removeListener !== undefined) this.emit('removeListener', type, listener) } return this }} 下面再来简单的测试一下 123456789101112131415// 测试var emitter = new EventEmitter()emitter.on('event2', function (arg1, arg2) { console.log('get event2', arg1, arg2)})emitter.on('event1', function (arg1, arg2) { console.log('get event1', arg1, arg2)})console.log('emit event')emitter.emit('event2', 'arg1', 'arg2')emitter.emit('event1', 'arg1', 'arg2') Ajax123456789101112131415161718192021222324252627var xhr = new XMLHttpRequest()if (xhr) { xhr.open('GET', url) xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText) } } xhr.send()}// ---------------------------------------------------// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 http 头// 然后在 send() 方法中添加需要发送的数据// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型// 下面是三种常用的设置方式// application/x-www-form-urlencoded 窗体数据被编码为 名称/值 对，这是标准的编码格式// multipart/form-data 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分// text/plain 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 xhr.open('POST', url, true)xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')xhr.send(data) Promise 版本 Ajax123456789101112131415161718192021222324function getJSON(url) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onreadystatechange = function () { if (this.readyState === 4) { if (this.status === 200) { resolve(this.responseText, this) } else { var resJson = { code: this.status, response: this.response } reject(resJson, this) } } } xhr.send() })}// 使用getJSON(url).then(function (data) { console.log(data)}).catch(function (status) { console.log(`Error: ${status}`)}) 终止请求我们在上面提到了 Ajax，所以在这里我们就来多看一点，那就是如何终止请求，目前来说，使用较多的请求数据有两种方式，一种是 Ajax，另一种就是 fetch，我们先来看看在 Ajax 当中终止请求的方式，方法很简单，当我们由于某种原因（比如重复请求）想要终止它的时候，我们只需要调用 abort() 即可 1xhr.abort() 但是对于 fetch 来说，我们主要使用的是 AbortSignal 这个接口，在 MDN 上的介绍是，AbortSignal 接口表示一个信号对象（signal object），它允许通过 AbortController 对象与 DOM 请求（如 Fetch）进行通信并在需要时将其中止 看到这里是不是有一些眉目了，我们只需要使用 AbortController() 构造函数创建一个控制器，然后使用 AbortController.signal 属性就可以了，当获取请求被启动时，我们在请求的选项对象中传递 AbortSignal 作为一个选项，这将信号和控制器与获取请求相关联，并允许我们通过调用 AbortController.abort() 来中止它，代码如下 12345678910111213141516const controller = new AbortController()const signal = controller.signalconsole.log(signal, `signal 的初始状态`)signal.addEventListener('abort', function (e) { console.log(signal, `signal 的中断状态`)})setTimeout(function () { controller.abort()}, 2000)fetch('/api', { signal }) .then((res) =&gt; { console.log(res, '请求成功') }) 但是也有一个需要注意的地方，那就是虽然 AbortController 已经诞生很长时间了，但是目前在 MDN 上还是被标注为实验性技术，所以还是需要根据实际使用场景来考虑是否使用 批量请求要求实现一个批量请求函数 multiRequest(urls, maxNum)，要求如下 要求最大并发数 maxNum 每当有一个请求返回，就留下一个空位，可以增加新的请求 所有请求完成后，结果按照 urls 里面的顺序依次打出 整体采用递归调用来实现，最初发送的请求数量上限为允许的最大值，并且这些请求中的每一个都应该在完成时继续递归发送，通过传入的索引来确定了 urls 里面具体是那个 url，保证最后输出的顺序不会乱，而是依次输出 1234567891011121314151617181920212223242526272829303132function multiRequest(urls = [], maxNum) { const len = urls.length // 请求总数量 const result = new Array(len).fill(false) // 根据请求数量创建一个数组来保存请求的结果 let count = 0 // 当前完成的数量 return new Promise((resolve, reject) =&gt; { while (count &lt; maxNum) { // 利用递归 next() } function next() { let current = count++ if (current &gt;= len) { // 处理边界条件 !result.includes(false) &amp;&amp; resolve(result) // 请求全部完成就将 promise 置为成功状态，然后返回 resolve(result) return } const url = urls[current] console.log(`开始 ${current}`, new Date().toLocaleString()) fetch(url).then((res) =&gt; { result[current] = res // 保存请求结果 console.log(`完成 ${current}`, new Date().toLocaleString()) if (current &lt; len) { // 请求没有全部完成，就递归 next() } }).catch((err) =&gt; { console.log(`结束 ${current}`, new Date().toLocaleString()) result[current] = err if (current &lt; len) { // 请求没有全部完成，就递归 next() } }) } })} getElementsByClassName()123456789101112131415function getElementsByClassName(classname) { if (document.querySelectorAll) { return document.querySelectorAll('.' + classname) } else { var elements = document.getElementsByTagName('*') var reg = new RegExp('(^|\\\\s)' + classname + '(\\\\s|$)') var results = [] for (let i = 0, length = elements.length; i &lt; length; i++) { if (reg.test(elements[i].className)) { results.push(elements[i]) } } } return results}","link":"/2019/08/02/JavaScript/53/"},{"title":"HTTP 协议","text":"最近在复习计算机网络相关知识，因为在复习过程中发现博客当中很多关于 HTTP 的内容都是东一块西一块的混杂在一起，没有形成体系，所以干脆就将之前的全部内容提取出来，然后重新的整理一遍，在借助一些书籍从 HTTP 诞生之时开始重新的梳理一遍其相关内容，也算是从零开始从新学习 HTTP 其实主要目的还是了解一下 HTTP、TCP/IP、HTTPS 等相关概念到底是什么，又是用来做什么的，这里因为 HTTP 相关内容篇幅较长，所以我们使用一张思维导图简单的汇总一下，如下（详细信息可以参考左侧目录） 这里需要注意，因为相较于 HTTP 协议，TCP/IP 协议的相关内容也是非常之多的，所以在本章当中我们只简单的介绍一下 TCP/IP 相关基本内容，更为详细的内容会在后续深入学习后再来进行补充 HTTP 概述1989 年 3 月，当时的互联网还只属于少数人，在这一互联网的黎明期，HTTP 诞生了，CERN（欧洲核子研究组织）的蒂姆·伯纳斯博士提出了一种能让远隔两地的研究者们共享知识的设想，最初设想的基本理念是借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网），针对于此提出了三项 WWW 构建技术，分别是 把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言） 作为文档传递协议的 HTTP 指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符） WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称，现在则用来表示这一系列的集合，也可简称为 Web 发展1990 年 11 月，CERN 成功研发了世界上第一台 Web 服务器和 Web 浏览器，1990 年，大家针对 HTML/1.0 草案进行了讨论，因 HTML/1.0 中存在多处模糊不清的部分，草案被直接废弃了，接着从 1993 年开始，各公司之间爆发的浏览器大战就没有停息过，在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种 Web 标准化视而不见，还屡次出现新增功能没有对应说明文档的情况，而在此过程当中，HTTP 的发展则是驻足不前的，各版本情况如下 HTTP/0.9HTTP 于 1990 年问世，那时的 HTTP 并没有作为正式的标准被建立，现在的 HTTP 其实含有 HTTP/1.0 之前版本的意思，因此被称为 HTTP/0.9 HTTP/1.0HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP/1.0，并记载于 RFC1945，虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端，地址如下 RFC1945 - Hypertext Transfer Protocol - HTTP/1.0 https://www.ietf.org/rfc/rfc1945.txt HTTP/1.11997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本，当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本，地址如下 RFC2616 - Hypertext Transfer Protocol - HTTP/1.1 https://www.ietf.org/rfc/rfc2616.txt 可见，作为 Web 文档传输协议的 HTTP，它的版本几乎没有更新（关于 HTTP/2，HTTP/3 相关知识我们会在后面进行介绍） 网络基础 TCP/IP为了理解 HTTP，我们有必要事先了解一下 TCP/IP 协议族，通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的，而 HTTP 属于它内部的一个子集，区别如下 TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输 而 HTTP 是应用层协议，主要解决如何包装数据 计算机与网络设备要相互通信，双方就必须基于相同的方法，比如如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，而我们就把这种规则称为协议（protocol），协议中存在各式各样的内容，从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等 像这样把与互联网相关联的协议集合起来总称为 TCP/IP，TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由 FTP、SMTP、TCP、UDP、IP 等协议构成的协议簇，只是因为在 TCP/IP 协议中 TCP 协议和 IP 协议最具代表性，所以被称为 TCP/IP 协议 一个比较简单的记忆方式，我们可以把 IP 想像成一种高速公路，它允许其它协议在上面行驶，TCP 和 UDP 等是高速公路上的卡车，它们携带的货物就是像 HTTP，文件传输协议 FTP 这样的协议 网络模型划分我们在做开发的过程当中，常常会听说到各种协议，当前存在三种比较流行的划分网络模型的方式，如下 OSI 七层模型 TCP/IP 四层模型 五层模型 对应如下图 但是这里我们主要介绍 TCP/IP 四层模型，关于其他部分只做简单介绍，如果想要了解更多可以另行查阅相关书籍或文章 OSI 七层模型OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了七层，每一层都有相关、相对应的物理设备，比如路由器，交换机等，OSI 七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其主要的功能使就是帮助不同类型的主机实现数据传输，它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，如下图 TCP/IP 四层模型TCP/IP 和 OSI 模型组并不能精确的匹配，但是我们可以尽可能的参考 OSI 模型并在其中找到 TCP/IP 的对应位置，OSI 模型到 TCP/IP 模型映射关系，通常人们认为 OSI 模型最上面三层（应用层、表示层、会话层）在 TCP/IP 中是一个应用层，由于 TCP/IP 有一个相对比较弱的会话层，由 TCP 和 RTP 下的打开和关闭连接组成，并在 TCP/UDP 下的各种应用提供不同的端口号，这些功能被单个的应用程序添加 那么 TCP/IP 四层模型跟 OSI 模型有什么不一样呢？ OSI 是一个完整的、完善的宏观理论模型，而 TCP/IP 模型，更加侧重的是互联网通信核心（也是就是围绕 TCP/IP 协议展开的一系列通信协议）的分层，因此它不包括物理层，以及其他一些不想干的协议，其次之所以说他是参考模型，是因为他本身也是 OSI 模型中的一部分，因此参考 OSI 模型对其进行分层 五层模型五层体系结构包括应用层、运输层、网络层、数据链路层和物理层，五层协议只是 OSI 和 TCP/IP 的综合，实际应用还是 TCP/IP 的四层结构，它的意义其实是为了方便学习计算机网络原理而采用的，综合了 OSI 七层模型和 TCP/IP 的四层模型而得到的五层模型 TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层，TCP/IP 协议族按层次分别分为以下四层，即应用层、传输层、网络层和数据链路层，把 TCP/IP 层次化是有好处的，比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉，而分层之后只需把变动的层替换掉即可，把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了 值得一提的是，层次化之后，设计也变得相对简单了，处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题，TCP/IP 协议族各层的作用如下 名称 释义 应用层 应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务，比如 FTP 和 DNS 服务就是其中两类，HTTP 协议也处于该层 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议 TCP 和 UDP 网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位，该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方，与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线 链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（网络适配器），及光纤等物理可见部分（还包括连接器等一切传输媒介），硬件上的范畴均在链路层的作用范围之内 TCP/IP 通信传输流利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则往应用层往上走 我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求，接着为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层 在网络层（IP 协议）增加作为通信目的地的 MAC 地址后转发给链路层，这样一来发往网络的通信请求就准备齐全了，接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装（encapsulate） IP、TCP 和 DNS下面我们来看看在 TCP/IP 协议族中与 HTTP 密不可分的三个协议 IP、TCP 和 DNS 负责传输的 IP 协议按层次分，IP（Internet Protocol）网际协议位于网络层，它的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）（需要注意别把 IP 和 IP 地址搞混淆，IP 其实是一种协议的名称） IP 地址指明了节点被分配到的地址，它可以和 MAC 地址进行配对，并且是可以变换的，而且 IP 间的通信依赖 MAC 地址 MAC 地址是指网卡所属的固定地址，但 MAC 地址基本上不会更改 在网络上，通常是经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标，这时会采用 ARP 协议（Address Resolution Protocol），ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址 其实简单来说就是需要借助 ARP 协议将目标主机的 IP 地址转换为对应主机的 MAC 地址才能进行通信 下面我们来简单的看一下 ARP 协议的工作原理，它主要的作用是为了从网络层的 IP 地址，解析出在数据链路层使用的硬件地址，但是需要注意的是，ARP 解决的是同一局域网上的主机和路由器的 IP 地址和硬件地址的映射问题，它的工作原理是下面这样的 每一台主机都设有一个 ARP 告诉缓存，里面有本局域网上的各个主机和路由器的 IP 地址到硬件地址的映射，当 A 要向本局域网上的 B 发送 IP 数据报时，则 A 先查看 ARP 高速缓存中有无 B 的 IP 地址 如果有，则就在 ARP 高速缓存中查出该 IP 地址的硬件地址，把这个硬件地址写入 MAC 帧，再通过局域网将 MAC 帧发往此硬件地址 如果没有，则 ARP 向本局域网广播（请求分组是广播，响应分组是单播）发送一个 ARP 请求分组，表明自己的 IP 地址和硬件地址以及要寻找的 IP 地址，B 接收到请求分组后，收下并且向 A 发送相应分组，其余主机不做相应，A 收到 B 的相应分组后再进行常规的数据传输 ARP 对每一个映射地址的项目都设有生存时间（例如 10 - 20 分钟），这是为了防止该局域网中某些主机的硬件地址发生改变的情况 确保可靠性的 TCP 协议按层次分，TCP 位于传输层，提供可靠的字节流服务，所谓的字节流服务（Byte Stream Service）是指为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理，而可靠的传输服务是指，能够把数据准确可靠地传给对方 TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方，为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three way handshaking）策略，用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达 握手过程中使用了 TCP 的标志 SYN（synchronize）和 ACK（acknowledgement），发送端首先发送一个带 SYN 标志的数据包给对方，接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息，最后发送端再回传一个带 ACK 标志的数据包代表握手结束，若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包 负责域名解析的 DNS 服务DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议，它提供域名到 IP 地址之间的解析服务，用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问，但要让计算机去理解名称，相对而言就变得困难了，因为计算机更擅长处理一长串数字，为了解决上述的问题，DNS 服务应运而生，DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务 这里我们就稍微深入一些，来看看 DNS 如何工作的，我们先从查询过程开始看起 查询过程 它的查询过程可以如下图所示 这里我们假设 m.xyz.com 需要查找 y.abc.com 的 IP 地址，具体流程是下面这样的 主机 m.xyz.com 向本地域名服务器进行『递归查询』 本地域名服务器『迭代查询』，先向一个根域名服务器查询 根域名服务器告诉本地域名服务器，下一步应该向顶级域名服务器 dns.com 查询 顶级域名服务器 dns.com 告诉本地域名服务器，下一步查找权限域名服务器 dns.adc.com 本地域名服务器向权限域名服务器发起查询，权限域名服务器告诉本地域名服务器所需的 IP 地址，本地域名服务器在告诉给本地主机 上图展示了 DNS 在本地 DNS 服务器是如何查询的，一般向本地 DNS 服务器发送请求是递归查询的，但是本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，如下 这里要注意区分两者的区别 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果，使用递归查询，用户只需要发出一次查询请求 迭代查询指的是查询请求后，域名服务器返回单次查询的结果，下一级的查询由用户自己请求，使用迭代查询，用户需要发出多次的查询请求 所以一般而言，主机向本地域名服务器查询时一般使用『递归查询』，而本地 DNS 服务器向其他域名服务器请求的过程是『迭代查询』的过程 这里我们在简单的补充一些关于域名服务器的分类（也就是上图当中右侧部分），如下 根域名服务器，最高层也是最重要的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名地址和 IP 地址，例如 a.rootserver.net 顶级域名服务器，这些域名服务器负责管理在该顶级域名服务器上注册的所有的二级域名，例如 com 权限域名服务器，负责一个区的域名服务器，如果当前权限域名服务器不能给出所需的 IP 地址，则返回客户应该找哪一个权限服务器 本地域名服务器，本地 DNS 一般是指你电脑上网时 IPv4 或者 IPv6 设置中填写的那个 DNS，这个有可能是手工指定的或者是 DHCP 自动分配的，当一台主机发送 DNS 请求报文时，这个查询报文就发送给本地域名服务器 DNS 缓存 在一个请求中，当某个 DNS 服务器收到一个 DNS 应答后，它能够将应答中的信息缓存在本地存储器中（返回的资源记录中的 TTL 代表了该条记录的缓存的时间） DNS 实现负载平衡 首先我们得清楚 DNS 是可以用于在冗余的服务器上实现负载平衡，这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址，举个例子来说 当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合在每个应答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求，以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡 UDP在这里我们简单的了解一下经常与 TCP 同时提到的 UDP 协议，UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议，在 OSI 模型中，在第四层传输层，处于 IP 协议的上一层，UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说当报文发送之后，是无法得知其是否安全完整到达的，它有以下几个特点 面向无连接 首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作，具体来说就是 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能 UDP 是面向报文的 发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此，应用程序必须选择合适大小的报文 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠，并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP 头部开销小，传输数据报文时是很高效的 UDP 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 HTTP 协议HTTP 协议（HyperText Transfer Protocol，超文本传输协议）定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器，从层次的角度看，HTTP 是面向（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件（包括文本，声音，图像等各种多媒体文件）的重要基础，也是 Web 联网的基础 客户机需要通过 HTTP 协议传输所要访问的超文本信息，HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成 我们在浏览器的地址栏里输入的网站地址叫做 URL（Uniform Resource Locator，统一资源定位符），当你在浏览器的地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏览的地址，浏览器通过超文本传输协议（HTTP），将 Web 服务器上站点的网页代码提取出来，并翻译成我们最终所见到的网页 HTTP 工作流程我们以下图为例，先来简单的梳理一下 HTTP 的整个工作流程，其实简单来说，就是请求与响应的过程 HTTP 通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列七个步骤 1、建立 TCP 连接在 HTTP 工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的（即著名的 TCP/IP 协议族），HTTP 是比 TCP 更高层次的应用层协议（可以参考上面的网络模型划分），根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此首先要建立 TCP 连接，一般 TCP 连接的端口号是 80 2、客户端向服务器发送请求命令一旦建立了 TCP 连接，客户端就会向服务器发送请求命令，例如 12GET /index.html HTTP/1.1Host: baidu.com 3、客户端发送请求头信息客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送 4、服务器应答客户端向服务器发出请求后，服务器会客户端返回响应，例如 12HTTP/1.1 200 OKDate: Tue, 10 Jul 2019 20:50:15 GMT 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成 5、服务器返回响应头信息正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档 6、服务器向客户端发送数据服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据 7、服务器关闭 TCP 连接一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了 Connection: keep-alive，TCP 连接在发送后将仍然保持打开状态，于是客户端可以继续通过相同的连接发送请求，保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽 HTTP 协议特点这里主要涉及到的是一些关于 HTTP 协议特点的基础知识 通过请求和响应的交换达成通信应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色，仅从一条通信线路来说，服务器端和客服端的角色是确定的，HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回，换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应 HTTP 是不保存状态的协议HTTP 是一种无状态协议，协议自身不对请求和响应之间的通信状态进行保存，也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理，这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的 可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存，于是我们引入了 Cookie 技术，有了 Cookie 再用 HTTP 协议通信，就可以管理状态了 使用 Cookie 的状态管理Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态，Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去，服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息 请求 URI 定位资源HTTP 协议使用 URI 定位互联网上的资源，正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到，但是我们在平时听到或者见到更多的应该是 URL（Uniform Resource Locator，统一资源定位符），那么这两者有什么区别呢？ 用大白话来说就是，URI 是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫 URI，本来设想的的使用两种方法定位，URL（地址定位）和 URN（名称定位），只是后来 URN 没流行起来，导致几乎目前所有的 URI 都是 URL，所以这里我们就以 URL 为例，如下所示 12345 协议 IP 地址 端口 资源的具体位置 | | | | | | | |----- ---------- ---- -------http://192.168.31.169:8888/index.html 第一部分是协议（或称为服务方式） 第二部分是存有该资源的主机 IP 地址（有时也包括端口号） 第三部分是主机资源的具体位置（如目录和文件名等） 第一部分和第三部分之间用 '://' 符号隔开，第二部分和第三部分用 '/' 符号分隔，第一部分和第二部分是不可缺少的，第三部分有时也可以省略 告知服务器意图的 HTTP 方法也就是 HTTP/1.1 当中可使用的方法，如下图 这里有几个需要注意的地方 HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法，当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的，这是因为请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作，但是 TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了 持久连接HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接，比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源，因此每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法，其特点是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，旨在建立一次 TCP 连接后进行多次请求和响应的交互，在 HTTP/1.1 中，所有的连接默认都是持久连接 但是有一些需要注意的地方 HTTP Keep-Alive 简单说就是保持当前的 TCP 连接，避免了重新建立连接 HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个 TCP 通道可以保持 5 秒，max = 100，表示这个长连接最多接收 100 次请求就断开 HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果，另外 Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP/1.1 版本中也如此，唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连接特性，否则会有意想不到的后果 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？分为两部分 判断传输数据是否达到了 Content-Length 指示的大小 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束，更多详细内容可见 HTTP Keep-Alive 模式 关于 chunked 分块传输可见下方的 Transfer-Encoding 部分内容 管线化默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求，在使用持久连接的情况下，某个连接上消息的传递类似于下面这样 1请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3 HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应，使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似下面这样（注意箭头的变化） 1请求1 ==&gt; 请求2 ==&gt; 请求3 ==&gt; 响应1 ==&gt; 响应2 ==&gt; 响应3， 这里也有一些需要注意的地方 管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持） 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变 HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文，请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文，在规范当中把 HTTP 请求分为三个部分，如下图所示 每条报文都包含一条来客户端的请求，或者一条来自客户端的响应，它们由三个部分组成，对报文进行描述的请求行（start line）、包含属性的请求头（Header）以及可选的包含数据的请求体（body），请求行与请求头就是由行分隔的 ASCII 文本，每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符，这个行终止符可以写作 CRLF（空行） 注意，尽管 HTTP 规范中说明应该用 CRLF 来表示行终止，但稳健的做法也应该接受单个换行符作为行的终止 请求报文HTTP 请求报文由『请求行』、『请求头』、『空行』（有时会忽略掉这一部分）和『请求体』（请求数据）四个部分组成，如下图所示 我们可以针对上图当中的内容简化一下，就变成了下面这样 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;header&gt; &lt;entity-body&gt; 与其相对应的 HTTP 请求的报文如下 1234567891011GET /index.html HTTP/1.1Host: www.baidu.comConnection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6,id;q=0.4Cookie: PSTM=1490844191; BIDUPSID=2145FF54639208435F60E1E165379255;这里是空行（CRLF） 请求行其中，下面的这行就是请求行 1GET /index.html HTTP/1.1 开头的 GET 表示请求访问服务器的类型，称为方法，HTTP/1.1 协议 规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE 等，一般比较常用的是 GET 和 POST 这两个方法 随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI，如果直接与服务器进行对话，只要 URL 的路径部分是资源的绝对路径，通常就不会有什么问题 最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能，其格式通常是 http/&lt;major&gt;.&lt;minor&gt;，其中主版本号（major）与次版本号（minor）都是整数 综合来看，大意是请求访问某台 HTTP 服务器上的 /index.htm 页面资源，在这里关于请求方法我们多看一点内容，来看两个经常会见到的问题 GET 和 POST 请求有什么区别？ 我们经常看到的说法是下面这样的 GET 请求参数放在 URL 上，POST 请求参数放在请求体里 GET 请求参数长度有限制，POST 请求参数长度可以非常大 POST 请求相较于 GET 请求安全一点点，因为 GET 请求的参数在 URL 上，且有历史记录 GET 请求能缓存，POST 不能 但是上述答案并不完善，其实 HTTP 协议并没有要求 GET/POST 请求参数必须放在 URL 上或请求体里，也没有规定 GET 请求的长度，目前对 URL 的长度限制，是各家浏览器设置的限制，GET 和 POST 的根本区别在于 GET 请求是幂等性的，而 POST 请求不是，那么什么是幂等性呢？ 幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用，例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作 由于 GET 请求是幂等的，在网络不好的环境中，GET 请求可能会重复尝试，造成重复操作数据的风险，因此 GET 请求用于无副作用的操作（如搜索），新增/删除等操作适合用 POST，另外在网上搜索的过程中还发现有另外一个区别，那就是 GET 会产生一个 TCP 数据包，而 POST 则会产生两个 TCP 数据包，简单来说就是 对于 GET 方式的请求，浏览器会把 HTTP Header 和 Data 一并发送出去，服务器响应 200（返回数据） 而对于 POST，浏览器先发送 Header，服务器响应 100 Continue，浏览器再发送 Data，服务器响应 200 OK（返回数据） 如果从根本上来说的话，GET 和 POST 到底是什么呢，其实就是 HTTP 协议中的两种发送请求的方法，HTTP 的底层是 TCP/IP，所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接，而且它们能做的事情是一样一样的，你要给 GET 加上请求体，给 POST 带上 URL 参数，技术上也是完全行的通的 所以 GET 和 POST 本质上就是 TCP 链接，并无差别，但是由于 HTTP 的规定和 浏览器/服务器 的限制，导致他们在应用过程中体现出一些不同 OPTIONS 方法有什么用？ 大致有以下三点 OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 '*' 来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常 JavaScript 当中的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限 请求头报文头包含若干个属性，格式为 key: value 形式的键值对，服务端据此获取客户端的信息，可以有零个或多个报文头，每个报文头都包含一个名字，后面跟着一个英文冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF，报文头是由一个空行（CRLF）结束的，表示了报文头列表的结束和实体主体部分的开始，有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的报文头 关于首部字段的相关内容，会在后面的 HTTP 首部字段章节当中来详细进行介绍 空行（请求）最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头 请求体它将一个页面表单中的组件值通过键值对形式编码成一个格式化串，它承载多个请求参数的数据，报文体可以传递请求参数，请求 URL 也可以通过类似于 /index.html?param1=value1&amp;param2=value2 的方式传递请求参数，请求数据不在 GET 方法中使用，而是在 POST 方法中使用，与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length 响应报文HTTP 的响应报文由『状态行』、『响应头』、『空行』（有时会忽略掉这一部分）和『响应体』四部分组成，如下图所示 响应报文也可以进行简化，如下 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt; &lt;entity-body&gt; 下面是一个响应报文示例 12345678HTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Thu, 30 Mar 2019 12:28:00 GMTContent-Type: text/html; charset=utf-8Connection: keep-aliveCache-Control: privateExpires: Thu, 30 Mar 2019 12:27:43 GMTSet-Cookie: BDSVRTM=0; path=/ 状态行状态行也大致分为四个部分 HTTP-Version（HTTP 协议版本），Status-Code（状态码），Reason-Phrase（状态码描述），CRLF（回车/换行符） 其中状态码（Status-Code）的格式是三位数字，其描述了请求过程中所发生的情况，每个状态码的第一位数字用于描述状态的一般类别，一般是由以下五段组成 1xx，处理中，一般是告诉客户端，请求已经收到了，正在处理 2xx，处理成功，一般表示请求已受理、已经处理完成等信息 3xx，重定向到其它地方，它让客户端再发起一个请求以完成整个处理 4xx，处理发生错误，错误发生在『客户端』，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx，处理发生错误，错误发生在『服务端』，如服务端抛出异常，路由出错，HTTP 版本不支持等 关于状态码的相关内容，会在后面的 HTTP 状态码章节当中来详细进行介绍 而紧跟着后面的状态码描述（Reason-Phrase），也就是所谓的原因短语，数字状态码的可读版本，包含行终止序列之前的所有文本，原因短语只对人类有意义，比如说，尽管响应行 HTTP/1.1 200 NOT OK 和 HTTP/1.1 200 OK 中原因短语的含义不同，但同样都会被当作成功的标志，下面是一个假想的请求报文与响应报文 不过需要注意的是，一组 HTTP 报文头总是应该以一个空行（仅有 CRLF）结束，甚至即使没有报文头和实体的主体部分也应该如此，但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误的）省略了最后的 CRLF，为了与这些流行但不符合规则的实现兼容，客户端和服务器都应该接受那些没有最后那个 CRLF 的报文 响应头响应头也是由格式为 key: value 形式的键值对组成，响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 Request-URI 进一步的信息 关于首部字段的相关内容，会在后面的 HTTP 首部字段章节当中来详细进行介绍 空行（响应）最后一个响应头之后是一个空行，发送回车符和换行符，通知浏览器以下不再有响应头 响应体服务器返回给浏览器的响应信息，下面是百度首页的响应体片段 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt; &lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt; &lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; HTTP 首部字段HTTP 协议的请求和响应报文中必定包含 HTTP 首部，只是我们平时在使用 Web 的过程中感受不到它，我们先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富，首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息，使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容 首部字段结构HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号 : 分隔，另外字段值对应单个 HTTP 首部字段可以有多个值，例如在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的对象类型 1Content -Type: text/html 另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示 1keep-alive: timeout=15, max-100 但是这里可能存在一个问题，那就是当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样呢？其实对于这种情况，在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致，有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段 首部字段类型HTTP 首部字段根据实际用途被分为以下四种类型 类型 描述 通用首部字段 请求报文和响应报文两方都会使用的首部 请求首部字段 从客户端向服务器端发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息 响应首部字段 从服务器端向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段 针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的的信息 另外还有单独为 Cookie 服务的首部字段和一些其他的首部字段，下面我们将会一一来进行介绍 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部，它们有以下这些 首部字段名 说明 Cache-Control 控制缓存的行为，用于随报文传送缓存指示 Connection 逐挑首部、连接的管理，允许客户端和服务器指定与 请求/响应 连接有关的选项 Date 提供了日期的时间标志，说明报文是什么时间创建的 Pragma 报文指令，另一种随报文传送指示的方式，但并不专用缓存 Trailer 报文末端的首部一览，如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂部分的首部集合 Transfer-Encoding 指定报文主体的传输编码方式，告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 Upgrade 给出了发送端可能想要升级使用的新版本或协议 Via 显示了报文经过的中间节点（代理、网关） Warning 错误通知 Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制，指令的参数是可选的，多个指令之间通过 ,（逗号） 分隔，如下 1Cache-Control: private, max-age = 0, no-cache 可用的指令按请求和响应分为两种，缓存请求指令如下所示 缓存请求指令 参数 说明 no-cache 无 强制向服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [s] 必需 响应的最大 Age 值 max-stale( =[s]) 可省略 接收已过期的响应 min-fresh = [s] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记（Token） 缓存响应指令如下所示 缓存响应指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age = [s] 必需 响应的最大 Age 值 s-maxage = [s] 必需 公共缓存服务器响应的最大 Age 值 cache-extension - 新指令标记（Token） 下面我们就先来看几个其中用来表示能否缓存的指令，它们有下面这几个 1Cache-Control: public 当指定使用 public 指令时，则明确表明其他用户也可利用缓存 1Cache-Control: private 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反，缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存 1Cache-Control: no-cache 使用 no-cache 指令是为了防止从缓存中返回过期的资源 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应，于是缓存服务器必须把客户端请求转发给源服务器 如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存，源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作 1Cache-Control: no-cache = Location 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存，换言之，无参数值的首部字段可以使用缓存，这里需要注意的是只能在响应指令中指定该参数 1Cache-Control: no-store 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息，因此该指令规定缓存不能在本地存储请求或响应的任一部分，这里需要注意的是，no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源，no-store 指令才是真正的不进行缓存 看完了能否缓存的指令，我们再来看看指定缓存期限和认证的指令 1Cache-Control: s-maxage = 604800（单位为秒） s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理），也就是说对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用 另外当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理 1Cache-Control: max-age = 604800（单位为秒） 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源，另外当指定 max-age 的值为 0，那么缓存服务器通常需要将请求转发给源服务器 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间，应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段，而 HTTP/1.0 版本的缓存服务器则相反 1Cache-Control: min-fresh = 60（单位为秒） min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源，比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了 1Cache-Control: max-stale = 3600（单位为秒） 使用 max-stale 可指示缓存资源，即使过期也照常接收，如果指令未指定参数值，那么无论经过多久，客户端都会接收响应，如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收 1Cache-Control: only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回，换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性 1Cache-Control: must-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效，另外使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用 max-stale） 1Cache-Control: proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 1Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型，这样做可防止缓存或代理压缩图片等类似操作 最后我们再来看一个 Cache-Control 扩展 1Cache-Control: private, community = \"UCI\" 通过 cache-extension 标记（Token），可以扩展 Cache-Control 首部字段内的指令，上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉 ConnectionConnection 首部字段具备以下两个作用 控制不再转发的首部字段 1Connection: Upgrade 在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即 Hop-by-hop 首部） 管理持久连接 1Connection: close HTTP/1.1 版本的默认连接都是持久连接，当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close 1Connection: keep-alive HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接，为此如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 keep-alive，那么我们为什么要使用 keep-alive 呢？ keep-alive 技术的创建目的，能在多次 HTTP 之前重用同一个 TCP 连接，从而减少 创建/关闭 多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），可以参考如下示意图 Date表明创建 HTTP 报文的日期和时间 1Date: Mon, 10 Jul 2019 15:50:06 GMT HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式 PragmaPragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义 1Pragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源，所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想 但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以发送的请求会同时包含 Cache-Control: no-cache 和 Pragma: no-cache Trailer1Trailer: Expires 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段，可应用在 HTTP/1.1 版本分块传输编码时 Transfer-Encoding1Transfer-Encoding: chunked 规定了传输报文主体时采用的编码方式，Transfer-Encoding 是一个用来标示 HTTP 报文传输格式的头部值，尽管这个取值理论上可以有很多，但是当前的 HTTP 规范里实际上只定义了一种传输取值，chunked 如果一个 HTTP 消息（请求消息或应答消息）的 Transfer-Encoding 消息头的值为 chunked，那么消息体由数量未定的块组成，并以最后一个大小为 0 的块为结束，每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个 CRLF（回车及换行），然后是数据本身，最后块 CRLF 结束，在一些实现中，块大小和 CRLF 之间填充有白空格（0x20） 最后一块是单行，由块大小（0），一些可选的填充白空格，以及 CRLF，最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段，消息最后以 CRLF 结尾，一个示例响应如下 12345678910HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Aand this is the second one0 几个需要注意的地方 chunked 和 multipart 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的，multipart 是一种 Content-Type，标示 HTTP 报文内容的类型，而 chunked 是一种传输格式，标示报头将以何种方式进行传输 chunked 传输不能事先知道内容的长度，只能靠最后的空 chunk 块来判断，因此对于下载请求来说，是没有办法实现进度的，在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用 chunked 方式进行下载 chunked 的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容，HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式（详细可见 Transfer-Encoding） Upgrade1Upgrade: TSL/1.0 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议 Via1Via: 1.1 a1.test.com(Squid/2.7) 为了追踪客户端和服务器端之间的请求和响应报文的传输路径，报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发，首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段内容 Warning该首部字段通常会告知用户一些与缓存相关的问题的警告，Warning 首部字段的格式如下，最后的日期时间可省略 1Warning：[警告码][警告的主机:端口号] \"[警告内容]\"([日期时间]) HTTP/1.1 中定义了七种警告，警告码对应的警告内容仅推荐参考，另外警告码具备扩展性，今后有可能追加新的警告码 警告码 警告内容 说明 110 Response is stale（响应已过期） 代理返回已过期的资源 111 Revalidation failed（再验证失败） 代理再验证资源有效性时失败（服务器无法到达等原因） 112 Disconnection operation（断开连接操作） 代理与互联网连接被故意切断 113 Heuristic expiration（试探性过期） 响应的试用期超过 24 小时（有效缓存的设定时间大于 24 小时的情况下） 199 Miscellaneous warning（杂项警告） 任意的警告内容 214 Transformation applied（使用了转换） 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning（持久杂项警告） 任意的警告内容 请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容 请求首部字段名 说明 Accept 用户代理可处理的媒体类型，也就是告诉服务器能够发送那些媒体类型 Accept-Charset 优先的字符集，也就是告诉服务器能够给发送那些字符集 Accept-Encoding 优先的内容编码，也就是告诉服务器能够发送那些编码方式 Accept-Language 优先的语言（自然语言），也就是告诉服务器能够发送那些语言 Authorization Web 认证信息，包含了客户端提供给服务器，以便对其自身进行认证的数据 Expect 期待服务器的特定行为，允许客户端列出某请求所要求的服务器行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag），如果实体标记与文档当前的实体标记相匹配，就获取这份文档 If-Modified-Since 比较资源的更新时间，除非在某个指定的日期之后资源被修改过，否则就限制这个请求 If-None-Match 比较实体标记（与 If-Macth 相反），如果提供的实体标记与当前文档的标记不相符，就获取文档 If-Range 资源未更新时发送实体 Byte 的范围请求，允许对文档的某个范围进行条件请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反），除非在某个指定日期之后资源没有被修改过，否则就限制这个请求 Max-Forwards 最大传输逐跳数，在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数，通常与 TRACE 方法一同使用 Proxy-Authorization 代理服务器要求客户端的认证信息，与 Authorization 首部相同，但这个首部是在与代理进行认证时使用的 Range 实体的字节范围请求，如果服务器支持范围请求，就请求资源的指定范围 Referer 提供了包含当前请求 URL 的文档的 URI TE 传输编码的优先级，告诉服务器可以使用那些扩展传输编码 User-Agent HTTP 客户端程序的信息，也就是将发起请求的应用程序名称告知服务器 Accept1Accept: text/html, application/xhtml+xml, application/xml; q = 0.5 Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级，可使用 type/subtype 这种形式，一次指定多种媒体类型 若想要给显示的媒体类型增加优先级，则使用 q = [数值] 来表示权重值，用分号（;）进行分隔，权重值的范围 0 ~ 1（可精确到小数点后三位），且 1 为最大值，不指定权重值时，默认为 1，当服务器提供多种内容时，将会首先返回权重值最高的媒体类型 Accept-Charset1Accept-Charset: iso-8859-5, unicode-1-1; q = 0.8 Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序，另外可一次性指定多种字符集，同样使用 q = [数值] 来表示相对优先级 Accept-Encoding1Accept-Encoding: gzip, deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码，同样使用 q = [数值] 来表示相对优先级，也可使用星号（*）作为通配符，指定任意的编码格式 Accept-Language1Accept-Lanuage: zh-cn, zh; q = 0.7, en = us, en; q = 0.3 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集，同样使用 q = [数值] 来表示相对优先级 Authorization1Authorization: Basic ldfKDHKfkDdasSAEdasd== 告知服务器用户代理的认证信息（证书值），通常想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中，共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异 Expect1Expect: 100-continue 告知服务器客户端期望出现的某种特定行为 From1From: test@email.com 告知服务器使用用户代理的电子邮件地址 Host1Host: www.test.com 告知服务器，请求的资源所处的互联网主机和端口号，Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段，因为请求被发送至服务器时，如果在相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求，因此就需要使用首部字段 Host 来明确指出请求的主机名，若服务器未设定主机名，那直接发送一个空值即可 1Host: If-Match形如 If-xxx 这种样式的请求首部字段，都可称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求 1If-Match: \"123456\" 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值，这时的服务器无法使用弱 ETag 值，服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时才会执行请求，反之则返回状态码 412 Precondition Failed 的响应 另外还可以使用星号（*）指定 If-Match 的字段值，针对这种情况服务器将会忽略 ETag 的值，只要资源存在就处理请求 If-Modified-Since1If-Modified-Since: Mon, 10 Jul 2019 15:50:06 GMT 首部字段 If-Modified-Since 属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求，而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应 If-None-Match1If-None-Match: \"123456\" 首部字段 If-None-Match 属于附带条件之一，它和首部字段 If-Match 作用相反，用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求，也就是只有在 If-None-Match 的字段值与 ETag 值不一致时，才处理该请求 If-Range1If-Range: \"123456\" 首部字段 If-Range 属于附带条件之一，它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理，反之则返回全体资源 我们可以思考一下不使用首部字段 If-Range 发送请求的情况，服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然范围请求作为前提是无效的，这时服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求，这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫 If-Unmodified-Since1If-Unmodified-Since: Mon, 10 Jul 2019 15:50:06 GMT 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反，它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求，如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回 Max-Forwards1Max-Forwards: 10 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目，服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值，当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应 Proxy-Authorization1Proxy-Authorization: Basic dGlwOjkpNLAGfFY5 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息，这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于认证行为发生在客户端与代理之间 Range1Range: bytes = 5001-10000 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围，接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应，无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源 Referer1Referer: http://www.test.com/index.html 首部字段 Referer 会告知服务器请求的原始资源的 URI TE1TE: gzip, deflate; q = 0.5 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级，它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码，首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式，应用后者时，只需把 trailers 赋值给该字段值 1TE: trailers User-Agent1User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/=20190101 Firefox/13.0.1 首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器，由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址，此外如果请求经过代理，那么中间也很可能被添加上代理服务器的名称 响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息 响应首部字段 说明 Accept-Ranges 是否接受字节范围请求，对此资源来说，服务器可接受的范围类型 Age 推算资源创建经过时间，（从最初创建开始）响应持续时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求，如果资源不可用的话，在此日期或时间重试 Server HTTP 服务器的安装信息，服务器应用程序软件的名称和版本 Vary 代理服务器缓存的管理信息，也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选处最合适的资源版本发送个客户端 WWW-Authenticate 服务器对客户端的认证信息 Accept-Ranges1Accept-Ranges: bytes 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源，可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none Age1Age: 600 首部字段 Age 能告知客户端，源服务器在多久前创建了响应，字段值的单位为秒，若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值，代理创建响应时必须加上首部字段 Age ETag1ETag: \"82e22293907ce725faf67773957acd12\" 首部字段 ETag 能告知客户端实体标识，它是一种可将资源以字符串形式做唯一性标识的方式，服务器会为每份资源分配对应的 ETag 值，另外当资源更新时，ETag 值也需要更新，生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配 ETag 中有强 ETag 值和弱 ETag 值之分，强 ETag 值，不论实体发生多么细微的变化都会改变其值 1ETag: \"usagi -1234\" 弱 ETag 值只用于提示资源是否相同，只有资源发生了根本改变，产生差异时才会改变 ETag 值，这时会在字段值最开始处附加 W/ 1ETag: W/\"usagi-1234\" Location1Location: http://www.test.com/index.html 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源，基本上该字段会配合 3xx: Redirection 的响应，提供重定向的 URI，几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问 Proxy-Authenticate1Proxy-Authenticate: Basic realm = \"Usagidesign Auth\" 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端，它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的 Retry-After1Retry-After: 120 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求，主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用，字段值可以指定为具体的日期时间（Mon, 10 Jul 2019 15:50:06 GMT 等格式），也可以是创建响应后的秒数 Server1Server: Apache/2.2.6 (Unix) PHP/5.2.5 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息，不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项 Vary1Vary: Accept-Language 首部字段 Vary 可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令，从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存，即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源 WWW-Authenticate1WWW-Authenticate: Basic realm = \"Usagidesign Auth\" 首部字段 WWW-Authenticate 用于 HTTP 访问认证，它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge） 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位为字节） Content-Location 替代对应资源的 URI Content-MD5 实体主体的 MD5 校验和 Content-Range 实体主体的位置范围，在整个资源中此实体表示的字节范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间，即实体不再有效，要从原始的源端再次获取此实体的日期和时间 Last-Modified 资源的最后修改日期时间 Allow1Allow: GET, HEAD 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法，当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回，与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回 Content-Encoding1Content-Encoding: gzip 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式，内容编码是指在不丢失实体信息的前提下所进行的压缩，主要采用下面这四种内容编码的方式 gzip，由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC） compress，由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW） deflate，组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式 identity，不执行压缩或不会变化的默认编码格式 Content-Language1Content-Language: zh-CN 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言） Content-Length1Content-Length: 15000 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节），对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段 Content-Location1Content-Location: http://www.sample.com/index.html 首部字段 Content-Location 给出与报文主体部分相对应的 URI，和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI Content-MD51Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY== 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达 Content-Range1Content-Range: bytes 5001-10000/10000 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求，字段值以字节为单位，表示当前发送部分及整个实体大小 Content-Type1Content-Type: text/html; charset=UTF-8 首部字段 Content-Type 说明了实体主体内对象的媒体类型，和首部字段 Accept 一样，字段值用 type/subtype 形式赋值，参数 charset 使用 iso-8859-1 等字符集进行赋值 Expires1Expires: Mon, 10 Jul 2019 15:50:06 GMT 首部字段 Expires 会将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存，当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值，但是当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令 Last-Modified1Last-Modified: Mon, 10 Jul 2019 15:50:06 GMT 首部字段 Last-Modified 指明资源最终修改的时间，一般来说这个值就是 Request-URI 指定资源被修改的时间，但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间 为 Cookie 服务的首部字段管理服务器与客户端之间状态的 Cookie，虽然没有被编人标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用，Cookie 的工作机制是用户识别及状态管理，Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写人用户的计算机内，接着当用户访问该 Web 网站时，可通过通信方式取回之前发放的 Cookie 调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的 Cookie 信息 响应首部字段 Cookie 服务器接收到的 Cookie 信息 请求首部字段 Set-Cookie1Set-Cookie: status=enable; expires=Mon, 10 Jul 2019 15:50:06 GMT; path=/; 下面的表格列举了 Set-Cookie 的字段值 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 expires 属性 Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期，当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内，这通常限于浏览器应用程序被关闭之前，另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法，但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作 path 属性 Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录 domain 属性 通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致，比如当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie，因此除了针对具体指定的多个域名发送 Cookie 之外，不指定 domain 属性显得更安全 secure 属性 1Set-Cookie: name=value; secure Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie，当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收 HttpOnly 属性 Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie，其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取 1Set-Cookie: name=value; HttpOnly 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作，但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了，因此也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了 Cookie1Cookie: status = enable 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie，接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送 其他首部字段HTTP 首部字段是可以自行扩展的，所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段，下面几个是比较常见的首部字段 X-Frame-Options1X-Frame-Options: DENY 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题，其主要目的是为了防止点击劫持（clickjacking）攻击，首部字段 X-Frame-Options 有以下两个可指定的字段值 DENY，拒绝 SAMEORIGIN，仅同源域名下的页面（Top-level-browsing-context）匹配时许可，（比如当指定 http://test.com/index.html 页面为 SAMEORIGIN 时，那么 test.com 上所有页面的 frame 都被允许可加载该页面，而其他域名的页面就不行了） X-XSS-Protection1X-XSS-Protection: 1 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关，首部字段 X-XSS-Protection 可指定的字段值如下 0，将 XSS 过滤设置成无效状态 1，将 XSS 过滤设置成有效状态 DNT1DNT: 1 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法，首部字段 DNT 可指定的字段值如下 0，同意被追踪 1，拒绝被追踪 由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT 做对应的支持 P3P1P3P: CP = \"CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND\" 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的，要进行 P3P 的设定，需按以下操作步骤进行 步骤 1，创建 P3P 隐私 步骤 2，创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml 步骤 3，从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中 HTTP 报文实体我们在之前的 HTTP 报文章节当中介绍了请求报文与响应报文相关内容，我们也了解了一些 HTTP 报文结构的相关内容，如下图 HTTP 报文实体概述我们在上面的示例当中可以了解到各个组成部分对应的内容，这里我们主要来看报文和实体的概念，如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物 报文，是网络中交换和传输的数据单元，即站点一次性要发送的数据块，报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变 实体，作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成（实体首部相关内容在上面第六点中已有阐述） 我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体，而左图中粉红框内容就是报文主体 通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异 内容编码HTTP 应用程序有时在发送之前需要对内容进行编码，例如在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间，服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容 这种类型的编码是在发送方应用到内容之上的，当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方，常见的内容编码类型有以下这几个 编码方式 描述 gzip 表明实体采用 GNU zip 编码 compress 表明实体采用 Unix 的文件压缩程序 deflate 表明实体采用 zlib 的格式压缩的 identity 表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式 传输编码在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码（ChunkedTransfer Coding） 分块编码分块编码把报文分割成若干已知大小的块，块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了，分块编码是一种传输编码，是报文的属性 若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止，当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送，如果服务器动态创建内容，就可能在发送之前无法知道主体的长度 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了，因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程，服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备，来看一个分块编码的报文示例 多部分媒体类型MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送，每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起，相应的 HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体，多部分对象集合包含的对象如下 multipart/form-data，在 Web 表单文件上传时使用 multipart/byteranges，状态码 206 Partial Content 响应报文包含了多个范围的内容时使用 在这里多提一点，就是关于 POST 请求，协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议中并没有规定数据必须使用什么编码方式，实际上开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以 服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析，所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分，下面是指定为几种类型后的区别 application/x-www-form-urlencoded这个也就是所谓的表单提交方式了，浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据，请求类似于下面这样 123456POST / HTTP/1.1Host: foo.comContent-Type: application/x-www-form-urlencodedContent-Length: 13say=Hi&amp;to=Mom 可以发现 Content-Type 被指定为 application/x-www-form-urlencoded，传递的是对应的 key 和 val multipart/form-data这种方式一般用来上传文件，也是一种常见的 POST 数据提交的方式，在我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data 123456789101112POST /test.html HTTP/1.1 Host: example.org Content-Type: multipart/form-data;boundary=\"boundary\" --boundary Content-Disposition: form-data; name=\"field1\" value1 --boundary Content-Disposition: form-data; name=\"field2\"; filename=\"example.txt\" value2 首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂，然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，指明本次请求的 boundary 是什么内容，消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制） 如果传输的是文件，还要包含文件名和文件类型信息，消息主体最后以 --boundary-- 标示结束，上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt; 表单 也只支持 这两种方式，通过 &lt;form&gt; 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded，其实 enctype 还支持 text/plain，不过用得比较少 application/jsonapplication/json 这个 Content-Type 一般用来告诉服务端消息主体是序列化后的 JSON 字符串，JSON 格式支持比键值对复杂得多的结构化数据，AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串 1234var data = { 'title': 'test', 'sub': [1, 2, 3] };$http.post(url, data).success(function (result) { // ...}); 最终发送的请求是 1234POST http://www.example.com http/1.1 Content-Type: application/json; charset = utf-8{ \"title\": \"test\", \"sub\": [1, 2, 3] }. 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口 text/xml这种方案现在一般使用较少，XML 作为编码方式的远程调用规范，典型的 XML-RPC 请求是这样的 123456789101112POST http://www.example.com http/1.1 Content-Type: text/xml&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; XML-RPC 协议简单、功能够用，各种语言的实现都有，JavaScript 中，也有类似 XML-RPC over AJAX 这样的库来支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务，不过，XML 结构过于臃肿，一般场景用 JSON 会更灵活方便 范围请求假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍，为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载，要实现该功能，这就要用到范围请求 有了范围请求，HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体，当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过，例如 1234GET /bigfile.html HTTP/1.1Host: www.test.comRange: bytes=20224-// ... 上面示例中，客户端请求的是文档开头 20224 字节之后的部分 内容协商同一个 Web 网站有可能存在着多份相同内容的页面，比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同，当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面，这样的机制称为内容协商（Content Negotiation） 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准，包含在请求报文中的某些首部字段就是判断的基准，比如以下这些 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 内容协商技术有以下三种类型， 类型 介绍 服务器驱动协商（Server-driven Negotiation） 由服务器端进行内容协商，以请求的首部字段为参考，在服务器端自动处理，但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容 客户端驱动协商（Agent-driven Negotiation） 由客户端进行内容协商的方式，用户从浏览器显示的可选项列表中手动选择，还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择，比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面 透明协商（Transparent Negotiation） 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法 HTTP 状态码HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作，状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误，比如状态码 200 OK ，以三位数字和原因短语组成，数字中的第一位指定了响应类别，后两位无分类，响应类别有以下五种 状态码 类别 原因短语 1xx Informational（信息性状态码） 代表请求已被接受，需要继续处理 2xx Success（成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码） 需要进行附加操作以完成请求（重定向之类） 4xx Client Error（客户端错误状态码） 服务器无法处理请求 5xx Server Error（服务器错误状态码） 服务器处理请求出错 其实只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题，又因为 HTTP 状态码种类繁多，数量达几十种，但是比较常用的有以下这些，所以我们下面主要来看这些具有代表性质的状态码 2xx 成功，该响应结果表明请求被正常处理了 200 OK，表示从客户端发来的请求在服务器端被正常处理了 204 No Content，代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，另外也不允许返回任何实体的主体，一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用 206 Partial Content，表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 首部字段指定范围的实体内容 3xx 重定向，表明浏览器需要执行某些特殊的处理以正确处理请求 301 Moved Permanently，永久性重定向，可以简单地理解为该资源已经被永久改变了位置，通常会发送 HTTP Location 来 重定向 到正确的新位置 302 Found，临时性重定向，表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问，和 301 Moved Permanently 状态码相似，但 302 Found 状态码代表资源不是被永久移动，只是临时性质的，换句话说，已移动的资源对应的 URI 将来还有可能发生改变 303 See Other，表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源，303 See Other 和 302 Found 状态码有着相同的功能，但 303 See Other 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 Found 状态码有区别（当 301/302/303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送，本质上 301/302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做） 304 Not Modified，未修改，自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，也就是说当访问资源出现 304 访问的情况下其实就是浏览器先在本地缓存了访问的资源，然后直接返回了缓存的资源，这里涉及到了请求头中的两个请求参数 If-Modified-Since 和 If-None-Match，详细可见上方的 HTTP 首部字段章节 307 Temporary Redirect，临时重定向，该状态码与 302 Found 有着相同的含义，尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守，307 会遵照浏览器标准，不会从 POST 变成 GET，但是对于处理响应时的行为，每种浏览器有可能出现不同的情况 4xx 客户端错误，表明客户端是发生错误的原因所在 400 Bad Request，错误请求，服务器不理解请求的语法，常见于客户端传参错误 401 Unauthorized，未授权，表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息，常见于客户端未登录 403 Forbidden，禁止访问，表明对请求资源的访问被服务器拒绝了，常见于客户端权限不足，未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因 404 Not Found，未找到，服务器找不到对应资源，除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过 Options 方法来查看服务器允许的访问方法（Access-Control-Allow-Methods） 5xx 服务器错误，结果表明服务器本身发生错误 500 Inter Server Error，表明服务器端在执行请求时发生了错误，无法完成请求，也可能是 Web 应用存在的某些临时的故障 501 Not Implemented，尚未实施，服务器不具备完成请求的功能 502 Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应 503 service unavailable，服务不可用，服务器目前无法使用（处于超载或停机维护状态）通常是暂时状态 这里需要注意一点，不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到 结构组件（代理、网关、隧道、缓存）HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道等，它们可以配合服务器工作，这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端 代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器，代理不改变请求 URI，会直接发送给前方持有资源的目标服务器，持有资源实体的服务器被称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端 在 HTTP 通信过程中，可级联多台代理服务器，请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器，转发时需要附加 Via 首部字段以标记出经过的主机信息，使用代理服务器可以利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等 代理有多种使用方法，按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文 缓存代理，代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上，当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回 透明代理，转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy），反之对报文内容进行加工的代理被称为非透明代理 网关 网关是一种特殊的服务器，作为其他服务器的中间实体使用，网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非 HTTP 协议服务，利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全，比如网关可以连接数据库，使用 SQL 语句查询数据，另外在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动 隧道 隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全的通信，隧道本身不会去解析 HTTP 请求，也就是说，请求保持原样中转给之后的服务器，隧道会在通信双方断开连接时结束 HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了 缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间，缓存服务器是代理服务器的一种，并归类在缓存代理类型中，换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本 缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源，因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了 缓存的有效期限即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求，因为这关系到被缓存资源的有效性问题，当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的旧资源了，即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性，若判断缓存失效，缓存服务器将会再次从源服务器上获取新资源 客户端的缓存缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中，浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取，另外和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源 更多关于浏览器缓存机制的相关内容，可以参考之前整理过的 浏览器缓存机制 了解更多，其实主要依赖的还是 Cache-Control，max-age，Expires 等一些头字段 HTTPS在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题 HTTP 的缺点到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而 HTTP 并非只有好的一面，事物皆具两面性，它也是有不足之处的，HTTP 主要有这些不足 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题，为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制，我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure） HTTPS 并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已，通常 HTTP 直接和 TCP 通信，当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了，简言之所谓的 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP HTTPS 是如何进行加密的更多关于 HTTPS 的详细内容，我们在之前已经详细的梳理过一次，详细可见 HTTPS 是如何进行加密的，主要包括什么是 HTTPS，为什么 HTTPS 会更安全，它的整套流程又是如何实现的等相关内容 HTTP 加密 多个客户端 对称加密秘钥如何传输 非对称加密 第三方认证 为什么要有签名 用户认证我们在之前的 Cookie、Session、Token 与 JWT 章节当中简单的介绍过认证，授权和凭证相关内容，在这里我们就稍微的深入的了解一下 HTTP 当中使用的认证方式，主要有下面这些 BASIC 认证（基本认证） DIGEST 认证（摘要认证） SSL 客户端认证 FormBase 认证（基于表单认证） 此外，还有 Windows 统一认证（Keberos 认证、NTLM 认证），但是在这里我们就不深入展开了，想了解更多可以自行查阅相关内容了解更多 BASIC 认证BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式，即便是现在仍有一部分的网站会使用这种认证方式，是 Web 服务器与通信客户端之间进行的认证方式，步骤如下 步骤一，当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应，该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm） 步骤二，接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器，发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理 步骤三，接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证，如验证通过，则返回一条包含 Request-URI 资源的响应 BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理，不需要任何附加信息即可对其解码，换言之由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高，另外除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一，BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用 DIGEST 认证为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证，DIGEST 认证同样使用 质询/响应 的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码 所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码，最后将响应码返回给对方进行认证的方式，因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了 DIGEST 认证的步骤如下 步骤一，请求需认证的资源时，服务器会随着状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应，该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce） 首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息，客户端就是依靠向服务器回送这两个值进行认证的 nonce 是一种每次随返回的 401 响应生成的任意随机字符串，该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现 步骤二，接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息，首部字段 Authorization 内必须包含 username，realm，nonce uri 和 response 的字段信息，其中 realm 和 nonce 就是之前从服务器接收到的响应中的字段 username 是 realm 限定范围内可进行认证的用户名 uri（digest-uri）即 Request-URI 的值，但考虑到经代理转发后 Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri 内 response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码 步骤三，接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性，认证通过后则返回包含 Request-URI 资源的响应，并且这时会在首部字段 Authentication-Info 写人一些认证成功的相关信息 DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱，DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制，DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准，因此它的适用范围也有所受限 SSL 客户端认证从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为，但如果用户 ID 和密码被盗，就很有可能被第三者冒充，利用 SSL 客户端认证则可以避免该情况的发生，SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式，凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端，SSL 客户端认证的步骤如下 为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书 步骤一，接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书 步骤二，用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Crtificate 报文方式发送给服务器 步骤三，服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信 在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用，所谓双因素认证就是指认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式 换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为，通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器 基于表单认证基于表单的认证方法并不是在 HTTP 协议中定义的，客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证，多数情况下，输人已事先登录的用户 ID 和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功 由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用，另外 SSL 客户端认证虽然具有高度的安全等级，但也存在着因为导入及维持费用等问题，不具备共同标准规范的表单认证，在每个 Web 网站上都会有各不相同的实现方式，如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级，但在表单认证的实现中存在问题的 Web 网站也是屡见不鲜 Cookie 与 Session这部分内容我们在 Cookie、Session、Token 与 JWT 当中已经介绍的很详细了，所以这里也就不详细展开了 追加协议虽然 HTTP 协议既简单又简捷，但随着时代的发展，其功能使用上捉襟见肘的疲态已经凸显，本章我们就来看看基于 HTTP 新增的功能的协议 SPDYSPDY 是 Google 开发的基于 TCP 的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验，SPDY 并不是一种用于替代 HTTP 的协议，而是对 HTTP 协议的增强，新协议的功能包括数据流的多路复用、请求优先级以及 HTTP 报头压缩 SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，同时考虑到安全性问题，SPDY 规定通信中使用 SSL，SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接，因此可照常使用 HTTP 的 GET 和 POST 等方法、Cookie 以及 HTTP 报文等 使用 SPDY 后，HTTP 协议额外获得以下功能 多路复用流，通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求，所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高 赋予请求优先级，SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序，这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题 压缩 HTTP 首部，压缩 HTTP 请求和响应的首部，这样一来通信产生的数据包数量和发送的字节数就更少了 推送功能，支持服务器主动向客户端推送数据的功能，这样服务器可直接发送数据，而不必等待客户端的请求 服务器提示功能，服务器可以主动提示客户端请求所需的资源，由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求 SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致，对 Web 本身的速度提升，还应该从其他可细致钻研的地方人手，比如改善 Web 内容的编写方式等 WebSocketWebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准，其中 WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准，WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题 一且 Web 服务器与客户端之间建立起 WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行，通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据，由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文 WebSocket协议的主要特点有以下这些 推送功能，支持由服务器向客户端推送数据的推送功能，这样服务器可直接发送数据，而不必等待客户端的请求 减少通信量，只要建立起 WebSocket 连接，就希望一直保持连接状态，和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了 一个实际的使用方式可以参考 在 Angular 当中使用 WebSocket WebDAVWebDAV（Web-based Distributed Authoring and Versioning）是一种基于 HTTP/1.1 协议的通信协议，它扩展了 HTTP/1.1，在 GET、POST、HEAD 等几个 HTTP 标准方法以外添加了一些新的方法，使应用程序可对 Web Server 直接读写，并支持写文件锁定（Locking）及解锁（Unlock），还可以支持文件的版本控制 针对服务器上的资源，WebDAV 新增加了一些概念 集合（Collection）是一种统一管理多个资源的概念，以集合为单位可进行各种操作，也可实现类似集合的集合这样的叠加 资源（Resource）把文件或集合称为资源 属性（Property）定义资源的属性，定义以键值对的格式执行 锁（Lock）把文件设置成无法编辑状态，多人同时编辑时，可防止在同一时间进行内容写入 WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法 PROPFIND，获取属性 PROPPATCH，修改属性 MKCOL，创建集合 COPY，复制资源及属性 MOVE，移动资源 LOCK，资源加锁 UNLOCK，资源解锁 为配合扩展的方法，状态码也随之扩展 102 Processing，可正常处理请求，但目前是处理中状态 207 Multi-Status，存在多种状态 422 Unprocessible Entit，格式正确，内容有误 423 Locked，资源已被加锁 424 Failed Dependency，处理与某请求关联的请求失败，因此不再维持依赖关系 507 Insufficient Storage，保存空间不足 HTTP/2因为内容较多，所以另外单开一章进行梳理，详细可见 HTTP/2，内容包括 HTTP/2 的前身 HTTP 应用场景 带宽和延迟 解决队头阻塞 开拓者 SPDY HTTP/2 连接 帧 帧大小/帧格式/帧定义 流 流的生命周期 流的状态 流的标识符 连接、流和帧的关系 消息/流量控制/请求优先级 HTTP/2 主要改动 多路复用 首部压缩（Header Compression） 服务端推送（Server Push） HTTP/3同 HTTP/2 类似，内容也较多，所以另外单开一章进行梳理，详细可见 HTTP/3，内容包括 RTT HTTP/1.x HTTP/2 HTTP/3 QUIC 协议 零 RTT 建立连接 连接迁移 队头阻塞/多路复用 拥塞控制 流量控制 安全简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象，应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标，对 Web 应用的攻击模式有以下两种 以服务器为目标的主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传人的攻击模式，由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源，主动攻击模式里具有代表性的攻击是 SQL 注人攻击和 OS 命令注人攻击 以服务器为目标的被动攻击（passive atack）是指利用圈套策略执行攻击代码的攻击模式，在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击，被动攻击通常的攻击模式如下所示 步骤一，攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌人攻击代码的 HTTP 请求 步骤二，当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱 步骤三，中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码 步骤四，执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果，被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造 因输出值转义不完全引发的安全漏洞实施 Web 应用的安全对策可大致分为以下两部分 客户端的验证 Web 应用端（服务器端）的验证 输入值验证 输出值转义 跨站脚本攻击跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击，动态创建的 HTML 部分有可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击，跨站脚本攻击有可能造成以下影响 利用虚假输入表单骗取用户个人信息 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求 显示伪造的文章或图片 SQL 注入攻击SQL 注人（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击，该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露 Web 应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加、删除等操作时，会使用 SQL 语句连接数据库进行特定的操作，如果在调用 SQL 语句的方式上存在疏漏，就有可能执行被恶意注人（Injection）非法 SQL 语句，SQL 注人攻击有可能会造成以下等影响 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务器业务关联的程序等 OS 命令注入攻击OS 命令注人攻击（OS CommandInjection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的，只要在能调用 Shell 函数的地方就有存在被攻击的风险，可以从 Web 应用中通过 Shell 来调用操作系统命令，倘若调用 Shell 时存在疏漏，就可以执行插人的非法 OS 命令 OS 命令注人攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序，也就是说，通过 OS 注人攻击可执行 OS 上安装着的各种程序 HTTP 首部注入攻击HTTP 首部注人攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，属于被动攻击模式，向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response Sliting Attack），如下所示，Web 应用有时会把从外部接收到的数值，赋给响应首部字段 Location 和 Set-Cookie（这里的 12345 就是插入值） 12Location: http://www.example.com/a.cgi?q=12345Set-Cookie: UID = 12345 HTTP 首部注人可能像这样，通过在某些响应首部字段需要处理输出值的地方，插入换行发动攻击，HTTP 首部注人攻击有可能会造成以下一些影响 设置任何 Cookie 信息 重定向至任意 URL 显示任意的主体（HTTP 响应截断攻击） HTTP 响应截断攻击HTTP 响应截断攻击是用在 HTTP 首部注人的一种攻击，攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送，利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的，这样的攻击叫做 HTTP 响应截断攻击，如下 1%0D%0A%0D%0A&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;之后，想要显示的网页内容&lt;!-- 在可能进行 HTTP 首部注人的环节，通过发送上面的字符串，返回结果得到以下这种响应 123Set-Cookie: UID = (%0D%0A: 换行符)(%0D%0A: 换行符)&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;之后，想要显示的网页内容&lt;!-- （原来页面对应的首部字段和主体部分全视为注释） 利用这个攻击，已触发陷阱的用户浏览器会显示伪造的 Web 页面，再让用户输入自己的个人信息等，可达到和跨站脚本攻击相同的效果 另外，滥用 HTTP/1.1 中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作，这种攻击称为缓存污染，使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的 Web 网页 邮件首部注入攻击邮件首部注人（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击，利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件 目录遍历攻击目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击，这种攻击有时也称为路径遍历（Path Traversal）攻击 通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用 ../ 等相对路径定位到 /etc/passed 等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到，这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件，固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限 远程文件包含漏洞远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读人时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击 这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能，但是该功能太危险，PHP 5.2.0 之后默认设定此功能无效，固然存在输出值转义的问题，但更应控制对任意文件名的指定 因设置或设计上的缺陷引发的安全漏洞因设置或设计上的缺陷引发的安全漏洞是指错误设置 Web 服务器，或是由设计上的一些问题引起的安全漏洞 强制浏览强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件，强制浏览有可能会造成以下一些影响 泄露顾客的个人信息等重要情报 泄露原本需要具有访问权限的用户才可查阅的信息内容 泄露未外连到外界的文件 对那些原本不愿公开的文件，为了保证安全会隐蔽其 URL，可一旦知道了那些 URL，也就意味着可浏览 URL 对应的文件，直接显示容易推测的文件名或文件目录索引时，通过某些方法可能会使 URL 产生泄露 不正确的错误消息处理不正确的错误消息处理（Eror Handling Vulnerability）的安全漏洞是指 Web 应用的错误信息内包含对攻击者有用的信息，与 Web 应用有关的主要错误信息如下所示 Web 应用抛出的错误消息 数据库等系统抛出的错误消息 Web 应用不必在用户的浏览画面上展现详细的错误消息，对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示 开放重定向开放重定向（OpenRedirect）是一种对指定的任意 URL 作重定向跳转的功能，而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站 因会话管理疏忽引发的安全漏洞会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果 会话劫持会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的，具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式，会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理，下面列举了几种攻击者可获得会话 ID 的途径 通过非正规的生成方法推测会话 ID 通过窃听或 XSS 攻击盗取会话 ID 通过会话固定攻击（Session Fixation）强行获取会话 ID 会话固定攻击对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击 跨站点请求伪造跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击，跨站点请求伪造有可能会造成以下等影响 利用已通过认证的用户权限更新设定信息等 利用已通过认证的用户权限购买商品 利用已通过认证的用户权限在留言板上发表言论 其他安全漏洞下面我们再来看一些不太常见的方式 密码破解密码破解攻击（Password Cracking）即算出密码，突破认证，攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），密码破解有以下两种手段 通过网络的密码试错 对 Web 应用提供的认证功能，通过网络尝试候选密码进行的一种攻击，主要有以下两种方式 穷举法（Brute-force Attack，又称暴力破解法）是指对所有密钥集合构成的密钥空间（Keyspace）进行穷举，即用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击 字典攻击是指利用事先收集好的候选密码（经过各种组合方式后存人字典），枚举字典中的密码，尝试通过认证的一种攻击手法 对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况） Web 应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加 salt 的手段对要保存的密码本身加密，那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式，从加密过的数据中导出明文通常有以下几种方法 通过穷举法（字典攻击进行类推），针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码 彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法等实际破解过程中缩短消耗时间的技巧，从彩虹表内搜索散列值就可以推导出对应的明文密码 拿到密钥，使用共享密钥加密方式对密码数据进行加密处理的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了 加密算法的漏洞考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法，而 Web 应用开发者独立实现的加密算法，想必尚未经过充分的验证，还是很有可能存在漏洞的 点击劫持点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上，然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段，这种行为又称为界面伪装（UI Redressing） 已设置陷阱的 Web 页面，表面上内容并无不妥，但早已埋入想让用户点击的链接，当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的 ifame 页面 DoS 攻击DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击，有时也叫做服务停止攻击或拒绝服务攻击，DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等，主要有以下两种 DoS 攻击方式 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态 通过攻击安全漏洞使服务停止 其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击 多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack），DDoS 攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板 后门程序后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能，利用后门程序就能够使用原本受限制的功能，通常的后门程序分为以下三种类型 开发阶段作为 Debug 调用的后门程序 开发者为了自身利益植入的后门程序 攻击者通过某种方法设置的后门程序 可通过监视进程和通信的状态发现被植人的后门程序，但设定在 Web 应用中的后门程序，由于和正常使用时区别不大，通常很难发现","link":"/2020/09/01/HTTP/10/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"}]}