{"pages":[{"title":"About","text":"待补充","link":"/about/index.html"}],"posts":[{"title":"依赖注入","text":"依赖注入是一种设计模式，先来看看为什么我们要使用这个模式 一个简单的 Person 类，依赖与 Id 和 Address 两个类 1234567891011121314151617181920class Id { static getId(type: string): Id { return new Id(); }}class Address { constructor(city, street) { }}class Person { id: Id; address: Address; constructor() { this.id = Id.getId('123'); this.address = new Address('北京', '北京') }} 在这种情况下，Person 显性的依赖于 Id 和 Address 两个类，需要知道 Id 和 Address 两个类的具体构成 下面来重构一下 123456789101112131415161718192021222324252627class Id { static getId(type: string): Id { return new Id(); }}class Address { constructor(city, street) { }}class Person { id: Id; address: Address; constructor(id: Id, address: Address) { this.id = id; this.address = address; }}// 在某个类当中调用的时候main() { const id = Id.getId('123'); const address = new Address('北京', '北京'); const person = new Person(id, address);} 这里存在一个小的问题，就是在 main() 方法中依然需要知道 Id 和 Address 两个类的具体构成 但是相对于之前的示例，依赖性不再是那么强烈 如果手动来进行解决的话，可以一级一级的往上推，直到入口函数当中统一处理 或者是依靠框架来帮助我们完成这样的任务 Angular 中依赖注入的实现原理在 Angular 的依赖注入中主要有三个概念 Injector 注入者，利用其提供的 API 去创建依赖的实例 Provider 告诉 Injector 如何去创建一个实例（构造这个对象） Object 创建好的对象，也就是当前所处的模块或者组件需要的依赖（某种类型的对象，依赖本身也是一种类型） 利用 Angular 来改写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import { Component, ReflectiveInjector, Inject } from '@angular/core';import { environment } from '../environments/environment';export class AppComponent { constructor() { // resolveAndCreate() 方法接收一个 provider 数组 // ReflectiveInjector 利用 resolveAndCreate() 方法会根据输入的一个 provider 数组来构建一个可以提供依赖性的池子 // 池子当中含有多个 provider 对象，该对象有两个属性 // 一个为 provide，可以简单的理解为 key，令牌等，作用是唯一性的一个标识 // 另外一个为类型，类型有多种，比如 useClass, useFactory 等 // 简单来说，池子的作用就是把在这个类中所有想使用的依赖都存放到里面 const injector = ReflectiveInjector.resolveAndCreate([ // 针对于 { provide: Person, useClass: Person }, 这种 useClass 可以直接简写为 // 可以直接使用类来去代替，因为本质上就是提供了这个类的构造，key/令牌 也是这个类的本身 Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 注入之后就可以来进行使用了，利用 injector 的 get() 方法来获取 Person 对象 const person = injector.get(Person) console.log(JSON.stringify(person)) }}class Id { static getId(type: string): Id { return new Id(); }}class Address { city: string; street: string; constructor(city, street) { this.city = city; this.street = street; }}// 依赖 Id 和 Address 两个类class Person { id: Id; address: Address; // 需要两个依赖性，一个是 Id，一个是 Address // 这里执行的流程就是会去上面的池子当中进行寻找 constructor(@Inject(Id) id, @Inject(Address) address) { this.id = id; this.address = address; }} 但是在大部分的情况下，其实我们并不需要显性的去手写这么一个 provider 对象 Angular 提供给了我们一些便利，我们可以利用这些便利来完成上面这样复杂的操作 在 Angular 中使用依赖注入来看看在项目当中真实状况下的 provider 123456789101112131415// 一个公共模块// 在 @NgModule 当中注入 BASE_CONFIG 这个静态变量@NgModule({ // ... providers: [ { provide: 'BASE_CONFIG', useValue: 'http://localhost:3000'} ]})// 使用import { Inject } from '@angular/core';constructor(@Inject('BASE_CONFIG') config) { console.log(config)} 我们在 Module 或者 Component 当中，只需要在 providers 数组当中提供这个 provide 对象 它便会自动的帮我们注册到 Inject 这个池子当中 所以在我们使用过程当中，只需要在 constructor 当中使用 @Inject() 注入进来即可 但是需要注意的一点就是，我们这样操作的话，在池子当中取的数据都是单例的 但是如果想要每次取的都是一个新的实例的话，比如之前的实例，只需在此基础上稍作调整，让其返回一个函数即可 12345678910111213141516171819202122232425export class AppComponent { constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { // 修改这里 return () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) const person = injector.get(Person) console.log(JSON.stringify(person)) }} 这是一种方式，另外一种方式就是利用父子传递的概念 12345678910111213141516171819202122232425262728constructor() { const injector = ReflectiveInjector.resolveAndCreate([ Person, { provide: Address, useFactory: () =&gt; { if (environment.production) { return new Address('北京', '北京') } else { return new Address('西藏', '拉萨') } } }, { provide: Id, useFactory: () =&gt; { return Id.getId('123') }} ]) // 创建一个子注入者，传入 Person // 这里有一点需要注意，在创建子注入者的时候，我们仅仅只传入了 Person，并没有传入 Id 和 Address // 这里的情况是 当在子池子中找不到的情况下就回去父池子当中进行查找 const childInjector = injector.resolveAndCreateChild([Person]) const personFromChild = childInjector.get(Person) const person = injector.get(Person) console.log(person === personFromChild) // false}","link":"/2018/10/14/Angular/02/"},{"title":"Angular 中的管道","text":"先来看看一些简单的使用场景 123456789&lt;p&gt;生日是 {{ birthday | data: 'yyyy-MM-dd' }}&lt;/p&gt;&lt;p&gt;圆周率为 {{ 3.14159265 | number: '1.2-2' }}&lt;/p&gt;&lt;p&gt;转为大写 {{ 'Angular' | uppercase }}&lt;/p&gt;&lt;p&gt;转为小写 {{ 'Angular' | lowercase }}&lt;/p&gt;&lt;p&gt;格式化 {{ { name: 'semlinker' } | json }}&lt;/p&gt; 管道参数管道可以接收任意数量的参数，使用方式是在管道名称后面添加 : 和参数值 如 number: '1.2-2' ，若需要传递多个参数则参数之间用冒号隔开 1&lt;p&gt;{{ 'semlinker' | slice:0:3 }}&lt;/p&gt; 管道链可以将多个管道连接在一起，组成管道链对数据进行处理 1&lt;p&gt;{{ 'semlinker' | slice:0:3 | uppercase }}&lt;/p&gt; 自定义管道管道是一个带有管道元数据装饰器的类，与组件和模块类似，就是一个简单的 TypeScript 类 通过 @pipe 装饰器来告诉 Angular 这是一个管道类，然后去实现 PipeTransform 接口即可 一个简单的管道，如果跟随参数，则返回和参数相乘的值，如果没有传递参数，则返回原值 123456789101112131415161718import { Pipe, PipeTransform } from '@angular/core';@Pipe({ name: 'formatNumber'})// 只需实现 PipeTransform 接口接口// 内部仅有一个 transform 方法export class TestPipe implements PipeTransform { transform(value: number, args?: number): any { if (!args) { args = 1; } return value * args; }} 然后使用也很简单 1&lt;div&gt;{{num | formatNumber: '2'}}&lt;/div&gt; 一个小技巧：在构造函数当中使用管道12345678910import { DatePipe } from '@angular/common';class MyService { constructor(private datePipe: DatePipe) {} transformDate(date) { this.datePipe.transform(myDate, 'yyyy-MM-dd'); }} AsyncPipe（异步管道）使用 AsyncPipe 可以直接在模版当中使用 Promise 和 Observable 对象 而不需要通过定义一个类的成员属性来存储返回的结果 两个例子，Promise 和 Observable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Promiseimport { Component } from '@angular/core';@Component({ selector: 'exe-promise-pipe', template: ` &lt;h4&gt;Promise with AsyncPipeComponent&lt;/h4&gt; &lt;p&gt;{{ promise | async }}&lt;/p&gt; `})export class PromiseAsyncPipeComponent { promise: Promise&lt;string&gt;; constructor() { this.promise = this.getPromise(); } getPromise(): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(`Promise with AsyncPipe complete!`); }, 2000); }); }}// Observablesimport { Component } from '@angular/core';import { Observable } from 'rxjs/Rx';@Component({ selector: 'exe-observable-pipe', template: ` &lt;h4&gt;Observable with AsyncPipe Component&lt;/h4&gt; &lt;p&gt;{{ observable | async }}&lt;/p&gt; `})export class ObservableAsyncPipeComponent { observable: Observable&lt;number&gt; constructor() { this.observable = this.getObservable(); } getObservable(): Observable&lt;number&gt; { return Observable .interval(1000) .take(10) .map(v =&gt; v * v); }} 两者的区别 Promise - 返回单个值，不可取消的 Observable - 随着时间的推移发出多个值，可以取消的，支持 map、filter、reduce 等操作符，延迟执行，当订阅的时候才会开始执行 AsyncPipe 会发送多次请求比如如下情况 12345678910@Component({ selector: 'exe-app', template: ` &lt;div&gt; &lt;p&gt;{{ (person$ | async)?.id }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.title }}&lt;/p&gt; &lt;p&gt;{{ (person$ | async)?.body }}&lt;/p&gt; &lt;/div&gt; `}) 几种解决办法 使用 share() 123// 使用 rxjs 中的共享操作符this.http.get(url) .map(res =&gt; res.json()).share() 使用 publishReplay() 但是页面当中如果有按钮存在的情况，再次请求同样的地址还是会发送请求，这时可以使用 publishReplay() 123456789101112131415constructor(private http: Http) { this.preparePersonInfo();}ngOnInit() { // 调用 connect() 方法的时候，将主动执行订阅操作 this.person$.connect();}// 调用 publishReplay() 方法后将返回一个 ConnectableObservable 对象preparePersonInfo() { this.person$ = this.http.get(url) .map(res =&gt; res.json()) .publishReplay()} 如果只需要从服务器获取数据并显示数据，可以使用 Promise 来修复 AsyncPipe 发送多次请求的问题 12this.person = this.http.get(url) .map(res =&gt; res.json()).toPromise() AsyncPipe 执行流程如下图","link":"/2018/11/11/Angular/04/"},{"title":":host 和 ::ng-deep","text":"这里会涉及到 Angular 的 ViewEncapsulation，即控制视图的封装模式，主要分为三种，原生 (Native)、仿真 (Emulated) 和无 (None) 三种 Native 模式：完全隔离，外面的样式无法影响组件，组件里面的样式也无法影响外面 Emulated 模式（默认值）：全局样式可以影响组件，但组件样式无法影响外层 None 意味着完全消除隔离特性，全局样式可以影响组件，组件样式也可以影响外层 这种情况下 Angular 不使用视图封装，会把 CSS 添加到全局样式中，而不会应用之前那些作用域规则、隔离和保护等 从本质上来说，这跟把组件的样式直接放进 HTML 是一样的 术语上来说就是 ViewEncapsulation 允许设置三个可选的值： ViewEncapsulation.Emulated - 无 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，使得组件的样式不受外部影响，这是 Angular 的默认设置 没有 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，使得组件的样式不受外部影响 虽然样式仍然是应用到整个 document，但 Angular 会为所在的类创建了一个 [_ngcontent-cmy-0] 选择器 ViewEncapsulation.Native - 使用原生的 Shadow DOM 特性 使用原生的 Shadow DOM 特性，Angular 会把组件按照浏览器支持的 Shadow DOM 形式渲染 ViewEncapsulation.None - 无 Shadow DOM，并且也无样式包装 即 没有 Shadow DOM，并且所有的样式都应用到整个 document，换句话说，组件的样式会受外界影响，可能被覆盖掉 唯一的区别在于 Shadow DOM，当然其作用是让组件的样式只进不出，换言之即组件内的样式不会影响到外部组件 三者的表现形成如下，假设基本模版为 12345@Component({ template: `&lt;h1&gt;test&lt;/h1&gt;`, styles: [`h1 { color: #f50; }`], encapsulation: ViewEncapsulation.Native}) 三种方式生成的分别为 Native1234#shadow-root (open) &lt;style&gt;h1 { color: #f50; }&lt;/style&gt; &lt;h1&gt;test&lt;/h1&gt; Emulated123&lt;style&gt;h1[_ngcontent-c0] { color: #f50; }&lt;/style&gt;&lt;h1 _ngcontent-c0&gt;test&lt;/h1&gt; None123&lt;style&gt;h1 { color: #f50; }&lt;/style&gt;&lt;h1&gt;test&lt;/h1&gt; 需要注意的是：Native 和 None 在内容是一样的，但其后者会影响至其他外部组件的 h1 元素 组件样式组件样式的封装模式取决于我们对 encapsulation 的配置，当然你可以了在 main.ts 时为所有组件统一设定一种行的模式，例如 1234// 使用 None 模式platformBrowserDynamic().bootstrapModule(AppModule, { defaultEncapsulation: ViewEncapsulation.None}) 虽然三种模式都有不同的风格，但对于一个组件而言，如果没有一很合理的使用风格在实际项目中会让我们很头疼，特别是当项目中同时在使用第三方组件库，情况会更为复杂 比如你在某一个组件当中添加了一个 class 样式 123.active-link { color: red;} 若组件设定为 None 模式，只要该组件出现过一次，并且在未来所有即使不再使用，那么这个样式也会得到保留，所有的添加了这个 class 的元素均会改变 反之，对于 Shadow 行为，它会为该组件创建一个额外的属性 _ngcontent-c1 来标识（不管是 Native、Emulated 本质是一样的）所设定的样式仅限于当前组件当中 而 Angular 中即采用 :host 来表示组件自身，所以前面的 CSS 样式可以调整为 123456789:host .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link[_ngcontent-c1] { color: red;} 然而我们会发现，对于第三方组件组件而言，.active-link 是其组件内部某个 HTML 元素的 class 而已，且它有自己的一套组件封装规则 但我们生成的 CSS 中包括了一个奇怪的字符 [_ngcontent-c1]，最终导致该组件样式无法改变内嵌的第三方组件内容的样式 在这种情况下，Angular 提供了一种对未来工具更好兼容性的命令 ::ng-deep 来强制样式允许侵入子组件 123456789:host ::ng-deep .active-link { color: red;}&lt;!-- 生成的样式为 --&gt;[_nghost-c1] .active-link { color: red;} 最终的结果就是这个样式只会在这个组件内部当中有效","link":"/2018/12/08/Angular/06/"},{"title":"动态加载已经声明的组件","text":"这里主要涉及到三个 API ViewChild 一个属性装饰器，用来从模版视图中获取对应的元素，可以通过模版变量获取，获取的时候可以通过 read 属性设置查询的条件，简单来说就是可以把视图转为不同的实例 ViewContainerRef 一个视图容器， 可以在上面创建、插入、删除组件等 ComponentFactoryResolver 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上 所以总结起来简单来说就是 特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询 然后使用 ComponentFactoryResolver 将已经声明但是未实例化的组件解析成可以动态加载的 component 再将此 component 呈现到之前的视图容器当中 一个简单的示例引用的是 Angular 组件基础内容 当中的示例 模版文件十分简洁，就是通过创建一个 #dyncomp 句柄，以便获得引用，详细可以参考上述链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 注意引入的内容，上文提到的所需的三个必须都要引入import { Component, OnInit, ViewChild, ViewContainerRef, ComponentFactoryResolver, ComponentRef } from '@angular/core';import { Child11Component } from './child11/child11.component';import { state } from '@angular/animations';@Component({ selector: 'dynamic-comp', templateUrl: './dynamic-comp.component.html', styleUrls: ['./dynamic-comp.component.scss']})export class DynamicCompComponent implements OnInit { // 这里引用模板里面定义的 dyncomp 容器标签 // 通过模版变量名来获取引用，然后可以通过 read 选项设置一个 ViewContainerRef // 最终在生命周期 ngAfterViewInit 之后便会获取此区域的一个 ViewContainerRef 实例 @ViewChild(\"dyncomp\", { read: ViewContainerRef }) dyncomp: ViewContainerRef; comp1: ComponentRef&lt;Child11Component&gt;; comp2: ComponentRef&lt;Child11Component&gt;; constructor( private resolver: ComponentFactoryResolver) { } ngOnInit() { } ngAfterContentInit() { console.log('动态创建组件的实例...'); // 这里是主要的加载组件函数 // 通过在 constructor 当中注入的 ComponentFactoryResolver 服务 // 调用其 resolveComponentFactory 来解析一个已经声明的组件并得到一个可动态加载的 componentFactory // 最后直接调用容器的 createComponent 函数将其解析出来的 componentFactory 动态的呈现到容器视图上 const childComp = this.resolver.resolveComponentFactory(Child11Component); this.comp1 = this.dyncomp.createComponent(childComp); // this.comp1.instance.title = '父层设置的新标题'; // this.comp1.instance.btnClick.subscribe((param) =&gt; { // console.log('---&gt;' + param); // }); // 可以创建多个组件实例出来 // let temp1 = this.dyncomp.createComponent(childComp); // temp1.instance.title = '第2个动态子组件'; // let temp2 = this.dyncomp.createComponent(childComp); // temp2.instance.title = '第3个动态子组件'; // let temp3 = this.dyncomp.createComponent(childComp); // temp3.instance.title = '第4个动态子组件'; // let temp4 = this.dyncomp.createComponent(childComp); // temp4.instance.title = '第5个动态子组件'; // let temp5 = this.dyncomp.createComponent(childComp); // temp5.instance.title = '第6个动态子组件'; /** * createComponent 方法可以调用很多次，会动态创建出多个组件实例 * 方法有第二个参数，表示组件渲染的顺序 */ this.comp2 = this.dyncomp.createComponent(childComp, 0); this.comp2.instance.title = '第二个子组件'; } public destoryChild(): void { this.comp1.destroy(); this.comp2.destroy(); }} 上面特别需要注意的一点就是，对于动态加载的组件必须要声明在特性模块的 entryComponents 中，如下所示 1234567891011121314151617// ...@NgModule({ declarations: [ AppComponent, DynamicCompComponent, Child11Component ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent], entryComponents: [Child11Component]})export class AppModule { } 也就是说对于此处声明的组件，Angular 都会创建一个 ComponentFactory 并将其存储在 ComponentFactoryResolve 中，也就是动态加载必须的步骤 动态创建模块的方式来加载动态创建的组件简单来说这种情况就是动态创建不存在的组件而不是已经声明的组件，在这种情况下就需要用到 Compiler 作用就是用于在运行的时候运行 Angular 编译器来创建 ComponentFactory 的服务，然后可以使用它来创建和呈现组件实例 我们知道，容器创建和呈现组件的函数需要一个 ComponentFactory，而 Compiler 能够在运行的时候动态创建一个 ComponentFactory 一个简单的示例 1234567891011121314151617181920212223242526272829303132333435363738// 首先引入 Compilerimport { Compiler } from '@angular/core';// ...// 然后在构造函数当中进行注入constructor( private cp: Compiler) {}// ...// 在创建的时候就不再是指定组件了而是模块// 容器的呈现还是一样，直接 createComponentthis.comp1 = this.dyncomp.createComponent(this.createModule());// 新增一个 createModule 函数createModule() { // 通过 Component 和 NgModule 修饰器动态创建新的组件和模块 @Component({ template: '动态组件' }) class DynamicCom {} @NgModule({ declarations: [ DynamicCom ] }) class DynamicModule { } // 然后调用 Compiler 的 compileModuleAndAllComponentsSync 方法获取一个新的 ComponentFactory return this.cp.compileModuleAndAllComponentsSync(DynamicModule).componentFactories .find(comFac =&gt; comFac.componentType === DynamicCom)} 一个引申开的问题，创建动态组件后，调用 componentRef.instance 不能更新界面数据在动态组件创建了以后，使用动态组件的实例 componentRef.instance 去改变动态组件的属性，比如 1componentRef.instance.name = '123' 界面上绑定的 属性不会更新，但是控制台输出发现其中的 name 已经变更 如果是在动态组件当中使用函数，可以改变 name 属性的值，并且 属性也是可是实时更新 但是如果使用的是 componentRef，这样数据实时更新就不会起作用了 两种解决方法，一种是使用 setTimeout，可以解决问题，但是并不怎么优雅 1234567891011121314151617181920212223242526272829303132@Component({ template: ` 我是测试模板 {{data}} `})export class CustomComponent implements OnInit { @Input() public data: string; public ngOnInit() { console.log(this.data); setTimeout(() =&gt; { console.log(this.data); }, 3000); }}// ----------------------------export class HomeComponent implements OnInit { constructor( private viewContainerRef: ViewContainerRef, private cfr: ComponentFactoryResolver ) { } public ngOnInit() { let factory = this.cfr.resolveComponentFactory(CustomComponent); let componentRef = this.viewContainerRef.createComponent(factory); componentRef.instance.data = 'hello'; setTimeout(() =&gt; { componentRef.instance.data = 'bye'; }, 2000); }} 第二种解决方式可以采用官方提供的 changeDetectorRef.markForCheck() 来解决这个问题 详细见 ChangeDetectorRef","link":"/2019/03/12/Angular/08/"},{"title":"清除浮动之 clearfix 的原理和方法","text":"CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列 Float 往往是用于图像，但它在布局时一样非常有用 元素的水平方向浮动，意味着元素只能左右移动而不能上下移动 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止 浮动元素之后的元素将围绕它 浮动元素之前的元素将不会受到影响 1. 问题的由来有这样一种情形：在一个容器（container）中，有两个浮动的子元素 1234&lt;div&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 在浏览器中一运行，就会出现意想不到的结果，实际视图是子元素显示在父容器的外部 2. 问题的原因与浮动定位有关在 CSS 规范中，浮动定位 不属于 正常的页面流（page flow），是 独立定位 的，所以，只含有浮动元素的父容器，在显示时不考虑子元素的位置，就当它们不存在一样 这就造成了显示出来，父容器好像空容器一样 3. 解决方法一：添加空元素经典的解决方法，就是在浮动元素下方添加一个非浮动元素 12345&lt;div&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 原理是父容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了，这种方法比较简单，但是要在页面中增加冗余标签，违背了语义的原则 4. 解决方法二：浮动的父容器另一种思路是，索性将父容器也改成浮动定位，这样它就可以带着子元素一起浮动了 1234&lt;div style=\"float:left;\"&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种方法不用修改 html 代码，但是缺点在于父容器变成浮动以后，会影响到后面元素的定位，而且有时候，父容器是定位死的，无法变成浮动 5. 解决方法三：浮动元素的自动 clearing让父容器变得可以自动”清理”（clearing）子元素的浮动，从而能够识别出浮动子元素的位置，不会出现显示上的差错 要做到这点，只要为父容器加上一条 'overflow: hidden' 的 CSS 语句就行了 至于为什么加上 'overflow: hidden' 就可以解决此类问题，可以参考 块格式化上下文| MDN 1234&lt;div style=\"overflow: hidden;\"&gt; &lt;div style=\"float:left;width:45%;\"&gt;&lt;/div&gt; &lt;div style=\"float:right;width:45%;\"&gt;&lt;/div&gt;&lt;/div&gt; 这种方法的缺点主要有二个，一个是 IE6 不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题 6. 解决方法四：能不能通过 CSS 语句添加子元素呢，这样就不用修改 HTML 代码了答案是可以的，我们知道 CSS 语句中有一个 :after 伪选择符，就可以在父容器的尾部自动创建一个子元素，这正好符合我们的需要 下面的代码参照了 lifesinger 的写法 123456.clearfix:after { content: \"\"; display: block; height: 0; clear: both;} 'clearfix' 是父容器的 class 名称 content: ''; 是在父容器的结尾处放一个空白字符 &quot;height: 0;&quot; 是让这个这个空白字符不显示出来 &quot;display: block; clear: both;&quot; 是确保这个空白字符是非浮动的独立区块 需要注意：:after 选择符 IE6 不支持，也就是说上面的这段代码在 IE6 中无效，这怎么办？ 我们添加一条 IE6 的独有命令 'zoom: 1;' 就行了，这条命令的作用是激活父元素的 'hasLayout' 属性，让父元素拥有自己的布局，IE6 会读取这条命令，其他浏览器则会直接忽略它 7. 最终代码12345678910.clearfix:after { content: ''; display: block; height: 0; clear: both;}.clearfix { zoom: 1;} 8. 附录 什么是 hasLayoutIE 使用 Layout 概念来控制元素的尺寸和位置，如果一个元素有 Layout，它就有自身的尺寸和位置，如果没有，它的尺寸和位置由最近的拥有布局的祖先元素控制 12345678910111213141516171819202122232425在默认情况下，拥有 Layout 的元素包括：&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt;（注意，&lt;p&gt; 和 &lt;div&gt; 默认不拥有 Layout）凡是具有以下 CSS 属性的元素，也会拥有布局--------float: left|rightdisplay: inline-blockwidth: any value other than 'auto'height: any value other than 'auto'zoom: any value other than 'normal' （IE 专用属性）writing-mode: tb-rl（IE 专用属性）overflow: hidden|scroll|auto（只对 IE7 及以上版本有效）overflow-x|-y: hidden|scroll|auto（只对 IE7 及以上版本有效） hasLayout 是 IE 特有的属性，不是 CSS 属性，可以用 Javascript 函数 hasLayout 查看一个元素是否拥有 Layout 如果有，这个函数就返回 true，否则返回 false，hasLayout 是一个只读属性，所以无法使用 Javascript 进行设置 参考： 浮动原理","link":"/2016/11/09/CSS/01/"},{"title":"CSS 单行，多行溢出隐藏","text":"单行，多行溢出隐藏在 Web 开发过程中是一个十分常见的需求 在 WebKit 浏览器或移动端（绝大部分是 WebKit 内核的浏览器）的页面实现比较简单，可以直接使用 WebKit 的 CSS 扩展属性(WebKit 是私有属性) 1-webkit-line-clamp 但是需要注意的是，这是一个不规范的属性（unsupported WebKit property），它并没有出现在 CSS 规范草案中 -webkit-line-clamp 用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性 常见结合属性有以下几种 display: -webkit-box 必须结合的属性，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 text-overflow: ellipsis 可以用来多行文本的情况下，用省略号 '...' 隐藏超出范围的文本 一般多行溢出常用的代码如下： 1234567p { overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;} 修改一下就可以实现单行溢出隐藏 123456p { text-overflow: ellipsis; overflow: hidden; word-break: break-all; white-space: normal;} 或者使用 jQuery 来做限制： 1234567891011121314151617181920212223242526272829303132333435363738394041/* 自动获取 css 宽度进行处理，如果 css 中未对 .test1 给定宽度，则不起作用 $('.test1').wordLimit(); 截取字符数，值为大于 0 的整数，这里表示 class 为 test2 的标签内字符数最多 24 个 $('.test2').wordLimit(24);*/(function ($) { $.fn.wordLimit = function (num) { this.each(function () { if (!num) { var copyThis = $(this.cloneNode(true)).hide().css({ 'position': 'absolute', 'width': 'auto', 'overflow': 'visible' }); $(this).after(copyThis); if (copyThis.width() &gt; $(this).width()) { $(this).text($(this).text().substring(0, $(this).text().length - 4)); $(this).html($(this).html() + '...'); copyThis.remove(); $(this).wordLimit(); } else { // 清除复制 copyThis.remove(); return; } } else { var maxwidth = num; if ($(this).text().length &gt; maxwidth) { $(this).text($(this).text().substring(0, maxwidth)); $(this).html($(this).html() + '...'); } } }); }})(jQuery);","link":"/2016/12/02/CSS/02/"},{"title":"伪类与伪元素","text":"先来看看官方的定义，伪元素和伪类 CSS 引入伪类和伪元素概念是为了格式化文档树以外的信息，也就是说，伪类和伪元素是用来修饰不在文档树中的部分，两者的区别如下 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的 比如说，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态 伪元素用于创建一些不在文档树中的元素，并为其添加样式 比如说，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式，虽然用户可以看到这些文本，但是这些文本实际上不在文档树中 简单的总结就是，伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素，两者的区别在于：有没有创建一个文档树之外的元素 伪元素是使用单冒号还是双冒号？CSS3 规范中的要求使用双冒号（::）表示伪元素，以此来区分伪元素和伪类，比如 ::before 和 ::after 等伪元素使用双冒号（::），:hover 和 :active 等伪类使用单冒号（:） 除了一些低于 IE8 版本的浏览器外，大部分浏览器都支持伪元素的双冒号（::）表示方法 然而，除了少部分伪元素，如 ::backdrop 必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法，比如 ::after，写成 :after 也可以正确运行 所以对于伪元素是使用单冒号还是双冒号的问题，可以参考 MDN 大概的意思就是：虽然 CSS3 标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法（为了向后兼容，建议你在目前还是使用单冒号的写法） 实际上，伪元素使用单冒号还是双冒号很难说得清谁对谁错，你可以按照个人的喜好来选择某一种写法 如何获取并修改伪元素的值这里主要涉及 ::before 和 ::after，其余几个伪元素（::first-letter、::first-line、::selection 等）由于没有 content 属性，所以一笔带过，本质上是一样的 获取伪元素的属性值由于 JavaScript 里没有可以直接操作伪元素的选择符，但是可以通过获取其 CSS 属性的方法来达到目的 这里可以利用 window.getComputedStyle 方法选择到伪元素，然后利用 getPropertyValue 方法获取对应的属性的值 1window.getComputedStyle(element[, pseudoElt]); 此方法包含两个参数，一个是元素本身另一个是元素的伪元素 1234var div = document.querySelector('div');// 获取 before 伪元素的字号大小（获取的时候使用 : 或者 :: 都是可以的）var fontSize = window.getComputedStyle(div, '::before').getPropertyValue('content'); 更改伪元素的属性值虽然上面的方法可以获取到伪元素的属性值，但是却无法更改，如果使用 JavaScript 来更改伪元素属性值的话，这里主要介绍下面两种方法 更改 data-* 属性值来更改伪元素的 content 值data-* 是 HTML5 新增的 DOM 元素属性，作用大致可以理解为标记，伪元素的 content 属性值除了常规赋值外，还有一种特殊的 attr() 方法来获取 1234567&lt;div class=\"test\" data-text=\"AAA\" data-color=\"red\"&gt;&lt;/div&gt;// CSS.test::before { content: attr(data-text); // AAA} 另外 content 其实可以多个 attr 连写，而且 attr() 内的可以是 DOM 元素的任意属性（比如 class 等，甚至非 W3C 标准属性也支持，不过不推荐这么做） 1234/* 注意用空格连接，不要用 + 号拼接 */.test::before { content: '类名是' attr(class) '颜色是' attr(data-color);} 需要注意，目前只有 content 属性支持这个方法 创建多个 class，通过切换 class 来达到改变样式的目的这个方法的优点是简单好用且无兼容性问题，缺点是多了一些其实用处不大的 class 参考： Attribute References: attr() Pseudo-elements and pseudo-classes 总结伪类与伪元素","link":"/2016/12/25/CSS/03/"},{"title":"输入网址到页面显示经历的过程","text":"总的来说大概就三个流程 1）http 客户端发起请求，创建端口 2）http 服务器在端口监听客户端的请求 3）http 服务器向客户端返回状态和内容 我们下面就来看看，以 Chrome 浏览器搜索 baidu 为例，当在浏览器内输入一个 www.baidu.com 以后，到底发生了什么 第 1 步 搜索自身的 DNS 缓存浏览器会搜索自身的 DNS 缓存，看看自身的缓存中有没有 baidu.com 这个域名已经缓存的地址，这个缓存的时间大概只有一分钟，有没有失效可以通过 chrome://net-internals/#dns 来查看浏览过的网站的 DNS 缓存 第 2 步 搜索操作系统的 DNS 缓存如果浏览器没有找到缓存，或者说这个缓存已经失效，则会搜索操作系统自身的 DNS 缓存，如果找到，则它会停止搜索，然后解析也会到此结束 第 3 步 读取本地的 HOST 文件如果操作系统的 DNS 缓存也没有找到，那么就会去尝试读取本地的 host 文件 第 4 步 向主控 DNS 服务器发送请求如果在 host 文件内也没有找到对应的配置项，那么浏览器就会发起一个 DNS 的系统调用，就会想本地主控 DNS 服务器（一般来说是你的宽带运营商提供）发起的一个域名解析请求 第 4.1 步 主控 DNS 服务器查找自身缓存首先会查找自身的缓存，找到对应的条目，如果说也没用过期，那就解析成功了，那么如果没有找到这个条目 第 4.2 步 主控 DNS 服务器发起请求拿到 IP 地址那么运营商的 DNS 服务器就会代替我们的浏览器发起一个迭代的 DNS 服务请求 大体步骤如下： 根域（拿到 com 域） –&gt; com 域 DNS 服务器（拿到 baidu.com） –&gt; baidu.com 的 DNS 服务器（域名的注册商提供，万网，新网等） –&gt; 结果发送给运营商的 DNS 服务器（就拿到了 baidu.com 这个域名对应的 IP 地址） –&gt; 结果返回操作系统内核，同时缓存起来（当然，这个缓存可能会失效，有时间长短 ） –&gt; 内核从服务器上拿到这个 IP 地址，就把这个结果返回给浏览器 –&gt; 最终浏览器拿到了 www.baidu.com 对应的 IP 地址 第 5 步 TCP 三次握手建立连接域名解析完成以后，也就拿到了域名对应的 IP 地址，发起经典的 TCP 三次握手，浏览器就会以随机端口像服务器的外部程序发起一个 TCP 连接请求，这个连接请求通过层层路由设备，到达服务器端以后 进入到网卡，然后进入到内核的 TCP/IP 协议栈（还有可能经过防火墙的过滤），最终到了 web 服务端，然后就建立起了这个 TCP/IP 的连接 第 6 步 到这里就可以发送请求了（GET, POST 等）TCP/IP 连接建立起来以后，浏览器就可以向服务器发送 HTTP 请求了，使用了比如说，用 HTTP 的 GET 方法请求一个根域里的一个域名，协议可以采用 HTTP 1.0 的一个协议 第 7 步 响应请求服务器端接受到了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器，如果是百度的页面，就会把完整的 HTML 页面代码返回给浏览器 第 8 步 加载数据浏览器拿到了百度的完整的 HTML 页面代码，在解析和渲染这个页面的时候，里面的 JS、CSS、图片等静态资源，他们同样也是一个个 HTTP 请求都需要经过上面的主要的七个步骤 第9步 渲染页面浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给了用户","link":"/2017/11/07/HTTP/01/"},{"title":"JavaScript 中的单例模式","text":"所谓单例：就是 保证一个类仅有一个实例，并提供一个访问它的全局访问点 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器的 window 对象 单例模式的核心是 确保只有一个实例，并提供全局访问 全局变量不是单例，但在 javascript 中，我们经常会把全局变量当成单例来使用如 1var a = {}; 但是全局变量存在着许多问题，容易造成命名空间污染，做为普通开发者，有必要减少全局变量的使用，常见解决方法有如下两种 使用命名空间适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量，最简单的方式依然是用对象字面量的方式 12345678namespace1 = { a: function () { alert(1); }, b: function () { alert(2); }} 把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会，另外我们还可以动态地创建 命名空间（Object-Oriented javascript） 1234567891011121314151617var MyApp = {};MyApp.namespace = function (name) { var parts = name.split('.'); var current = MyApp; for (var i in parts) { if (!current[parts[i]]) { current[parts[i]] = {}; } current = current[parts[i]]; }}MyApp.namespace('event');MyApp.namespace('dom.style');console.dir(MyApp); 上述代码等价于 123456var MyApp = { event: {}, dom: { style: {} }}; 全用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信 123456789var user = (function () { var __name = 'sven', __age = 29; return { getUserInfo: function () { return __name + '-' + __age; } }})(); 我们用下划线来约定私有变量 _name 和 _age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染 单例模式的重点是惰性单例，所谓惰性单例指的是 在需要的时候才创建对象实例 逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象 1234var obj;if (!obj) { obj = xx;} 一个通用的惰性单例 123456var getSingle = function (fn) { var result; return function(){ return result || (result = fn.apply(this, arguments)) }} 两个示例创建唯一一个登录框12345678910111213var createLoginLayer = function () { var div = document.createElement('div'); div.innerHTML = '我是登录窗口'; div.style.display = 'none'; return div;}var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';} 创建唯一一个 iframe 用于动态加载第三方页面12345678910var createSingleIframe = getSingle(function () { var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;});document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleIframe(); loginLayer.src = 'xxxxx.com';} 单例模式的用途不止用于创建对象，比如我们通常渲染完页面中一个列表之后，接下来要给列表绑定 click 事件，如果是通过 ajax 动态往列表里追回数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次 但是我们不想去判断当前是否是第一次渲染列表，如果我们是借助于 jQuery，我们通常选择给节点绑定 one 事件 1234567891011121314var bindEvent = function () { $('div').one('click', function () { alert('click'); });};var render = function () { console.log('开始渲染列表'); bindEvent();}render();render();render(); 如果利用 getSingle 函数，也能达到一样的效果： 123456789101112131415var bindEvent = getSingle(function () { document.getElementById('div1').onclick = function () { alert('click'); } return true;});var render = function () { console.log('开始渲染列表'); bindEvent();}render();render();render(); 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个事件","link":"/2017/01/25/JavaScript/04/"},{"title":"CommonJS、AMD 和 CMD","text":"CommonJs 是服务器端模块的规范，Node.js 采用了这个规范，根据 CommonJS 规范，一个单独的文件就是一个模块 加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象 比如 123456789101112131415161718// foobar.js// 私有变量var test = 123;// 公有方法function foobar () { this.foo = function () { // do someing ... } this.bar = function () { //do someing ... }}// exports 对象上的方法和变量是公有的var foobar = new foobar();exports.foobar = foobar; 1234// require 方法默认读取 js 文件，所以可以省略 js 后缀var test = require('./foobar').foobar;test.bar(); CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作，像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式 所以 CommonJS 规范比较适用，但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式，所以就有了 AMD 和 CMD 解决方案 AMDAMD 用白话文讲就是 异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行，所有依赖某些模块的语句均放置在回调函数中 适用 AMD 规范适用 define 方法定义模块 12345678// 通过数组引入依赖 ，回调函数通过形参传入依赖define(['someModule1', 'someModule2'], function (someModule1, someModule2) { function foo() { // someing someModule1.test(); } return { foo: foo }}); AMD 规范允许输出模块兼容 CommonJS 规范，这时 define 方法如下 1234567define(function (require, exports, module) { var reqModule = require(\"./someModule\"); requModule.test(); exports.asplode = function () { //someing }}); CMD123456789101112131415161718192021// AMDdefine(['./a', './b'], function (a, b) { // 依赖一开始就写好 a.test(); b.test();});// CMDdefine(function (requie, exports, module) { // 依赖可以就近书写 var a = require('./a'); a.test(); ... // 软依赖 if (status) { var b = requie('./b'); b.test(); }}); 虽然 AMD 也支持 CMD 写法，但依赖前置是官方文档的默认模块定义写法 AMD 与 CMD 区别具体的区别可以参考两者的规范，这里只是简单的介绍 AMD规范 CMD规范 总的来说，区别有两点 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同），CMD 推崇 as lazy as possible CMD 推崇依赖就近，AMD 推崇依赖前置 CMD 推崇依赖就近，可以把依赖写进你的代码中的任意一行，例 1234567define(function (require, exports, module) { var a = require('./a') a.doSomething() var b = require('./b') b.doSomething()}) 代码在运行时，首先是不知道依赖的，需要遍历所有的 require 关键字，找出后面的依赖，具体做法是将 function toString 后，用正则匹配出 require 关键字后面的依赖，显然，这是一种牺牲性能来换取更多开发便利的方法 而 AMD 是依赖前置的，换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块，表现在 require 函数的调用结构上为 1234define(['./a', './b'], function (a, b) { a.doSomething() b.doSomething()}) 代码在一旦运行到此处，能立即知晓依赖，而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大 比如当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组 但是这不是全部的情况，有的时候情况是这样的 1234// 函数体内：if (status) { a.doSomething()} 在这个函数体内，可能依赖 a，也可能不依赖 a，这种可能的依赖成为”软依赖”，对于软依赖当然可以直接当硬依赖处理，但是这样不经济，因为依赖是不一定的，有可能加载了此处的依赖而实际上没有用上 对于软依赖的处理，推荐 依赖前置 + 回调函数 的实现形式，上面的例子简单表述如下 123456// 函数体内：if (status) { async(['a'], function (a) { a.doSomething() })} 我们先把依赖分为两种，”强依赖” —— 肯定需要 和 “弱依赖” —— 可能需要 对于强依赖，如果要性能优先，则考虑参照依赖前置的思想设计你的模块加载器，也更推崇这个方案一些 如果考虑开发成本优先，则考虑按照依赖就近的思想设计你的模块加载器，对于弱依赖，只需要将弱依赖的部分改写到回调函数内即可 参考资料 CommonJS 到 Sea.js 以代码爱好者角度来看 AMD 与 CMD AMD 和 CMD 的区别有哪些？ JavaSript模块规范 - AMD规范与CMD规范介绍","link":"/2017/02/03/JavaScript/05/"},{"title":"JavaScript 中的值和引用","text":"ECMAScirpt 变量有两种不同的数据类型：基本类型，引用类型 引用就像一种特殊的指针，是来指向变量的指针（别名），如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此 JavaScript 中没有指针，引用的工作机制也不尽相同，在 JavaScript 中变量不可能成为指向另一个变量的引用 JavaScript 引用指向的是值，如果一个值有多个引用，这些引用指向的都是同一个值，它们是没有引用/指向关系 JavaScript 对值和引用的 赋值/传递 在语法上没有区别，完全根据值的类型来决定 先来看一个例子 1234567891011121314151617var a = 2;var b = a; // b 是 a 的值的一个副本b++;a; // 2b; // 3// ===&gt;var c = [1, 2, 3];var d = c;d.push(4);c; // [1, 2, 3, 4]d; // [1, 2, 3, 4] 上例中的 2 是一个标量基本类型值，所以变量 a 持有该值的一个副本，b 持有它的另一个复本，所以，b 更改时，a 的值保持不变 c 和 d 则分别指向同一个复合值 [1, 2, 3] 的两个不同引用，请注意，c 和 d 仅仅是指向值 [1, 2, 3]，并非持有 所以它们更改的是同一个值（比如调用 push() 方法），随后它们都指向了更改后的新值 [1, 2, 3, 4] 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来 赋值/传递，包括 undefined，boolean，number，string，null 和 ES6 中的 Symbol 复合值（compound value）– 对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来 赋值/传递 由上可知，由于引用指向的是值本身而非变量，所以一个引用无法更改另外一个引用的指向 1234567891011var a = [1, 2, 3];var b = a;a; // [1, 2, 3]b; // [1, 2, 3]// ===&gt;b = [4, 5, 6];a; // [1, 2, 3]b; // [4, 5, 6] 从上面例子可以看出 b = [4, 5, 6] 并不影响 a 指向 [1, 2, 3] 引用类型值的传递但是函数的参数就经常让人产生这样的疑惑 123456789101112131415function foo (x) { x.push(4); x; // [1, 2, 3, 4] // ===&gt; x = [4, 5, 6]; x.push(7); x; // [4, 5, 6, 7]}var a = [1, 2, 3];foo(a);a; // [1, 2, 3, 4] 我们向函数传递 a 的时候，实际是将引用 a 的一个复本赋值给 x，而 a 仍然指向 [1, 2, 3] 在函数中我们可以通过引用 x 来更改数组的值（如上，数组在 push(4) 后变为了 [1, 2, 3, 4]） 但 x = [4, 5, 6] 并不影响 a 的指向，所以 a 仍然指向 [1, 2, 3, 4] 我们不能通过引用 x 来更改引用 a 的指向，只能更改 a 和 x 共同指向的值 如果要将 a 的值变为 [4, 5, 6, 7]，那么就必须更改 x 指向的数组，而不是为 x 赋值一个新的数组 123456789101112131415function foo (x) { x.push(4); x; // [1, 2, 3, 4] // ===&gt; x.length = 0; x.push(4, 5, 6, 7); x; // [4, 5, 6, 7]}var a = [1, 2, 3];foo(a);a; // [4, 5, 6, 7] 这样一来，在不创建新数组，而只是更改了当前的数组的情况下，a 的指向就变成了 [4, 5, 6, 7] 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定 如果通过值复制的方式来传递复合值（数组），那么就需要为其创建一个复本，这样传递的就不再是原始值，比如 12// slice() 方法不传参数的情况会返回当前数组的一个浅副本（shallow copy）foo(a.slice()) 这样一来，由于传递给函数的是指向该副本的引用，所以 foo() 中的操作不会再影响 a 指向的数组 基本类型值的传递相反，如果要将标量基本类型值传递到函数内并进行更改，这时候就需要将该值封装到一个复合值（对象，数组等）中，然后通过引用复制的方式传递 1234567891011function foo (wrap) { wrap.a = 22;}var obj = { a: 2}foo(obj); obj.a; // 22 这里的 obj 是一个封装了标量基本类型值 a 的封装对象，obj 引用的一个复本作为参数 wrap 被传递到 foo() 中 这样我们就可以通过 wrap 来访问该对象并更改它的属性，函数执行结束后 obj.a 的值就变为了 22 与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值： 12345678910function foo (x) { x = x + 1; x; // 3}var a = 2;var b = new Number(a); // Objeact(a) 也是一样foo(b);b; // 2，而不是 3 这是因为标量基本类型的值是不可更改的（字符串和布尔也是如此），如果一个数字对象的标量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象 x = x + 1 中，x 中的标量基本类型值 2 从数字对象中拆封（提取）出来以后，x 就从引用变成了数字对象 它的值为 2 + 1 等于 3，然而函数外的 b 仍然指向原来那个值为 2 的数字对象 最后再来看两个小小的案例 12345678910111213141516171819// 第一个var o1 = new Object();var o2 = o1;o2.name = 'a';console.log(o1.name); // a// 第二个function changeObjectProperty (o) { o.name = 'a'; o = new Object(); o.name = 'b'; console.log(o.name);}var o = new Object();changeObjectProperty(o);console.log(o.name); 第一个就不用多说了，看了上面的内容以后应该会很清晰的得出 o1.name 也是为 a 的（引用的同一个地址） 至于第二个，如果 o 是按引用传递的，那么结果应该是 'b'，但实际结果却仍是 'a' 在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变，我们可以把参数想象成局部变量 当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存 内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能 如何引用一个对象，但是不改变原有对象的值（解决方法就是在一个函数中去引用），所以 对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值 对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象","link":"/2017/02/22/JavaScript/06/"},{"title":"Object.create( ... )","text":"Object.create() 是 E5 的一个新特性，其实可以理解为继承一个对象 官方的定义为 Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象 基本语法为 1Object.create(proto, [ propertiesObject ]) 参数 proto 一个对象，作为新创建对象的原型 propertiesObject 可选，该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符 注意，该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的 使用 Object.create 的 propertyObject 参数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var o;// 创建一个原型为 null 的空对象o = Object.create(null);o = {};// 以字面量方式创建的空对象就相当于o = Object.create(Object.prototype);o = Object.create(Object.prototype, { // foo 会成为所创建对象的数据属性 foo: { writable:true, configurable:true, value: 'hello' }, // bar 会成为所创建对象的访问器属性 bar: { configurable: false, get: function() { return 10 }, set: function(value) { console.log('Setting `o.bar` to', value) }}})function Constructor(){}o = new Constructor();// 上面的一句就相当于:o = Object.create(Constructor.prototype);// 当然，如果在 Constructor 函数中有一些初始化代码，Object.create 不能执行那些代码// 创建一个以另一个空对象为原型，且拥有一个属性 p 的对象o = Object.create({}, { p: { value: 42 } })// 省略了的属性特性默认为 false，所以属性 p 是不可写，不可枚举，不可配置的o.p = 24o.p// 42o.q = 12for (var prop in o) { console.log(prop)}// 'q'delete o.p// false// 创建一个可写的，可枚举的，可配置的属性 po2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } }); 使用 Object.create 实现类式继承（单继承） 123456789101112131415161718192021222324252627// Shape - superclassfunction Shape() { this.x = 0; this.y = 0;}Shape.prototype.move = function (x, y) { this.x += x; this.y += y; console.info('Shape moved.');};// Rectangle - subclassfunction Rectangle () { Shape.call(this); // call super constructor.}Rectangle.prototype = Object.create(Shape.prototype);// 可以把 constructor 指回去Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();rect instanceof Rectangle // true.rect instanceof Shape // true.rect.move(1, 1); // Outputs, 'Shape moved.' 不过有几个需要注意的地方 第一种情况12345var a = {x: 1};var b = Object.create(a);console.log(b); //输出 {};console.log(b.__proto__); // 输出 {x: 1} 第二种情况1234567// 如果用的是 b = new object(a)connsole.log(b); //输出 {x: 1}congsole.log(b.__proto__); // 输出 {}// 注意区分 __proto__ 和 prototype 另外一个实例12345678910111213141516171819202122232425262728function Foo(name) { this.name = name;}Foo.prototype.myName = function () { return this.name;};function Bar(name, label) { Foo.call(this, name); this.label = label;}// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototypeBar.prototype = Object.create(Foo.prototype);// 注意！现在没有 Bar.prototype.constructor 了// 如果你需要这个属性的话可能需要手动修复一下它// Bar.prototype.constructor = Bar;Bar.prototype.myLabel = function () { return this.label;};var a = new Bar('a', 'obj a');a.myName(); // 'a' a.myLabel(); // 'obj a' 这段代码的核心部分就是语句 Bar.prototype = Object.create( Foo.prototype ) 调用 Object.create(..) 会凭空创建一个’新’对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype） 换句话说，这条语句的意思是，’创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype‘ 声明函数 Bar() 的时候，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype 因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉 注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题 12345// 和你想要的机制不一样Bar.prototype = Foo.prototype;// 基本上满足你的需求，但是可能会产生一些副作用Bar.prototype = new Foo(); Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象 因此当你执行类似 Bar.prototype.myLabel = ... 的赋值语句时会直接修改 Foo.prototype 对象本身 Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象，但是它使用了 Foo(..) 的’构造函数调用’ 如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的’后代’，后果不堪设想 因此，要创建一个合适的关联对象，我们必须使用 Object.create(..) 而不是使用具有副作用的 Foo(..) 这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象 ES6 中的 Object.setPrototypeOf(..)如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了，在 ES6 之前，我们只能通过设置 .__proto__ 属性来实现 但是这个方法并不是标准并且无法兼容所有浏览器，ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联 我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法 12345// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create(Foo.prototype);// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype); 如果忽略掉 Object.create(..) 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高，不过无论如何，这是两种完全不同的语法 Object.create(null)通过 Object.create(null) 创建出来的对象，就没有 Object.prototype 上的一些方法，所以并不是所有的对象都继承有 Object.prototype 上的一些方法 看下面代码 12345var obj = Object.create(null);obj.__proto__; // undefinedobj.toString(); // obj.toString is not a function Object.create(null) 会创建一个拥有空（或者说 null）[[Prototype]] 链接的对象，这个对象无法进行委托 由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 这些特殊的空 [[Prototype]] 对象通常被称作’字典’，它们完全不会受到原型链的干扰，因此非常适合用来存储数据 另外一个需要注意的地方，那就是并不是所有的函数对象都会有 prototype 属性，代码如下 12345678910function abc() {}abc.prototype // abc{}var binded = abc.bind(null);typeof binded // 'function'// 但是需要注意，binded 没有 prototype 属性binded.prototype // undefined","link":"/2017/03/03/JavaScript/07/"},{"title":"JavaScript 中的 == 和 ===","text":"两者的区别在于：== 允许在相等比较中进行强制类型转换，而 === 则不允许 javascript 拥有两套等性运算符： '===' 和 '!=='，和他们的双胞胎 '==' 和 '!=' 好的那一个会按你所期望的方式工作，如果两个操作数是相同的类型，具有相同的值，那么 '===' 产生 'true'，'!==' 产生 'false'，当操作数具有相同类型时，双胞胎做正确的事，但是如果他们是不同类型，它们试图强制值 == 操作符在做任意按需类型转换后将比较相等性，而 === 操作符并不会， === 运算符将不做转换，所以如果两值不一样类型 === 将返回 false，这种情况下，=== 将更快，并可能比 == 返回不同的结果，在所有其他情况下的性能都是一样的，这里有一些有趣的例子： 1234567891011121314151617181920212223242526272829303132[] == ![] // true'' == '0' // false2 == [2] // true'' == [null] // true0 == '\\n' // true0 == '' // true0 == '0' // true'0' == false // truefasle == 'false' // false'true' == true // false42 == '42' // true'foo' == ['foo'] // true// 七种比较少见的情况'0' == false; // truefalse == 0 // truefalse == '' // truefalse == [] // true'' == 0 // true'' == [] // true0 == [] // true 总之，始终建议使用 === 和 !== 1234567891011121314151617var a = [1, 2, 3];var b = [1, 2, 3];var c = { x: 1, y: 2 };var d = { x: 1, y: 2 };var e = 'text';var f = 'te' + 'xt';a == b // falsea === b // falsec == d // falsec === d // falsee == f // truee === f // true 特殊情况下，当你比较字面量和对象的时候，考虑到它的 toString 或者 valueOf 方法，例如，考虑比较由字符串构造函数创建的字符串对象和字符串字面量 12'abc' == new String('abc') // true'abc' === new String('abc') // false 这里的 == 操作符正在检查这两个对象的值并返回 true，但是鉴于它们不是相同类型并且 === 返回 false 再看一个综合的实例 [] == ![] 为什么是 true首先我们需要明确一下：相等运算符 '==' 的规则，有 boolean 的转为数字，有 Object 的转为原始值（类型转换与测试） 有了这个观点我们可以先看几个比较直白点的比较 [] == [] 当两个值都是对象 (引用值) 时, 比较的是两个引用值在内存中是否是同一个对象. 因为此 [] 非彼 [], 虽然同为空数组, 确是两个互不相关的空数组, 自然 == 为 false [] == false 当 '==' 号两边其中一个是布尔值的话，先把它转换为数字（见规范），于是就变成了求 [] == 0 [] == 0 当 '==' 的一边是字符串或数字，另一边是对象的时候（数组也是对象），先把对象值转换为原始值再判断相等，对象值到原始值是怎么转换的呢？对于所有非日期类对象来说，对象到原始值的转换基本上就是对象到数字的转换，也就是所谓的抽象操作 ToPrimitive 大致有以下 3 个步骤： 首先检查该值是否有 valueOf() 的方法，如果有并且返回基本类型值，就使用该值进行强制类型转换为这个原始值 如果没有，则调用 toString 方法，如果 toString 方法返回的是原始值（如果存在），则对象转换为这个原始值 如果 valueOf 和 toString 方法均没有返回原始值，则抛出 TypeError 异常 根据以上可以得知，首先调用 [].valueOf() 方法，返回值是对象自身，即 []，这不是一个原始值，所以继续调用 [].toString() 方法，返回的是空字符串 ''，这是一个原始值，所以此值就作为对象转换为原始值的输出，于是问题就变成了求 '' == 0 然后根据之前所知，会将 '' 转成数字为 0，所以最后的结果为 true 那么现在在回到主题 [] == ![]因为 ! 的优先级比 == 要高，所以会先执行 ![]，也就是先把 [] 转为布尔类型再取反，[] 转布尔值是 true 因为在 JavaScript 里除了 false 自身以外只有 5 个假值，分别是 ''，undefined, null, +0，-0， NaN，除了这 5 个假值以外，其他所有值转布尔类型都是 true 一切对象都是真值，包括 new Boolean(false)，于是问题就成了刚才我们讨论的 [] == false 了 参照标准, 该比较变成了 [] == ToNumber(false), 即 [] == 0，这个时候又变成了 ToPrimitive([]) == 0, 即 '' == 0 接下来就是比较 ToNumber('') == 0, 也就是 0 == 0, 最终结果为 true 直白点来说就是： 12345678910111213141516171819202122232425[] == ![] ===&gt; [] == false ([] 转布尔值是 true) ===&gt; [] == 0 （当 '==' 号两边其中一个是布尔值的话，先把它转换为数字）===&gt; []（[].valueOf() 返回还是 对象自身） == 0 ===&gt; []（[].toString() 返回 ''） == 0 ===&gt; ''（会转成数字为 0） == 0 ===&gt; 0 == 0 查询规范后的总结字符串 和 数字 之间的比较（字符串 ==&gt; 数字） 如果 type(x) 是数字，type(y) 是字符串，则返回 x == ToNumber(y) 的结果 如果 type(x) 是字符串，type(y) 是数字，则返回 ToNumber(x) == y 的结果 其他类型 和 布尔类型 之间的比较（布尔 ==&gt; 数字） 如果 type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果 如果 type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果 null 和 undefined 之间的比较 如果 x 是 null，y 是 undefined，则结果为 true 如果 x 是 undefined，y 是 null，则结果为 true 对象 和 非对象 之间的比较（对象 ==&gt; ToPrimitive(对象)） 如果 type(x) 是字符串或数字，type(y) 是对象，则返回 x == ToPrimitive(y) 的结果 如果 type(x) 是对象，type(y) 是字符串或数字，则返回 ToPrimitive(x) == y 的结果","link":"/2017/03/17/JavaScript/09/"},{"title":"原型和原型对象","text":"所谓 JavaScript 中的原型，则大都是 prototype、__proto__ 和 constructor 的三者之间的关系，如下图所示 乍看上去感觉很复杂，其实说的就是两句代码之间的关系 12function Foo(){};var f1 = new Foo; 下面来分类介绍 构造函数用来初始化新创建的对象的函数是构造函数，在例子中，Foo() 函数是构造函数 实例对象通过构造函数的 new 操作创建的对象是实例对象，可以用一个构造函数，构造多个实例对象 123456function Foo () {};var f1 = new Foo;var f2 = new Foo;console.log(f1 === f2); // false 原型对象及 prototype构造函数有一个 prototype 属性，指向实例对象的原型对象，通过同一个构造函数实例化的多个对象具有相同的原型对象，经常使用原型对象来实现继承 1234567891011function Foo(){};Foo.prototype.a = 1;var f1 = new Foo;var f2 = new Foo;console.log(Foo.prototype.a); // 1console.log(f1.a); // 1console.log(f2.a); // 1 constructor原型对象有一个 constructor 属性，指向该原型对象对应的构造函数 123function Foo(){};console.log(Foo.prototype.constructor === Foo); // true 由于实例对象可以继承原型对象的属性，所以实例对象也拥有 constructor 属性，同样指向原型对象对应的构造函数 1234function Foo(){};var f1 = new Foo;console.log(f1.constructor === Foo); // true proto实例对象有一个 proto 属性，指向该实例对象对应的原型对象（需要注意，实例对象也是对象） 12345function Foo(){};var f1 = new Foo;console.log(f1.__proto__ === Foo.prototype); // true 不过需要注意是，如果实例对象 f1 是通过 Object.create() 创建的话，结果就不一样了 123456function Foo(){};var f1 = Object.create(Foo)console.log(f1.__proto__ === Foo.prototype); // falseconsole.log(f1.__proto__ === Foo); // true 下面来看图 第一部分， Foo如下图所示 实例对象 f1 是通过构造函数 Foo() 的 new 操作创建的 构造函数 Foo() 的原型对象是 Foo.prototype，实例对象 f1 通过 __proto__ 属性也指向原型对象 Foo.prototype 12345function Foo(){};var f1 = new Foo;console.log(f1.__proto__ === Foo.prototype); // true 实例对象 f1 本身并没有 constructor 属性，但它可以继承原型对象 Foo.prototype 的 constructor 属性 1234567function Foo(){};var f1 = new Foo;console.log(Foo.prototype.constructor === Foo); // trueconsole.log(f1.constructor === Foo); // trueconsole.log(f1.hasOwnProperty('constructor')); // false 第二部分， Object如下图所示 Foo.prototype 是 f1 的原型对象，同时它也是实例对象 实际上，任何对象都可以看做是通过 Object() 构造函数的 new 操作实例化的对象 所以，Foo.prototype 作为实例对象，它的构造函数是 Object()，原型对象是 Object.prototype 相应地，构造函数 Object() 的 prototype 属性指向原型对象 Object.prototype，实例对象 Foo.prototype 的 proto 属性同样指向原型对象 Object.prototype 12345function Foo(){};var f1 = new Foo;console.log(Foo.prototype.__proto__ === Object.prototype); // true 实例对象 Foo.prototype 本身具有 constructor 属性，所以它会覆盖继承自原型对象 Object.prototype 的 constructor 属性 1234567function Foo(){};var f1 = new Foo;console.log(Foo.prototype.constructor === Foo); // trueconsole.log(Object.prototype.constructor === Object); // trueconsole.log(Foo.prototype.hasOwnProperty('constructor')); // true 如果 Object.prototype 作为实例对象的话，其原型对象为 null 1console.log(Object.prototype.__proto__ === null); // true 第三部分， Function如下图所示 函数也是对象，只不过是具有特殊功能的对象而已，任何函数都可以看做是通过 Function() 构造函数的 new 操作实例化的结果 如果把函数 Foo 当成实例对象的话，其构造函数是 Function()，其原型对象是 Function.prototype 类似地，函数 Object 的构造函数也是 Function()，其原型对象是 Function.prototype 123456function Foo(){};var f1 = new Foo;console.log(Foo.__proto__ === Function.prototype); // trueconsole.log(Object.__proto__ === Function.prototype); // true 原型对象 Function.prototype 的 constructor 属性指向构造函数 Function() 实例对象 Object 和 Foo 本身没有 constructor 属性，需要继承原型对象 Function.prototype 的 constructor 属性 1234567891011function Foo(){};var f1 = new Foo;console.log(Function.prototype.constructor === Function); // trueconsole.log(Foo.constructor === Function); // trueconsole.log(Object.constructor === Function); // trueconsole.log(Foo.hasOwnProperty('constructor')); // falseconsole.log(Object.hasOwnProperty('constructor')); // false 所有的函数都可以看成是构造函数 Function() 的 new 操作的实例化对象 那么，Function 可以看成是调用其自身的 new 操作的实例化的结果 所以，如果 Function 作为实例对象，其构造函数是 Function，其原型对象是 Function.prototype 1234console.log(Function.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.constructor === Function); // trueconsole.log(Function.prototype === Function); // true 如果 Function.prototype 作为实例对象的话，其原型对象是什么呢？ 和前面一样，所有的对象都可以看成是 Object() 构造函数的 new 操作的实例化结果 所以，Function.prototype 的原型对象是 Object.prototype，其原型函数是 Object() 1console.log(Function.prototype.__proto__ === Object.prototype); // true 而 Object.prototype 的原型对象是 null 1console.log(Object.prototype.__proto__ === null); // true 总结 函数(Function 也是函数)是 new Function 的结果，所以函数可以作为实例对象，其构造函数是 Function()，原型对象是 Function.prototype 对象(函数也是对象)是 new Object 的结果，所以对象可以作为实例对象，其构造函数是 Object()，原型对象是 Object.prototype Object.prototype 的原型对象是 null 参考 js 中 proto 和 prototype 的区别和关系？ Js 中 Prototype、proto、Constructor、Object、Function 关系介绍 一张图理解 prototype、proto 和 constructor 的三角关系 proto VS. prototype in JavaScript","link":"/2017/04/08/JavaScript/11/"},{"title":"parseInt() 与 parseFloat()","text":"在 JavaScript 中，parseInt() 函数和 parseFloat() 函数功能类型，都是将 “数字字符串” 转化为一个数值 下面就一个一个来看 parseFloat(string)parseFloat() 函数可解析一个字符串，并返回一个浮点数 指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串 parseInt(string, radix)parseInt() 函数可解析一个字符串，并返回一个整数 radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析 差异parseInt 和 parseFloat 都是将字符串类型转换为 number 类型.两者区别在于 parseFloat 会将 . 号转换为浮点数,而 parseInt 直接忽略停止转换 比如当处理 '5.12asc' 时，parseInt 直接转换为 5，parseFloat 会转换为 5.12，parseInt 还可以指定第二位参数来指定转换结果的进制 (2, 8, 16)(范围为 2 - 36) parseFloat 与 NANparseFloat 会将它的字符串参数解析成为浮点数并返回，如果在解析过程中遇到了正负号（+ 或 -）、数字 (0 - 9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数 同时参数字符串首位的空白符会被忽略，如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN 根据 #parseFloat 可知，当调用 parseFloat 函数，是先转成字符串，再转为数字，如果不能转为数字，则返回 NaN 大体意思就是 如果返回的是原始类型（即 Number，String，Boolean，Undefined，Null），则将此返回值转为字符串，再尝试将字符串转为数字，如果不能转成数字则返回 NaN 如果 toString 方法返回的不是原始类型，则继续调用 valueOf 方法，如果返回的是原始类型，则将其转为字符串，再将字符串转为数字返回 如果 valueOf 方法返回的也不是原始类型,则返回 NaN parseFloat() 精度的问题只有字符串中的第一个数字会被返回，开头和结尾的空格是允许的 提示，如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN，如果只想解析数字的整数部分，请使用 parseInt() 方法 12345678910111213parseFloat('10'); // 10parseFloat('10.00'); // 10parseFloat('10.33'); // 10.33parseFloat('34 45 66'); // 34parseFloat(' 60 '); // 60parseFloat('40 years'); // 40parseFloat('He was 40'); // NaN 通过以上一些实例，parseFloat 的用法大致应该了解一些了，下面来说一些遇到的问题 12var num = parseFloat('233333.9') - parseFloat('0.2');console.log(num); // 233333.69999999998 造成这种情况的原因就在于能被计算机读懂的是二进制，而不是十进制，把 0.2 转换为二进制看一看 10.2 =&gt; 0.0011 0011 0011 0011…（无限循环） 这样一看问题就很明显了，我们需要做的就是尽量避免这样的情况发生 1234567891011// 第一种，四舍五入Math.round(parseFloat('233333.9') - parseFloat'0.2')); // 第二种，保留几位小数num.toFixed(2); // toFixed(n) 中的 n 代表保留几位 // 第三种，扩大一定的倍数，对结果在缩小这个倍数var num1 = parseFloat('233333.9') * 1000000000000;var num2 = parseFloat('0.2') * 1000000000000;var num3 = (num1 - num2) / 1000000000000; 另外还可以使用一些第三方库来进行解决，比如 bignumber 经典的 map(parseInt) 问题12// 下面的语句返回什么呢:['1', '2', '3'].map(parseInt); 你可能觉的会是 [1, 2, 3]，但实际的结果是 [1, NaN, NaN] 通常使用 parseInt 时，只需要传递一个参数，但实际上 parseInt 可以有两个参数，第二个参数是进制数，可以通过语句 'alert(parseInt.length) === 2' 来验证 map 方法在调用 callback 函数时，会给它传递三个参数，当前正在遍历的元素，元素索引，原数组本身 第三个参数 parseInt 会忽视，但第二个参数不会，也就是说 parseInt 把传过来的索引值当成进制数来使用，从而返回了 NaN 123456789// 解决方法// 应该使用如下的用户函数 returnInt function returnInt (element) { return parseInt(element,10);} ['1', '2', '3'].map(returnInt);// 返回 [1, 2, 3]","link":"/2017/04/15/JavaScript/12/"},{"title":"JavaScript 中的遍历和枚举","text":"先来看下面这个实例 123456var myObject = { a: undefined }; myObject.a; // undefined myObject.b; // undefined 两个返回值均返回 undefined，但是这个值有可能是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined，那么如何区分这两种情况呢？ 我们可以在不访问属性值的情况下判断对象中是否存在这个属性 123456789var myObject = { a: 2 }; ('a' in myObject); // true ('b' in myObject); // false myObject.hasOwnProperty( 'a' ); // true myObject.hasOwnProperty( 'b' ); // false in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中，相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链 所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（比如通过Object.create(null) 来创建），在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败 这时可以使用一种更加强硬的方法来进行判断，Object.prototype.hasOwnProperty.call(myObject, 'a')，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定到 myObject 上 不过需要注意，看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在，对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4 枚举先来看一个实例 1234567891011121314151617181920212223242526var myObject = { }; Object.defineProperty( myObject, 'a', // 让 a 像普通属性一样可以枚举 { enumerable: true, value: 2 } ); Object.defineProperty( myObject, 'b', // 让 b 不可枚举 { enumerable: false, value: 3 } ); myObject.b; // 3 ('b' in myObject); // true myObject.hasOwnProperty( 'b' ); // true // myObject 中仅能枚举出 afor (var k in myObject) { console.log( k, myObject[k] ); } // 'a' 2 可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管可以通过 in 操作符来判断是否存在），原因是’可枚举’就相当于’可以出现在对象属性的遍历中’ 注意，在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性 建议是只在对象上应用 for..in 循环，在数组中就使用传统的 for 循环来遍历数值索引 也可以通过另一种方式来区分属性是否可枚举 123456789101112131415161718192021var myObject = { }; Object.defineProperty( myObject, 'a', // 让 a 像普通属性一样可以枚举 { enumerable: true, value: 2 } ); Object.defineProperty( myObject, 'b', // 让 b 不可枚举 { enumerable: false, value: 3 } ); myObject.propertyIsEnumerable( 'a' ); // true myObject.propertyIsEnumerable( 'b' ); // false Object.keys( myObject ); // ['a'] Object.getOwnPropertyNames( myObject ); // ['a', 'b'] propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举 in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性 遍历for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链），但是如何遍历属性的值呢？ 对于数值索引的数组来说，可以使用标准的 for 循环来遍历值 123456var myArray = [ 1, 2, 3 ]; for (var i = 0; i &lt; myArray.length; i++) { console.log( myArray[i] ); } // 1 2 3 这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i] 使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值 在 ES6 中增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象），利用它便可以直接遍历值而不是数组下标（或者对象属性） 123456789var myArray = [ 1, 2, 3 ]; for (var v of myArray) { console.log( v ); } // 1 // 2 // 3 for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值 数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上，我们使用内置的 @@iterator 来手动遍历数组，看看它是怎么工作的 1234567var myArray = [ 1, 2, 3 ]; var it = myArray[Symbol.iterator](); it.next(); // { value: 1, done: false } it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { done: true } 我们使用 ES6 中的符号 Symbol.iterator 来获取对象的 @@iterator 内部属性 虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数（这点很重要） 和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历 当然，你可以给任何想遍历的对象定义 @@iterator，举例来说， 123456789101112131415161718192021222324252627282930313233343536373839var myObject = { a: 2, b: 3 }; // 主要是为了让它不可枚举Object.defineProperty( myObject, Symbol.iterator, { enumerable: false, writable: false, configurable: true, value: function() { var o = this; var idx = 0; var ks = Object.keys( o ); return { next: function() { return { value: o[ks[idx++]], done: (idx &gt; ks.length) }; } }; } }); // 手动遍历 myObject var it = myObject[Symbol.iterator](); it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { value: undefined, done: true } // 用 for..of 遍历 myObject for (var v of myObject) { console.log( v ); } // 2 // 3 for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值（需要注意遍历对象属性 / 值时的顺序）","link":"/2017/04/22/JavaScript/13/"},{"title":"JavaScript 中的 || 和 &&","text":"逻辑运算符 ||（或） 和 &amp;&amp;（与）应该不陌生，但是称为 ‘逻辑运算符’ 不太准确，称之为 ‘选择器运算符’ 或者 ‘操作数选择器运算符’ 更恰当一些 因为在 JavaScript 中，它们返回的并不是布尔值，它们的返回值是两个操作数中的一个（且仅一个），即选择两个操作数中的一个，然后返回它的值 二元逻辑运算符 &amp;&amp; 和 || 运算符的返回值不一定是布尔类型，而是两个操作数其中一个的值 123456789var a = '42';var b = 'abc';var c = null;a || b; // 42a &amp;&amp; b; // 'abc'c || b; // 'abc'c &amp;&amp; b; // null || 和 &amp;&amp; 首先会对 第一个操作数 执行条件判断，如果其值不是布尔，就先进行 ToBoolean 强制类型转换，然后在执行条件判断 对于 ||，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值 &amp;&amp; 则相反，如果条件判断结果为 true，就返回第二个操作数的值，如果为 false 就返回第一个操作数的值 ||下面是一个十分常见的 || 用法： 123456789function foo (a, b) { a = a || 'hello'; b = b || 'world'; console.log( a + ' ' + b )}foo(); // hello worldfoo('world', 'hello') // world hello a = a || 'hello' 检查变量 a，如果还未赋值（或者为假值），就赋予它一个默认值（'hello'） 但是需要注意，如果传入的是 foo('', '')，这时会同样的返回 hello world，因为传入的是一个假值，|| 判断不成立，会返回默认值 &amp;&amp;如果第一个操作数为真值，则 &amp;&amp; 运算符 ‘选择’ 第二个操作数作为返回值，这也叫做 ‘守护运算符’，即前面的表达式为后面的表达式 ‘把关’ 1234567function foo () { console.log(a);}var a = 42;a &amp;&amp; foo(); // 42 foo() 只有在条件判断 a 通过时才会被调用，如果条件判断未通过，a &amp;&amp; foo() 就会悄然终止（也叫做 ‘短路’），foo() 不会被调用 短路对于 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数，这种现象称之为 ‘短路’（即执行最短路径） 以 a &amp;&amp; b 为例，如果 a 是一个假值，足以决定 &amp;&amp; 的结果，就没有必要再判断 b 的值 同样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，就没有必要再判断 b 的值 隐式强制类型转换既然返回的不是 true 和 false，那么为什么 a &amp;&amp; (b || c) 这样的表达式在 if 或者 for 中没有出现问题 这是因为这些条件判断表达式最后还会执行布尔值的隐式强制类型转换 1234567var a = 42;var b = null;var c = 'foo';if (a &amp;&amp; (b || c)) { console.log('hello') // hello} 这里的 a &amp;&amp; (b || c) 的结果实际上是 'foo' 而非 true，然后再由 if 将 foo 强制类型转换为布尔值，所以最后结果为 true 如果要避免隐式强制类型转换，可以采用下面的方式 1234567var a = 42;var b = null;var c = 'foo';if (!!a &amp;&amp; (!!b || !!c)) { console.log('hello') // hello} 运算符优先级JavaScript 中的 &amp;&amp; 和 || 运算符返回它们其中一个操作数的值，而非 true 或 false，但是两个运算符三个操作数呢： 123456var a = 42;var b = 'foo';var c = [1, 2, 3];a &amp;&amp; b || c;a || b &amp;&amp; c; 这里就涉及到了运算符优先级，这里只列举一部分，完整的列表可以参考 MDN - 运算符优先级 用 ',' 来连接一系列语句的时候，它的优先级最低，其他操作数的优先级都比它高 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ -- - ~ ! 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 == != === !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 | 按位或 &amp;&amp; 逻辑与 || 逻辑或 ? : 条件（三元） , 多重求值 下面是一个极端的例子，如果理清其中的逻辑之后，以后在遇到类似情况就都比较清晰了 1234567var a = 42;var b = 'foo';var c = false;var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;d; // 42 根据上面的运算符优先级，上例可以分解为 1234567var d = ((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a;var d = ((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a; 这样一来，就可以得出最后的结果为 42 小小总结逻辑运算符 '||' 和 '&amp;&amp;' 都是遵行短路原则，只要确定符号前面的真假，既可确定返回值 只要 '||' 前面为 false，无论 '||' 后面是 true 还是 false，结果都返回 '||' 后面的值 只要 '||' 前面为 true，无论 '||' 后面是 true 还是 false，结果都返回 '||' 前面的值 只要 '&amp;&amp;' 前面是 false，无论 '&amp;&amp;' 后面是 true 还是 false，结果都将返 '&amp;&amp;' 前面的值 只要 '&amp;&amp;' 前面是 true，无论 '&amp;&amp;' 后面是 true 还是 false，结果都将返 '&amp;&amp;' 后面的值","link":"/2017/05/19/JavaScript/19/"},{"title":"map/reduce","text":"map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值，这个函数必须接收两个参数 下面分别来看这两个方法 map由于 map() 方法定义在 javascript 的 Array 中 比如我们有一个函数 f(x) = x * x，要把这个函数作用在一个数组 [1, 2, 3, 4, 5, 6, 7, 8, 9] 上 我们调用 Array 的 map() 方法，传入我们自己的函数，就得到了一个新的 Array 作为结果 123456function pow(x) { return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] 再比如，把 Array 的所有数字转为字符串 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduceArray 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3...] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是 1[x1, x2, x3, x4].reduce(f) = f( f( f(x1, x2), x3 ), x4 ) 比方说对一个 Array 求和，就可以用 reduce 实现 12345var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x + y;}); // 25 要把 [1, 3, 5, 7, 9] 变换成整数 13579，reduce() 也能派上用场 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x * 10 + y;}); // 13579 利用 reduce() 求积 123function product(arr) { return arr.reduce(function(x, y){ return x * y})} 一个综合实例实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 cbaacfdeaebb 方法一利用 hash table，缺点是 Object.keys() 不能保证顺序，所以存在风险 12345678var o = [].reduce.call('cbaacfdeaebb', function (p, n) { return p[n] = (p[n] || 0) + 1, p;}, {}), s = Object.keys(o).reduce(function (p, n) { return o[p] &lt;= o[n] ? p : n; });console.log(s, o[s]); 方法二引入了 index 来解决顺序问题 1234567891011121314const all = 'cbaacfdeaebb'.split('') .reduce((all, ch, i) =&gt; { const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 }); m.count++; return all; }, {});const theOne = Object.keys(all) .map(ch =&gt; all[ch]) .reduce((min, t) =&gt; min.count === t.count ? (min.index &gt; t.index ? t : min) : (min.count &gt; t.count ? t : min));console.log(`${theOne.ch}: ${theOne.count}`); 方法三利用数组代替 hash table，解决了顺序问题，但是 Array.sort() 并不一定是稳定的，风险可能更大 12345678910function findFirstChar(string) { const desc = []; [...string].forEach((char, index) =&gt; { const item = desc.find(item =&gt; item.char === char) item ? item.count++ : desc.push({ char, index, count: 1 }) }) return desc.sort((a, b) =&gt; a.count - b.count)[0]} 方法四使用 Object.values，但是目前还是草案 123456789101112const less = (x, y) =&gt; (x.count &lt;= y.count &amp;&amp; x.first &lt; y.first) ? x : y;function firstSingle(string) { let map = {} string.split('') .forEach((char, index) =&gt; { map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char } }); return Object.values(map).reduce(less).char} 方法五代码简短，但是执行效率不是很高 123456var str = 'cbaacfdeaebb';var result = [...new Set(str)] .map(el =&gt; ({ el, len: str.split(el).length })) .reduce((a, e) =&gt; (a.len &gt; e.len ? e : a)) .el;","link":"/2017/06/01/JavaScript/20/"},{"title":"JavaScript 中节点（Node）相关属性","text":"一些常见的 nodeType 值 1 - 普通元素节点，比如 div，p 等 3 - 文本节点 8 - 注释节点 9 - document 节点 10 - 文档 DTD childNodes用来获取子节点，注意，返回的是一个类数组对象 1var childs = oDiv.childNodes; 这里存在一个坑，比如如下 123456&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 当 div 中没有文本节点的时候，此时应该为 4 个节点，但是 IE9，Chrome，FireFox 会认为存在 9 个节点，而 IE8 则认为只有 4 个节点 这时因为高级浏览器会把空文本节点也当作为一个节点，标签前后的空文本也会被算作一个节点 而且对于注释的前后算不算空文本节点，每个浏览器的解释也有不相同，所以我们在使用节点的时候，一定要过滤，比如判断节点的 nodeType 是不是 1（普通元素节点） 12345678910// 得到真正的标签子节点function getRealChild(elem) { var result = []; for (var i = 0; i &lt; elem.childNodes.length; i++) { if (elem.childNodes[i].nodeType == 1) { result.push(elem.childNodes[i]); } } return result;} 另外，如果要改变文本节点的内容（nodeType 为 3），需要改变其 nodeValue 属性 1oDiv.childNodes[0].nodeValue = '张三' parentNodeparentNode 属性表示父节点，任何节点的 parentNode 的 nodeType 一定为 1，也就是说父节点一定是标签节点 previousSibling 和 nextSibling表示 上/下 一个兄弟节点，需要注意的是，其可能是 文本/注释 节点，而原生 JavaScript 当中并没有提供 prevAll()，nextAll()，siblings() 等方法 如果不存在 上/下 兄弟节点，则会返回 null，所以可以利用这个特性来写一个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// prevfunction getRealPrev(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 while (o = o.previousSibling) { if (o.nodeType == 1) { return o; } return null; }}// nextfunction getRealNext(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 while (o = o.nextSibling) { if (o.nodeType == 1) { return o; } return null; }}// prevAllfunction getRealprevAll(elem) { // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向上查询 // 如果不存在上一个节点，则会返回 null，便自动停止循环 while (o = o.previousSibling) { if (o.nodeType == 1) { result.unshift(o) } return result; }}// nextAllfunction getRealnextAll(elem) { // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点 var o = elem; var result = []; // 循环遍历，将循环的结果再次赋予 o，依次向下查询 // 如果不存在下一个节点，则会返回 null，便自动停止循环 while (o = o.nextSibling) { if (o.nodeType == 1) { result.push(o) } return result; }} 而 siblings() 方法则可以使用双重循环来实现，比如下面这个方法 1234567891011function toggleActive() { var span = document.querySelectorAll('.span') for (var i = 0; i &lt; span.length; i++) { span[i].addEventListener('click', function () { for (var j = 0; j &lt; span.length; j++) { span[j].classList.remove('active') } this.classList.add('active') }) }} 创建节点使用 document.createElement('标签名') 来创建一个节点，需要注意的是，创建出来的节点是不存在与 DOM 树上的，即孤儿节点，需要手动添加至 DOM 树中 1234var oBox = document.getElementById('div');var oDiv = document.createElement('div');oBox.appendChild(oDiv); 一个需要注意的地方，JavaScript 中存储 DOM 节点的变量是动态的，比如如下例子 12345678910var oBox = document.getElementById('box')var oDiv = oBox.getElementsByTagName('div')// 会造成死循环// 因为 oDiv.length 会动态增加for (var i = 0; i &lt; oDiv.length; i++) { var oP = document.createElement('p'); oP.innerHTML = '123'; oBox.appendChild(oP);} 解决方法很简单，用一个变量将 length 存储起来即可 123for (var i = 0; l = oDiv.length, i &lt; l; i++) { // ...} 插入节点appendChild()常用的方法是使用 appendChild() 来追加至元素的末尾，需要注意的地方就是 如果节点已经存在（比如 DOM 树中已经存在），而不是新创建的，这个时候则会移动该节点（不会克隆） insetBefore()接收两个参数，一个是新创建的元素，另一个为参照点 1oBox.insetBefore('新创建的元素，参照元素') 这样插入的元素会以参照的元素依次往上添加（即添加的为 3，2，1参照），如果想让顺序变为正序，使用 oBox.childNodes[0] 为参照点即可（需要注意，如果使用 childNodes[0] 来做参照删除元素的话，会存在空白节点） 删除节点节点不能自己删除，如果想要删除节点，必须使用父元素参照 1'父元素'.removeChild('删除的元素') 如果不知道父元素是谁，则可以使用 1'需要删除的元素'.parentNode.removeChild('需要删除的元素') 替换节点使用 replaceChild() 方法，一般使用的不是很多 1'父元素'.replaceChild('新节点', '旧节点') 比如 oBox.replaceChild(div1, div2) 结果是将 div1 节点处的内容替换至 div2 处（div1 处的节点内容就不存在了） 克隆节点比较常用的方式是使用 innerHTML 的方式来进行克隆（亦或是修改），但是执行效率没有 DOM 原生方法速度快 原生的方法是 cloneNode([true])，可以追加一个布尔值参数 true，表示深度克隆，克隆其所有的子节点","link":"/2017/06/26/JavaScript/21/"},{"title":"函数的 length 和 callee 属性","text":"需要注意：ES6 以后不再提倡使用 callee 属性 函数的 length 是形参列表的长度，就是函数定义的时候写在 () 中的参数个数，无视实参的个数 也就是说，arguments.callee.length 就是形参列表的个数，而 arguments.length 则表示实参个数 即在调用函数的时候传入进来的实参个数 123456function fn(a, b, c, d, e, f) { console.log(arguments.callee.length); // 6 console.log(arguments.length); // 3}fn(1, 2, 3) callee在函数内部，如果想要得到函数本身，使用 this 是得不到的，这时一般会使用 arguments.callee 12345function fn() { console.log(arguments.callee === fn); // true，即 arguments.callee 就是函数本身}fn(); 相关实例123456789function fun(m, n, o, p, q, r) { alert(this.length);}function f(a, b) { arguments[0](9, 10, 11, 12, 13);}f(fun, 5, 6, 7); // 4 函数的最终调用，是 arguments 对象进行的调用，而 arguments 对象则是一个类数组对象，所以函数 fun 中的 this 就是代表的 arguments 对象，所以 this.length 就是表示调用函数 f() 的实参个数 如果换成如下形式 123456789function fun(m, n, o, p, q, r) { alert(this.callee.length);}function f(a, b) { arguments[0](9, 10, 11, 12, 13);}f(fun, 5, 6, 7); // 2 因为函数 fun 里面的 this 是 arguments 对象，所以 arguments 对象的 callee 属性就是 f() 函数 它的长度就是它的形参列表个数，为 2 再来看一个相关示例 12345678910111213function fun(a, b, c, d) { // 决定了 fun2 当中的 this 指向的是 fun 当中的 arguments 对象 arguments[0](5, 6);}function fun2(q, w, e, r, t) { alert(this.length); // 6 alert(this.callee.length); // 4 alert(arguments.length); // 2 alert(arguments.callee.length); // 5}fun(fun2, 8, 9, 10, 11, 12); 一个大的综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var number = 2;var obj = { number: 4, // fn1 是一个 IIFE fn1: (function () { // 此时 this 为 window，即把全局变量中的 number 修改为了 4 this.number *= 2; // 此时 number 为 undefined，所以 undefined * 2 为 NaN number = number * 2; // 变量提升，var number; var number = 3; // 然后返回一个函数（闭包） return function () { // 闭包特性，此时 this 为 window，所以此时全局变量中的 number 为 8 this.number *= 2; // 闭包特性，number 可以拿到 fn1() 作用域当中的 number 值，所以 3 * 3 = 9 number *= 3; // 9 alert(number); } })()}var fn1 = obj.fn1;// 此时全局中的 number 为 4// 因为 IIFE 肯定最先执行alert(number);// 调用的实际上是返回的那个函数// 把全局中的 number 变为了 8，闭包中的 number 变为了 9// 执行的 alert() 弹出的是闭包中的 number 为 9fn1();// 这样调用的话，this 指向的是 obj// 此时 this.number *= 2; 即把 obj.number 变为了 8// 此时的闭包还是老的闭包，因为没有重新赋值（因为没有执行过类似 var fn1 = obj.fn1 的操作）// 因为之前执行过 fn1，所以闭包中的 number 为 9，此时再次调用后变为 27obj.fn1();// 此时全局的 number 为 8alert(window.number);// 8alert(obj.number);","link":"/2017/07/02/JavaScript/22/"},{"title":"ES6 中的 class","text":"首先需要明确的一些 类的内部所有定义的方法，都是不可枚举的 类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式 一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加 不存在变量提升（hoist） 类的方法内部如果含有 this，它默认指向类的实例 class 中的方法有三种类型：构造函数、静态方法、原型方法 class 内部只有静态方法，没有静态属性 私有方法ES6 不提供，只能通过变通方法模拟实现 一种做法是在命名上加以区别 12345678910111213class Widget { // 公有方法 foo(baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // ...} 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的 12345678910111213class Widget { // foo 是公有方法，内部调用了 bar.call(this, baz) // 使得 bar 实际上成为了当前模块的私有方法 foo(baz) { bar.call(this, baz); } // ...}function bar(baz) { return this.snaf = baz;} 有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值 12345678910111213141516const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass { // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return this[snaf] = baz; } // ...}; 私有属性与私有方法一样，ES6 不支持私有属性，但是可以通过闭包来实现私有属性 12345678910111213141516171819202122232425262728var People = (function () { var p = new WeakMap(); class People { constructor(name) { var privateProperties = { name: name }; p.set(this, privateProperties); } sayName() { console.log(this.name); } get name() { return p.get(this).name; } } return People;})();var p = new People('zhangsan');console.log(p.name);p.sayName();var p2 = new People('lisi');console.log(p2.name);p2.sayName(); 静态方法静态方法一般用来提供一些工具方法，可以通过 static 关键字定义静态方法 123456789101112131415class People { constructor(name) { this.name = name; } sayName() { console.log(this.name); } static formatName(name) { return name.toUpperCase(); }}console.log(People.formatName('zhangsan')); 静态属性Class 内部只有静态方法，没有静态属性 静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性 1234class Foo {}Foo.prop = 1;Foo.prop // 1 getters &amp; setters现在可以通过 get 和 set 关键字来定义 getters 和 setters 了 1234567891011121314151617181920212223class People { constructor(name) { this.name = name; } get name() { return this._name.toUpperCase(); } set name(name) { this._name = name; } sayName() { console.log(this.name); }}var p = new People('zhangsan');console.log(p.name); // ZHANGSANconsole.log(p._name); // zhangsanp.sayName(); // ZHANGSAN 因为定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的 继承通过关键字 extends 来继承一个类，并且可以通过 super 关键字来引用父类 1234567891011121314151617181920class People { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}class Student extends People { constructor(name, grade) { super(name); this.grade = grade; } sayGrade() { console.log(this.grade); }} 几个注意事项： 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错，这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工，如果不调用 super 方法，子类就得不到 this 对象 如果子类没有定义 constructor 方法，这个方法会被默认添加，也就是说不管有没有显式定义，任何一个子类都有 constructor 方法 在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错（因为只有 super 方法才能返回父类实例） Object.getPrototypeOf 方法可以用来从子类上获取父类（判断一个类是否继承了另一个类） super 关键字 使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 super 作为函数调用时 super 作为函数调用时，代表父类的构造函数（子类的构造函数必须执行一次 super 函数） 虽然代表了父类的构造函数，但是 super 内部的 this 指的是子类的实例（相当于 Father.prototype.constructor.call(this)） 作为函数时，super() 只能用在子类的构造函数之中，用在其他地方就会报错 super 作为对象调用时 在普通方法中，指向父类的原型对象，在静态方法中，指向父类（与父类静态方法相呼应） 当 super 指向父类的原型对象时，定义在父类实例上的方法或属性，是无法通过 super 调用的（定义在 prototype 上的则可以取到） 通过 super 调用父类的方法时，super 会绑定子类的 this 通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性，如下代码 123456789101112131415161718192021class A { constructor() { this.x = 1; }}class B extends A { constructor() { super(); this.x = 2; // 等同于对 this.x 赋值为 3 super.x = 3; // 而当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined console.log(super.x); // undefined console.log(this.x); // 3 }}let b = new B();","link":"/2017/09/22/JavaScript/24/"},{"title":"JavaScript 中的 this","text":"this 是 JavaScript 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 随着函数使用场合的不同，this 的值会发生变化，但是有一个总的原则，那就是 this 指向的是，调用函数的那个对象 JavaScript 中函数的调用有以下几种方式： 为对象方法调用 作为函数调用 作为构造函数调用 使用 apply 或 call 调用 下面就按照调用方式的不同，分别讨论 this 的含义 作为对象方法调用在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象 1234567891011var point = { x: 0, y: 0, moveTo: function (x, y) { this.x = this.x + x; this.y = this.y + y; }};// this 绑定到当前对象，即 point 对象point.moveTo(1, 1) 纯粹的函数调用函数也可以直接被调用，此时 this 绑定到全局对象，在浏览器中，window 就是该全局对象（Node.js 中为 Global） 比如下面的例子，函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的 123456function makeNoSense(x) { this.x = x;}makeNoSense(5);x; // x 已经成为一个值为 5 的全局变量 对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题 我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移 结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y 1234567891011121314151617181920212223242526var point = { x: 0, y: 0, moveTo: function (x, y) { // 内部函数 var moveX = function (x) { this.x = x; }; // 内部函数 var moveY = function (y) { this.y = y; }; moveX(x); moveY(y); }};point.moveTo(1, 1);point.x; // ==&gt;0 point.y; // ==&gt;0 x; // ==&gt;1 y; // ==&gt;1 内部函数中的 this 成为全局的了，为了规避这一设计缺陷，一般使用变量替代的方法，该变量常被命名为 that/_this/self 12345678910111213141516171819202122var point = { x: 0, y: 0, moveTo: function (x, y) { var that = this; // 内部函数 var moveX = function (x) { that.x = x; }; // 内部函数 var moveY = function (y) { that.y = y; } moveX(x); moveY(y); }};point.moveTo(1, 1);point.x; // ==&gt;1 point.y; // ==&gt;1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object），实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已 包括内置对象函数在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用，实际上并不存在所谓的构造函数，只有对于函数的构造调用 使用 new 来调用函数，会自动执行以下操作 创建（或者说构造）一个全新的对象 这个新对象会被执行 [[原型]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数会自动返回这个新对象 这时，this 就指这个新对象， 如果不使用 new 调用，则和普通函数一样 12345678910111213141516function C() { this.a = 37;}var o = new C();console.log(o.a); // 37function C2() { this.a = 37; // 手动的设置了返回对象，与 this 绑定的默认对象被取消 return { a: 38 };}o = new C2();console.log(o.a); // 38 使用 apply 或 call 调用apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，因此，this 指的就是这第一个参数 1234567891011121314function Point(x, y) { this.x = x; this.y = y; this.moveTo = function (x, y) { this.x = x; this.y = y; }}var p1 = new Point(0, 0);var p2 = { x: 0, y: 0 };p1.moveTo(1, 1);p1.moveTo.apply(p2, [10, 10]); 在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法 使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上 这时候 this 也被绑定到对象 p2 上，另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的 注意，apply() 的参数为空时，默认调用全局对象 四种方式的优先级如下所示，优先级从上往下： 由 new 调用绑定到新创建的对象 由 call 或者 apply（或者 bind）调用？绑定到指定的对象 由上下文对象调用？绑定到那个上下文对象 默认：在严格模式下绑定到 undefined，否则绑定到全局对象 以上是 this 常见的几种使用方式，下面来看看一些不太常见的场景 原型链中的 this相同的概念在定义在原型链中的方法也是一致的，如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样 123456789101112var o = { f: function () { return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型，但是这对于最终在 o 中找到 f 属性的查找过程来说没有关系 查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p，也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p getter 与 setter 中的 this作为 getter 或 setter 函数都会绑定 this 到从设置属性或得到属性的那个对象 123456789101112131415161718function modulus() { return Math.sqrt(this.re * this.re + this.im * this.im);}var o = { re: 1, im: -1, get phase() { return Math.atan2(this.im, this.re); }};Object.defineProperty(o, 'modulus', { get: modulus, enumerable: true, configurable: true});// -0.78... 1.4142...console.log(o.phase, o.modulus); DOM 事件处理函数中的 this当函数被用作事件处理函数时，它的 this 指向触发事件的元素 需要注意，IE 的 attachEvent() 中的 this 指向 window（IE11+ 已经支持 addEventListener()） 1234567891011121314151617// 被调用时，将关联的元素变成蓝色function bluify(e) { // 总是 true console.log(this === e.currentTarget); // 当 currentTarget 和 target 是同一个对象是为 true console.log(this === e.target); this.style.backgroundColor = '#A5D9F3';}// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('*');// 将 bluify 作为元素的点击监听函数，当元素被点击时，就会变成蓝色for (var i = 0; i &lt; elements.length; i++) { elements[i].addEventListener('click', bluify, false);} 内联事件处理函数中的 this当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素 123&lt;button onclick=\"alert(this.tagName.toLowerCase());\"&gt; Show inner this&lt;/button&gt; 上面的 alert 会显示 button，但是注意只有外层代码中的 this 是这样设置的，如果使用闭包（如下所示），则里面的 this 是指向 window/global 的 123&lt;button onclick=\"alert((function(){return this})());\"&gt; Show inner this&lt;/button&gt;","link":"/2017/10/09/JavaScript/27/"},{"title":"call，apply，bind 的定义与实现","text":"关于 bind 的实现原理以及用处可以参考 Function.prototype.bind() bind 方法的定义见 [Function.prototype.bind (thisArg [, arg1 [, arg2, …]])](http://lzw.me/pages/ecmascript/#324) 使用方式如下 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数 bind 返回的绑定函数也能使用 new 操作符创建对象（这种行为就像把原函数当成构造器），提供的 this 值被忽略，同时调用时的参数被提供给模拟函数 bind 方法与 call、apply 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数 还可以写成 fn.bind(obj, arg1)(arg2) 一句话概括就是 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 bind 方法的第一个参数作为 this，传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数 bind初级实现 123456789Function.prototype.bind = Function.prototype.bind || function (context) { // 记住 this，就是需要绑定 this 的实例函数（原函数） var _this = this; var argsArray = Array.prototype.slice.call(arguments); return function () { // 剔除第一个参数，其余作为参数来传递（提供给原函数） return _this.apply(context, argsArray.slice(1)); }} 这里存在一些问题，在于在预置参数功能丢失的现象（因为使用了 argsArray.slice(1)），比较好的解决方式是下面这种 1234567Function.prototype.bind = Function.prototype.bind || function (context) { var _this = this; var args = Array.prototype.slice.call(this.arguments, 1); return function () { return _this.apply(context, args.concat(Array.prototype.slice.call(arguments))) }} 但是 bind 当中还有一点比较特殊 bind 返回的函数如果作为构造函数，搭配 new 关键字出现的话，我们的绑定 this 就需要”被忽略” 这样一来就需要在构造函数的场景下来进行兼容 12345678910111213Function.prototype.bind = Function.prototype.bind || function (context) { var _this = this; var args = Array.prototype.slice.call(arguments, 1); var F = function () { }; F.prototype = this.prototype; var bound = function () { return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments))); } bound.prototype = new F(); return bound;} 如果比较严谨的话，还需要判断调用 bind 方法的一定要为一个函数，否则就抛出一个错误 123if (typeof this !== 'function') { throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)} 完整代码如下 1234567891011121314151617181920212223Function.prototype.bind = Function.prototype.bind || function (context) { // 判断调用对象是否是函数 if (typeof this !== 'function') { throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`) } // 记住 this，就是需要绑定 this 的实例函数（原函数） var _this = this; var args = Array.prototype.slice.call(arguments, 1); // 在构造函数的场景下来进行兼容（因为在搭配 new 使用的时候，绑定的 this 需要被忽略） var F = function () { }; F.prototype = this.prototype; var bound = function () { return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments))); } bound.prototype = new F(); return bound;} call 和 apply 的实现通过观察可以发现，在之前的实现里面，我们使用了很多 call 和 apply 这两个内部方法，接下来我们就尝试自己实现一下这两个方法 call 和 apply 本质是一样的，区别就在于参数的不同 call 方法的定义 [15.3.4.4 Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )](http://lzw.me/pages/ecmascript/#323) 简单来说就是 call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法 apply() 方法在使用一个指定的 this 值和参数值必须是数组类型的前提下调用某个函数或方法 原理call() 和 apply() 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 this 来获得它的引用，比如以对象 o 的方法来调用函数 f() 123f.call(o)f.apply(o) 大致原理如下所示 1234o.m = f; // 将 f 存储为 o 的临时方法o.m(); // 调用它，不传入参数delete o.m; // 将临时方法删除 在严格模式中，call() 和 apply() 的第一个参数都会变成 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined 在 ES3 或者非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代 简单来说就是，f.call(o) 其原理就是先通过 o.m = f 将 f 作为 o 的某个临时属性 m 存储，然后执行 m，执行完毕后将 m 属性删除 实现这里以 apply 为例 初级实现 12345Function.prototype.apply = function (context) { context.fn = this; context.fn(); delete context.fn;} 但是需要注意，这里分为两种情况，传递参数和没有传递参数，并且 apply 有一点不同，它的参数是一个数组，在执行的时候会把数组的值依次传递给函数当参数 所以就需要实现类似 context.fn(arg1, arg2, arg3 ...) 的调用方式，所以这里采用 ... 扩展运算符来依次传递参数 1234Function.prototype.apply = function (context) { context.fn(...arguments[1]) delete context.fn;} 有几个需要注意的地方 this 参数可以传递 null 或者不传，当为 null 的时候，则指向 window，并且函数也是可以指定返回值的 123456Function.prototype.myApply = function (context = window) { context.fn = this; let result = arguments[1] ? context.fn(...arguments[1]) : context.fn() delete context.fn; return result;} 而 call 方法，则跟 apply 类似，只需要注意每个函数都可以调用 call 方法，来改变当前这个函数执行的 this 关键字，并且支持传入参数 实现如下所示 1234567Function.prototype.call = function (context = window) { context.fn = this; let args = [...arguments].slice(1); let result = content.fn(...args) delete context.fn; return result;}","link":"/2018/04/16/JavaScript/32/"},{"title":"运算符优先级","text":"先来看看下面这个示例 12345678910111213var provider = { test: { $get: function () { return function anonymous(config) { console.log(this); // window }; } }};var type = \"test\";var config = {};new provider[type].$get()(config); 这里需要明确两点，一个是构造函数的返回，另一个是 new 操作符的执行顺序 构造函数的返回简单来说 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象 如果返回的是一个引用类型的值时，返回的是引用对象本身 比如如下示例 12345678910111213function Person() { }const person = new Person();console.log(typeof person); // object// ----function Person() { return function () { }}const person = new Person();console.log(typeof person); // function new 操作符的执行顺序在 MDN 的 new 操作符描述中，语法是 1new constructor[([arguments])] 可以发现，参数 arguments 是可缺省的，那么就意味着，对于不含参数的构造函数而言，new Person() 和 new Person 是一样的 那么又会涉及到一个问题，为什么执行的时候是执行的 new Person()，而不是 (new Person)() 呢，这里就涉及到操作符的执行顺序 这里也只列举几个这里用到的运算符，更多详细的可以参考 运算符优先级 (JavaScript) 优先级 运算类型 关联性 运算符 20 圆括号 n/a ( … ) 19 成员访问 从左到右 … . … new（带参数列表） n/a new … ( … ) 18 函数调用 从左到右 … ( … ) new（无参数列表） 从右到左 new … … 13 加法 从左到右 … + … 减法 从左到右 … - … 了解了原理之后，我们可以很轻松的将上面的问题解析为 12// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用(new provider[type].$get())(config); 这里还有一个扩展的小问题，下面的结果是多少 1var str = 'Hello' + true ? 'World' : 'JavaScript'; 结果是 World， 因为 + 运算符优先级是高于条件运算符的 其实就相当于执行了 ('Hello' + true) ? 'World' : 'JavaScript' 在来看一个操作符相关的问题 123456789101112131415161718192021222324252627282930313233function Foo() { getName = function () { console.log('1'); }; return this;}Foo.getName = function () { console.log('2');};Foo.prototype.getName = function () { console.log('3');};var getName = function () { console.log('4');};function getName() { console.log(5);}// 输出结果依次为多少Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName();// 结果为 2 4 1 1 2 3 3 一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方 1234567function Foo() { // 注意这里是全局的 getName = function () { console.log('1'); }; return this;} 还有下面这个，两者都会提升，但是函数声明的提升级别是要比 var 高的，所以实际执行的是 12345678function getName() { console.log(5);}// 会覆盖上面的var getName = function () { console.log('4');}; Foo.getName(); 函数 Foo 本身并没有执行，执行的是函数的属性 getName，输出的是 2 getName(); 这是在全局执行 getName()，根据我们上面的分析可知，输出的结果是 4 Foo().getName(); 因为 () 的优先级最高，所以首先运行 Foo()，全局的 getName 被覆盖成输出 console.log('1')，并且返回的 this 此时代表的是 window 也就是相当于执行了 window.getName()，所以输出的结果为 1 getName(); 这个因为之前调用了 Foo()，所以输出的结果仍然是 1 new Foo.getName(); 因为 . 操作符要比 new 优先级要高，所以执行的是 new (Foo.getName)()，所以输出为 2 new Foo().getName(); 根据优先级可知，带参数的 new 操作符是优先级最高的，所以执行的就是 (new Foo()).getName() 而 new Foo() 生成的对象身上没有 getName() 的方法，那么就会去 prototype 当中寻找，所以输出的是 3 new new Foo().getName(); 老规矩，按照优先级添加括号，首先带参数的 new 操作符优先级最高，则为 new (new Foo().getName()) 然后就会发现和上面是类似的，可以转换为 new ((new Foo()).getName())，所以输出的也为 3","link":"/2018/05/27/JavaScript/33/"},{"title":"JavaScript 并发模型","text":"JavaScript 的一大特点就是单线程，这意味着在任何时候只能有一段代码执行，JavaScript 主线程在运行时，会建立一个执行同步代码的栈和执行异步代码的队列 并发模型可以参考下面这个理论模型 JavaScript 执行引擎的主线程运行的时候，产生堆（heap）和栈（stack） 程序中代码依次进入栈中等待执行，若执行时遇到异步方法，该异步方法会被添加到用于回调的队列（queue）中（即 JavaScript 执行引擎的主线程拥有一个执行 栈/堆 和一个任务队列） 栈（stack）：函数调用会形成了一个堆栈帧 堆（heap）：对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域 队列（queue）：一个 JavaScript 运行时包含了一个待处理的消息队列 每一个消息都与一个函数相关联 当栈为空时，则从队列中取出一个消息进行处理 这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧） 当栈再次为空的时候，也就意味着该消息处理结束 Event Loop 这里主要介绍两个点，queue 和 callback 关于 queue，如上文的解释，值得注意的是，除了 IO 设备的事件（比如 load）会被添加到 queue 中，用户操作产生的事件（比如 click, touchmove）同样也会被添加到 queue 中 队列中的这些事件会在主线程的执行栈被清空时被依次读取（队列先进先出，即先被压入队列中的事件会被先执行） 关于 callback，被主线程挂起来的代码，等主线程执行队列中的事件时，事件对应的 callback 代码就会被执行 针对上面的并发模型和 JavaScript 的同步异步运行机制，我们可以看到整个流程大致是这样的 所有同步任务都在主线程上执行，形成一个执行栈（并发模型的 stack） 主线程之外，还存在一个任务队列（并发模型的 queue），只要异步任务有了运行结果，就在任务队列中放置一个事件 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件和那些对应的异步任务，于是等待结束状态，进入执行栈开始执行 主线程不断重复上面的第三步 因为主线程从 “任务队列” 中读取事件的过程是循环不断的，因此这种运行机制又称为 Event Loop（事件循环） 简单总结就是，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件（click，load，done） 只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些事件所对应的回调函数 定时器定时器一般主要指 setTimeout() 和 setInterval() 这两个函数，如下 1234567console.log(1);setTimeout(function () { console.log(2);}, 5000);console.log(3); 需要注意的是，定时器只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数 下面我们就结合 Event Loop 看看单线程的 JavaScript 执行引擎是如何来执行该方法的 JavaScript 执行引擎主线程运行，产生 heap 和 stack 从上往下执行同步代码，console.log(1) 被压入执行栈，因为 console.log() 方法是 webkit 内核支持的普通方法而非 WebAPIs 的方法，因此立即出栈被引擎执行，输出 1 JavaScript 执行引擎继续往下，遇到 setTimeout() 异步方法（如上图，setTimeout() 属于 WebAPIs），将 setTimeout(callback, 5000) 添加到执行栈 因为 setTimeout() 属于 WebAPIs 中的方法，JavaScript 执行引擎在将 setTimeout() 出栈执行时，注册 setTimeout() 延时方法交由浏览器内核其他模块（以 webkit 为例，是 webcore 模块）处理 继续运行 setTimeout() 下面的 console.log(3) 代码，原理同步骤 2 当延时方法到达触发条件，即到达设置的延时时间时（5 秒后），该延时方法就会被添加至任务队列里，这一过程由浏览器内核其他模块处理，与执行引擎主线程独立 JavaScript 执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行 将队列的第一个回调函数重新压入执行栈，执行回调函数中的代码 console.log(2)，原理同步骤 2，回调函数的代码执行完毕，清空执行栈 JavaScript 执行引擎继续轮循队列，直到队列为空 执行完毕 以上就是一个基本的 JavaScript 并发模型 下面再来看一个经典的案例 1234567891011121314151617181920// 请写出下面代码的输出结果setTimeout(() =&gt; { console.log(1)}, 0);console.log(2);new Promise((res) =&gt; { console.log(3) res() console.log(4)}).then(() =&gt; { console.log(5)}).then(() =&gt; { console.log(6)})console.log(7)// 2 3 4 7 5 6 1 唯一需要注意的地方就是，新建的 Promise 对象时需要传入一个函数参数，这个函数参数是同步代码 Macrotask 和 Microtask在之前定时器的示例当中，Promise 在 resolve 后先于 setTimeout 执行，说明 Promise 任务的优先级比 setTimeout 任务的优先级要高 这就引出了两个概念：Macrotask（宏任务）和 Microtask（微任务），两者的区别如下 Macrotask 包含 setTimeout，setInterval，setImmediate，I/O，UI rendering Microtask 包含 process.nextTick，Promises，Object.observe（废弃），MutationObserver 执行顺序Macrotask 和 Microtask 的执行顺序如下 在执行每个 Macrotask（宏任务）之前，会先检查有微任务队列中有没有任务需要处理，若有，就先将微任务队列中的任务全部放入同步执行栈中执行，直到微任务队列被清空 然后再执行宏任务队列中的任务，循环往复，比如下面这个例子 123456789101112131415161718192021setTimeout(() =&gt; { console.log(1)}, 0)new Promise((res) =&gt; { res()}).then(() =&gt; { console.log(4)}).then(() =&gt; { console.log(5)}).then(() =&gt; { console.log(6)}).then(() =&gt; { console.log(7)}).then(() =&gt; { console.log(8)}).then(() =&gt; { console.log(9)}).then(() =&gt; { console.log(10)}) 因此，这就能解释为什么 Promise 会优先于 setTimeout 执行，即使 Promise 的执行链很长 这是因为 setTimeout 属于 Macrotask，而 Promise 属于 Microtask，在执行 Macrotask 之前需要先将 Microtask 队列清空 简单的总结就是 Microtask 会优先 Macrotask 执行 Microtask 会被循环提取到执行引擎主线程的执行栈，直到 Microtask 任务队列清空，才会执行 Macrotask 参考 并发模型与事件循环 JavaScript 的并发模型","link":"/2018/08/12/JavaScript/36/"},{"title":"Map / forEach","text":"先来看一看 MDN 上对 Map 和 ForEach 的定义 forEach() 方法对数组的每个元素执行一次提供的函数 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 两者的共同点 都是循环遍历数组中的每一项， forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数（数组中的当前项 item，当前项的索引 index，原始数组 input） 匿名函数中的 this 都是指 window 只能遍历数组 forEach()首先需要注意，forEach() 方法是没有返回值的 它不会返回执行结果，而是 undefined，也就是说，forEach() 会修改原来的数组（而 map() 方法会得到一个新的数组并返回） 123arr[].forEach(function (value, index, array) { // ...}) 参数 value 为数组中的当前项，index 当前项的索引，array 原始数组 数组中有几项，那么传递进去的匿名回调函数就需要执行几次 理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组 123456789let ary = [12, 23, 24, 42, 1];let res = ary.forEach(function (item, index, input) { input[index] = item * 10;})console.log(res); // --&gt; undefinedconsole.log(ary); // --&gt; 通过数组索引改变了原数组 map()是有返回值的，并且可以通过 return 操作符返回出来 123456arr[].map(function (value, index, array) { // ... return xxx}) 参数 value 为数组中的当前项，index 当前项的索引，array 原始数组 区别在于 map 的回调函数中支持 return 返回值 return的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了） 12345678let ary = [12, 23, 24, 42, 1];let res = ary.map(function (item, index, input) { return item * 10;})console.log(res); // --&gt;[120, 230, 240, 420, 10] 原数组拷贝了一份，并进行了修改console.log(ary); // --&gt;[12, 23, 24, 42, 1] 原数组并未发生变化 速度对比可以使用 jsPref 来进行两者的速度比较，map-vs-foreach-speed-test 结果如下 哪个更好至于这两个方法哪个更好，完全取决于你想要做什么（使用场景） forEach 适合于你并不打算改变数据的时候，而只是想用数据做一些事情，比如打印数据 12345678910let arr = ['a', 'b', 'c', 'd'];arr.forEach(letter =&gt; { console.log(letter);});// a// b// c// d 而 map() 适用于你要改变数据值的时候，不仅仅在于它更快，而且返回一个新的数组 这样的优点在于你可以使用复合（map()，filter()，reduce() 等组合使用）来玩出更多的花样 1234let arr = [1, 2, 3, 4, 5];let arr2 = arr.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5);// arr2 = [6, 8, 10] 我们首先使用 map 将每一个元素乘以 2，然后紧接着筛选出那些大于 5 的元素，最终结果赋值给 arr2 附录：JavaScript 中数组迭代的方法","link":"/2018/09/12/JavaScript/37/"},{"title":"Angular-CLI 与其整体架构","text":"因为年后公司项目转向 Angular 架构了，只有暂时性的放下 vue 和 react，赶紧抓紧时间学习 Angular 跟上大部队的脚步才是 俗话说得好，技多不压身，就当学习一门新的框架了，XD Angular 在 2.x 之后的版本中相较与 1.x 的版本变化很多，说其为两个不同的框架也不为过 在新的版本当中，提供了一个 Angular-CLI 的脚手架，用于实现自动化开发工作流程，它可以创建一个新的 Angular 应用程序，并附带以下相关工具 运行带有 LiveReload 支持的开发服务器，以便在开发过程中预览应用程序 添加功能到现有的 Angular 应用程序（提供了一系列 ng g xxx 相关命令） 运行应用程序的单元测试 运行应用程序的端到端（E2E）测试 构建应用程序 那么就先从最基本的 Angular-CLI 生成的目录结构以及相关初始化入口文件开始 Angular-CLI 目录结构12345678910111213141516171819202122232425262728293031323334353637├── e2e 端到端│ ├── app.e2e-spec.ts 端到端测试文件│ ├── app.po.ts 端到端测试入口文件│ └── tsconfig.e2e.json 用于端到端测试的 typescript 编译器的配置文件├── node_modules 第三方依赖包├── src 项目主文件所在目录│ ├── app 组件所在文件夹│ │ ├── app.component.css 组件的样式文件│ │ ├── app.component.html 组件的 HTML 模板文件│ │ ├── app.component.spec.ts 组件的单元测试文件│ │ ├── app.component.ts 组件定义文件│ │ └── app.module.ts 模块定义配置文件│ ├── assets 静态资源│ │ └── .gitkeep assets 目录用于存放图片等静态资源文件，构建时会拷贝到发布包里，新创建时一般为空│ │ 但是由于 git 会忽略空文件夹，放置 .gitkeep 这个空文件以保证目录得到管理│ ├── environments 环境│ │ ├── environment.prod.ts 生产环境配置文件，在 .angular-cli.json 中被 mapping，mapping 值为 prod│ │ └── environment.ts 开发环境配置，在 .angular-cli.json 中被 mapping，mapping 值为 dev│ ├── favicon.ico 网页左上角显示的图标│ ├── index.html 项目主页│ ├── main.ts Angular 程序的入口│ ├── polyfills.ts 不同浏览器，比如一些老旧的浏览器及版本的支持│ ├── styles.css 全局的样式│ ├── test.ts 单元测试入口│ ├── tsconfig.app.json Angular 应用的 typescript 编译器的配置文件│ ├── tsconfig.spec.json 单元测试的 typescirpt 编译器的配置文件│ ├── tsconfig.app.json Angular 应用的 typescript 编译器的配置文件│ └── typings.d.ts 项目中使用的 typescript 类型的引用文件├── .angular-cli.json CLI 的配置文件，可以设定项目的基础信息，比如构建后的目标目录名称等├── .editorconfig 编辑器的配置文件├── .gitignore 为了保证自动生成的文件不被提交的 git 配置文件├── karma.conf.js karma 单元测试的配置文件├── package.json npm 的配置文件以及第三方依赖包├── protractor.conf.js protractor 的端到端测试的配置文件├── README.md 项目的基本信息，主要包含使用 cli 命令如何对项目进行 构建/测试/运行 等├── tsconfig.json typescirpt 编译器的配置文件└── tslint.json 提供给 TSLint 和 Codelyzer 的配置信息 app.module.ts这个模块的作用是告诉 Angular 如何组装该应用 12345678910111213141516171819202122232425262728293031// app.module.ts// 浏览器解析的模块import { BrowserModule } from '@angular/platform-browser';// Angular 核心模块import { NgModule } from '@angular/core';// 自定义模块import { AppComponent } from './app.component';// @NgModule 装饰器将 AppModule 标记为 Angular 模块类（也称为 NgModule 类）// @NgModule 接受一个元数据对象，告诉 Angular 如何编译和启动应用@NgModule({ // 引入当前项目运行的组件，自定义组件都需要引入并且在这个里面进行配置（定义） declarations: [ AppComponent ], // 引入其他的模块，表示当前的项目依赖哪些模块（比如请求数据的模块等） imports: [ BrowserModule ], // 注入服务 providers: [], // 默认的启动哪个组件 bootstrap: [AppComponent]})// 导出模块，因为是根模块，所以不需要导出任何东西，默认为空即可// 但是需要注意，一定要写，即使导出为空export class AppModule { } app.component.ts1234567891011121314151617// app.component.ts// 引入 Angular 中的 Component 组件import { Component } from '@angular/core';@Component({ // 使用组件的名称 selector: 'app-root', // 组件对应的 html templateUrl: './app.component.html', // 组件对应的 css styleUrls: ['./app.component.css']})// 数据export class AppComponent { title = 'app';} 整体架构整体架构可以如下图所示 Angular 使用扩展语法编写 HTML 模版，使用组件对其进行管理，通过服务来添加应用逻辑，最后使用模块来对组件进行打包 通过引导根模块来启动应用，Angular 在浏览器中接管、展现应用的内容，根据操作指令响应用户的交互 Angular 的架构主要分为四大块 组件 - Angular 应用的基本构件块，可以简单的理解为一个组件就是一段带有业务逻辑和数据的 HTML 指令 - 允许向 HTML 元素添加自定义行为 模块 - 模块用来将应用中不同的部分组织成一个 Angular 框架可以理解的单元（组件） 服务 - 用来封装可从用的业务逻辑 启动过程整个启动过程是通过引导模块来进行的，每个 Angular 应用至少应该有一个模块，而此模块被称为根模块（App Module） 根模块 @NgModule 装饰器所谓的根模块，也就是我们的 app.module.ts 文件，如下所示 12345678910111213141516171819202122232425262728import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';// @NgModule 装饰器用来为模块定义元数据@NgModule({ // declarations 列出了应用中的顶层组件，包括引导性组件 AppComponent 和我们自己创建的组件 // 在 module 里面声明的组件在 module 范围内都可以直接使用 // 也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件 declarations: [ AppComponent, ... ], // 引入相关依赖 // BrowserModule 提供了运行在浏览器中的应用所需要的关键服务（Service）和指令（Directive） // 这个模块所有需要在浏览器中跑的应用都必须引用 imports: [ BrowserModule ], // providers 列出会在此模块中 \"注入\" 的服务（Service） providers: [], // bootstrap 指明哪个组件为引导性组件（默认的是 AppComponent） // 当 Angular 引导应用时，它会在 DOM 中渲染这个引导性组件 // 并把结果放进 index.html 的该组件的元素标签中（默认为 app-root） bootstrap: [AppComponent]})export class AppModule { } 而根模块在 Angular 程序的入口 main.ts 中被使用，也就是所谓的引导过程 Angular 通过在 main.ts 中引导 AppModule 来启动应用，但是针对不同的平台 Angular 提供了很多引导选项 默认的采用是即时（JiT）编译器动态引导，一般多用在进行开发调试的时候 12345678910111213141516// main.ts// 连同 Angular 编译器一起发布到浏览器import { enableProdMode } from '@angular/core';import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';import { AppModule } from './app/app.module';import { environment } from './environments/environment';if (environment.production) { enableProdMode();}// 对 AppModule 进行引导// Angular 编译器在浏览器中编译并引导该应用platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)); 另一种方式是使用预编译器（AoT - Ahead-Of-Time）进行静态引导，静态方案可以生成更小、启动更快的应用 建议优先使用它，特别是在移动设备或高延迟网络下，使用 static 选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂 它们的核心就是 AppModuleNgFactory，引导预编译的 AppModuleNgFactory 的语法和动态引导 AppModule 类的方式很相似 12345678// 不把编译器发布到浏览器import { platformBrowser } from '@angular/platform-browser';// 静态编译器会生成一个 AppModule 的工厂 AppModuleNgFactoryimport { AppModuleNgFactory } from './app.module.ngfactory';// 引导 AppModuleNgFactoryplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory); 模块化Anagulr 应用是模块化的，被称为 NgModule @NgModule 是一个装饰器，装饰器其实是函数，是用来 ‘装饰’ 函数，它可以把元数据附加到类上 NgModule 装饰器用来描述模块属性，常见的模块属性如下所示 属性 说明 declarations 声明本模块中拥有的视图类，Angular 有三种视图类：组件，指令和管道 exports declarations 的子集，可用于其他模块的组件模版 imports 本模块声明的组件模板需要的类所在的其他模块 providers 服务的创建者，并加入到全局服务列表中，可用于应用任何部分 bootstrap 指定应用的主视图（根组件），它是所有其他视图的宿主 有两个地方需要注意 exports 属性并不是必须的，因为其他组件无需导入根模块，所以根模块也不需要导出 只有根模块才能设置 bootstrap 属性 Angular 模块库Angular 提供了一组模块库，比如 NgModule 就是 angular/core 的 Angular 库中的模块 Angular 的库都带有 @angular 的前缀 组件和 @NgModule 类似，@Component 为 Angular 的组件装饰器，主要属性如下 属性 说明 selector CSS 选择器，它告诉 Angular 在父级 HTML 中查找 selector 中定义的标签，创建并插入该组件 template/templateUrl 组件或者组件 HTML 模块的相对地址 providers 组件所需服务的依赖注入提供商数组，这是在告诉 Angular 该组件的构造函数需要一个 HeroService 服务，这样组件就可以从服务中获得数据 在根模块的 bootstrap 属性中设定了 AppComponent 组件，说明根模块引导的为 AppComponent 组件 1234567891011import { Component } from '@angular/core';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'Angular Examples';} 装饰器 @Component 将三个东西结合在了一起，selector 和 HTML 模板以及 CSS 样式 通过插值的方式保证数据进行交互和传递 通过修改填充的内容则可以直接影响输出 通过 CSS 样式直接调整显示，做到数据和显示的分离 这也就是整体 Angular 程序的启动过程，不过特别需要注意的是 当组件编写完成后还需要进行组件声明后才能使用，每个组件都必须在一个 Angular 模块而且只能在一个 Angular 模块中进行声明 一个简单的双向绑定示例在新的版本当中，使用 Angular 双向绑定与之前有所不同 因为需要在当前模块中首先引入 FormsModule 模块才能使用双向绑定 12345678910111213// 当前所在的模块 xx.module.ts，特别需要注意，要使用双向绑定，需要引入 FormsModule 模块import { BrowserModule } from '@angular/platform-browser'import { NgModule } from '@angular/core'import { AppComponent } from './app.component'import { FormsModule } from '@angular/forms'@NgModule({ imports: [ BrowserModule, FormsModule ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]})export class AppModule { } 123456789101112131415161718192021// 组件部分 xx.component.tsimport { Component } from '@angular/core'import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'import { AppModule } from './app.module'// 定义组件的元信息@Component({ selector: 'my-app', templateUrl: './app.component.html'})// 定义组件类export class AppComponent { hero: Hero = { name: 'zhangsan' }}export class Hero { name: String} 然后在模版当中使用即可，注意要使用 [(...)]=&quot;&quot; 格式来进行绑定 12// 模版文件 xx.component.html&lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"&gt;","link":"/2018/10/12/Angular/01/"},{"title":"Angular 中的装饰器","text":"Angular 中的装饰器可以简单的总结为以下几句 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 它分为 类装饰器 (Class decorators) 属性装饰器 (Property decorators) 方法装饰器 (Method decorators) 参数装饰器 (Parameter decorators) TypeScript 中的装饰器123456789101112131415161718192021222324252627// 类装饰器// 用来装饰类的，它接收一个参数：// target: TFunction - 被装饰的类declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void// 属性装饰器// 用来装饰类的属性，它接收两个参数：// target: Object - 被装饰的类// propertyKey: string | symbol - 被装饰类的属性名declare type PropertyDecorator = (target:Object, propertyKey: string | symbol ) =&gt; void;// 方法装饰器// 用来装饰类的属性，它接收三个参数// target: Object - 被装饰的类// propertyKey: string | symbol - 方法名// descriptor: TypePropertyDescript - 属性描述符declare type MethodDecorator = &lt;T&gt;(target:Object, propertyKey: string | symbol, descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;// 参数装饰器// 用来装饰函数参数，它接收三个参数// target: Object - 被装饰的类// propertyKey: string | symbol - 方法名// parameterIndex: number - 方法中参数的索引值declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number ) =&gt; void Angular 内置装饰器 类装饰器 - @Component、@NgModule、@Pipe、@Injectable 属性装饰器 - @Input、@Output、@ContentChild、@ContentChildren、@ViewChild、@ViewChildren 方法装饰器 - @HostListener、@HostBinding 参数装饰器 - @Inject、@Optional、@Self、@SkipSelf、@Host 这里主要介绍 @Input，@Output，@ViewChild，@ViewChildren，@HostListener 和 @HostBinding 六种 InputInput 是属性装饰器，用来定义组件内的输入属性，一般用来实现父组件向子组件传递数据 @Input()123456789101112131415161718192021222324252627282930313233343536// counter.component.tsimport { Component, Input } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0; increment() { this.count++; } decrement() { this.count--; }}// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5;} @Input(‘bindingPropertyName’)Input 装饰器支持一个可选的参数，用来指定组件绑定属性的名称 如果没有指定，则默认使用 @Input 装饰器，装饰的属性名，如下所示 12345678910111213// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0;}// app.component.ts@Component({ selector: 'exe-app', // 绑定的时候如果写成 [value]，那么在 @Input() 接收的时候指定为 value 即可 template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `}) inputs还可以使用 inputs 属性将绑定的输入属性名称直接写到 @Component({}) 的元数据当中 12345678910111213141516171819// counter.component.tsexport class CounterComponent { @Input('value') count: number = 0;}// app.component.ts@Component({ selector: 'exe-app', template: ` &lt;exe-counter [value]=\"initialCount\"&gt;&lt;/exe-counter&gt; `, // 如果模版当中指定的为 [count]=\"initialCount\" // 可以直接写为 inputs: ['count'] inputs: ['count: value']})export class CounterComponent { count: number = 0;} 不过需要注意的是，不能同时使用 @Input 装饰器，或在 @Directive、@Component inputs 字段中定义同一个输入属性 12345678// 错误的使用方式@Component({ selector: 'exe-counter', inputs:['count:value'] })export class CounterComponent { @Input('value') count: number = 0;} @Input 和 inputs 两者的区别它们都是用来定义输入属性，而不同的地方在于 inputs 定义在指令的 metadata 信息中，开发者对指令的输入属性一目了然 此外对于未选用 TypeScript 作为开发语言的开发者，也只能在 metadata 中定义指令的输入属性 @Input 属于属性装饰器，通过它可以一起定义属性的访问描述符（public、private、protected） 1@Input() public attr: string; @Output 与其类似 1@Output('countChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); setter &amp; gettersetter 和 getter 是用来约束属性的设置和获取，它们提供了一些属性读写的封装，可以让代码更便捷，更具可扩展性 通过 setter 和 getter 方式，我们对类中的私有属性进行了封装，能避免外界操作影响到该私有属性 123456789101112131415161718192021222324252627282930313233import { Component, Input } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }} &lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { _count: number = 0; biggerThanTen: boolean = false; @Input() set count (num: number) { this.biggerThanTen = num &gt; 10; this._count = num; } get count(): number { return this._count; } increment() { this.count++; } decrement() { this.count--; }} OutputOutput 是属性装饰器，用来定义组件内的输出属性，主要用来实现子组件将信息通过事件的形式通知到父级组件 EventEmitterOutput 属性装饰器一般是和 EventEmitter 一起相互配合来使用的，先看 EventEmitter 12345let numberEmitter: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); numberEmitter.subscribe((v: number) =&gt; console.log(v));numberEmitter.emit(10); 具体的应用流程为 子指令创建一个 EventEmitter 实例，并将其作为输出属性导出 子指令调用已创建的 EventEmitter 实例中的 emit(payload) 方法来触发一个事件 而父指令通过事件绑定 (eventName) 的方式监听该事件，并通过 $event 对象来获取 payload 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// counter.component.tsimport { Component, Input, Output, EventEmitter } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent { @Input() count: number = 0; @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); increment() { this.count++; this.change.emit(this.count); } decrement() { this.count--; this.change.emit(this.count); }}// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'exe-app', template: ` &lt;exe-counter [count]=\"initialCount\" (change)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `})export class AppComponent { initialCount: number = 5; countChange(ev: number) { console.log('${ev}') }} @Output(‘bindingPropertyName’)同 @Input 一样，@Output 装饰器支持一个可选的参数，用来指定组件绑定属性的名称 如果没有指定，则默认使用 @Output 装饰器，装饰的属性名 12345678910111213// counter.component.tsexport class CounterComponent { @Output('counterChange') change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();}// app.component.ts@Component({ template: ` &lt;exe-counter [count]=\"initialCount\" (counterChange)=\"countChange($event)\"&gt;&lt;/exe-counter&gt; `}) outputs同 inputs 一样，也支持在组建内部添加 outputs 属性，但是和上面一样不太推荐这种写法 ngOnChanges当数据绑定输入属性的值发生变化的时候，Angular 将会主动调用 ngOnChanges 方法 它会获得一个 SimpleChanges 对象，包含绑定属性的新值和旧值，它主要用于监测组件输入属性的变化 1234567891011121314151617181920212223242526import { Component, Input, SimpleChanges, OnChanges } from '@angular/core';@Component({ selector: 'exe-counter', template: ` &lt;p&gt;当前值: {{ count }}&lt;/p&gt; &lt;button (click)=\"increment()\"&gt; + &lt;/button&gt; &lt;button (click)=\"decrement()\"&gt; - &lt;/button&gt; `})export class CounterComponent implements OnChanges{ @Input() count: number = 0; ngOnChanges(changes: SimpleChanges) { console.dir(changes['count']); } increment() { this.count++; } decrement() { this.count--; }} 可以在控制台当中看到 SimpleChanges 对象的一些值（包括新值和旧值） 需要注意的是，当手动改变输入属性的值，是不会触发 ngOnChanges 钩子的 @ViewChild()通过 @ViewChild() 装饰器可以获得子组件的引用，从而可以在父组件当中来直接调用子组件的方法 12// 父组件&lt;app-header #child1&gt;&lt;/app-header&gt; 12345678910111213141516171819export class AppComponent implements OnInit{ @ViewChild('child1') child1: HeaderComponent; ngOnInit() { this.child1.run('...'); }}// 子组件export class HeaderComponent implements OnInit { constructor() { } ngOnInit() { } run(name) { console.log(name); }} @ViewChild 使用类型查询1234567891011121314151617181920212223242526272829303132333435// child.component.tsimport { Component, OnInit } from '@angular/core';@Component({ selector: 'exe-child', template: ` &lt;p&gt;Child Component&lt;/p&gt; `})export class ChildComponent { name: string = 'child-component';}// app.component.tsimport { Component, ViewChild, AfterViewInit } from '@angular/core';import { ChildComponent } from './child.component';@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { // 通过 @ViewChild() 来获取子组件 @ViewChild(ChildComponent) childCmp: ChildComponent; ngAfterViewInit() { console.dir(this.childCmp); }} ViewChildrenViewChildren 用来从模版视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 123456789101112131415161718192021import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';import { ChildComponent } from './child.component';@Component({ selector: 'my-app', template: ` &lt;h4&gt;Welcome to Angular World&lt;/h4&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; &lt;exe-child&gt;&lt;/exe-child&gt; `,})export class AppComponent { @ViewChildren(ChildComponent) childCmps: QueryList&lt;ChildComponent&gt;; ngAfterViewInit() { console.dir(this.childCmps); }} 运行之后可以在控制台当中看到输出多个 ChildComponent 小结ViewChild 装饰器用于获取模板视图中的元素，它支持 Type 类型或 string 类型的选择器 同时支持设置 read 查询条件，以获取不同类型的实例 ViewChildren 装饰器是用来从模板视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合 HostListener &amp; HostBindingHost Element（宿主元素）宿主元素的概念同时适用于指令和组件，对于指令来说，应用指令的元素，就是宿主元素 如果在自定义组件中使用的话，那么自定义组件就是宿主元素 HostListenerHostListener 是属性装饰器，用来为宿主元素添加事件监听 HostListenerDecorator 装饰器定义如下 1234export interface HostListenerDecorator { (eventName: string, args?: string[]): any; new (eventName: string, args?: string[]): any;} 使用 1234567891011121314import { Directive, HostListener } from '@angular/core';@Directive({ selector: 'onClicks'})export class onClicks { @HostListener('click') onClick() { // ... }} 此外还可以监听宿主元素外，其他对象产生的事件，比如 window 或 document 对象 一个点击目标区域会添加背景颜色，点击其他区域取消掉高亮 1234567891011121314151617181920export class SetBackgroundDirective { constructor( private el: ElementRef, private re: Renderer2 ) {} @HostListener('document:click', ['$event']) onClick(btn: Event) { if (this.el.nativeElement.contains(event.target)) { this.highlight('yellow'); } else { this.highlight(null); } } highlight(color: string) { this.re.setStyle(this.el.nativeElement, 'backgroundColor', color); }} Host Event Listener还可以使用 host 参数来进行绑定（不太建议使用这种方式，推荐使用装饰器风格） 123456789101112131415import { Directive } from '@angular/core';@Directive({ selector: 'button[counting]', host: { '(click)': 'onClick($event.target)' }})export class CountClicks { numberOfClicks = 0; onClick(btn: HTMLElement) { console.log('button', btn, 'number of clicks:', this.numberOfClicks++); }} HostBindingHostBinding 是属性装饰器，用来动态设置宿主元素的属性值，定义如下 1234export interface HostBindingDecorator { (hostPropertyName?: string): any; new (hostPropertyName?: string): any;} 应用 123456789101112131415161718@Directive({ selector: '[exeButtonPress]'})export class ExeButtonPress { @HostBinding('attr.data') data = 'button'; @HostBinding('class.active') isActive: boolean; @HostListener('mouseenter') enter() { this.isActive = true; } @HostListener('mouseleave') leave() { this.isActive = false; }} 和上面一样，我们也可以在指令的元数据当中来进行绑定（同样的不建议这样使用） 123456789101112131415161718192021@Directive({ selector: '[exeButtonPress]', host: { 'data': 'button', '[class.active]': 'isActive' }})export class ExeButtonPress { isActive: boolean; @HostListener('mouseenter') enter() { this.isActive = true; } @HostListener('mouseleave') leave() { this.isActive = false; }}","link":"/2018/12/05/Angular/05/"},{"title":"ExpressionChangedAfterItHasBeenCheckedError","text":"最近在开发过程中，遇到了 ExpressionChangedAfterItHasBeenCheckedError 这个错误 google 一翻后，发现各种说法众说纷纭，所有抽出时间深入了解一下这个错误，做一下总结，也可以避免以后在遇到这个问题的时候不知道怎么处理 简单来说，这个错误主要涉及到 Angular 的变化监测机制 关于变化监测每个 Angular 应用都是以组件树的形态呈现的，Angular 在变化监测阶段会按以下的顺序对每个组件执行如下操作（标记为 List1） 更新所有绑定在子 component/directive 上的属性 调用所有子 component/directive 的 ngOnInit，ngOnChanges，ngDoCheck 生命周期函数 解析、更新当前组件 DOM 上的 value 运行子 component 的变化监测流程（List1） 调用所有子 component/directive 上的 ngAfterViewInit 生命周期 每一步操作后，Angular 会保存与这次操作有关的 values 值，这个值被存在组件 view 的 oldValues 属性中 在开发模式下，所有组件完成变化监测之后 Angular 会开始下一个监测流程，第二次监测流程并不会再次执行上面列出的变化监测流程，而会比较之前变化监测循环保存的值（存在 oldValues 中的）与当前监测流程的值是否一致（标记为 List2） 检查被传递到子组件的 values（oldValues）与当前组件要被用于更新的 values（instance.value）是否一致 检查被用于更新 DOM 元素的 values（oldValues）与当前要被用于这些组件更新的 values（instance.value）是否一致 对所有子 component 执行相同的检查 需要注意的是：这些额外的检查（List2）只发生在开发模式下 示例接下来我们来看一个例子，假设你有一个父组件 A 和一个子组件 B，A 组件中有两个属性 name 和 text，A 组件的模板中使用了 name 属性 1template: '&lt;span&gt;{{name}}&lt;/span&gt;' 然后在模板中加入 B 组件，并且通过输入属性绑定给 B 组件输入 text 属性 123456789101112@Component({ selector: 'a-comp', template: ` &lt;span&gt;{{name}}&lt;/span&gt; &lt;b-comp [text]=\"text\"&gt;&lt;/b-comp&gt; `})export class AComponent { name = 'I am A component'; text = 'A message for the child component';} 那么 Angular 在开始变化监测后会发生什么呢？ List1 变化监测会从 A 组件开始检查，第一步将 text 表达式中的 A message for the child component 向下传递到 B 组件，并且将这个值存在 view 上 1view.oldValues[0] = 'A message for the child component'; 然后到了变化监测列表里的第二步，调用相应的生命周期函数 接下来执行第三步，将 表达式解析为 I am A component 文本，将解析好的值更新到 DOM 上，并且存入 oldValues 1view.oldValues[1] = 'I am A component'; 最后 Angular 对 B 组件执行相同的操作（List1），一旦 B 组件完成以上的操作，此次变化监测循环便完成了 但是如果 Angular 在开发模式下运行，那么将会执行另一个监测流程（List2） text 属性在传递给 B 组件时的值是 A message for the child component 并存入 oldValues ，现在想象一下 A 组件在此之后将 text 的值更新为 updated text 然后 List2 的第一步将会检查 text 属性是否被改变 12AComponentView.instance.text === view.oldValues[0]; // false'updated text' === 'A message for the child component'; // false 这个时候 Angular 就该抛出这个错误了 1ExpressionChangedAfterItHasBeenCheckedError 同理，如果更新已经被渲染在 DOM 中并且被存在 oldValues 中的 name 属性，也会抛出相同的错误 12AComponentView.instance.name === view.oldValues[1]; // false'updated name' === 'I am A component'; // false 现在你可能会有些疑惑，这些值怎么会被改变呢？ 数据改变的原因罪魁祸首一般都是子组件或指令，下面我们来详细的看一下之前的示例 我们将在子组件的 ngOnInit（此时数据已绑定）生命周期钩子中更新 text 属性 12345678910// B 组件export class BComponent { @Input() text; constructor(private parent: AppComponent) { } ngOnInit() { this.parent.text = 'updated text'; }} 我们可以看到预期的错误 123Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'A message for the child component'. Current value: 'updated text'. 现在我们对被用于父组件模板的 name 属性做相同的操作 123ngOnInit() { this.parent.name = 'updated name';} 这时候程序并没有报错，为什么会这样呢？ 如果你仔细看变化监测（List1）的执行顺序，你会发现子组件的 ngOnInit 将在当前 component 的 DOM 更新之前被调用（在记录 oldValues 前改变了数据），这就是为什么上面的例子中更改 name 属性却不会报错 然后我们来利用一个在 DOM 中 values 更新之后的钩子来做实验，比如 ngAfterViewInit 是一个不错的选择 123456789export class BComponent { @Input() text; constructor(private parent: AppComponent) {} ngAfterViewInit() { this.parent.name = 'updated name'; }} 我们又一次得到了预期的错误 123AppComponent.ngfactory.js:8 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'I am A component'. Current value: 'updated name'. 当然现实中遇到的情况会更加错综复杂，父组件中属性在二次监测之前被更新通常是使用的外部服务或 observabals 间接导致的，但是其本质原因是相同的 可行解决方案如果你 google 过这个错误，那么你应该看过一些回答推荐使用异步更新数据和强制增加一个变化监测循环两种方法来解决这个错误 比如在动态创建组件的情况下，解决这个问题最好的方案是改变创建组件时所处的生命周期钩子 虽然这两种方式都可以解决问题，但是还是更推荐重新设计你的应用而不是使用这两种方法来解决这个问题 异步更新你应该注意到一件事，不管是变化监测还是第二次的验证 digest 都是同步执行的 这意味着如果我们在代码中异步更新属性的值，那么在第二次验证循环运行时这些属性是不会被改变的，那么也就不会报错了 123456789101112131415161718export class BComponent { name = 'I am B component'; @Input() text; constructor(private parent: AppComponent) {} ngOnInit() { setTimeout(() =&gt; { this.parent.text = 'updated text'; }); } ngAfterViewInit() { setTimeout(() =&gt; { this.parent.name = 'updated name'; }); }} 确实没有错误抛出，setTimeout 将函数加入 macrotask 队列中，函数会在下一个 VM 周期里被调用 也可以通过使用 promise 里的 then 回调将函数加入当前 VM 周期其他同步代码被执行完之后 1Promise.resolve(null).then(() =&gt; this.parent.name = 'updated name'); Promise.then 并不会被放入 macrotask，而是创建一个 microtask microtask 队列将在当前周期中所有同步代码被执行完毕之后执行，因此属性的更新会发生在验证步骤之后 另外补充一个知识点，给 EventEmitter 传一个 true 能使事件的 emit 变为异步 1new EventEmitter(true); 强制变化监测另一个解决方案是在父组件 A 的第一和第二次验证之间强制加一个变化监测循环 触发强制变化监测的最佳位置是在 ngAfterViewInit 生命周期内，这时候所有的子组件的流程都已经执行完毕，所以随便在之前的哪个位置改变父组件的属性都无所谓 12345678910export class AppComponent { name = 'I am A component'; text = 'A message for the child component'; constructor(private cd: ChangeDetectorRef) { } ngAfterViewInit() { this.cd.detectChanges(); }} 一样没有报错，但是其实这里有个问题，当在父组件 A 中触发新添加的变化监测时，Anuglar 同样会为所有的子组件运行一次变化监测，那么父组件可能会被又一次更新 为什么需要第二次监测循环Angular 强制使用至上而下的单向数据流，在父元素完成变化监测之后不允许内部子组件在第二次变化监测前改变父组件的属性，这能确保第一次变化监测后的组件树是稳定的 如果在监测循环周期里有属性的改变导致依赖这些属性的使用者需要同步更新变化，那么这棵组件树就是不稳定的 上面例子中子组件 B 依赖父组件的 text 属性，每当属性的值改变，在这些改变被传递到 B 组件之前这棵组件树都处于不稳定的状态 这同样体现在 DOM 与属性之间的关系上，DOM 作为这些属性的使用者，然后将这些属性渲染到 UI 界面上，如果某些属性没有同步更新到界面上，用户将会看到错误的界面 所以如果你在数据同步过程完成之后再通过子组件修改父组件中的属性会发生什么呢？ 是的，你留下了一个不稳定的组件树，其中数据变更的顺序将无法预测，大部分时候这将会给用户呈现出一个有错误数据的页面，而且问题的排查将十分困难 可能你会问了，那为什么不等到组件树稳定之后再进行变化监测呢？ 答案很简单，组件树可能永远不会稳定下来，一个子组件更新了父组件中的属性，父组件的属性又更新子组件的状态，子组件状态的更新又触发更新父组件的属性… 这将是个无限循环，之前展示了很多组件对属性直接更新或依赖的情况，但实际中的应用对属性的更新和依赖通常是间接，不易排查的 最后一个问题是，为什么第二次循环监测只在开发模式下运行？ 我猜想这是因为数据层不稳定在框架运行时并不会产生引人关注的错误，毕竟数据在下一次监测循环后就会稳定下来，当然，在开发时期将可能得错误解决总好过在上线后的应用中排查错误 附录：三个实例共享服务地址见 demo01 这个应用中父组件和子组件共用一个共享服务，子元素通过共享服务设置一个属性的值并反映到父元素上，这个模式下子元素改变父元素的值的方式并不像上面简单例子中那么显而易见，是间接更新了父元素的属性 同步事件广播地址见 demo02 这个应用中父元素监听一个子元素广播的事件，这个事件导致父元素的属性被更新，这个属性又被用于子元素的 Input 绑定，这同样间接更新了父元素的属性 动态的组件实例化地址见 demo03 这种模式与之前两种模式略有不同，前两种模式都是 List2 中的第一步检测抛出的错误，而这种模式是由 DOM 更新检测（List2 第二步）抛出的错误，这个应用中父组件在 ngAfterViewInit 生命周期中动态添加子组件 该生命周期发生在当前组件 DOM 初次更新之后，而添加子组件将会修改 DOM 结构，那么前后两次 DOM 中所使用的 values 值就不同了（前提是子组件带有新的 value 引用），所以抛出了错误 解决这个问题最好的方案是改变创建组件时所处的生命周期钩子，动态创建组件的流程就可以被移到 ngOnInit 中 即使文档中说明了 ViewChildren 只能在 ngAfterViewInit 之后被获取到，但是创建视图时就在填充子组件了，所以能提前获取 ViewChildren 参考 ExpressionChangedAfterItHasBeenCheckedError ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked on ng 4 Everything you need to know about change detection in Angular","link":"/2019/01/11/Angular/07/"},{"title":"动态加载（补充）","text":"之前介绍了 Angular 中动态加载的一些相关内容（见 Angular 中的动态加载），这里做一些补充，主要包括 Angular 中利用指令来指定宿主对象 Angular 中如何动态添加宿主 如何与动态添加后的组件进行通信 Angular 使用指令来指定宿主对象在 Angular 中，我们通常需要一个宿主（Host）来给动态加载的组件提供一个容器，这个宿主在 Angular 中就是 ng-template 我们需要找到组件中的容器，并且将目标组件加载到这个宿主中，就需要通过创建一个指令（Directive）来对容器进行标记 先来看看模版文件 123456// app.component.ts&lt;h1&gt; {{title}}&lt;/h1&gt;&lt;ng-template dl-host&gt;&lt;ng-template&gt; 然后我们添加一个用于标记这个属性的指令 dl-host.directive 123456789101112// dl-host.directive.tsimport { Directive, ViewContainerRef } from '@angular/core';@Directive({ selector: '[dl-host]'})export class DlHostDirective { // 在这里注入了一个 ViewContainerRef 的服务 // 它的作用就是为组件提供容器，并且提供了一系列的管理这些组件的方法 constructor(public viewContainerRef: ViewContainerRef) { }} 这样一来，我们就可以在 app.component 中通过 @ViewChild 获取到 dl-host 的实例，因此进而获取到其中的 ViewContainerRef 另外，我们还需要为 ViewContainerRef 提供需要创建组件 A 的工厂 所以还需要在 app.component 中注入一个工厂生成器 ComponentFactoryResolver 并且在 app.module 中将需要生成的组件注册为一个 @NgModule.entryComponent 关于 @NgModule.entryComponent 可以参考之前的介绍 12345678910111213141516171819202122// app.comonent.tsimport { Component, ViewChild, ComponentFactoryResolver } from '@angular/core';import { DlHostDirective } from './dl-host.directive';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { title = 'app works!'; @ViewChild(DlHostDirective) dlHost: DlHostDirective; constructor(private componentFactoryResolver: ComponentFactoryResolver) { } ngAfterViewInit() { this.dlHost.viewContainerRef.createComponent( this.componentFactoryResolver.resolveComponentFactory(AComponent) ); }} 下面是模块内容 1234567891011121314151617// app.module.tsimport { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';import { AComponent } from './a/a.component';import { DlHostDirective } from './dl-host.directive';@NgModule({ declarations: [AppComponent, AComponent, DlHostDirective], imports: [BrowserModule, FormsModule, HttpModule], entryComponents: [AComponent], providers: [], bootstrap: [AppComponent]})export class AppModule { } Angular 中如何动态添加宿主我们不可能在每一个需要动态添加组件的时候提供一个宿主组件，因为我们甚至都不会知道一个组件会在哪儿被创建出来并且被添加到页面中 就比如一个模态窗口，你希望在你需要使用的时候就能打开，而并非受限与宿主，在这种需求的前提下，我们就需要动态添加一个宿主到组件中 现在我们可以将 app.component 作为宿主的载体，但是并不提供宿主的显式声明，而是由我们动态去生成宿主 先将 app.component 还原 1234// app.component.ts&lt;h1&gt; {{title}}&lt;/h1&gt; 然后我们需要往 DOM 中注入一个 Node，例如一个 div 节点作为页面上的宿主，再通过工厂生成一个 AComponent 并将这个组件的根节点添加到宿主上 在这种情况下我们需要通过工厂直接创建组件，而不是在使用 ComponentContanerRef 1234567891011121314151617181920212223242526272829303132333435363738// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); } ngAfterViewInit() { let host = document.createElement(\"div\"); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.component.destroy(); }} 这种手动添加 DOM 的方式会有一个问题，那就是无法对数据进行脏检查 如果修改了 a.component.ts 是不会触发更新的，所以我们需要手动的去通知应用处理这个组件的视图，对这个组件进行脏检查 1234567891011121314151617181920212223242526272829303132333435363738394041// app.comonent.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); appRef.attachView(this.component.hostView); } ngAfterViewInit() { let host = document.createElement(\"div\"); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.appRef.detachView(this.component.hostView); this.component.destroy(); }} 如何与动态添加后的组件进行通信简单的方法是动态加载的组件通过 @Output() 向外 emit() 事件，外部组件通过监听事件（subscribe）得到通知 12345678910111213141516171819202122232425// 动态加载的组件 a.component// html 模版部分如下，简单的绑定一个点击事件// &lt;p (click)=\"onTitleClick()\"&gt;// {{title}}// &lt;/p&gt;// 组件部分如下import { Component, Output, Input, EventEmitter } from '@angular/core';@Component({ selector: 'app-a', templateUrl: './a.component.html', styleUrls: ['./a.component.css']})export class AComponent { @Input() title = 'a works!'; @Output() onTitleChange = new EventEmitter&lt;any&gt;(); onTitleClick() { this.onTitleChange.emit(); }} 下面来看看外部组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 外部组件 app.component.tsimport { Component, ComponentFactoryResolver, Injector, ElementRef, ComponentRef, ApplicationRef, AfterViewInit, OnDestroy} from '@angular/core';import { AComponent } from './a/a.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent implements OnDestroy { title = 'app works!'; component: ComponentRef&lt;AComponent&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver, private elementRef: ElementRef, private injector: Injector, private appRef: ApplicationRef ) { this.component = this.componentFactoryResolver .resolveComponentFactory(AComponent) .create(this.injector); appRef.attachView(this.component.hostView); (&lt;AComponent&gt;this.component.instance).onTitleChange .subscribe(() =&gt; { console.log('title clicked') }); (&lt;AComponent&gt;this.component.instance).title = 'a works again!'; } ngAfterViewInit() { let host = document.createElement('div'); host.appendChild((this.component.hostView as any).rootNodes[0]); this.elementRef.nativeElement.appendChild(host); } ngOnDestroy() { this.appRef.detachView(this.component.hostView); this.component.destroy(); }} 查看页面可以看到界面就显示了 a works again! 的文字，点击这行文字，就可以看到在 console 中输入了 title clicked","link":"/2019/03/13/Angular/09/"},{"title":"session 和 cookie","text":"这篇在跟着学习 node-lessons 过程中遇到的一些问题整合而成 众所周知，HTTP是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？ 比如在淘宝的某个页面中，你进行了登陆操作，当你跳转到商品页时，服务端如何知道你是已经登陆的状态？ cookie首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步 服务器向客户端发送 cookie 常使用 HTTP 协议规定的 set-cookie 头操作 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分 浏览器将 cookie 保存 每次请求浏览器都会将 cookie 发向服务器 其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种 path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间，当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除，一般用来保存 session 的 session_id secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie，一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie express 中的 cookieexpress 在 4.x 版本之后，session 管理和 cookies 等许多模块都不再直接包含在 express 中，而是需要单独添加相应模块 express4 中操作 cookie 使用 cookie-parser 模块 1234567891011121314151617181920212223var express = require('express');// 首先引入 cookie-parser 这个模块var cookieParser = require('cookie-parser');var app = express();app.listen(3000);// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 cookie 可选参数app.use(cookieParser());app.get('/', function (req, res) { // 如果请求中的 cookie 存在 isVisit, 则输出 cookie // 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟 if (req.cookies.isVisit) { console.log(req.cookies); res.send('再次欢迎访问'); } else { res.cookie('isVisit', 1, { maxAge: 60 * 1000 }); res.send('欢迎第一次访问'); }}); sessioncookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造 那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率 为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的 session 的运作通过一个 session_id 来进行，session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段 当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中 当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据 由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造，伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低 session 可以存放在内存、cookie本身、redis 或 memcached 等缓存中，或者放置于 数据库中 线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到 express 中操作 session 要用到 express-session 这个模块 主要的方法就是 session(options)，其中 options 中包含可选参数，主要有 name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等，express 生态中都有相应模块的支持 secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: '/', httpOnly: true, secure: false, maxAge: null }) genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包 rolling: 每个请求都重新设置一个 cookie，默认为 false resave: 即使 session 没有被修改，也保存 session 值，默认为 true 在内存中存储 sessionexpress-session 默认使用内存来存 session，对于开发调试来说很方便 12345678910111213141516171819202122232425var express = require('express');// 首先引入 express-session 这个模块var session = require('express-session');var app = express();app.listen(5000);// 按照上面的解释，设置 session 的可选参数app.use(session({ secret: 'recommand 128 bytes random string', // 建议使用 128 个字符的随机字符串 cookie: { maxAge: 60 * 1000 }}));app.get('/', function (req, res) { // 检查 session 中的 isVisit 字段 // 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1 if (req.session.isVisit) { req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来此页面&lt;/p&gt;'); } else { req.session.isVisit = 1; res.send('欢迎第一次来这里'); console.log(req.session); }}); 在 redis 中存储 sessionsession 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session 假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中，而下一次访问时，他被负载均衡到了进程 2，则此时进程 2 的内存中没有他的信息，认为他是个新用户，这就会导致用户在我们服务中的状态不一致 使用 redis 作为缓存，可以使用 connect-redis 模块来得到 redis 连接实例，然后在 session 中设置存储方式为该实例 12345678910111213141516171819202122232425var express = require('express');var session = require('express-session');var redisStore = require('connect-redis')(session);var app = express();app.listen(5000);app.use(session({ // 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行 // 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用 // 比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法 // 编写自己的 store 也很简单 store: new redisStore(), secret: 'somesecrettoken'}));app.get('/', function (req, res) { if (req.session.isVisit) { req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来到此页面&lt;/p&gt;'); } else { req.session.isVisit = 1; res.send('欢迎第一次来这里'); }}); 我们可以运行 redis-cli 查看结果，如图可以看到 redis 中缓存结果 各种存储的利弊上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库 其中，开发环境存内存就好了，一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题，但内存 session 除了省事之外，没有别的好处 cookie session 我们下面会提到，现在说说利弊，用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息，当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的，它的弊端是增大了数据量传输，利端是方便 缓存方式是最常用的方式了，即快，又能共享状态，相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输，推荐使用 数据库 session，除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧 signedCookiecookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造 其实不是这样的，那只是为了方便理解才那么写，要知道，计算机领域有个名词叫 签名，专业点说，叫 信息摘要算法 比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证，相应的 cookie 长这样： dotcom_user=zhangsan，它说明现在的用户是 zhangsan 这个用户，如果我在浏览器中装个插件，把它改成 dotcom_user=ricardo，服务器一读取，就会误认为我是 ricardo，然后我就可以进行 ricardo 才能进行的操作了 OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名 假设我的服务器有个秘密字符串，是 this_is_my_secret_and_fuck_you_all，我为用户 cookie 的 dotcom_user 字段设置了个值 zhangsan cookie 本应是 1{ dotcom_user: 'zhangsan' } 这样的，而如果我们签个名，比如把 dotcom_user 的值跟我的 secret_string 做个 sha1 1sha1('this_is_my_secret_and_fuck_you_all' + 'zhangsan') === '4850a42e3bc0d39c978770392cbd8dc2923e3d1d' 然后把 cookie 变成这样 1234{ dotcom_user: 'zhangsan', 'dotcom_user.sig': '4850a42e3bc0d39c978770392cbd8dc2923e3d1d',} 这样一来，用户就没法伪造信息了，一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致 毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高 cookie-sessioncookie-session 的实现跟 signedCookies 差不多 不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险 回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中，他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了，而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分 如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中，这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了，如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中 session cookie初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie，即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失 常见的场景就是在开发用户登陆状态保持时 假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁，所以我们要在 cookie 中，也保存一份关于用户身份的信息 比如有这样一个用户 1{ username: 'zhangsan', age: 22, company: 'baidu', location: 'beijing' } 我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username 登陆的检验过程伪代码如下 12345678910111213if (req.session.user) { // 获取 user 并进行下一步 next()} else if (req.signedCookies['username']) { // 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中 getuser(function (err, user) { req.session.user = user; next(); });} else { // 当做为登陆用户处理 next();}","link":"/2017/11/26/HTTP/02/"},{"title":"域名发散与收敛","text":"先扩展一个知识：performance - 监控网页与程序性能 域名发散在 PC 时代为了突破浏览器的域名并发限制，遵循这样一条定律：http 静态资源采用多个子域名 目的是充分利用现代浏览器的多线程并发下载能力，由于浏览器的限制，每个浏览器，允许对每个域名的连接数一般是有上限的，附一张网上流传甚广的图： 域名发散出现的原因其实是在以前，服务器的负载能力差，网速慢，设备差，稍微流量大一点 Server 就崩溃了 为了保护你的服务器不崩溃，浏览器要对 max connections 有所限制，如果每个用户的 max connections 不限制的话， 结果就是服务器的负载能力会低至冰点（另外也有说是关于 DDOS） 所以 PC 时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速 假设现在浏览器对每个域名连接数为 1，那么现实情况是 浏览器解析完我们的文档之后开始发起请求，对文件进行加载. 然后一个一个文件 在 max connections 下进行排队下载 但如果我们使用了域名分散之后，使用多个 domain 进行资源的下载，就有 这样完全可以省略掉排队的时间.提升网页加载的速度 域名收敛这里首先会涉及到一个问题，为什么你手机打开网页时，白屏时间会这么长？ 一个网页白屏时间是由下面几部分决定的 所以，网页的优化就可以从上述几个部分开始. 这里我们要提及的就是 DNS 优化, 即域名收敛，那么什么是域名收敛呢 顾名思义，域名收敛的意思就是建议将静态资源只放在一个域名下面，而非发散情况下的多个域名下 上面也说到了，域名发散可以突破浏览器的域名并发限制，那么为要反其道而行之呢？ 因为因地制宜，不同情况区别对待，域名发散是 PC 时代的产物，而现在进入移动互联网时代，通过无线设备访问网站，App 的用户已占据了很大一部分比重，而域名收敛正是在这种情况下提出的 这里就不能不提到 http 请求了 简单来说就说就是 1）、 DNS 域名解析 ==&gt; 2）、 发起 TCP 的 3 次握手 ==&gt; 3）、 建立 TCP 连接后发起 http 请求 ==&gt; 4）、 服务器响应 http 请求 ==&gt; 5）、 … 在这里第一步，也是关键的第一步 DNS 解析，在移动端的 http 请求耗时中，DNS 解析占据了大部分时间 在深入了解 DNS 解析之前，先科普一下 域名结构 域名结构或者叫命名空间，是一个树状结构，有树就得有根，这个根是一个点 &quot;.&quot;（dot） 以 www.example.com 为例，完整的形式应该是 www.example.com.（注意最后有一个点），就是根结点 root ，只不过平时是浏览器或者系统的解析器自动帮我们补全了 我们要想获取根域都有那些，可以在终端下直接使用 dig 命令（需要安装 dig 指令），如下: 根节点之后就是顶级域名，就是 .cn，.com，.gov 这些，顶级域划分为通用顶级域 （com、org、net 等）和国家与地区顶级域（cn、hk、us、tw等） 我们可以继续使用 dig 查看一下 顶级域名的解析路径，加上 + trace 参数选项，意思是追踪 DNS 解析过程，如下： 可以看到是先到根节点，再查找到 com ，就是根结点会告知下一个结点 com 在哪：就是 com. 172800 IN NS [a-m].gtld-servers.net 顶级域之后就是我们熟知的一级域名，譬如 www.example.com 中的 example 就是一级域 NS上面两张 dig 命令贴图中间出现了很多次 NS ，NS 即是 NameServer，大部分情况下又叫权威名称服务器简称权威 什么是权威呢，通俗点讲其实是某些域的权威，也就是权威上面有这些域的最新，最全的数据，所有这些域的数据都应该以此为准（只有权威可以增删改这些域的数据），就像上面 dig com + trace 的结果可以看到，com 的权威是上面的 13 个根域，同理，所有的顶级域（cn、org、net 等等）的权威都是根域 DNS 解析其实上面就是 DNS 解析的一个大致过程，即迭代解析 一个完整的 DNS 解析过程如下（摘自 域名收敛–前端优化） Step1: 首先拿到 URL 后，浏览器会寻找本地的 DNS 缓存，看看是否有对应的 IP 地址，如果缓存中存在那就好了，如果没有，那就得向 DNS Server 发送一个请求，找到你想要的 IP 地址 Step2: 首先他会向你的 ISP（互联网服务提供商）相关的 DNS servers 发送 DNS query，然后这些 DNS 进行递归查询（recursive），所谓的递归查询，就是能够直接返回对应的 IP 地址，而不是其他的 DNS server 地址 Step3: 如果上述的 DNS Servers 没有你要的域名地址，则就会发送迭代查询，即会先从 root nameservers 找起， 即是假如你要查询 www.example.com ，会先从包含根结点的 13 台最高级域名服务器开始 Step4: 接着，以从右向左的方式递进，找到 com. 然后向包含 com 的 TLD（顶级域名）nameservers 发送 DNS 请求，接着找到包含 example 的 DNS server Step5: 现在进入到了 example.com 部分，即是现在正在询问的是权威服务器，该服务器里面包含了你想要的域名信息，也就是拿到了最后的结果 record Step6: 递归查询的 DNS Server 接受到这 record 之后, 会将该 record 保存一份到本地，如果下一次你再请求这个 domain 时，我就可以直接返回给你了，由于每条记录都会存在 TLL ，所以 server 每隔一段时间都会发送一次请求，获取新的 record Step7: 最后，再经由最近的 DNS Server 将该条 record 返回， 同样，你的设备也会存一份该 record 的副本 之后，就是 TCP 的事了，下面是一张萌萌的简化图： 梳理一下，迭代查询的过程如下： 流程: . ==&gt; com. ==&gt; .exampl.com. ==&gt; www.example.com. ==&gt; IP adress 关于 TTLTTL 是 Time To Live 的缩写，该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量，TTL 是 IPv4 包头的一个 8 bit 字段 简单的说它表示 DNS 记录在 DNS 服务器上缓存时间 DNS 解析其实是一个很复杂的过程，在 PC 上，我们采用域名发散策略，是因为在 PC 端上，DNS 解析通常而言只需要几十 ms ，完全可以接受的 而移动端，2G / 3G / 4G / WIFI 网络，而且移动 4G 容易在信号不理想的地段降级成 2G ，通过大量的数据采集和真实网络抓包分析（存在 DNS 解析的请求），DNS 的消耗相当可观，2G 网络大量 5-10s，3G 网络平均也要 3-5s（数据来源于淘宝）， 下面附上在 2G / 3G / 4G / WIFI 情况下 DNS 递归解析的时间 （ms）： 因为在增加域的同时，往往会给浏览器带来 DNS 解析的开销，所以在这种情况下，提出了域名收敛，减少域名数量可以降低 DNS 解析的成本 下图是手机端页面加载数和域名分散数的关系: 在 2 个域名分散条件下，网页的加载速度提升较大，而第 3 个以后就比较慢了， 所以，一般来说，域名分散的数量最好在 3 以下 HttpDNS上面过程如果顺利，本地 DNS 有缓存，也就是几十 ms 到几百 ms 的事情，不顺利，几秒到十几秒都有可能 严格来讲，DNS 才是我们发出去的第一个请求，所以减少开销就两条路： 第一个就是减少 DNS 的请求 第二个就是缩短 DNS 解析路径 第一个就是做域名收敛的主要原因，相比于 PC 是对于域名的并发限制，无线上来说对并发的要求会弱很多（一般尽量是第一屏，后面使用懒加载） 第二个就是缩短解析路径，这里所说的缩短解析路径其实就说各级的缓存：本机的缓存，LocalDNS 的缓存，不过他们或多或少也不靠谱，尤其是运营商的 LocalDNS 给你劫持一下，篡改一下都是常有的事情，于是这个情况下，就有了 HttpDNS HttpDNS 是为了解决移动端 DNS 解析请求而生的，顺便解决 DNS 劫持，合并请求和缓存结果进而提高解析质量 结论在移动网络环境下，减少非必要 DNS 请求，将相关域名收敛成一个，可以尝到缓存的红利，进而可以减少打开页面时间，移动端减少 DNS 解析时间有两种方式： 减少 DNS 请求 缩短 DNS 解析路径 从上面的各种网络环境下 DNS 解析时间对比，减少 DNS 请求是我们做域名收敛的主要原因，HttpDNS 的诞生不仅可以合并请求，缩短 DNS 解析路径，还有防止运营商劫持等功效 扩展：关于 SPDY单纯的在移动端采用域名收敛并不能很大幅度的提升性能，很重要的一点是，在移动端建连的消耗非常大，而 SPDY 协议可以完成多路复用的加密全双工通道，显著提升非 wifi 环境下的网络体验，当域名收敛配合 SPDY 才能最大程度发挥他们的效用，达到事半功倍 所谓 SPDY 就是一种开放的网络传输协议，由 Google 开发，用来发送网页内容，基于传输控制协议（TCP）的应用层协议 ，是 HTTP/2 的前身 SPDY 的作用就是，在不增加域名的情况下，解除最大连接数的限制，主要的特点就是多路复用，他的目的就是致力于取消并发连接上限 那么相比 HTTP，SPDY 具体的优势在哪里呢： 1. 多路复用 请求优化SPDY 规定在一个 SPDY 连接内可以有无限个并行请求，即允许多个并发 HTTP 请求共用一个 TCP 会话 这样 SPDY 通过复用在单个 TCP 连接上的多次请求，而非为每个请求单独开放连接，这样只需建立一个 TCP 连接就可以传送网页上所有资源，不仅可以减少消息交互往返的时间还可以避免创建新连接造成的延迟，使得 TCP 的效率更高 此外，SPDY 的多路复用可以设置优先级，而不像传统 HTTP 那样严格按照先入先出一个一个处理请求，它会选择性的先传输 CSS 这样更重要的资源，然后再传输网站图标之类不太重要的资源，可以避免让非关键资源占用网络通道的问题，提升 TCP 的性能 2. 支持服务器推送技术服务器可以主动向客户端发起通信向客户端推送数据，这种预加载可以使用户一直保持一个快速的网络 3. SPDY 压缩了 HTTP 头舍弃掉了不必要的头信息，经过压缩之后可以节省多余数据传输所带来的等待时间和带宽 4. 强制使用 SSL 传输协议Google 认为 Web 未来的发展方向必定是安全的网络连接，全部请求 SSL 加密后，信息传输更加安全 看看 SPDY 的作用图： 参考： SPDY协议介绍 15年双11手淘前端技术巡演 - H5性能最佳实践 HttpDNS 服务详解 DNS（wiki 无线性能优化：域名收敛 域名收敛–前端优化(二) 域名发散–前端优化(三)","link":"/2017/12/01/HTTP/03/"},{"title":"HTTP 缓存机制","text":"先来简单说一下 Web 缓存，所谓 Web 缓存，是一种保存 Web 资源副本并在下次请求时直接使用该副本的技术 Web 缓存可以分为这几种，浏览器缓存、CDN 缓存、服务器缓存、数据库数据缓存 因为可能会直接使用副本免于重新发送请求或者仅仅确认资源没变无需重新传输资源实体 Web 缓存可以减少延迟加快网页打开速度、重复利用资源减少网络带宽消耗、降低请求次数或者减少传输内容从而减轻服务器压力， 缓存的流程简单来说，浏览器在请求一个资源时，使用缓存的流程大概如下， 首先浏览器会判断，这个资源是否有缓存，没有的话，正常请求 如果有缓存的话，浏览会判断缓存是否过期，如果缓存没有过期，则直接使用，此时就是 200（from cache），通过上次缓存留下的 cache-control，max-age 和 Expires（需要注意的是，cache-control 的优先级高于 Expires，下面会详细介绍） 如果浏览器的缓存过期了，它会请求服务器，服务器会校验缓存的数据是否真的发生了更改 如果服务器端发现数据没有变，就会返回一个 304 告诉浏览器，你请求的数据 &quot;Not Modified&quot;，可以继续用缓存，同时浏览器会更新缓存首部的过期时间等信息 这里浏览器发起请求时，会用到上次缓存首部的 Last-Modified/E-tag 具体做法是取出上次缓存的 Last-Modified 的值，放在本次请求 header 的 If-Modified-Since 中 取出上次缓存的 E-tag 的值，放在本次请求 header 中的 If-None-Match 中 服务器会据此判断资源是否发生过修改，浏览器中的缓存是否依然可用 如果服务器端修改了上次缓存的内容，则直接返回 200，并携带新的内容 强缓存和协商缓存浏览器 HTTP 缓存可以分为强缓存和协商缓存，强缓存和协商缓存最大也是最根本的区别是 强缓存命中的话不会发请求到服务器（比如 chrome 中的 200 from memory cache） 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified） 所以上图可以简单的调整为 而浏览器 HTTP 缓存由 HTTP 报文的首部字段决定 浏览器对于请求资源，拥有一系列成熟的缓存策略 按照发生的时间顺序分别为存储策略，过期策略，协商策略，其中存储策略在收到响应后应用，过期策略和协商策略则在发送请求前应用 下面表格表示的就是 http header 中与缓存有关的 key key 描述 存储策略 过期策略 协商策略 Pragma http1.0 字段，指定缓存机制 ✔️ ✔️ Cache-Control 指定缓存机制，覆盖其它设置 ✔️ Expires http1.0 字段，指定缓存的过期时间 ✔️ Last-Modified 资源最后一次的修改时间 ✔️ ETag 唯一标识请求资源的字符串 ✔️ 而缓存协商策略用于重新验证缓存资源是否有效，有关的 key 如下 key 描述 If-Modified-Since 缓存校验字段，值为资源最后一次的修改时间，即上次收到的 Last-Modified 值 If-Unmodified-Since 同上，处理方式与之相反 If-Match 缓存校验字段，值为唯一标识请求资源的字符串，即上次收到的 ETag 值 If-None-Match 同上，处理方式与之相反 下面就按控制强缓存的字段按优先级介绍 PragmaPragma 是 HTTP/1.1 之前版本遗留的通用首部字段，仅作为于 HTTP/1.0 的向后兼容而使用 虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现 RFC 中该字段只有 no-cache 一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度，因为它优先级最高，当存在时一定不会命中强缓存 Cache-ControlCache-Control 是一个通用首部字段，也是 HTTP/1.1 控制浏览器缓存的主流字段，和浏览器缓存相关的是如下几个响应指令 指令 参数 说明 private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它） public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 no-cache 可省略 缓存前必需确认其有效性 no-store 无 不缓存请求或响应的任何内容 max-age=[s] 必需 响应的最大值 max-age（单位为 s）设置缓存的存在时间，相对于发送请求的时间，只有响应报文首部设置 Cache-Control 为非 0 的 max-age 或者设置了大于请求日期的 Expires才有可能命中强缓存 当满足这个条件，同时响应报文首部中 Cache-Control 不存在 no-cache、no-store 且请求报文首部不存在 Pragma 字段，才会真正命中强缓存 no-cache表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存 Chrome 硬性重新加载（Command + shift + R）会在请求的首部加上 Pragma：no-cache 和 Cache-Control：no-cache no-store表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据 public表明响应可以被浏览器、CDN 等等缓存 private响应只作为私有的缓存，不能被 CDN 等缓存，如果要求 HTTP 认证，响应会自动设置为 private ExpiresExpires 是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP 缓存被认为是有效的 无效的日期比如 0，表示这个资源已经过期了，如果同时设置了 Cache-Control 响应首部字段的 max-age 则 Expires 会被忽略，它也是 HTTP/1.1 之前版本遗留的通用首部字段，仅作为于 HTTP/1.0 的向后兼容而使用 下面再来看看控制协商缓存的字段 Last-Modified / If-Modified-SinceIf-Modified-Since 是一个请求首部字段，并且只能用在 GET 或者 HEAD 请求中 Last-Modified 是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间 当带着 If-Modified-Since 头访问服务器请求资源时，服务器会检查 Last-Modified 如果 Last-Modified 的时间早于或等于 If-Modified-Since 则会返回一个不带主体的 304 响应，否则将重新返回资源 需要注意的是，如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有 etag 实体标签条件首部 那么只有这两个条件都满足时，才能返回 304 NotModified 响应 语法格式如下 123If-Modified-Since: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMTLast-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT ETag / If-None-MatchETag 是一个响应首部字段，它是根据实体内容生成的一段 hash 字符串，标识资源的状态，由服务端产生 If-None-Match 是一个条件式的请求首部，如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的 ETag 则当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的 200 响应 否则服务器会返回不带实体的 304 响应，ETag 优先级比 Last-Modified 高，同时存在时会以 ETag 为准 语法格式如下 12345If-None-Match: &lt;etag_value&gt;If-None-Match: &lt;etag_value&gt;, &lt;etag_value&gt;, …If-None-Match: * ETag 属性之间的比较采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的 例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的 因为 ETag 的特性，所以相较于 Last-Modified 有一些优势 某些情况下服务器无法获取资源的最后修改时间 资源的最后修改时间变了但是内容没变，使用 ETag 可以正确缓存 如果资源修改非常频繁，在秒以下的时间进行修改，Last-Modified 只能精确到秒 整体流程 优先级若同时存在各种缓存头时，各缓存头优先级及生效情况如下 强缓存和对比缓存同时存在，如果强缓存还在生效期则强制缓存覆盖对比缓存，对比缓存不生效 如果强缓存不在有效期，对比缓存生效，即：强缓存优先级 &gt; 对比缓存优先级 pragma，和 cache-control 类似，前者是 http1.0 内容，后者是 http1.1 内容 并且 pragma 优先级 &gt; cache-control 优先级，不过前者目前基本不使用 强缓存 expires 和 cache-control 同时存在时，则 cache-control 会覆盖 expires expires 无论有没有过期都无效，即 cache-control 优先级 &gt; expires 优先级 对比缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified Last-Modified 不会生效，即 ETag优先级 &gt; Last-Modified 优先级 针对于一般的项目，由于 css 和 js 在打包时加了 md5 值，建议直接使用强缓存，并且 expires 和 cache-control 同时使用，建议设置时长为 7 天较为妥当，图片文件由于没有加 md5 值，建议采用对比缓存，html 文件也建议采用对比缓存 浏览器的不同表现需要注意的是，当我们不设置 cache-control，只设置对比缓存，在不同浏览器下会有不同的表现 chrome 会直接从本地缓存获取，其他会请求服务器返回 304，这时候有两种方式让他们的响应一致 设置 cache-control: public, max-age=0;，这里的 public 是关键 因为默认值是 private，表示其他代理都不要缓存，只有服务器缓存，而 max-age 又为 0 所以每次都会发起 200 的请求，设置 public 的意思就是允许其他各级代理缓存资源，因此如果资源没改变会返回 304 直接设置 max-age = 1000，即是一秒之后内容过期，目的是触发浏览器缓存，也能达到想要 304 的效果 如何让浏览器不缓存静态资源实际上，工作中很多场景都需要避免浏览器缓存，除了浏览器隐私模式，请求时想要禁用缓存 还可以设置请求头: Cache-Control: no-cache, no-store, must-revalidate 当然，还有一种常用做法，即给请求的资源增加一个版本号，比如 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=2.1.1\"/&gt; 这样做的好处就是你可以自由控制什么时候加载最新的资源 不仅如此，HTML 也可以禁用缓存，即在页面的 &lt;head&gt; 节点中加入 &lt;meta&gt; 标签 1&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache，no-store，must-revalidate\"/&gt; 上述虽能禁用缓存，但只有部分浏览器支持，而且由于代理不解析 HTML 文档，故代理服务器也不支持这种方式 总结Expires / Cache-Control 用来设置缓存时间，即资源有效时间（状态码 200（from cache）），可避免请求发送到服务器 Last-Modified / ETag 用来判断资源是否被修改了（状态码 304（not change）），可避免传输相同的资源内容，造成带宽和时间的浪费 使用原则需要兼容 HTTP1.0 的时候需要使用 Expires，不然可以考虑直接使用 Cache-Control 需要处理一秒内多次修改的情况，或者其他 Last-Modified 处理不了的情况，才使用 ETag，否则使用 Last-- Modified 对于所有可缓存资源，需要指定一个 Expires 或 Cache-Control，同时指定 Last-Modified 或者 Etag 可以通过标识文件版本名、加长缓存时间的方式来减少 304 响应","link":"/2017/12/12/HTTP/04/"},{"title":"JavaScript 中的事件，冒泡与捕获","text":"事件就是用户或浏览器自身执行的某种动作，诸如 click、load、mouseover 事件处理程序响应某个事件的函数就叫事件处理程序（或事件侦听器） 1. HTML 事件处理程序1&lt;input type='button' value='click me' onclick='alert(1)'&gt; 在 html 中指定事件处理程序有个缺点，即 html 与 javascript 代码紧密耦合，如果要更换处理程序，就要改动两个地方 html 代码和 javascript 代码 2. DOM 0 级事件处理程序123btn.onclick = function () { alert('DOM0');} 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 1btn.onclick = null; // 删除事件处理程序 3. DOM 2 级事件处理程序定义了两个方法 addEventListener() 和 removeEventListener() 接收三个参数，要处理的事件名，做为事件处理程序的函数，布尔值（true 表示捕获阶段，false 表示冒泡阶段） 123btn.addEventListener('click', 'show', false);btn.removeEventListener('click', 'show', false); 普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个 几个需要注意的地方 eventName 的值均不含 on，例如注册鼠标点击事件 eventName 为 click 处理函数中的 this 依然指的是指当前 dom 元素 通过 addEventListener 添加的事件处理程序，只能通过 removeEventListener 来删除（也就是说 addEventListener 添加的匿名函数将无法被删除） 4. IE 事件处理程序123attachEvent() // 添加事件detachEvent() // 添加事件 接收相同的两个参数，事件处理程序的名称和事件处理程序的函数，不使用第三个参数的原因是 IE8 级更早版本只支持冒泡型事件，所以 attachEvent 添加的事件都会被添加到冒泡阶段 123btn.attachEvent('onclick', show);btn.detachEvent('onclick', show) 注意，通过 attachEvent 添加的事件第一个参数是 'onclick' 而非标准事件中的 'click'，在使用 attachEvent 方法和 DOM0 级事件处理程序的主要区别在于事件处理程序的作用域 采用 DOM0 级处理方式，事件处理程序会在其所属元素的作用域内运行，而使用 attachEvent，事件处理程序会在全局作用域内运行，因此 this 等于 window 123456var btn = document.getElementById('btn');btn.attachEvent('onclick', function () { // 此处 this 是 window alert(this);}); 5. 跨浏览器的事件处理程序事件对象 在触发 DOM 上的事件的时候都会产生一个对象 事件对象 event DOM 中的事件对象 type 属性 用于获取事件的类型 target 属性 用于获取事件目标 stopPropagation() 方法 用于阻止事件冒泡 preventDefault() 方法 阻止事件的默认行为 兼容方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243var eventHandle = { // 添加 addEvent: function (el, type, fn) { if (el.addEventListener) { el.addEventListener(type, fn, false); } else if (el.attachEvent) { el.attachEvent('on' + type, fn); } }, // 删除 removeEvent: function (el, type, fn) { if (el.removeEventListener) { el.removeEventListener(type, fn, false); } else if (el.detachEvent) { el.detachEvent('on' + type, fn); } }, // 事件对象 getEvent: function (e) { return e ? event : window.event; }, // 事件监听的元素 getElement: function (e) { return e.target || e.srcElement; }, // 阻止冒泡 stopBubble: function (e) { if (e &amp;&amp; e.stopPropagation) { e.stopPropagation(); } else { window.event.cancelBubble = true; } }, // 阻止默认行为 stopDefault: function (e) { if (e &amp;&amp; e.preventDefault) { e.preventDefault(); } else { window.event.returnValue = false; } return false; }} 关于 event event 代表事件的状态，例如触发 event 对象的元素、鼠标的位置及状态、按下的键等等 event 对象只在事件发生的过程中才有效 firefox 里的 event 跟 IE 里的不同，IE 里的是全局变量，随时可用，firefox 里的要用参数引导才能用，是运行时的临时变量 在 IE/Opera 中是 window.event，在 Firefox 中是 event，而事件的对象，在 IE 中是 window.event.srcElement，在 Firefox 中是 event.target，Opera 中两者都可用 下面两句效果相同： 1234function a(e){ var e = (e) ? evt : ((window.event) ? window.event : null); var e = e || window.event; // firefox 下 window.event 为 null, IE 下 event 为 null} 在 jQuery 当中阻止事件冒泡的方法如下 12345// 阻止事件冒泡e.stopPropagation()// 阻止事件默认行为e.preventDefault() return false 等效于同时调用 e.preventDefault() 和 e.stopPropagation() 事件委托使用事件委托技术能让你避免对特定的每个节点添加事件监听器,事件监听器是被添加到它们的父元素上 事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件，也就是利用冒泡的原理，把事件加到父级上，触发执行效果，可以提高性能 看一个例子，需要触发每个 li 来改变他们的背景颜色 12345&lt;ul &gt; &lt;li&gt;111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt;&lt;/ul&gt; 12345678for(var i = 0; i &lt; li.length; i++) { li[i].onmouseover = function () { this.style.background = 'red'; } li[i].onmouseout = function () { this.style.background = ''; }} 利用循环可以达到我们的目的，但是如果说我们可能有很多个 li 用 for 循环的话就比较影响性能了 所以这里可以尝试使用用事件委托的方式来实现 1234567891011121314151617ul.onmouseover = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red'; }}ul.onmouseout = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = ''; }} 还有另外一个好处，就是新添加的元素还会有之前的事件 比如我们要实现一个点击 btn 动态的添加 li 的效果，相比利用 for 循环来实现，利用事件委托机制也可以达成我们的目标 12345678910111213141516171819202122ul.onmouseover = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red'; }}ul.onmouseout = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { target.style.background = ''; }}btn.onclick = function () { iNow++; var li = document.createElement('li'); li.innerHTML = 1111 * iNow; oUl.appendChild(li);} 事件流，冒泡与捕获所谓事件流，即为了描述事件的传播而规定的一个事件传播方向，分为两个阶段，事件捕获和事件冒泡 正常情况下，事件先从最外层的元素向内捕获，然后从最内层的元素往外层传播 事件的触发一定是按照事件流的顺序而来 DOM 0 级1234567btn.onclick = function () { alert(1)}btn.onclick = function () { alert(2)} 只能监听冒泡阶段，如果给同一个对象，同一个事件名绑定多个监听，后面的会覆盖掉之前的 this 指向的是触发事件的 DOM 元素 IE 6，7，8 中事件只能冒泡到 document，不能继续冒泡到 window 对象上 所以一般不能给 window 添加 click 事件 DOM 2 级123btn.addEventListener('click', function () { // ...}, false) 最后一个参数，true 表示捕获阶段，而 false 则表示为冒泡阶段 几个注意事项： 所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到 window 对象 如果不是最内层的元素同时绑定有捕获和冒泡事件，改变事件绑定的先后顺序，不会影响执行结果，依然是先捕获后冒泡 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行 this 指向的是触发事件的元素（也就是事件传播到的这个元素） 一个比较完整的案例，页面布局如下 1234567&lt;div id='box1'&gt; &lt;div id='box2'&gt; &lt;div id='box3'&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 测试相关代码如下 12345678910111213141516171819202122232425262728293031box2.onclick = function () { alert('A');};box2.onclick = function () { alert('B');};box2.addEventListener('click', function () { alert('C');}, false);box2.addEventListener('click', function () { alert('D');}, false);box2.addEventListener('click', function () { alert('E');}, true);box2.addEventListener('click', function () { alert('F');}, true);box3.addEventListener('click', function () { alert('G');}, false);box3.addEventListener('click', function () { alert('H');}, true); 执行后的结果依次为：E =&gt; F =&gt; G =&gt; H =&gt; B =&gt; C =&gt; D 最后总结如下 DOM 0 级添加到冒泡阶段 DOM 0 级同名事件会发生覆盖 true 表示捕获阶段，false 表示冒泡阶段，会先执行捕获 DOM 2 级同名事件不会覆盖，按先后顺序执行 DOM 2 级最内层的元素不区分冒泡和捕获，按先后顺序执行（无论是 DOM 0 级还是 DOM 2 级）","link":"/2016/11/14/JavaScript/01/"},{"title":"JavaScript 中的 call 和 apply","text":"call() 和 apply() 方法主要是用来扩充函数的作用域和改变 this 的指向（改变被调用函数的上下文），都接收两个参数 apply() 方法 第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是 arguments 对象 call() 方法 也接收两个参数，仅仅在于和 apply() 的传参方式不同，传递函数的参数必须逐个写入 两者的区别123function().call(object, a, b, c ...)function().apply(object, [a, b, c ...]) 功能基本一样，都是对象 object 调用这里的 funciton() 不同之处是 call 参数从第二个开始都是传递给 funciton 的，可以依次罗列用 '，' 隔开，而 apply 只有两个参数，第二个是一个数组，其中存储了所有传递给 function 的参数 12345678910var bar = {baz: 'baz'};function foo () { console.log(this)}foo.call('bar');// 输出 Object {baz: 'baz'}// 其实就是让一个对象调用一个函数，在使用了 call 以后，即调用了显式绑定，this 就指向了所传进去的对象 不过需要注意的是，apply 和 call 在严格模式下的不同 1234567function foo (x, y) { 'use strict'; console.log(x, y, this);}foo.apply(null); // undefined undefined nullfoo.apply(undefined); // undefined undefined undefined 我们可以尝试来手动实现一下这两个函数 原理call 和 apply 本质是一样的，区别就在于参数的不同 call 方法的定义 ES5 - Call 简单来说就是 call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法 apply() 方法在使用一个指定的 this 值和参数值必须是数组类型的前提下调用某个函数或方法 call() 和 apply() 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 this 来获得它的引用，比如以对象 o 的方法来调用函数 f() 123f.call(o)f.apply(o) 大致原理如下所示 1234o.m = f; // 将 f 存储为 o 的临时方法o.m(); // 调用它，不传入参数delete o.m; // 将临时方法删除 在严格模式中，call() 和 apply() 的第一个参数都会变成 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined 在 ES3 或者非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代 简单来说就是，f.call(o) 其原理就是先通过 o.m = f 将 f 作为 o 的某个临时属性 m 存储，然后执行 m，执行完毕后将 m 属性删除 实现这里以 apply 为例 初级实现 12345Function.prototype.apply = function (context) { context.fn = this; context.fn(); delete context.fn;} 但是 apply 有一点不同，它的参数是一个数组，在执行的时候会把数组的值依次传递给函数当参数 需要实现类似 context.fn(arg1, arg2, arg3 ...) 的调用方式，这里采用 evel 来实现 123456789101112131415Function.prototype.apply = function (context) { var args = arguments[1]; context.fn = this; // 使用 evel 来实现（并不是唯一的方式） // 来得到 context.fn(arg1,arg2,arg3...) var fnStr = 'context.fn('; for (var i = 0; i &lt; args.length; i++) { fnStr += i == args.length - 1 ? args[i] : args[i] + ','; } fnStr += ')'; eval(fnStr); delete context.fn;} 有几个需要注意的地方 this 参数可以传递 null 或者不传，当为 null 的时候，则指向 window 函数是可以指定返回值的 123456789101112131415161718192021Function.prototype.apply = function (context) { var context = context || window; var args = arguments[1]; context.fn = this; if (args === void 0) { return context.fn(); } // 使用 evel 来实现（并不是唯一的方式） // 来得到 context.fn(arg1, arg2, arg3 ...) var fnStr = 'context.fn('; for (var i = 0; i &lt; args.length; i++) { fnStr += i == args.length - 1 ? args[i] : args[i] + ','; } fnStr += ')'; var returnVal = eval(fnStr); delete context.fn; return returnVal;} 还有一个问题，即 context.fn = this，这里我们只是假设不存在名为 fn 的属性，所以这里我们需要保证 fn 的唯一性 这里可以采用 ES6 提供的 symbol 数据类型，直接添加即可 12var fn = Symbol()context[fn] = this 如果不使用 symbol，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下 123456789101112function symbol(obj) { var unique_proper = \"00\" + Math.random(); if (obj.hasOwnProperty(unique_proper)) { // 如果已经存在这个属性，则递归调用，直到没有这个属性 arguments.callee(obj) } else { return unique_proper; }}// 使用var fn = symbol(context); 而 call 方法，可以利用上面的 apply 来简单实现 123Function.prototype.call = function (context) { return this.apply(([].shift.apply(arguments), arguments));} 延伸下面是两个实际使用场景 123456789101112131415161718192021222324function sum (num1, num2) { return num1 + num2;}function callSum1 (num1, num2) { // 使用 sum 这个函数来完成一次调用，调用的参数就是 callSum1 这个函数的参数 // apply 的第二个参数表示一组参数数组 return sum.apply(this, arguments);}function callSum2 (num1, num2) { // 第二个参数是数组 return sum.apply(this, [num1, num2]);}callSum1(12, 22);callSum2(22, 32);function callSum3 (num1, num2) { // call 是通过参数列表来完成传递，其余和 apply 没什么区别 return sum.call(this, num1, num2);}callSum3(32, 42); 另外一个实例 12345678910111213var color = 'red';function showColor () { alert(this.color);}function Circle (color) { this.color = color;}var c = new Circle('yellow');showColor.call(this); // 使用上下文来调用 showColor，结果是redshowColor.call(c); // 上下文对象是 c，结果就是 yellow 通过以上发现，使用 call 和 apply 以后，对象中可以不需要定义方法了 这就是 call 和 apply 的一种运用 扩展：this.init.apply(this, arguments)在 prototype 框架中有如下一段代码 12345678910111213141516171819202122var Class = { create: function () { return function () { this.initialize.apply(this, arguments); } }};// Class 使用方法如下var A = Class.create();A.prototype = { initialize: function (v) { this.value = v; }, showValue: function () { alert(this.value); }};var a = new A(\"helloWord!\");a.showValue(); var a = new A(&quot;helloWord!&quot;) 其实这句话的含义就是构造个一个 function 复制给 a，这个 function 是 123function () { this.initialize.apply(this, arguments);} 这个 function 方法是用来做构造函数的。使用 function 构造对象时，会让构造出来的对象的 initialize 方法执行 apply() 方法 function 中的第一个 this 是指用 new 调用构造函数之后生成的对象，也就是前面的 a，那么第二个 this 也当然应该是指同一个对象 this 调用 initialize 方法，参数是 arguments 对象（参数的数组对象），在构造函数执行时，对象 a 就会去执行 initialize 方法来初始化 arguments 作为 create 返回的构造函数的实参数组 传递给方法 apply，在调用 initialize 时作为参数传递给初始化函数 initialize 那么在 var a = new A(&quot;helloWord!&quot;); 的时候 &quot;helloWord!&quot; 就是实参数组（虽然只有一个字符串），传递给方法 apply 然后在调用 initialize 的时候作为参数传递给初始化函数 initialize 一个实际使用场景 12345678910111213141516171819(function(){ function Circle (nRadius, sMessage) { this.init.apply(this, arguments); } Circle.prototype = { init : function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI : 3.14, fnGetArea : function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } }; var c = new Circle(5, '构造初始化 面积'); alert(c.fnGetArea()); //构造初始化 面积: 78.5})(); 扩展：Math.max.apply(null, arr)max() 方法可以返回两个指定的数中带有较大的值的那个数 12345var arr = [1, 3, 5, 7, 9, 11, 2, 4, 6, 8, 10];console.log(Math.max.apply(null, arr));// 使用 call 方法可以达到同样目的// Math.max.call(null, 1, 2, 3, 4, 5); Math.max() 方法，支持传递多个参数，比如：Math.max(1, 3, 5, 7, 9, 11) 但是它不支持直接传递一个数组作为参数，比如：Math.max(new Array(1, 3, 5, 7, 9, 11)) 这里，只要我们有方法把数组，一个一个拆分开来，传递到 Math.max() 方法中，就实现了传递数组的方法，这里就可以利用到 apply() 函数 所有函数都有 apply(作用域链, 参数) 这个方法，这个函数的 “参数”，接收一个数组，并且是将数组中的每个值分开来，传递给调用函数，所以就实现了传递一个数组，取得最大值的方法 Function.apply() 是 JavaScript 的一个 OOP 特性，一般用来模拟继承和扩展 this 的用途 xx.apply 是一个调用函数的方法，其参数为：apply(Function, Args) Function 为要调用的方法，Args 是参数列表，当 Function 为 null 时，默认为上文 即 1Math.max.apply(null, arr) 扩展：Array.prototype.slice.call(arguments, 0)在 JavaScript 中我们经常会看到 Array.prototype.slice.call(arguments, 0) 的写法，这个方法的作用是把类数组对象转换成一个真正的数组 这里涉及到 slice() 方法和 call() 方法 slice()方法数组和字符串都有这个 slice 方法，这个方法的作用是截取一段数据，在数组中，该方法的返回值是包含截取元素的组成的数组，在字符串中，该方法的返回值是包含截取字符串组成的字符串 1234// 参数 start 表示数组片段开始处的下标，如果是负数，它声明从数组末尾开始算起的位置// 参数 end 表示数组片段结束处的后一个元素的下标，如果没有指定这个参数，切分的数组包含从 start 开始到数组结束的所有元素// 如果这个参数是负数，它声明的是从数组尾部开始算起的元素（不包括结束位置）array.slice(start, end) 需要注意的是，如果 slice() 方法没有传递参数，则默认是从 index 序列为 0 开始截取（见 MDN - Array.prototype.slice()） 比如： 1234567[1, 2, 3, 4, 5, 6].slice(2, 4);[1, 2, 3, 4, 5, 6].slice(-4, -2);[1, 2, 3, 4, 5, 6].slice();'everything'.slice(2, 4);'everything'.slice(-4, -2);'everything'.slice(); 前两个的返回值均为 [3, 4]，为数组，而后两个的返回值分别为 'er' 和 'hi'，为字符串 如果之传入一个参数的话，那就是输出从开始位置到结束位置的所有元素 而如果不传递参数，则是从 0 开始计算（可以认为返回一个原对象的副本，因为 slice 方法返回的是一个新的数组） 在字符串中，和 slice() 方法类型的还有两个方法：substring() 和 substr() 方法 其中，substring() 方法表示返回从开始位置到结束位置的字符串，substr() 接收两个参数，第一个参数表示开始位置，第二个参数表示要截取的字符个数，和前两个方法略有不同 当传入方法的参数为负数时，这三种方法又略有不同： slice() 像上面说的，是负数加上字符串的长度得出相应的正值 substring() 方法的参数均置为零 substr() 方法的第一个参数为负值加上字符串长度得到的正值，第二个参数置为零 Array.prototype.slice.call(arguments, 0)在 Array.prototype.slice.call(arguments, 0) 中，Array.prototype.slice 调用的是 Array 的原型方法，对于正真的数组是有 slice() 方法，但是对于像 arguments 或者自己定义的一些类数组对象虽然存在 length 等若干属性，但是并没有 slice() 方法 所以对于这种类数组对象就得使用原型方法来使用 slice() 方法，即 Array.prototype.slice（如果在自定义中的类数组对象中自定义了 slice() 方法，那么自然可以直接调用） 简单点说就是：对于 arguments 类数组，我们调用 Array.prototype.slice 原型方法，并用 call() 方法，将作用域限定在 arguments 中，这里 Array.prototype 就可以理解为 arguments，同参数 0 为 slice() 方法的第一个参数，即开始位置索引，通过这种方法就将 arguments 类数组转换成了真数组 Array.prototype.slice.call(arguments) 能将具有 length 属性的对象转成数组，除了 IE 下的节点集合（因为 ie 下的 dom 对象是以 com 对象的形式实现的，js 对象与 com 对象不能进行转换） 12345678910111213var a = { length: 2, 0: 'first', 1: 'second' };Array.prototype.slice.call(a); // ['first', 'second']var a = { length: 2 };Array.prototype.slice.call(a); // [undefined, undefined] 猜测 slice 的内部实现12345678910Array.prototype.slice = function (start, end) { var result = new Array(); start = start || 0; // this 指向调用的对象，当用了 call 后，能够改变 this 的指向，也就是指向传进来的对象 end = end || this.length; for (var i = start; i &lt; end; i++) { result.push(this[i]); } return result;} 一个转成数组的通用函数12345678910111213var toArray = function (s) { try { return Array.prototype.slice.call(s); } catch (e) { var arr = []; for (var i = 0, len = s.length; i &lt; len; i++) { // arr.push(s[i]); // 据说这样比 push 快 arr[i] = s[i]; } return arr; }} jQuery 中的 toArray()jQuery 中的方法 .toArray() 是将当前 jQuery 对象转换为真正的数组，转换后的数组包含了所有元素，方法 .toArray() 的实现巧妙地借用了数组的方法 slice() 12345678910111213141516//...// Save a reference to some core methodstoString = Object.prototype.toString,hasOwn = Object.prototype.hasOwnProperty,push = Array.prototype.push,slice = Array.prototype.slice,trim = String.prototype.trim,indexOf = Array.prototype.indexOf,toArray: function() { return slice.call(this, 0);},//... 连同 slice() 一起声明的还有 toString() 、hasOwn() 、trim() 、indexOf()，这里通过声明对这些核心方法的引用 使得在 jQuery 代码中可以借用这些核心方法的功能，执行时可通过方法 call() 和 apply() 指定方法执行的环境，即关键字 this 所引用的对象","link":"/2017/01/10/JavaScript/02/"},{"title":"JavaScript 中的作用域","text":"在看作用域之前，我们先来看看 IIFE，也就是所谓的立即执行函数，那么为什么需要 IIFE 传统的方法啰嗦，定义和执行分开写 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window） 转变表达式的办法有很多，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了 IIFE一个简单的 IIFE 12(function foo() {...}) // 这里是故意换行，实际上可以和下面的括号连起来(); 这就等价于： 123var foo = function () {...}; // 这就不是定义，而是表达式了foo(); 但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式 1(function foo(){...}()); 另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如 1234567891011!function foo() {...}(); // ...// 又或者+function foo() {...}(); // ...void function () { // ...}(); 所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的函数作用域，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了 如果你需要全局对象，那就 pass 给 IIFE 123void function (global) { // 在这里，global 就是全局对象了}(this) // 在浏览器里，this 就是 window 对象 变量提升（Hoisting）先看一个例子 12345678910var a = 1;function foo () { if (!a) { var a = 2; } alert(a);};foo(); // 输出 2 之所以输出 2，这就是所谓的变量提升了 所谓 ‘声明变量’ 1var a; 所谓 ‘定义变量’ 1var a = 1; 声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已 定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义 总结下来就是： 123var a; // 这是声明a = 1; // 这是定义（赋值）var a = 1; // 合二为一：声明变量的存在并赋值给它 当你以为你只做了一件事情的时候（var a = 1），实际上解释器把这件事情分解成了两个步骤 一个是声明（var a），另一个是定义（a = 1） 可以把之前的例子稍微转换一下，就成了如下 123456789101112var a;a = 1;function foo() { var a; // 关键在这里 if (!a) { a = 2; } alert(a); // 此时的 a 并非函数体外的那个全局变量}foo() 如代码所示，在进入函数体后解释器声明了新的变量 a，而无论 if 语句的条件如何，都将为新的变量 a 赋值为 2 作用域（Scoping）JavaScript 在 ES6 之前是没有块级作用域的（Block Scoping），只有函数作用域（Function Scoping） 当解析器读到 if 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 Hoisting JavaScript 只有函数作用域！ 所以在上文当中，若是想要 alert(a) 弹出那个 1，也可以创建有一个新的作用域，就是利用之前所说的 IIFE 123456789101112131415var a = 1;function foo() { // 这个就是 IIFE，它会创建一个新的函数作用域 // 并且该作用域在 foo() 的内部，所以 alert 访问不到 // 不过这个作用域可以访问上层作用域，这就叫 闭包 if (!a) { (function() { var a = 2; }()); }; alert(a);};foo(); 请始终保持作用域内所有变量的声明放置在作用域的顶部 因为这样可以避免 Hoisting 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问 但是，变量声明的提升并非 Hoisting 的全部 在 JavaScript 中，有四种方式可以让命名进入到作用域中（按优先级） 语言定义的命名：比如 this 或者 arguments，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 this 之类的，这样是没有意义的 形式参数：函数定义时声明的形式参数会作为变量被 hoisting 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的 Hosting 只提升了命名，没有提升定义 函数声明与函数表达式的差别先看两个例子 12345678910111213141516171819// test1function test () { foo(); function foo() { alert('出现'); }}test();// test2function test () { foo(); var foo = function() { alert('不会出现'); }}test(); 在第一个例子里，函数 foo 是一个声明，既然是声明就会被提升（特意包裹了一个外层作用域，因为全局作用域需要你的想象，不是那么直观，但是道理是一样的），所以在执行 foo() 之前，作用域就知道函数 foo 的存在了 这叫做：函数声明（Function Declaration），函数声明会连通命名和函数体一起被提升至作用域顶部 然而在第二个例子里，被提升的仅仅是变量名 foo，至于它的定义依然停留在原处，因此在执行 foo() 之前，作用域只知道 foo 的命名，不知道它到底是什么，所以执行会报错（通常会是：foo is not a function） 这叫做：函数表达式（Function Expression），函数表达式只有命名会被提升，定义的函数体则不会 变量对象JavaScript 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（VO） 变量对象（Variable Object，缩写为 VO）是一个抽象概念中的 ‘对象’，它用于存储执行上下文中 变量 函数声明 函数参数 VO 按照如下顺序填充： 函数参数（若为传入，初始化该参数值为 undefined） 函数声明（若发生命名冲突，会覆盖） 变量声明（初始化变量值为 undefined，若发生命名冲突，会忽略） 来看看以下几个实例，可以加深我们理解 VO 123456function foo (x, y, z) { function x () {}; alert(x); // function x () {}}foo(100); 在初始化阶段，先初始化函数的参数，参数 x 即为传进来的参数，为 100，但是在处理函数声明的时候，发生冲突，x 会被覆盖，所以返回的是一个函数对象 12345678910111213141516171819202122232425262728// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略function foo(x, y, z) { function fn() { }; var fn; console.log(fn); // function fn () {}}foo(100);// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作function foo(x, y, z) { function fn() { }; var fn = 1; console.log(fn); // 1}foo(100);// 在看一个容易出错的，最终会输出 100 和 0var num = 0;function a(num) { num = 100; console.log(num);}a();console.log(num); 函数表达式不会影响 VO，比如 var a = function foo(){} 这里的 foo 是函数表达式的名称，这个是不会记录到 AO 中的，这也是为什么我们不能在外部通过 foo 来获取到这个函数对象 实战先来看几个 setTimeout 相关的问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 第一个var a = 6;setTimeout(function () { alert(a); // 输出 66 a = 666;}, 1000);a = 66;// 第二个var a = 6;setTimeout(function () { var a = 666; alert(a); // 输出 666}, 1000);a = 66;//第三个var a = 6;setTimeout(function () { alert(a); // 输出 undefined var a = 666;}, 1000);a = 66;//第四个var a = 6;setTimeout(function () { a = 666; alert(a); // 输出 666}, 1000);a = 66;//第五个var a = 6; setTimeout(function(){ alert(a); var a = 66; }, 1000);a = 666; alert(a); // 666, undefined; 这几个问题涉及到了 setTimeout 的工作原理，执行环境与作用域还有函数的创建与调用 首先先说一下 setTimeout(function(){},time) 函数，现在在我们的 js 文件中有这么一段代码：setTimeout(a(), 5000) 在执行流执行到 setTimeout 代码时，并不会原地踏步地等待执行完毕后再向下执行，而是会告诉浏览器，我这段代码要等待 5 秒之后再执行，然后立即向下执行接下来的代码 现在可以先解决第一个问题了 首先定义了一个局部变量 a，并且 a = 6 ，然后执行流遇到了 setTimeout()，告诉浏览器，我 1 秒之后再执行这段代码，此时 a 仍然为 6 然后跳过 setTimeout() 中的代码继续向下执行，就碰到了 a = 66，将 a 赋值为 66 ，一秒过去了之后，浏览器开始调用 setTimeout() 函数中的匿名函数，遇到了 alert(a)，在此之前匿名函数中并没有创造局部变量 a，所以随着作用域链由内向外搜寻看看有没有变量 a，当搜寻到外部函数的作用域时，发现 a 已经被赋值成了 66，则返回结果，最终弹出窗口显示 66 第二个问题中，由于在 setTimeout() 的匿名函数中拥有了一个局部变量 a，所以最后 alert(a) 输出的是 666，（因为 var a = 666; 定义了局部变量 a，并且赋值为 666，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量） 至于第三个问题，涉及到了一个函数的创建与执行的区别，前面的运行同上面两个类似所以，直到执行流遇到 alert(a) 的时候，开始搜寻当前环境下有没有 a 变量，最终发现了一个 a 变量（被前置的，当前为 undefined），但是在未执行 var a = 666 之前，a 并没有被赋值，所以 alert(a) 的最终结果为 undefined，这也解释了为什么第四个最终会输出 666 至于最后一个，需要注意的是是先弹出 666，然后才是 undefined，（异步处理，声明提前） 再来看几个比较绕的： 12345678910111213141516171819function test() { var a = 1; setTimeout(function () { alert(a); a = 3; }, 1000); a = 2; setTimeout(function () { alert(a); a = 4; }, 3000);};test();alert(0); 首先 setTimeout 是一个异步延迟函数，上面说过了的，先弹出 0 是很明显的，因为 test 中的两个 alert() 都被延迟了，再弹出 0 之前 test 中的 a 是 2 所以在弹出 0 之后的第一个定时器中的 alert 就是 2 了，在弹 2 之后执行了赋值操作 a = 3，所以第二个定时器弹出的为 3","link":"/2017/01/18/JavaScript/03/"},{"title":"JavaScript 中的类型检测","text":"在 JavaScript 中我们会经常看到这种代码，变量和 null 的比较 1234567var Controller = { process: function (items) { if (items !== null) { // do something } }} 仅仅和 null 比较并不能提供足够的信息来判断后续代码的执行是否真的安全，好在 JavaScript 提供了多钟方式来检测变量的真实性 检测原始值在 JS 中有 5 种原始类型：字符串，数字，布尔值，null 和 undefined，如果你希望检测一个值是否为原始类型，最佳选择是使用 typeof 运算符 对于字符串，typeof 返回 'string' 对于数字，typeof 返回 'number' 对于布尔值，typeof 返回 'boolean' 对于 undefined，typeof 返回 'undefined' 使用 typeof 来检测 4 种原始值的类型是非常安全的做法 123456789101112131415161718192021// 检测字符串if (typeof name === 'string') { anotherName = name.slice(0, 2);}// 检测数字if (typeof cont === 'number') { updateCount(cont);}// 检测布尔值if (typeof found === 'boolean' &amp;&amp; found) { message('Found!');}// 检测undefinedif (typeof myApp === 'undefined') { myApp = { // do something }} typeof 运算符的独特之处在于，将其用于一个未声明的变量也不会报错，未定义的变量和值为 undefined 的变量通过 typeof 都将返回 'undefined' 最后一个原始值 null，一般不用于检测语句，但有一个例外，如果所期望的值真的是 null，则可以直接和 null 进行比较，这时应当使用 '===' 或者 '!==' 来和 null 进行比较 12345var element = document.getElementById('myDiv');if (element !== null) { element.classList.add('found');} 如果 DOM 元素不存在，则通过 document.getElementById() 得到的值为 null，这个方法要么返回一个节点，要么返回 null，由于这时 null 是可预见的一种输出，则可以使用 !== 来检测返回结果 检测引用值引用值也称对象(object)，在 JS 中除了原始值之外的值都是引用，有这几种内置的引用的类型：Object, Array, Error, Date typeof 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 'object' 1234567console.log(typeof {}); // 'object'console.log(typeof []); // 'object'console.log(typeof new Date()); // 'object'console.log(typeof new RegExp()); // 'object' typeof 另外一种不推荐的用法是检测 null 的类型的时候，将会返回 'object' 1console.log(typeof null); // 'object' 所以，在检测某个引用值的类型的最好的方法是使用 instanceof 运算符 12345678910111213141516// 检测日期if (value instanceof Date) { console.log(value.getFullYear());}// 检测正则表达式if (value instanceof RegExp) { if (value.test(anotherValue)) { console.log('Matches'); }}// 检测 Errorif (value instanceof Error) { throw value;} instanceof 的一个有意思的特征是它不仅检测构造这个对象的构造器，还检测原型链，原型链包含了很多信息，包括定义对象所采用的继承模式 比如，默认情况下，每个对象都继承自 Object，因此每个对象的 value instanceof Object 都会返回 true 1234var now = new Date();console.log(now instanceof Date); // trueconsole.log(now instanceof Object); // true 正因为这个原因，使用 value instanceof Object 来判断对象是否属于某个特定类型的做法并非最佳 instanceof 运算符也可以检测自定义的类型 12345678function Person(name) { this.name = name;}var me = new Person('zhangsan');console.log(me instanceof Person); // trueconsole.log(me instanceof Object); // true 变量 me 是 Person 的实例，因此 me instanceof Person 返回的是 true，之前也提到过，所有对象都被认为是 Object 的实例，故也返回 true 在 JS 中检测自定义类型的时候，最好的做法就是使用 instanceof 运算符，这也是唯一的方法，但是也有例外 假设在一 frameA 中的一个对象被传入到了 frameB 中，两个 frame 中都定义了构造函数 Person，如果来自 A 的对象是 A 的 Person 的实例，则如下规则成立 12345// trueframeAPersonInstance instanceof frameAPersonInstance// falseframeAPersonInstance instanceof frameBPersonInstance 因为每个 frame 内都有用 Person 的一份 copy，它被认为是该 frame 中的 Person 拷贝的实例，尽管两个定义可能完全不一样 这个问题不仅出现在自定义类型身上，其他两个非常重要的内置类型也有这个问题：函数和数组，对于这两个类型来说，一般不使用 instanceof 函数检测从技术上讲，JavaScript 中的函数是引用类型，同样存在 Function 构造函数，每个函数都是其实例，比如： 1234function myFunc () {}// 不推荐console.log( myFunc instanceof Function ); // true 然而，这个方法并不能跨 frame 使用，因为每个 frame 中都有各自的 Function 构造函数，好在 typeof 运算符也可以用于函数 1234function myFunc () {}// 推荐，返回的是 functionconsole.log( typeof myFunc === 'function' ); // true 检测函数最好的方法是使用 typeof ，因为它可以跨 frame 使用 数组检测同之前一样，每个 frame 中都有各自的 Array 构造函数，因此一个 frame 中的实例在另外一个 frame 里不会被识别，但是，调用某个值的内置 toString() 方法在所有浏览器中都会返回标准的字符串结果，对于数组来说，其返回的字符串为 '[object Array]'，也不用考虑数组是在哪个 frame 中被构造出来的 123function isArray (value) { return Object.prototype.toString.call(value) === '[object Array]';} 这种方法在识别内置对象的时候往往十分有用，但是对于自定义对象请不要使用这种方法，比如，内置的 JSON 对象将返回 '[object JSON]' 从那时起，ES5 中将 Array.isArray() 正式的引入，唯一的目的就是检测一个值是否为数组 1234567function isArray (value) { if (typeof Array.isArray === 'function') { return Array.isArray(value); } else { return Object.prototype.toString.call(value) === '[object Array]'; }} 属性检测另外一种用到 null（和 undefined）的场景是当检测一个属性是否在对象中存在的时候，比如 1234567891011121314// 不推荐的写法，检测假值if (object[prototype]) { // ...}// 不推荐的写法，与 null 比较if (object[propertyName] != null) { // ...}// 不推荐的写法，与 undefined 比较if (object[propertyName] != undefined) { // ...} 以上代码的每个判断，实际上是通过给定的名字来检查属性的值，而非判断给定的名字的所指的属性是否存在，因为当这些属性值为假值（false value）的时候，结果会出错，比如 0， null， undefined， false， ''(空字符串) 判断属性是否存在的最好的方法是使用 in 运算符，in 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值，如果实例对象的属性存在，或者继承自对象的原型，in 运算符都会返回 true 1234567891011121314var object = { count: 0, related: null};// 推荐if ('count' in object) { // ...}// 不推荐if (object['count']) { // ...} 如果你只想检查实例对象的某个属性是否存在，则使用 hasOwnProperty() 方法，所有继承自 Object 的对象都有这个方法，如果实例中存在这个属性则返回 true 需要注意的是：如果这个属性只存在原型里，则会返回 false 但是在 IE8 以及更早的版本中，DOM 对象并非继承自 Object，因此也不包含这个方法，也就是说，你在调用 DOM 对象的 hasOwnProperty() 方法之前应当先检测其是否存在（如果你已经知道对象不是DOM，则可以省略这一步） 123456789// 对于所有非 DOM 对象来说，这是好的写法if (object.hasOwnProperty('count')) { // ...}// 如果你不确定是否为 DOM 对象，则可以这样写if ('hasOwnProperty' in object &amp;&amp; object.hasOwnProperty('count')) { // ...} 在判断实例对象是否存在的时候，推荐使用 in 运算符，只有在需要判断实例属性的时候才会用到 hasOwnProperty() 不管你什么时候需要检测属性的存在性，请使用 in 运算符或者 hasOwnProperty()，这样可以避免很多 BUG 附：关于 hasOwnProperty()hasOwnProperty() 函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性，如果有，返回 true，否则返回 false 该方法属于 Object 对象，由于所有的对象都’继承’了 Object 的对象实例，因此几乎所有的实例对象都可以使用该方法 1234567891011121314151617181920212223242526272829303132function Site() { this.name = 'zhangsan'; this.url = 'http://www.baidu.com/'; this.sayHello = function () { console.log('欢迎来到 ' + this.name); };}var obj = { engine: 'PHP', sayHi: function () { console.log('欢迎访问 ' + this.url); }};// 使用对象 obj 覆盖 Site 本身的 prototype 属性Site.prototype = obj;var s = new Site();console.log(s.hasOwnProperty('name')); // trueconsole.log(s.hasOwnProperty('sayHello')); // true// 以下属性继承自原型链，因此为 falseconsole.log(s.hasOwnProperty('engine')); // falseconsole.log(s.hasOwnProperty('sayHi')); // falseconsole.log(s.hasOwnProperty('toString')); // false// 想要查看对象(包括原型链)是否具备指定的属性，可以使用 in 操作符console.log('engine' in s); // trueconsole.log('sayHi' in s); // trueconsole.log('toString' in s); // true","link":"/2017/03/09/JavaScript/08/"},{"title":"constructor、__proto__ 和 prototype 区别和关系","text":"constructor 属性返回对创建此对象的数组函数的引用，它是不会影响任何 JavaScript 的内部属性的 看下面一段代码 12345678function Foo() { // ... }Foo.prototype.constructor === Foo; // true var a = new Foo();a.constructor === Foo; // true 看起来 a.constructor === Foo 为 true 则意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样 实际上，.constructor 引用同样被委托给了 Foo.prototype，而 Foo.prototype.constructor 默认指向 Foo Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性，如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性 思考下面的代码 12345678function Foo() { } Foo.prototype = { }; // 创建一个新原型对象 var a1 = new Foo(); a1.constructor === Foo; // false a1.constructor === Object; // true a1 并没有 .constructor 属性，所以它会委托 prototype 链上的 Foo.prototype，但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype，这个对象有 .constructor 属性，指向内置的 Object(..) 函数 当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举的属性 123456789101112function Foo() { } Foo.prototype = { }; // 创建一个新原型对象 // 需要在 Foo.prototype 上 '修复' 丢失的 .constructor 属性 // 新对象属性起到 Foo.prototype 的作用 Object.defineProperty( Foo.prototype, 'constructor' , { enumerable: false, writable: true, configurable: true, value: Foo // 让 .constructor 指向 Foo } ); 实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用 .constructor 并不是一个不可变属性，它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改） 此外，你可以给任意 prototype 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值 所以这是一个非常不可靠并且不安全的引用，通常来说要尽量避免使用这些引用 但是有的时候，为了将实例的构造器的原型对象暴露出来，比如写了一个插件，别人得到的都是你实例化后的对象，如果想扩展下对象，就可以用 instance.constructor.prototype 去修改或扩展原型对象 1234567891011121314151617var a, b;(function () { function A(arg1, arg2) { this.a = 1; this.b = 2; } A.prototype.log = function () { console.log(this.a); } a = new A(); b = new A();})()a.log(); // 1b.log(); // 1 因为 A 在闭包里，所以现在我们是不能直接访问 A 的，那如果我们想给类 A 增加新方法，那么就可以通过访问 constructor 就可以了 1234567// a.constructor.prototype 在 chrome，firefox 中可以通过 a.__proto__ 直接访问a.constructor.prototype.log2 = function () { console.log(this.b)}a.log2(); // 2b.log2(); // 2 或者我们想知道 a 的构造函数有几个参数？ 1a.constructor.length 或者再复杂点，我想知道 a 的构造函数的参数名是什么 12a.constructor.toString().match(/\\(.*\\)/).pop().slice(1,-1).split(',');// ['arg1', 'arg2'] proto（隐式原型） 与 prototype（显式原型）proto .__proto__ 并不存在于你正在使用的对象中，实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的 Object.prototype 中（它们是不可枚举的） .__proto__ 看起来很像一个属性，但是实际上它更像一个 getter/setter .__proto__ 的实现大致上是这样的 12345678910Object.defineProperty(Object.prototype, '__proto__', { get: function () { return Object.getPrototypeOf(this); }, set: function (o) { // ES6 中的 setPrototypeOf(..) Object.setPrototypeOf(this, o); return o; }}); prototype所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止 toString()、valueOf() 和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们 JavaScript中这个机制的本质就是对象之间的关联关系 简单来说 prototype 机制就是指对象中的一个内部链接引用另一个对象 两者间的联系记住以下两点 __proto__ 是每个对象都有的一个属性，而 prototype 是函数才会有的属性 __proto__ 指向的是构造该对象的构造函数的原型，而 prototype 指向的，是以当前函数作为构造函数构造出来的对象的原型对象 明确以下三点 通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性 Object.prototype 这个对象，它的 __proto__ 指向的是 null console.log(Object.prototype.__proto__) 输出 null 理解下面这个图 接下来详细说明 显式原型(explicit prototype property)每一个函数在创建之后都会拥有一个名为 prototype 的属性，这个属性指向函数的原型对象 显式原型的作用用来实现基于原型的继承与属性的共享 隐式原型(implicit prototype link)JavaScript 中任意对象都有一个内置属性 prototype，在 ES5 之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 __proto__ 来访问，ES5 中有了对于这个内置属性标准的 Get 方法 Object.getPrototypeOf() 隐式原型的作用是构成原型链，同样用于实现基于原型的继承，举个例子，当我们访问 obj 这个对象中的 x 属性时，如果在 obj 中找不到，那么就会沿着 __proto__ 依次查找 二者的关系隐式原型指向创建这个对象的函数(constructor)的 prototype 通过下面的一些实例巩固一下123456789101112131415161718192021var obj = { a : 1 };console.log(obj.__proto__ === Object.prototype); // truevar str = new String('123');console.log(str.__proto__ === String.prototype); // truefunction Point(){};var Circle = Object.create(Point);console.log(Circle.__proto__ === Point); // trueconsole.log(Circle.__proto__ === Point.prototype); // falsevar p = new Point();console.log(Point.__proto__); // function Empty() {}console.log(Point.prototype); // Point {}console.log(p.__proto__); // Point {}console.log(p.prototype); // undefined 一些说明123456789101112131415161718192021222324252627// obj 一般对象var obj = {}console.log(obj.constructor) // function Object() { }console.log(obj.prototype) // undefinedconsole.log(obj.__proto__) // Object { } [ 注意，这个是对象，不是构造函数 Object () { } ]console.log(obj.__proto__.constructor) // function Object() { }console.log(obj.__proto__.__proto__) // nullconsole.log(obj.__proto__.prototype) // undefined// -------------------------------------------------------------------------// 函数（包括普通函数，构造函数，原生函数[Array，Object，String等]）function fn () {}console.log(fn.constructor) // Function() { }console.log(fn.prototype) // Object {constructor: function} 构造函数console.log(fn.__proto__) // function () { } 空函数 emptyconsole.log(fn.__proto__.constructor) // Function() { }console.log(fn.__proto__.__proto__) // Object { } [ 注意这个是对象，不是构造函数 Object () { } ]console.log(fn.__proto__.prototype) // undefined Array.prototype.proto 指向什么？Array.prototype 也是一个对象，对象就是由 Object() 这个构造函数创建的，因此 1Array.prototype.__proto__ === Object.prototype; // true 也可以理解为，所有的内建对象都是由 Object() 创建而来 自定义对象12345678910111213141516171819202122232425// 1. 默认情况下function Foo() {}var foo = new Foo()Foo.prototype.__proto__ === Object.prototype // true 理由同上// 2. 其他情况 // （1）function Bar() {} // 这时我们想让 Foo 继承 BarFoo.prototype = new Bar()Foo.prototype.__proto__ === Bar.prototype // true // （2）Foo.prototype = { // 我们不想让 Foo 继承谁，但是我们要自己重新定义 Foo.prototype a: 10, b: -10}// 这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 Foo.prototype.__proto__ === Object.prototype 以上两种情况都等于完全重写了 Foo.prototype，所以 Foo.prototype.constructor 也跟着改变了，于是乎 constructor 这个属性和原来的构造函数 Foo() 也就切断了联系 instanceofinstanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系，instanceof 的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例，它的内部实现原理是这样的 123456// 设 L instanceof R // 通过判断L.__proto__.__proto__ ..... === R.prototype // 最终返回true or false 也就是沿着 L 的 __proto__ 一直寻找到原型链末端，直到等于 R.prototype 为止 知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了 1234567Function instanceof Object // true Object instanceof Function // true Function instanceof Function // trueObject instanceof Object // trueNumber instanceof Number // false","link":"/2017/04/06/JavaScript/10/"},{"title":"Object.defineProperty()","text":"Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象 123456// obj 需要定义属性的对象// prop 需定义或修改的属性的名字// descriptor 将被定义或修改的属性的描述符// 返回值 返回传入函数的对象，即第一个参数 objObject.defineProperty(obj, prop, descriptor) 对象里目前存在的属性描述符有两种主要形式，数据描述符和存取描述符 数据描述符是一个拥有可写或不可写值的属性 存取描述符是由一对 getter-setter 函数功能来描述的属性 描述符必须是两种形式之一，不能同时是两者，并且数据描述符和存取描述符不能混合使用 在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读 但是从 ES5 开始，所有属性都具备了属性描述符 12345678910111213141516var myObject = { a: 2}Object.getOwnPropertyDescriptor(myObject, a);/*{ value: 2, writable: true, enumerable: true, configurable: true}*/ 如你所见，这个普通的对象属性对应的属性描述符（也被称为’数据描述符’，因为它只保存一个数据值），不仅仅只有一个 2，它还包含了另外三个特性，writable（可写），enumerable（可枚举），configurable（可配置） 在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(...) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置 12345678910var myObject = {}Object.defineProperty( myObject, 'a', { value: 2, writable: true, configurable: true, enumerable: true});myObject.a; // 2 我们使用 defineProperty(...) 给 myObject 添加了一个普通的属性并显式的指定了一些特性，然而，一般不会使用这种方式，除非你想修改属性描述符 默认情况下，使用 Object.defineProperty() 增加的属性值是不可改变的 1. Writablewritable 决定是否可以修改属性的值 123456789101112var myObject = {}Object.defineProperty(myObject, a, { value: 2, writable: false, // 不可写 configurable: true, enumerable: true})myObject.a = 3;myObject.a; // 2 如你所见，我们对于属性值的修改静默失败（silently failed），如果在严格模式（'use strict'）下，还会导致出错 简单来说，你可以把 writable: false 看作是属性不可改变，相当于空操作的 setter（后面会提到） 2. Configurable只有属性是可配置的，就可以使用 defineProperty(...) 方法来修改属性描述符 123456789101112131415161718192021222324var myObject = { a: 2}myObject.a = 3;myObject.a; // 3Object.defineProperty( myObject, 'a', { value: 4, writable: true, configurable: false, // 不可配置 enumerable: true})myObject.a; // 4myObject.a = 5;myObject.a; // 5Object.defineProperty( myObject, 'a', { value: 6, writable: true, configurable: true, enumerable: true}) // TypeError 最后一个 defineProperty(...) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错 注意，把 configurable 修成为 false 是单向操作，无法撤销 需要注意一个例外，即便属性是 configurable: false ，我们还是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true 除了无法修改，configurable: false 还会禁止删除这个属性 12345678910111213141516171819202122var myObject = { a: 2};myObject.a; // 2delete myObject.a; myObject.a; // undefinedObject.defineProperty(myObject, 'a', { value: 2, writable: true, configurable: false, enumerable: true});myObject.a; // 2 delete myObject.a; myObject.a; // 2 如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的 在本例中，delete 只用来直接删除对象的（可删除）属性，如果对象的某个属性是某个 对象/函数 的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象/函数就可以被垃圾回收（是一个删除对象属性的操作，仅此而已） 3. Enumerable这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环，如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它，相对地，设置成 true 就会让它出现在枚举中 如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable: false 简单总结一下 Writable 如果在 Object.defineProperty() 中定义了 writable: false，重新给对象赋值的话是无效的，严格模式（'use strict'）下，还会导致出错 Configurable 如果在 Object.defineProperty() 中定义了 configurable: false，可以重新给对象赋值，但是不管是不是处于严格模式，不能再重新使用 Object.defineProperty 来重新配置属性，这样的操作会导致报错 需要注意的是，把 configurable 修成为 false 的操作是单向操作，是无法撤销的！（同时也会禁止删除这个属性）但是可以把 writable 的状态由 true 改成 false，但是无法由 false 改成 true（同样是单向操作） Enumerable 如果在 Object.defineProperty() 中定义了 enumerable: false，属性就不会出现在对象的属性枚举中，比如说 for..in 循环，虽然仍然可以正常访问它 不变性有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现 很重要的一点是，所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性，如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的 123myImmutableObject.foo; // [1, 2, 3] myImmutableObject.foo.push( 4 );myImmutableObject.foo; // [1, 2, 3, 4] 1. 对象常量结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性（不可修改、重定义或者删除） 1234567var myObject = {};Object.defineProperty(myObject, 'FAVORITE_NUMBER', { value: 42, writable: false, configurable: false}); 2. 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..) 12345678var myObject = { a: 2};Object.preventExtensions(myObject);myObject.b = 3;myObject.b; // undefined 在非严格模式下，创建属性 b 会静默失败，在严格模式下，将会抛出 TypeError 错误 3. 密封Object.seal(..) 会创建一个’密封’的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为configurable: false 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值） 4. 冻结Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有’数据访问’属性标记为 writable: false，这样就无法修改它们的值 [[Get]]先看以下代码 12345var myObject = { a: 2};myObject.a; // 2 myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样 在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用，[[Get]]()） 对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值 然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为（遍历可能存在的 [[Prototype]] 链，也就是原型链） 如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined， 12345var myObject = { a: 2};myObject.b; // undefined 注意，这种方法和访问变量时是不一样的，如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常， 1234567var myObject = { a: undefined }; myObject.a; // undefined myObject.b; // undefined 从返回值的角度来说，这两个引用没有区别 — 它们都返回了 undefined 然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理 由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以 [[Get]] 操作返回了 undefined [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作 [[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素） 属性是否是访问描述符？如果是并且存在 setter 就调用 setter 属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常 如果都不是，将该值设置为属性的值 Getter 和 Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上，getter 是一个隐藏函数，会在获取属性值时调用，setter 也是一个隐藏函数，会在设置属性值时调用 当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为’访问描述符’（和’数据描述符’相对） 对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性 12345678910111213141516171819202122var myObject = { // 给 a 定义一个 getter get a() { return 2; }};Object.defineProperty( myObject, // 目标对象 'b', // 属性名 { // 描述符 // 给 b 设置一个 getter get: function () { return this.a * 2 }, // 确保 b 会出现在对象的属性列表中 enumerable: true });myObject.a; // 2myObject.b; // 4 不管是对象文字语法中的 get a() {..}，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值 123456789var myObject = { // 给 a 定义一个getter get a() { return 2; }};myObject.a = 3;myObject.a; // 2 由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误，而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的 为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作，通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为）， 12345678910111213var myObject = { // 给 a 定义一个 getter get a() { return this._a_; }, // 给 a 定义一个 setter set a(val) { this._a_ = val * 2; }};myObject.a = 2;myObject.a; // 4 参考 《You Don’t Know JS》 《JavaScript 高级程序设计》 MDN - Object.defineProperty()","link":"/2017/05/02/JavaScript/14/"},{"title":"Function.prototype.bind()","text":"要想改变被调用函数的上下文，可以使用 call 或 apply 方法，但如果重复使用就会很不方便，因为每次都要把上下文对象作为参数传递，而且还会使代码变得不直观 针对这种情况，我们可以使用 bind 方法来永久地绑定函数的上下文，使其无论被谁调用，上下文都是固定的。bind 语法如下： 1func.bind(thisArg[, arg1[, arg2[, ...]]]) 其中 func 是待绑定函数，thisArg 是改变的上下文对象，arg1、arg2 是绑定的参数表。bind 方法返回值是上下文为 thisArg 的 func。通过下面例子可以帮你理解 bind 的使用方法： 12345678910111213141516171819202122var someuser = { name: 'abc', func: function () { console.log(this.name); }};var foo = { name: 'foobar'};foo.func = someuser.func;foo.func(); // 输出 foobar foo.func1 = someuser.func.bind(someuser);foo.func1(); // 输出 abc func = someuser.func.bind(foo);func(); // 输出 foobar func2 = func;func2(); // 输出 foobar 上面代码直接将 foo.func 赋值为 someuser.func，调用 foo.func() 时，this 指针为 foo，所以输出结果是 foobar foo.func1 使用了 bind 方法，将 someuser 作为 this 指针绑定到 someuser.func，调用 foo.func1() 时，this 指针为 someuser，所以输出结果是 abc 全局函数 func 同样使用了 bind 方法，将 foo 作为 this 指针绑定到 someuser.func，调用 func() 时，this 指针为 foo，所以输出结果是 foobar 而 func2 直接将绑定过的 func 赋值过来，与 func 行为完全相同 使用 bind 绑定参数表bind 方法还有一个重要的功能：绑定参数表，如下例所示 1234567891011var person = { name: 'foo', says: function (act, obj) { console.log(this.name + ' ' + act + ' ' + obj); }};person.says('loves', 'bor'); // 输出 foo loves bor fooLoves = person.says.bind(person, 'loves');fooLoves('you'); // 输出 foo loves you 可以看到，fooLoves 将 this 指针绑定到了 person，并将第一个参数绑定到 loves，之后在调用 fooLoves 的时候，只需传入第三个参数 这个特性可以用于创建一个函数的 “捷径” ，之后我们可以通过这个 “捷径” 调用，以便在代码多处调用时省略重复输入相同的参数，也就是下面会说到的 currying 理解 bind尽管 bind 很优美，还是有一些令人迷惑的地方，例如下面的代码 12345678910111213141516var someuser = { name: 'abc', func: function () { console.log(this.name); }};var foo = { name: 'foobar'};func = someuser.func.bind(foo);func(); // 输出 foobar func2 = func.bind(someuser);func2(); // 输出 foobar 全局函数 func 通过 someuser.func.bind 将 this 指针绑定到了 foo，调用 func() 输出了 foobar 我们试图将 func2 赋值为已绑定的 func 重新通过 bind 将 this 指针绑定到 someuser 的结果， 而调用 func2 时却发现输出值仍为 foobar， 即 this 指针还是停留在 foo 对象上，这是为什么呢？要想解释这个现象，我们必须了解 bind 方法的原理，让我们看一个 bind 方法的简化版本（不支持绑定参数表） 123someuser.func.bind = function(self) { return this.call(self);}; 假设上面函数是 someuser.func 的 bind 方法的实现，函数体内 this 指向的是 someuser.func，因为函数也是对象，所以 this.call(self) 的作用就是以 self 作为 this 指针调用 someuser.func 123456789// 将 func = someuser.func.bind(foo) 展开func = function() { return someuser.func.call(foo); };// 再将 func2 = func.bind(someuser) 展开func2 = function() { return func.call(someuser);}; 从上面展开过程我们可以看出，func2 实际上是以 someuser 作为 func 的 this 指针调用了 func，而 func 根本没有使用 this 指针，所以两次 bind 是没有效果的 bind 与 currying比如我们有一个函数 123function add(a, b, c) { return a + b + c;} add 函数的作用是把参数 a, b, c 进行 拼接/相加，但是有的时候不需要一次把这个函数都调用完成，而是我调用一次把前两个参数传完了以后，然后得到了这样的一个函数，再去调用，并且每次传入第三个值 1234// 由于我们不需要改变它的 this，所以随便传入一个 undefined/null ，但是我们提供了额外的参数 100var func = add.bind(null, 100);func(1, 2); // 103 然后我们拿到这样一个 bind 函数以后，相当于这个 100 就会固定赋值给第一个参数，也就是这里的 a 参数， 然后在调用的时候传入 1 和 2 参数，1 和 2 就会分别给 b 和 c，所以，最后的结果为 103 附：currying 的实现12345678910111213141516171819202122232425262728293031// 定义模块Function.prototype.method = function (name, func) { this.prototype[name] = func; return this;}// 应用模块Function.method(\"curry\", function () { var slice = Array.prototype.slice, that = this, args = slice.apply(arguments); return function () { return that.apply(null, args.concat(slice.apply(arguments))); }})// 定义方法 addvar add = function (a, b) { if (typeof a !== \"number\" || typeof b !== \"number\") { throw { name: \"TypeError\", message: \"add needs numbers\" }; } return a + b;}// 应用var add1 = add.curry(1);console.log(add1(5)) bind 与 new123456789function foo() { this.b = 100; return this.a;}var func = foo.bind({ a: 1 });func(); // 1new func(); // {b: 100} 声明了一个全部变量 b，并且把它的值赋为 100，然后返回全局变量 a，这样我们直接调用的话，那么 this 就会指向 bind 这样的一个参数，所以 return this.a 就会返回 1 如果使用了 new，ruturn 除非是对象，如果不是对象，将会把 this 做为返回值，并且 this 会被初始化为默认的一个空对象，这个对象的原型为 foo.prototype 所以说，我们用 new 去调用的话，这种情况下，即使我们使用了 bind 方法，但是这个 this 依然会指向没有 bind 的时候所指向的（正常状态），这样一个空对象的 b 属性会被赋值为 100，然后整个这个对象会做为返回值返回，会忽略这样一个 return bind 详解bind 方法主要实现以下功能 一个是绑定函数里面的 this（或者说改变函数里面的 this 指向） 另一个就是把函数拆分为不同的子函数，即柯里化功能 还有就是在 new 调用的时候，忽略掉 bind 的作用 其实在使用 bind 的时候，无非就分为两种情况，一种是直接调用，另一种就是 new 调用，如下所示 12345678910function foo(c) { this.b = 100; console.log(c); return this.a;}var func = foo.bind({a: 1}, 20);func(); // 20 1new func(); // 20 {b: 100} bind 具体实现方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142if (!Function.prototype.bind) { // 传入的 oThis 就是 foo.bind({a: 1}, 20) 中传入的对象 {a: 1} Function.prototype.bind = function (oThis) { if (typeof this !== \"function\") { throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); } // 调用数组方法，剔除掉第一个参数，得到剩余参数 var aArgs = Array.prototype.slice.call(arguments, 1), // 这里的 this 指向函数对象 foo fToBind = this, fNOP = function () { }, // 最后返回的就是这个对象，其实就是 fToBind.apply(...) // 在不调用 func 的情况下，func 本质就是返回的 apply(..) 函数 fBound = function () { // 这里的 this 指的是调用 bind 后 func 的执行环境 // 第一点，见最后 return fToBind.apply(this instanceof fNOP ? this : oThis, // 这里的 arguments 和上面的不一样，这里是 func() 的执行环境 // 比如 foo.bind({a:1}, 20) 中剩余的参数 20 和调用 func(b, c) 时的参数 b 和 c // 这里就利用 aArgs.concat() 连接了起来，实现了柯里化的功能 // 单单执行 bind 的时候是空数组（类数组对象），因为 arguments 是指向 实参 对象的引用 // 只有在函数调用的时候，传入了实参以后，才会有 arguments 对象 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 第二点，见最后 fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; };} 比较好理解的地方都直接标记在注释当中了，现在就剩下比较饶的两点，一个一个来看 简单来说就是分为以下两种情况，第一种就是直接调用的情况 正常调用的时候，即 func()，此时 func() 中的 this 是指向 window 的，所以 this instanceof fNOP 为 false 此时执行的是 fToBind.apply(oThis, ...)，这里的 oThis 也就是传入 bind() 的第一个参数对象 {a: 1} 所以这时 foo() 函数中的 this 就可以指向这个参数对象（{a: 1}） 而 bind() 后剩余的参数（比如 bind({a:1}, 20) 中的 20）和 fBound 的一些自己的参数，这个就是通过最后的 aArgs.concat() 拼接完成的 第二种就是 new 调用的情况 当在对 func() 使用 new 的时候，本质上 func() 就是作为构造函数在使用了，所以此时的 this 指向的是一个空对象（见最后） 这时的 this instanceof fNOP 就为 true 了，而此时执行的也就是 fToBind.apply(this, ...) 所以这时的 this 就作为 foo() 函数中调用的 this，也就不再指向 bind() 后的参数对象了，而是作为函数体内正常的 this 使用 这也就忽略掉 bind 的作用了（即 new 了以后，this 和 bind() 后绑定的参数没有关系了） 关于 this 指向的是一个空对象当一个函数被作为一个构造函数来使用（使用 new 关键字），它的 this 与即将被创建的新对象绑定（见 构造函数中的 this） 当构造器返回的默认值是一个 this 引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回 this（不指定，则默认为一个空对象） 12345function foo() { console.log(this.__proto__ === foo.prototype) // true}new foo() 关于 fNOP.prototype = this.prototype在之前的代码中有这么一段 123456fNOP = function () { },// ...fNOP.prototype = this.prototype;fBound.prototype = new fNOP(); 之所以会拷贝一个 fNOP 的 prototype 给 fBound，由于是拷贝所以修改 fBound 的 prototype 不会影响到 fNOP 的 prototype 其实这两种方法是等价的： 123456fNOP.prototype = this.prototype;fBound.prototype = new fNOP();// ==&gt; 两者是相等的fBound.prototype = Object.creat(this.prototype); 如果直接使用 fBound.prototype = this.prototype; 的话，那么在改变 func 的 prototype 的时候，foo 的 prototype 也会跟着变，所以不推荐 c","link":"/2017/05/07/JavaScript/15/"},{"title":"Javascript 中的闭包","text":"所谓闭包「官方」的解释是：是指拥有多个变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分 看起来有点绕，换个说法，简而言之，闭包就是： 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在 闭包就是就是函数的’堆栈’在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配 当在一个函数内定义另外一个函数就会产生闭包 做为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别，闭包的差别在于局部变变量可以在函数执行结束后仍然被函数外的代码访问 这意味着函数必须返回一个指向闭包的’引用’，或将这个’引用’赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问 但是在 ECMAScript 中，函数对象中定义的内部函数(inner function) 是可以直接访问外部函数的局部变量，通过这种机制，我们就可以以如下的方式完成对闭包的访问了 123456789101112function greeting(name) { // local variable var text = 'Hello ' + name; // 每次调用时，产生闭包，并返回内部函数对象给调用者 return function () { alert(text); }}var sayHello = greeting('Closure');// 通过闭包访问到了局部变量 textsayHello() 上述代码的执行结果是：Hello Closure，因为 sayHello() 函数在 greeting 函数执行完毕后，仍然可以访问到了定义在其之内的局部变量 text 闭包模型在本质上来说，闭包就是将函数内部和函数外部连接起来的一座桥梁 闭包可以用在许多地方，它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中 在 ECMAscript 的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分 文法环境（The LexicalEnvironment） 变量环境（The VariableEnvironment） this 绑定 我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针) 环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景 全局的上下文场景中此引用值为 Null，这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景 比如上面的例子，sayHello 函数在最下层，上层是函数 greeting，最外层是全局场景 当 sayHello 被调用的时候，sayHello 会通过上下文场景找到局部变量 text 的值，因此在屏幕的对话框中显示出 'Hello Closure' 作用域链在 JavaScript 中当进行函数的调用，会为每一个函数增加一个属性 SCOPE，通过这个属性来指向一块内存，这块内存中包含有所有的上下文使用的变量 当在某个函数中调用了新函数之后，新函数依然会有一个作用域来执行原有的函数的 SCOPE 和自己新增加的 SCOPE，这样就形成了一个链式结构，这就是 JavaScript 中的作用域链 12345678910111213141516171819var color = 'red';var showColor = function () { alert(this.color);}function changeColor() { var anotherColor = 'blue'; function swapColor() { var tempColor = anotherColor; anotherColor = color; color = tempColor; } swapColor();}changeColor();showColor(); // blue 作用域链图如下所示 在看一个实例 123456789101112131415161718192021function compareObjectFunction(prop) { return function (obj1, obj2) { if (obj1[prop] &gt; obj2[prop]) { return 1; } else if (obj1[prop] &lt; obj2[prop]) { return -1; } else { return 0; } }}var o1 = { name: 'zhangsan', age: 20 };var o2 = { name: 'lisi', age: 30 };var compare = compareObjectFunction('age');// 此时就是比较 o1 和 o2 了var rel = compare(o1, o2);console.log(rel); 在传统语言中（比如 JAVA），以上代码执行完成后，prop 就会被释放，但是在 JS 中，这个作用域却被放大了 在 JS 中，prop 在这里依然可以访问，这种通过返回函数来扩大函数的作用域的方法就是闭包，以上函数的作用域链图如下所示 闭包中的作用域变量123456789101112131415161718192021function fn1() { // 创建了一个数组 var fns = new Array(); // i 这个变量是保存在 fn1 这个作用域中的 for (var i = 0; i &lt; 10; i++) { // 数组中 fns 的值是一组数组 fns[i] = function () { return i; } } return fns;}var fs = fn1();for (var i = 0; i &lt; fs.length; i++) { console.log(fs[i]());} 我们期望的是输出 0 ~ 9，但是此时通过闭包来调用所有函数，当输出i的时候会去上一级的作用域中查找，这个时候 i 的值已经为 10，所以连续输出 10 个 10 修改一下，使用闭包来达到我们的期望： 12345678910111213141516171819202122232425function fn1() { // 创建了一个数组 var fns = new Array(); // i 这个变量是保存在 fn1 这个作用域中的 for (var i = 0; i &lt; 10; i++) { // 使用闭包，需要注意的是消耗的内存比较大 (function (num) { fns[num] = function () { return num; } })(i) } return fns;}var fs = fn1();for (var i = 0; i &lt; fs.length; i++) { // 每一个 fs 都是在不同作用域链中，num 也是保存在不同的作用域中，所以输出 0 ~ 9 console.log(fs[i]());} 闭包中的 this 的指向浏览器中的顶级域，其实就是 window 对象，所谓的闭包中的 this 指向，通俗点说就是，谁调用这个函数（即 xx.fn() 中的 xx），谁就是这个函数（fn）的 this JavaScript 中的 this 指向函数调用时的上下文，可以想像成每个函数在被调用时，动态注入了一个 this 对象 所以在非严格模式下内部的 this 指向 window 对象，严格模式下应为 undefined，其实，引入 this 的初衷就是想在原型继承的情况下，得到函数的调用者，如下实例 12345678910111213var obj = { method: function () { return this; }};console.assert(obj.method() === obj);var F = function () { };F.prototype = obj;var instance = new F;console.assert(instance.method() === instance); 如果函数没有指明调用者呢，那就让 this 指向全局对象吧 12345var global = this;console.assert( global === window );var g = obj.method();console.assert( g() === global ); 再看一个实例 12345678910111213var name = 'window';var person = { name: '张三', age: 20, say: function () { return function () { return this.name; } }}console.log(person.say()()); // window 当完成 person.say() 之后，这个函数就调用结束了，在这个函数调用结束之前 this 是指向 preson，但是在调用匿名函数的时候，this 就指向了 window，所以得到的结果是 window 我们可以把函数中的 this 用一个临时变量保存起来，就可以得到我们想要的结果 12345678910111213141516 var name = 'window';var person = { name: '张三', age: 20, say: function () { // that 就指向 person（把 this 保存起来） var that = this; return function () { return that.name; } }}console.log(person.say()()); 此时 that 就是指向 person 的，所以调用 that.name 就是 person 中的 name","link":"/2017/05/12/JavaScript/16/"},{"title":"闭包的样列","text":"接上回 Javascript 中的闭包 前面我们大致了解了 Javascript 闭包是什么，闭包在 Javascript 是怎么实现的，下面我们来看一些例子来更加深入的理解闭包 先来看 5 个摘自 JavaScript Closures for Dummies 的案例 实例1：闭包中局部变量是引用而非拷贝123456789101112function say667() { // 局部变量 var num = 666; var sayAlert = function () { alert(num); } num++; return sayAlert;}var sayAlert = say667();sayAlert() 因此执行结果应该弹出的 667 而非 666 实例2：多个函数绑定同一个闭包，因为他们定义在同一个函数内12345678910111213141516function setupSomeGlobals() { var num = 666; // 存储一些函数作为全局变量的引用 gAlertNumber = function () { alert(num); } gIncreaseNumber = function () { num++; } gSetNumber = function (x) { num = x; }}setupSomeGlobals(); // 为三个全局变量赋值gAlertNumber(); // 666gIncreaseNumber();gAlertNumber(); // 667gSetNumber(12);gAlertNumber(); // 12 实例3：当在一个循环中赋值函数时，这些函数将绑定同样的闭包1234567891011121314151617181920function buildList(list) { var result = []; for (var i = 0; i &lt; list.length; i++) { var item = 'item' + list[i]; result.push(function () { alert(item + ' ' + list[i]) }); } return result;}function testList() { var fnlist = buildList([1, 2, 3]); // 只使用 j 防止混乱 for (var j = 0; j &lt; fnlist.length; j++) { fnlist[j](); }}testList() // 弹出三次 item3 undefined 因为这三个函数绑定了同一个闭包，而且 item 的值为最后计算的结果，但是当 i 跳出循环时 i 值为 4，所以 list[4] 的结果为 undefined 实例4：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后1234567891011function sayAlice() { var sayAlert = function () { alert(alice); } // 但是如果把 return 语句放到 var 上面，结果就是 undefined var alice = 'Hello Alice'; return sayAlert;}var helloAlice = sayAlice();helloAlice(); 执行结果是弹出 'Hello Alice' 的窗口，即使局部变量声明在函数 sayAlert 之后，局部变量仍然可以被访问到 实例5：每次函数调用的时候创建一个新的闭包123456789101112131415161718function newClosure(someNum, someRef) { var num = someNum; var anArray = [1, 2, 3]; var ref = someRef; return function (x) { num += x; anArray.push(num); alert('num: ' + num + ' anArray ' + anArray.toString() + ' ref.someVar ' + ref.someVar); }}closure1 = newClosure(40, { someVar: 'closure 1' });closure2 = newClosure(1000, { someVar: 'closure 2' });closure1(5); // num: 45 anArray[1, 2, 3, 45] ref: 'someVar closure1'closure2(-10); // num: 990 anArray[1, 2, 3, 990] ref: 'someVar closure2' 下面是一些平常遇到过的坑： 实例一：闭包引用的局部变量，不会自动清除123456789101112function f1() { var n = 999; nAdd = function () { n += 1 }; function f2() { alert(n); } return f2;}var result = f1();result(); // 999nAdd();result(); // 1000 在上述代码中，result 实际上就是闭包 f2 函数，它一共运行了两次，第一次的值是 999，第二次的值是 1000 这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除 原因在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1 ，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage-collection）回收 这段代码中另一个值得注意的地方，就是 nAdd = function () { n += 1 } 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量 其次，nAdd 的值是一个匿名函数（anonymous-function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作 实例二：闭包中的 this12345678910111213141516171819202122232425262728// 1var name = 'The Window';var object = { name: 'My Object', getNameFunc: function () { return function () { return this.name; }; }};alert(object.getNameFunc()());// 2var name = 'The Window';var object = { name: 'My Object', getNameFunc: function () { var that = this; return function () { return that.name; }; }};alert(object.getNameFunc()()); 第一个 打印结果为 The window 第二个 打印结果为 My Object 第一个 this 为全局对象，所以 alert 处理的 name 为 The window 第二个 that 为 object 对象，所以 alert 处理的 name 为 My object 第二个好理解，因为在调用前用 that 保存了 object 自己的 this，所以在闭包内可以调用 实例三：闭包中的作用域12345678910111213141516171819202122// 1function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10);}foo(2);// 2function foo(x) { var tmp = 3; return function (y) { alert(x + y + (++tmp)); }}var bar = foo(2); // bar 现在是一个闭包bar(10); // 16bar(10); // 17 1 中不管执行多少次，都会 alert 16，因为 bar 能访问 foo 的参数 x，也能访问 foo 的变量 tmp，但这还不是闭包 只有当你 return 的是内部 function 时，就是一个闭包（即这时才会产生一个闭包） 内部 function 会 close-over 外部 function 的变量直到内部 function 结束 2 中的脚本也会 alert 16，因为虽然 bar 不直接处于 foo 的内部作用域，但 bar 还是能访问 x 和 tmp，但是，由于 tmp 仍存在于 bar 闭包的内部，所以它还是会自加 1，而且你每次调用 bar 时它都会自加 1 上面的 x 是一个字面值（值传递），和 JavaScript 里其他的字面值一样，当调用 foo 时，实参 x 的值被复制了一份，复制的那一份作为了 foo 的参数 x 那么问题来了，JavaScript 里处理 object 时是用到引用传递的，那么，你调用 foo 时传递一个 object，foo 函数 return 的闭包也会引用最初那个 object，也就有了下面的 3 1234567891011121314// 3function foo(x) { var tmp = 3; return function (y) { alert(x + y + tmp); x.memb = x.memb ? x.memb + 1 : 1; alert(x.memb); }}var age = new Number(2);var bar = foo(age); // bar 现在是一个引用了 age 的闭包bar(10); 不出我们意料，每次运行 bar(10)，x.memb 都会自加 1，但需要注意的是 x 每次都指向同一个 object，运行两次 bar(10) 后，age.memb 会变成 2 这里还有一个不用 return 关键字的闭包例子 123456function closureExample(objID, text, timedelay) { setTimeout(function () { document.getElementById(objID).innerHTML = text; }, timedelay);}closureExample('myDiv', 'Closure is created', 500); 注意，外部函数不是必需的 通过访问外部变量，一个闭包可以维持（keep alive）这些变量，在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出，但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据 闭包经常用于创建含有隐藏数据的函数（但并不总是这样），看下面这段代码 123456789101112131415161718192021222324var db = (function () { // 创建一个隐藏的 object, 这个 object 持有一些数据 // 从外部是不能访问这个 object 的 var data = {}; // 创建一个函数, 这个函数提供一些访问 data 的数据的方法 return function (key, val) { if (val === undefined) { // get return data[key] } else { // set return data[key] = val } }; // 我们可以调用这个匿名方法 // 返回这个内部函数，它是一个闭包})();db('x'); // 返回 undefineddb('x', 1); // 设置 data['x'] 为 1db('x'); // 返回 1// 我们不可能访问 data 这个 object 本身// 但是我们可以设置它的成员 闭包的应用：Singleton 单件123456789101112131415var singleton = function () { var privateVariable; function privateFunction(x) { //...privateVariable... } return { firstMethod: function (a, b) { //...privateVariable... }, secondMethod: function (c) { //...privateFunction()... } };}(); 这个单件通过闭包来实现，通过闭包完成了私有的成员和方法的封装，匿名主函数返回一个对象，对象包含了两个方法，方法 1 可以方法私有变量，方法 2 访问内部私有函数 需要注意的地方是匿名主函数结束的地方的 ()，如果没有这个 () 就不能产生单件，因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用，这个就是利用闭包产生单件的方法","link":"/2017/05/12/JavaScript/17/"},{"title":"原型和闭包","text":"接之前 Javascript 中的闭包 闭包的样列 最近又复习了一次 深入理解 javascript 原型和闭包 算是一个小小的总结吧 对象 - 若干属性的集合1234567891011121314// 简单的值类型，不是对象console.log(typeof x); // undefinedconsole.log(typeof 10); // numberconsole.log(typeof 'abc'); // stringconsole.log(typeof true); // boolean// 函数其实也是对象，也是可以做为参数传递的console.log(typeof function () { }); //function// 引用类型console.log(typeof [1, 'a', true]); //objectconsole.log(typeof { a: 10, b: 20 }); //objectconsole.log(typeof null); //objectconsole.log(typeof new Number(10)); //object 判断一个变量是不是对象，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 函数和对象的关系对象是可以通过函数来创建 1234567891011//var obj = { a: 10, b: 20 };//var arr = [5, 'x', true];var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = 'x';arr[2] = true; prototype每个函数都有一个属性叫做 prorotype，这个 prototype 的属性值是一个对象（属性的集合），默认的还有一个叫做 constructor 的属性，指向这个函数本身 例如 Object 的 prototype 上就挂载了一系列方法 我们也可以在自己自定义的方法的 prototype 中新增自己的属性 123456789function Foo () {...}Foo.prototype.name = ..Foo.prototype.getName = function () {..}var bar = new Foo();console.log(bar.name);console.log(bar.getName()); Foo 是一个函数，bar 对象是通过 Foo 函数 new 出来的，这样一来，bar 对象就可以调用 Foo.prototype 上的属性和方法 因为每个对象都有一个隐藏的属性 __proto__（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 prototype，即 1bar.__proto__ === Foo.prototype // true instanceof对于值类型可以使用 typeof 判断，但是对于引用类型的时候，返回值只有 object/function，这个时候就可以使用 instanceof 比如判断 f1 instanceof Object，按照上图来说就是： 沿着 f1 的 __proto__ 这条线来找，同时沿着 Object 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true，如果找到终点还未重合，则返回 false 这也解释了为何一下结果均返回 true 12345Object instanceof Function; // trueFunction instanceof Object; // trueFunction instanceof Function; // true 完整原型图如下所示： instanceof 表示的就是一种继承关系，或者原型链的结构 一个小小的练习题： 12345678910111213141516171819202122232425262728var a = { x: 1, y: { z: 2 }};var b = {};b.__proto__ = a;// a 和 b 都是对象（通过new Object() 生成，这里是简写）// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 // 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找// 所以 b.x 为 1，b.y 为 { z: 2 }console.log(a.x);console.log(b.x);// 然后把 b.x 重新赋值为 22// 因为是基本类型，所以 a.x 是不变的b.x = 22;console.log(a.x);console.log(b.x);// 这个同上面那个类似// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址// 其中一个变化的话自然会引起另外一个变化b.y.z = 33;console.log(a.y.z);console.log(b.y.z); 继承访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 __proto__ 这条链往上找，这就是原型链 可以利用 hasOwnProperty 来区分一个属性是不是从原型上继承得到的（特别是在 for..in 循环中） hasOwnProperty 这个方法存在与 Object.prototype 上，对象的原型链是沿着 __proto__ 这条线走的，因此在查找对象的 hasOwnProperty 属性的时候，就会顺着原型链一直查找到 Object.prototype 由于所有的对象的原型链都会找到 Object.prototype，因此所有的对象都会有 Object.prototype 的方法，这就是所谓的继承 同样的，每个函数都有 call，apply 方法，这也是”继承”而来的，函数由 Function 函数构建，因此继承的 Function.prototype 中的方法 至于为什么 Function.prototype 上也会有 hasOwnProperty 方法，这是因为 Function.prototype 同样继承自 Object.prorotype 执行上下文环境简单来说，函数每被调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数 需要注意一点：函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了 javascript 在执行一个代码段之前，都会进行这些 “准备工作” 来生成执行上下文，其实分三种情况 – 全局代码，函数体，eval 代码（不推荐这个） 全局执行上下文环境在产生执行全局上下文时，浏览器通常会做以下三个准备工作： 提取 var 声明的变量，并赋值（默认）为 undefined（变量提升） 提取声明式函数（function foo () {..}） 给 this 赋值（指向 window 或当前对象） 函数体上下文环境（也就是所谓的局部）会在以上三个的基础上增加以下三条： 给函数参数赋值 给 arguments 赋值（是一个实参副本，与实参保持一致） 自由变量的取值作用域，查找并赋值 所以总结来说就是，在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空 而在执行 js 代码时，会有数不清的函数调用次数，会产生许多个上下文环境，这么多上下文环境该如何管理，以及如何销毁而释放内存就主要依靠下面的执行上下文栈 执行上下文栈执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境 处于活动状态的执行上下文环境只有一个 其实这是一个 压栈 ==&gt; 出栈 的过程，如下图所示： 压栈：函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈 出栈：函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境 注意：若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的） 上面这种只是较为理想的情况，有一种情况无法做到这样干净利落的说销毁就销毁，这个就是 – 闭包 thisthis 是 Javascript 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 随着函数使用场合的不同，this 的值会发生变化，但是有一个总的原则，那就是 this 指的是，调用函数的那个对象 JavaScript 中函数的调用有以下几种方式： 为对象方法调用 作为函数调用 作为构造函数调用 使用 apply 或 call 调用 一个小案例，在 jQuery 中，有下面这样一段代码： 12345678jQuery.extend = jQuery.fn.extend = function () { // ... if (i === length) { target = this; i--; } // ...} jQuery.extend 和 jQuery.fn.extend 都指向了同一个函数，但是当执行时，函数中的 this 是不一样的 执行 jQuery.extend( .. ) 时，this 指向 jQuery 执行 jQuery.fn.extend( .. ) 时，this 指向 jQuery.fn 这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则 作用域javascript 中没有块级作用域（ES6 之前），除了全局作用域以外，只有函数可以创建作用域 我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好（先声明，在使用），除了这两个地方，其他地方都不要出现变量声明 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突 除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时确定 抽象来看待的话，作用域只是一个 “地盘”，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的值 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了 所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值","link":"/2017/05/14/JavaScript/18/"},{"title":"JSON.parse() && JSON.stringify()","text":"对于这两个方法，以前只是使用，但是并没有去深入研究，只是简单的知道一个是将对象或者数组转为 JSON 字符串，另外一个就是反过来转换 JSON 的 但是深入了解以后却发现东西还是有点多的，特别是还支持第二个参数配置，于是便查阅资料深入了解一下，在这里记录记录 JSON.parse()JSON.parse() 用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象，提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 12var json = '{\"result\":true, \"count\":42}';JSON.parse(json); // {result: true, count: 42} 语法如下 1JSON.parse(text[, reviver]) 如果被解析的 JSON 字符串是非法的（text），则会抛出一个语法错误异常（需要注意，JSON.parse() 不允许最后一个键值对后面存在逗号） 如果指定了 reviver 函数，则解析出的 JavaScript 值（解析值）会经过一次转换后才将被最终返回（返回值） 意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数 在调用过程中，当前属性所属的对象会作为 this 值，当前属性名和属性值会分别作为第一个和第二个参数传入 reviver 中 如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值 需要注意的是 当遍历到最顶层的值（解析值）时，传入 reviver 函数的参数会是空字符串 &quot;&quot;（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了） 当前的 this 值会是 {&quot;&quot;: 修改过的解析值}，在编写 reviver 函数时，要注意到这个特例（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历） 下面是两个示例 1234567891011121314151617181920212223242526// 如果到了最顶层，则直接返回属性值// 否则将属性值变为原来的 2 倍JSON.parse('{\"p\": 5}', function (k, v) { if(k === '') return v; return v * 2; }); // { p: 10 }JSON.parse(' {\"1\": 1, \"2\": 2, \"3\": {\"4\": 4, \"5\": {\"6\": 6}}} ', function (k, v) { // 输出当前的属性名，从而得知遍历顺序是从内向外的 console.log(k); ， // 最后一个属性名会是个空字符串 // 返回原始属性值，相当于没有传递 reviver 参数 return v; });// 1// 2// 4// 6// 5// 3 // \"\" JSON.stringify()方法是将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串，如果指定了 replacer 是一个函数，则可以替换值，或者如果指定了 replacer 是一个数组，可选的仅包括指定的属性 语法如下 1JSON.stringify(value[, replacer [, space]]) 关于可选参数 replacer 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 如果该参数为 null 或者未提供，则对象所有的属性都会被序列化 关于可选参数 space 指定缩进用的空白字符串，用于美化输出（pretty-print） 如果参数是个数字，它代表有多少的空格（上限为 10），该值若小于 1，则意味着没有空格 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格 如果该参数没有提供（或者为 null）将没有空格 关于序列化，有下面五点注意事项： 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 undefined、任意的函数以及 symbol 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 null 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们 不可枚举的属性会被忽略 123456789101112131415161718192021222324252627282930313233343536373839404142434445JSON.stringify({}); // '{}'JSON.stringify(true); // 'true'JSON.stringify(\"foo\"); // '\"foo\"'JSON.stringify([1, \"false\", false]); // '[1, \"false\", false]'JSON.stringify({ x: 5 }); // '{\"x\": 5}'JSON.stringify({ x: 5, y: 6 });// \"{\"x\": 5, \"y\": 6}\"JSON.stringify([new Number(1), new String(\"false\"), new Boolean(false)]);// '[1, \"false\", false]'JSON.stringify({ x: undefined, y: Object, z: Symbol(\"\") });// '{}'JSON.stringify([undefined, Object, Symbol(\"\")]);// '[null, null, null]' JSON.stringify({ [Symbol(\"foo\")]: \"foo\" });// '{}'JSON.stringify({ [Symbol.for(\"foo\")]: \"foo\" }, [Symbol.for(\"foo\")]);// '{}'JSON.stringify( { [Symbol.for(\"foo\")]: \"foo\" }, function (k, v) { if (typeof k === \"symbol\") { return \"a symbol\"; } });// undefined JSON.stringify( Object.create( null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } } ));// 不可枚举的属性默认会被忽略// \"{\"y\":\"y\"}\" replacer 参数replacer 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化 如果返回一个 Number, 转换成相应的字符串被添加入 JSON 字符串 如果返回一个 String, 该字符串作为属性值被添加入 JSON 如果返回一个 Boolean, &quot;true&quot; 或者 &quot;false&quot; 被作为属性值被添加入 JSON 字符串 如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法（除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串） 如果返回 undefined，该属性值不会在 JSON 字符串中输出 需要注意的是，不能用 replacer 方法，从数组中移除值（values），如若返回 undefined 或者一个函数，将会被 null 取代 123456789var foo = { foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7 };var jsonString = JSON.stringify(foo, (key, value) =&gt; { if (typeof value === \"string\") { return undefined; } return value;});console.log(jsonString); // {\"week\": 45, \"month\": 7} 如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化） 12var foo = { foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7 };console.log(JSON.stringify(foo, ['week', 'month'])); // 只保留 week 和 month 属性值 关于 toJSON 方法需要注意的是，如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为（即为调用 toJSON 方法后的返回值会被序列化） 123456789var obj = { foo: 'foo', toJSON: function () { return 'bar'; }};JSON.stringify(obj); // '\"bar\"'JSON.stringify({ x: obj }); // '{\"x\":\"bar\"}' 使用 JSON.stringify 来格式化对象在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观 我们可以利用 replacer 和 space 参数来对其进行格式化 1234567891011121314151617181920212223242526272829// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理var foo = function (key, value) { if (typeof (value) === 'function' || typeof(value) === 'symbol') { return value.toString() } else if (typeof (value) === 'undefined') { return 'undefined' } else { return value; }}var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex; }, address: null } } };JSON.stringify(json, foo, 2);// {// \"bar\": \"aaa\",// \"foo\": {// \"age\": \"Symbol(23)\"// },// \"baz\": \"undefined\",// \"o\": {// \"name\": \"zhangsan\",// \"userInfo\": {// \"sex\": 0,// \"getSex\": \"function () { return this.sex; }\",// \"address\": null// }// }// }","link":"/2017/07/06/JavaScript/23/"},{"title":"JavaScript 中的函数","text":"一般来说，一个函数是可以通过外部代码调用的一个 “子程序”（或在递归的情况下由内部函数调用） 像程序本身一样，一个函数由称为函数体的一系列语句组成，值可以传递给一个函数，函数将返回一个值 在 JavaScript 中，函数是头等（first-class）对象，因为它们可以像任何其他对象一样具有属性和方法 它们与其他对象的区别在于函数可以被调用，简而言之，它们是 Function 对象 下面是一个简单的函数定义方式 123456// 第一种定义方式function fn1() { alert('fn1');}typeof fn1; // function 在 JavaScript 中函数就是对象，只不过函数是一个非常特殊的对象，是一个 Function 类的实例，其实在内存中存储的操作是通过一个键值对来存储的（如下图所示） 函数的名称仅仅是一个键，它的值是指向了内存中的一个对象，这个对象就是 Function 的一个对象 由于函数是一个对象，所以可以通过如下方式定义 以下是通过函数的拷贝来完成赋值的，两个引用并没有指向同一个对象 123456789101112var fn2 = fn1;// fn1 两个的值是虽然相等，但是指向不同的空间fn2();// fn1 的值改变了以后，不会影响 fn2 的值fn1 = function () { alert('fnn1');}fn2(); // 这里修改了 fn1 的内容，fn2 未做修改，故还是 fn1fn1(); // fnn1 函数虽然是一个对象，但是却和对象有一些区别，对象是通过引用的指向完成对象的赋值的，而函数确实通过对象的拷贝来完成的，所以 fn1 虽然改变了，但是并不会影响 fn2 对于对象而言，是通过引用的指向来完成赋值的，此时修改 o1 或者 o2 会将两个值都完成修改 123456// o1 和 o2 其实指向了同一块空间，当修改 o2 的值的时候，o1 的也会改变var o1 = new Object();var o2 = o1;o2.name = 'abc';alert(o1.name); // abc 函数对象简单来说，对象就是 &quot;名/值&quot; 对的集合并拥有一个连到原型对象的隐藏连接 对象字面量产生的对象连接到 Object.prototype， 函数对象连接到 Function.prototype（该原型对象本身连接到 object.prototype） 每个函数在创建的时候会有两个附加属性：函数上下文 和 实现函数行为的代码 每个函数对象在创建的时候也会带有一个 constructor 属性，它的值是一个拥有 constructor 属性且值即为该函数的对象 函数的与众不同之处在于 它们可以被调用 调用调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数，除了声明的时候定义的形式参数，每个函数接收两个附加的参数 this 和 arguments 参数 this 的值取决于调用的模式，在 JavaScript 中一共有四种调用模式： 方法调用模式 函数调用模式 构造调用模式 apply/call 调用模式 当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配的时候不会导致程序错误 如果实际参数过多，超出的参数值将会被忽略 如果实际参数过少，缺失的部分将会被替换为 undefined 对参数的值不会进行类型检查，即 任何类型的值都可以被传递给参数 函数重载（没有重载）12345678910function sum(num1, num2) { return num1 + num2;}function sum(num1) { return num1 + 100;}sum(10); // 110sum(10, 20); // 110 换一种写法，可以看的更清楚些 12345678910var sum = function (num1, num2) { return num1 + num2;}var sum = function (num1) { return num1 + 100;}sum(10); // 110sum(10, 20); // 110 此时 sum 所指向的空间已经从有两个参数的函数变化到只有 num1 的函数中 在调用的时候就只会调用 num1 的函数 特别指出：函数的参数和调用没用关系，如果函数只有一个参数，但是却传入了两个参数，仅仅只会匹配一个 函数是对象，不存在重载，只会存在覆盖，后面定义的会覆盖前面所定义的 123456789101112/** * 如下定义方式等于定义了一个 * function fn(num1, num2) { * alert(num1 + num2); * } * * 所以通过以下的例子，充分说明了函数就是一个对象 */var fn = new Function('num1', 'num2', 'alert(num1 + num2)');fn(12, 22); // 34 函数的值传递由于函数是对象，所以可以直接把函数通过参数传递进来 123456789101112131415161718function callFun(fun, arg) { // 第一个参数就是函数对象 return fun(arg);}function sum(num) { return num + 100;}function say(str) { alert(str);}// 调用了 say 函数callFun(say, 'abc');// 调用了 sum 函数callFun(sum, 20); 作为返回值来传递（也就是所谓的闭包） 1234567891011121314function fn1(arg) { var rel = function (num) { return arg + num; } return rel;}// 此时 f 是一个函数对象，可以完成调用// 在外部调用的时候，更改函数内部的值var f = fn1(20);f(20); //40f(11); //31 实例下面是一些实际操作的例子 1） 12345678910function sortByNum(a, b) { return a - b;}var arr = [1, 2, 11, 33, 12, 190];// 对于 JavaScript 而言，默认是按照字符串来进行排序的arr.sort(); // 1, 11, 12, 190, 2, 33arr.sort(sortByNum); // 1, 2, 11, 12, 33, 190 2） 123456789101112131415161718192021222324252627function Person(name, age) { this.name = name; this.age = age;}var p1 = new Person('Lily', 30);var p2 = new Person('Jim', 35);var p3 = new Person('Aid', 40);var ps = [p1, p2, p3];function sortByName(obj1, obj2) { if (obj1.name &gt; obj2.name) { return 1; } else if (obj1.name == obj2.name) { return 0; } else { return -1; }}function sortByAge(obj1, obj2) { return obj1.age - obj2.age;}ps.sort(sortByName);ps.sort(sortByAge); 使用如上的方式来处理排序，带来的问题是需要为每一个属性都设置一个函数，显得不是很灵活，所以可以通过函数的返回值来调用,实现函数排序功能 1234567891011121314function sortByProperty(propertyName) { var sortFun = function (obj1, obj2) { if (obj1[propertyName] &gt; obj2[propertyName]) { return 1; } else if (obj1[propertyName] == obj2[propertyName]) { return 0; } else { return -1; } }}ps.sort(sortByProperty('name'));ps.sort(sortByProperty('age')); 函数中的 arguments在函数对象中有一个属性叫做 arguments，通过这个属性可以获取相应的参数值，这个属性是一个类数组对象，其实就是传递进来的参数的一个集合 123456function say(num) { alert(num); // 1 alert(arguments.length); // 3}say(1, 2, 3); arguments.callee()在 arguments 这对象中有一个 callee 的方法，arguments.callee(arg) 可以实现反向的调用（不推荐使用） 12345678910function factorial(num) { if (num &lt;= 1) { return 1; } else { // 此时和函数名耦合在一起 return num * factorial(num - 1); }}factorial(5); // 120 以上是一个求阶乘的函数，递归调用的函数名称和原有函数名耦合在一起，如果将这个函数名称更改以后，递归就会失效 12345678var fn = factorial;// 此时不会报错fn(5); //120factorial = null;fn(5); // 报错 此时由于 fn 函数依然使用 factorial 这个名称来调用，但是 factorial 已经指向 null 了，所以会报错，如上情况就需要使用 arguments.callee 方法来调用（已经不再建议使用） 1234567891011function factorial(num) { if (num &lt;= 1) { return 1; } else { // 以下就实现了函数名的解耦，在 JavaScript 中通常都是使用这种方式来做递归 return num * arguments.callee(num - 1); }}// 120fn(5); 函数中的 this当需要创建一个函数对象的时候，设置函数对象的属性和方法需要通过 this 关键字来引用 但是特别注意 this 关键字在调用的时候会根据不同的调用对象而变得不同 123456789101112131415var color = 'red';function showColor() { alert(this.color);}function Circle(color) { this.color = color; this.showColor = showColor;}var c = new Circle('yellow');c.showColor(); // yellowshowColor(); // red 使用 c 来调用 showColor 方法，等于调用了 showColor 方法，此时的 this 是 c，所以是 yellow 直接调用 showColor，此时调用的对象等于是 window，showColor 的 this 就是 window，所以就会在 window 中寻找 color 返回值当一个函数被调用的时候，它从第一个语句开始执行，并在遇到关闭函数体的 } 时结束，从而是的函数把控制权交还给调用该函数的程序部分 return 语句可用来使函数提前返回，当 return 被执行的时候，函数立即返回而不再执行余下的语句 一个函数总是有一个返回值，如果没有指定返回值，则返回 unfefined 如果函数在前面加上 new 前缀的方式来调用，且返回值不是一个对象，则返回 this（该新对象） 简单的总结就是，如果一个构造函数不写 return 语句，则系统会自动帮你返回一个对象，但是如果写了 return 语句，则 如果 return 的是一个基本类型的值（比如 string，number），则会忽略这个 return，该返回什么还是返回什么，但是会阻止构造函数接下来的执行 如果 return 了一个引用类型，则原有的 return 会被覆盖","link":"/2017/10/08/JavaScript/26/"},{"title":"原型链和继承","text":"原型和原型对象 constructor、proto 和 prototype 区别和关系 先来小小的回顾一下，再来看看继承相关问题 每一个构造函数都有一个属性叫做 prototype，指向一个对象，当这个构造函数被 new 的时候，它的每一个实例的 __proto__ 属性都会指向这个属性 每一个函数天生都有 prototype 属性，指向一个空对象，也就是说，不需要去手动的定义这个属性 12345678function People(name, age) { this.name = name; this.age = age;}var man = new People('小明', 20);People.prototype === man.__proto__; // true 如上，这时的 People.prototype 是 People 构造函数的 '原型'，People.prototype 则是 man 的 ‘原型对象’ 当 man 身上没有某个属性或者方法的时候，它会沿着 __proto__ 属性依次向上查询 总结如下： 任何函数都有 prototype，是一个空对象（也有特殊情况，比如 Object.create(null)） prototype 的值是一个对象，这个函数 new 出来的实例对象的 __proto__ 是指向这个函数的 prototype 的 继承在那些基于类的语言（比如 Java）中，继承（inheritance/extends）提供了两个有用的服务，如果一个新的类与一个已存在的类大部分相似，那么你只需说明其不同点即可 JavaScript 是一门弱类型语言，从不需要类型转换，它可以模拟那些基于类的模式，同时它也支持其他更具表现力的模式 在基于类的语言中，对象是类的实例，并且类可以用另一个类继承，JavaScript 是一门基于原型的语言，这意味着对象直接从其他对象继承 类式继承（构造函数）类式继承是在函数对象内调用父类的构造函数，使得自身获得父类的方法和属性（call 和 apply 方法为类式继承提供了支持） 1234567891011121314var father = function () { this.age = 20; this.say = function () { alert('hello i am ' + this.name + ' and i am ' + this.age + 'years old'); }}var child = function () { this.name = 'zhangsan'; father.call(this);}var man = new child();man.say(); 原型继承它有别于类继承是因为继承不在对象本身，而在对象的原型上（prototype） 当一个对象需要调用某个方法时，它回去最近的原型上查找该方法，如果没有找到，它会再次往下继续查找 这样逐级查找，一直找到了要找的方法，这些查找的原型构成了该对象的原型链条（最后指向 Object.prototype.__proto__ 也就是 null） 12345678var father = function () { }father.prototype.a = function () { }var child = function () { }child.prototype = new father();var man = new child();man.a(); 下面是一个简单的例子 1234567891011function Foo () { this.y = 2;}typeof Foo.prototype; // ObjectFoo.prototype.x = 1;var obj3 = new Foo();obj3.x; // 1obj3.y; // 2 用函数声名的方式声明函数 Foo 的时候，就会有一个内置的属性，并且这个属性是一个对象，而且是预设的 然后给这个对象属性增加一个 x，赋值为 1，然后用 new Foo()来创建一个 Foo 的实例 当使用 new 去使用的时候，函数会做为一个构造器来使用，这时候 this 会指向一个对象，而这个对象的原型会指向构造器的 prototype 属性 所以，y 是这个对象上的，故为 2，而 x 是原型链上的，也就是 Foo.prototype 上的，为 1 对比构造函数继承的方法都会存在父对象之中，每一次实例，都会将 funciton 保存在内存中，这样的做法毫无疑问会带来性能上的问题 其次类式继承是不可变的，在运行时，无法修改或者添加新的方法，而且类式继承不支持多重继承 而原型继承是可以通过改变原型链接而对子类进行修改的（重写方法即可），对于原型继承，可以使用类似 extend 等方法对对象进行扩展 组合模式另外的一种模式，是结合类继承和原型继承的各自优点来进行对父类的继承，用类式继承属性，而原型继承方法 这种模式避免了属性的公用，因为一般来说，每一个子类的属性都是私有的，而方法得到了统一 12345678910111213function father() { this.a = 'father'}father.prototype.b = function () { alert(this.a)}var child = function () { father.call(this)}child.prototype = new father(); 使用 Object.create(…)还有一种方式就是使用 Object.create() 来实现，Object.create() 的作用是 创建一个空对象，并且这个对象的原型指向这个参数 典型的 '原型风格' 12345678910111213141516171819202122232425262728function Foo(name) { this.name = name;}Foo.prototype.myName = function () { return this.name;};function Bar(name, label) { Foo.call(this, name); this.label = label;}// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototypeBar.prototype = Object.create(Foo.prototype);// 注意！现在没有 Bar.prototype.constructor 了// 如果你需要这个属性的话可能需要手动修复一下它// Bar.prototype.constructor = Bar;Bar.prototype.myLabel = function () { return this.label;};var a = new Bar('a', 'obj a');a.myName(); // 'a'a.myLabel(); // 'obj a' 关于 constructor代码如下： 12345var father = function () {}var child = function () { }child.prototype = new father();var man = new child(); 任何一个 prototype 对象都有一个 constructor 属性，指向它的构造函数，在执行比如下面步骤之前 1child.prototype = new father(); child.prototype.constructor 是指向 child 的，但是在执行以后，child.prototype.constructor 便指向了 father 更重要的是，每一个实例也有一个 constructor 属性，默认调用 prototype 对象的 constructor 属性 12345// 运行前man.constructor === child.prototype.constructor // true// 运行后man.constructor === father // true 这显然会导致继承链的紊乱（man 明明是用构造函数 child 生成的），因此我们必须手动纠正，将 child.prototype 对象的 constructor 值改为 child 这是很重要的一点，即如果替换了 prototype 对象 1o.prototype = {}; 那么，下一步必然是为新的 prototype 对象加上 constructor 属性，并将这个属性指回原来的构造函数 1o.prototype.constructor = o; 总结其实还有另外一种方式，用如上例子表示就是： 1child.prototype = father.prototype; 这样一来，在改变 child 的同时，也将同时改变 father 即 child.prototype 和 father.prototype 现在指向了同一个对象，那么任何对 child.prototype 的修改，都会反映到 father.prototype，强烈不推荐 而之前的： 1child.prototype = new father(); 说起来也会存在一些小问题，这样一来相当于直接运行了一遍 father（new 的作用），如果在 father 里做了一些其他事情（比如改变全局变量等）就会造成一些副作用 所以如果要实现继承的话，推荐使用 Object.create(...) 一个原型继承的综合实例1234567891011121314151617181920212223242526// Person 类function Person (name, age) { this.name = name; this.age = age;}Person.prototype.hi = function () { console.log(this.name + this.age);}Person.prototype.LEGS_NUM = 2;Person.prototype.ARMS_NUM = 2;Person.prototype.walk = function () { console.log('walk');}// Student 类function Student (age, name, className) { Person.call(this, age, name); this.className = className;}// 使用 Object.create 来得到以 Person.prototype 做为原型的一个空对象Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student; 添加自己新的方法来覆盖 Person 上的方法1234567891011121314151617Student.prototype.hi = function () { console.log(this.name + this.age + this.className);}// 添加自己新的方法Student.prototype.learn = function (subject) { console.log(this.name + subject + this.className);}// testvar man = new Student('name',20,'Class 3 , Grade 2');man.hi(); // name 20 Class 3 , Grade 2man.LEGS_NUM; // 2man.walk(); // walkman.learn('math') // man math Class 3 , Grade 2 原型链原理图 改变 prototype123456789101112131415Student.prototype.x = 101;man.x; // 101// 修改的 man 的原型的指向对象Student.prototype = {y: 2};// 当我们去修改 Student.prototype 的值的时候，不能修改已经实例化的一些对象，已经实例化的对象// 是指向当时的 Student.prototype，不会影响已经创建的实例man.y; // undefinedman.x; // 101var abc = new Student('aaa',3,'bbb');abc.x; // undefinedabc.y; // 2 所以，当我们动态的修改 prototype 属性的时候，是会影响所有已经创建和新创建的实例的 但是如果修改整个 prototype 赋值为新的对象的话，新的实例是不会修改的，但是会影响后续的实例 几种实现继承方式的优缺点123456789101112131415161718192021function Person () {}function Student () {}Student.prototype = Person.prototype; // 1 在改变 Student 的同时，也改变了 Person，不推荐Student.prototype = new Person(); // 2 也可以实现继承，但是 Student 只是一个类，还没有实例化，只是为了继承，而调用构造函数Student.prototype = Object.create(Person.prototype);// 3 相对来说比较妥当的，自己的修改不会影响到原型链，ES5 之后才实现// ES5之前的话，可以判断一下if (!Object.create) { Object.create = function (proto) { function F() {} F.prototype = proto; return new F; };} 调用子类方法1234567891011121314151617181920function Person (name) { this.name = name;}function Student (name, className) { this.className = className; Person.call(this, name); }// testvar man = new Student('man','abc');man; // Student{className: 'abc', name: 'man'}// 若子类的方法覆盖了基类的方法Person.prototype.init = function () {};Student.prototype.init = function () { // do something... Person.prototype.init.apply(this, arguments);}","link":"/2018/01/10/JavaScript/28/"},{"title":"变量的赋值与深浅拷贝","text":"在 JavaScript 中，变量的赋值分为 「传值」 与 「传址」 给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」 基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较 12345678910var num1 = 123;var num2 = 123;var num3 = num1;num1 === num2; // truenum1 === num3; // truenum1 = 456;num1 === num2; // falsenum1 === num3; // false 引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较 12345678910var arr1 = [1, 2, 3];var arr2 = [1, 2, 3];var arr3 = arr1;arr1 === arr2; // falsearr1 === arr3; // truearr3 = [1, 2, 3];arr1 === arr3; // falsearr2 === arr3; // false JavaScript 中变量的拷贝拷贝分为浅拷贝和深拷贝 深复制 和 浅复制 只针对像（Object），Array 这样的复杂对象 简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级 浅拷贝浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性 对于目标对象第一层为基本类型的数据，就是直接赋值，即「传值」 而对于目标对象第一层为引用数据类型的数据，就是直接赋与内存中的堆内存地址，即「传址」 一个简单的浅复制实现 123456789101112var obj = { a: 1, arr: [2, 3] };var shallowObj = shallowCopy(obj);function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst;} 因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的 所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址 所以 123shallowObj.arr[1] = 5;obj.arr[1] // = 5 深拷贝深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性 一般来说，在 JavaScript 中考虑复合类型的深层复制的时候，往往就是指对于 Date，Object 和 Array 三个复合类型的处 一般简单的处理方式是建立一个新的空对象，然后递归遍历旧的的对象，直到发现基础类型的子节点才赋予到新对象对应的位置 不过这个方法存在一个问题，就是 JavaScript 中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后需要考虑原型应不应该被赋予给新对象 一般在使用过程中，我们通常会使用 hasOwnProperty 方法来进行判断是否过滤掉那些继承自原型链上的属性 先来看看一个简单的实现 123456789101112131415161718192021function deepCopy(o, c) { var c = c || {} for (var i in o) { if (typeof o[i] === 'object') { // 要考虑深复制问题了 if (o[i].constructor === Array) { // 这是数组 c[i] = [] } else { // 这是对象 c[i] = {} } deepCopy(o[i], c[i]) } else { c[i] = o[i] } } return c} 下面这个则是较为完善的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function _isPlainObject(target) { return (typeof target === 'object' &amp;&amp; !!target &amp;&amp; !Array.isArray(target));}function shallowExtend() { var args = Array.prototype.slice.call(arguments); // 第一个参数作为 target var target = args[0]; var src; target = _isPlainObject(target) ? target : {}; for (var i = 1; i &lt; args.length; i++) { src = args[i]; if (!_isPlainObject(src)) { continue; } for (var key in src) { if (src.hasOwnProperty(key)) { if (src[key] != undefined) { target[key] = src[key]; } } } } return target;}var target = { key: 'value', num: 1, bool: false, arr: [1, 2, 3], obj: { objKey: 'objValue' },};var result = shallowExtend({}, target, { key: 'changeValue', num: 2})// 对原引用类型数据做修改target.arr.push(4);console.log(target.arr === result.arr) // trueconsole.log(result)// {// key: 'changeValue',// num: 2,// bool: false,// arr: [1, 2, 3, 4],// obj: {// objKey: 'objValue'// },// } JavaScript 中的 mixinJavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承，可以使用 mixin mixin 简单通俗的讲就是把一个对象的方法和属性拷贝到另一个对象上（和继承有区别） mixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现 子类通过在 this 对象上面绑定方法，达到多重继承的目的 一个简单的 mixin 1234567891011121314151617181920function extend(destClass, srcClass) { var destProto = destClass.prototype; var srcProto = srcClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } }}function Book() { }Book.prototype.printName = function () { console.log('I am a book, named hello');};function JS() { }extend(JS, Book);var js = new JS();console.log(js); mixin 实现多继承 1234567891011121314151617181920212223242526function extend(destClass) { var classes = Array.prototype.slice.call(arguments, 1); for (var i = 0; i &lt; classes.length; i++) { var srcClass = classes[i]; var srcProto = srcClass.prototype; var destProto = destClass.prototype; for (var method in srcProto) { if (!destProto[method]) { destProto[method] = srcProto[method]; } } }}function Book() { }Book.prototype.getName = function () { };Book.prototype.setName = function () { };function Tech() { }Tech.prototype.showTech = function () { };function JS() { }extend(JS, Book, Tech);var js = new JS();console.log(js); 很多前端库里都有 mixin 方法，比如 jQuery 的 extend，Underscore 中的 _.extend 下面我们就来看看 jQuery 中的 extend 的实现 jQuery 中的 extend 的实现先来看看怎么使用 1234$.extend( target [, object1 ] [, objectN ] )// 可以添加参数来指示是否深度合并$.extend( [deep ], target, object1 [, objectN ] ) 需要注意的是，第一个参数不支持传递 false 取值 解释 deep 可选，Boolean 类型 指示是否深度合并对象，默认为 false，如果该值为 true，且多个对象的某个同名属性也都是对象，则该 ‘属性对象’ 的属性也将进行合并 target Object 类型 目标对象，其他对象的成员属性将被附加到该对象上 object1 可选，Object 类型 第一个被合并的对象 objectN 可选，Object 类型 第 N 个被合并的对象 简单来说，该方法的作用是用一个或多个其他对象来扩展一个对象，返回扩展后的对象 如果不指定 target，则是给 jQuery 命名空间本身进行扩展（有利于为 jQuery 增加新方法） 如果第一个参数设置为 true，则 jQuery 返回一个深层次的副本，递归的复制找到的任何对象，否则的话副本会与原对象共享结构 未定义的属性不会被复制，然而从对象的原型继承的属性将会被复制 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 版本为 3.31jQuery.extend = jQuery.fn.extend = function () { var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; // 如果第一个参数是布尔值，则为判断是否深拷贝的标志变量 if (typeof target === \"boolean\") { deep = target; // 跳过 deep 标志变量，留意上面 i 的初始值为1 target = arguments[i] || {}; // i 自增1 i++; } // 判断 target 是否为 object / array / function 以外的类型变量 if (typeof target !== \"object\" &amp;&amp; !isFunction(target)) { // 如果是其它类型变量，则强制重新赋值为新的空对象 target = {}; } // 如果只传入 1 个参数，或者是传入 2 个参数，第一个参数为 deep 变量，第二个为 target // 所以 length 的值可能为 1 或 2，但无论是 1 或 2，下段 for 循环只会运行一次 if (i === length) { // 将 jQuery 本身赋值给 target target = this; // i 自减1，可能的值为 0 或 1 i--; } for (; i &lt; length; i++) { // 以下拷贝操作，只针对非 null 或 undefined 的 arguments[i] 进行 if ((options = arguments[i]) != null) { // Extend the base object for (name in options) { src = target[name]; copy = options[name]; // 避免死循环的情况 if (target === copy) { continue; } // 如果是深拷贝，且 copy 值有效，且 copy 值为纯 object 或纯 array if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { if (copyIsArray) { // 数组情况 copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; } else { // 对象情况 clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}; } // 克隆 copy 对象到原对象并赋值回原属性，而不是重新赋值 // 递归调用 target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values } else if (copy !== undefined) { target[name] = copy; } } } } // Return the modified object return target;};","link":"/2018/01/14/JavaScript/29/"},{"title":"JavaScript 中的类型判断","text":"Javascript 由于各种各样的原因，在判断一个变量的数据类型方面一直存在着一些问题，其中最典型的问题恐怕就是 typeof null 会返回 object 因此在这里简单的总结一下判断数据类型时常见的陷阱，以及正确的处理姿势 原始值在 JavaScript 中有 5 种原始类型：字符串，数字，布尔值，null 和 undefined，如果你希望检测一个值是否为原始类型，最佳选择是使用 typeof 运算符 对于数字类型的值，typeof 会返回 number（NaN 也是一个数字类型，因为它在 JavaScript 中代表的是特殊非数字值） 对于字符串类型的值，typeof 会返回 string 对于布尔类型的值，typeof 会返回 boolean 对于对象，数组，null 而言，typeof 会返回 object 对于函数类型而言，typeof 返回 function 如果运算数没有定义（不存在或未赋值），将会返回 undefined 还有一个原始值 null，一般不用于检测语句，但有一个例外，如果所期望的值真的是 null，则可以直接和 null 进行比较，这时应当使用 '===' 或者 '!==' 来和 null 进行比较 12345var element = document.getElementById('myDiv'); if (element !== null) { element.classList.add('found');} 引用值在 JavaScript 中除了原始值之外的值都是引用，有这几种内置的引用的类型：Object, Array, Error, Date typeof 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 'object' 1234567console.log(typeof {}); // 'object' console.log(typeof []); // 'object' console.log(typeof new Date()); // 'object' console.log(typeof new RegExp()); // 'object' 所以，在检测某个引用值的类型的最好的方法是使用 instanceof 运算符： 12345678910111213141516// 检测日期if (value instanceof Date) { console.log(value.getFullYear());} // 检测正则表达式if (value instanceof RegExp) { if (value.test(anotherValue)) { console.log('Matches'); }} // 检测 Errorif (value instanceof Error) { throw value;} 默认情况下，每个对象都继承自 Object，因此每个对象的 value instanceof Object 都会返回 true 1234var now = new Date(); console.log(now instanceof Date); // trueconsole.log(now instanceof Object); // true 正因为这个原因，使用 value instanceof Object 来判断对象是否属于某个特定类型的做法并非最佳 在 JavaScript 中检测自定义类型的时候，最好的做法就是使用 instanceof 运算符，这也是唯一的方法，但是也有例外（跨 frame） 空对象检测一般有下面这几种方式 最常见的思路，for...in 遍历属性，为真则为’非空数组’，否则为’空数组’ 1234567// 如果不为空，则会执行到这一步，返回 truefor (var i in obj) { return true}// 如果为空，返回 falsereturn false 通过 JSON 自带的 stringify() 方法来判断 JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串 这里需要注意一点：undefined、任意的函数以及 symbol 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 null 即 1JSON.stringify({a: undefined}); // { } 详细可以参考 JSON.parse() &amp;&amp; JSON.stringify() 1234567if (JSON.stringify(data) === '{}') { // 如果为空，返回 false return false}// 如果不为空，则会执行到这一步，返回 truereturn true 这里需要注意为什么不用 toString()，因为它返回的不是我们需要的 12var a = {}a.toString() // \"[object Object]\" ES6 新增的方法 Object.keys() Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组 如果我们的对象为空，他会返回一个空数组，如下 12var a = {}Object.keys(a) // [] 我们可以依靠 Object.keys() 这个方法通过判断它的长度来知道它是否为空 1234567if (Object.keys(object).length === 0) { // 如果为空，返回 false return false}// 如果不为空，则会执行到这一步，返回 truereturn true 函数检测检测函数最好的方法是使用 typeof ，因为它可以跨 frame 使用 1234function myFunc () {} // 推荐，返回的是 functionconsole.log( typeof myFunc === 'function' ); // true 数组检测在没有 isArray 方法之前，一般会采用如下方式来进行判断 123var isArray = function (value) { return value &amp;&amp; typeof value === \"object\" &amp;&amp; value.constructor === \"Array\";} 上面这个方法在 从不同的窗口（window / frame）里构造的数组的时候会失败，所以我们不得不考虑更多 123456var isArray = function (value) { return value &amp;&amp; typeof value === \"object\" &amp;&amp; typeof value.length === \"number\" &amp;&amp; typeof value.slice === \"function\" &amp;&amp; !(value.propertyIsEnumerable(\"length\"));} 首先，我们要判断这个值是否为真，不接受 null 和其他为假的值 其次判断 typeof 运算的结果是否为 object，对于对象，数组和 null 来说，返回的是 true（但是对于对象来说并非如此） 然后判断这个值是否包含一个 splice 的方法，对于数组来说，又将会得到 true 最后判断 length 属性是否是可枚举的，对于数组来说，将得到 false 但是在 ES5 之后，将 Array.isArray() 正式的引入，唯一的目的就是检测一个值是否为数组 1234567function isArray (value) { if (typeof Array.isArray === 'function') { return Array.isArray(value); } else { return Object.prototype.toString.call(value) === '[object Array]'; }} 属性检测判断属性是否存在的最好的方法是使用 in 运算符，in 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值 如果实例对象的属性存在，或者继承自对象的原型，in 运算符都会返回 true 1234567891011121314var object = { count: 0, related: null}; // 推荐if ('count' in object) { // ...} // 不推荐if (object['count']) { // ...} 如果你只想检查实例对象的某个属性是否存在，则使用 hasOwnProperty() 方法 所以在判断实例对象是否存在的时候，推荐使用 in 运算符，只有在需要判断实例属性的时候才会用到 hasOwnProperty() hasOwnProperty，isPrototypeOf，instanceofhasOwnProperty是用来判断一个对象是否有你给出名称的属性或对象（需要注意的是，此方法无法检查该对象的原型链中是否具有该属性） 该属性必须是对象本身的一个成员，在跨浏览器的设计中，我们不能依赖于 for in 来获取对象的成员名称，一般使用 hasOwnProperty 来判断 123456789101112var buz = { fog: '123'};for (var name in buz) { if (buz.hasOwnProperty(name)) { alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]); } else { alert(name); // toString or something else }} 在 Object.prototype 中调用 hasOwnProperty() 1234567891011121314151617181920// 对象var man = { hands: 2, legs: 2, heads: 1};// 将一个方法添加到对象上if (typeof Object.prototype.clone === \"undefined\") { Object.prototype.clone = function () { // ... }}// 使用 hasOwnProperty()for (var i in man) { if (Object.prototype.hasOwnProperty.call(man, i)) { // 过滤 console.log(i, \":\", man[i]); }} 在使用 hasOwnProperty() 对 man 对象进行精炼后，可有效的避免命名冲突，也可以使用一个本地变量来缓存比较长的属性名 12345678var i, hasOwn = Object.prototype.hasOwnProperty;for (var i in man) { // 过滤 if (hasOwn.call(man, i)) { console.log(i, \":\", man[i]); }} 严格来讲，不使用 hasOwnProperty() 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度 但是当确认不了对象的内容（和原型链）的时候，最好还是加上 hasOwnProperty() 这样安全的检查 isPrototypeOf是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回 true，否则返回 false 12345678910111213141516171819202122232425262728293031323334353637function Fee() { // . . .}function Fi() { // . . .}Fi.prototype = new Fee();function Fo() { // . . .}Fo.prototype = new Fi();function Fum() { // . . .}Fum.prototype = new Fo();// ---------------------------var fum = new Fum();// ...if (Fi.prototype.isPrototypeOf(fum)) { // do something safe} instanceof用来测试一个对象在其原型链构造函数上是否具有 prototype 属性，直白的说就是，用来检测 constructor.prototype 是否存在于参数 object 的原型链上 1234567891011121314151617181920212223242526// 定义构造函数function C() { }function D() { }var o = new C();// true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof C;// false，因为 D.prototype 不在 o 的原型链上o instanceof D;o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 trueC.prototype instanceof Object // true，同上C.prototype = {};var o2 = new C();o2 instanceof C; // trueo instanceof C; // false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 ture，因为 Foo.prototype 属性的值有可能会改变 改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false 另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的 ES 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 魔法属性，是可以实现的 比如执行 obj.__proto__ = {} 之后，obj instanceof Foo 就会返回 false 了 更多详细见： MDN - instanceof 所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 123var fn = function () { };console.log(fn instanceof Object); // true 总结 原始值（字符串，数字，布尔值，undefined） – typeof 引用值（Date，RegExp，Error） – instanceof 函数 – typeof 数组 – isArray 属性检测（是否存在） – in / hasOwnProperty()","link":"/2018/03/17/JavaScript/30/"},{"title":"promise 和 setTimeout","text":"首先，我们要知道为什么要使用 promise 来看下面这个示例，读取一个文件，在控制台输出这个文件内容 12345var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data);}); 看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容 12345678var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { console.log(data); fs.readFile('2.txt', 'utf8', function (err, data) { console.log(data); });}); 要是读取更多的文件呢? 12345678910var fs = require('fs');fs.readFile('1.txt', 'utf8', function (err, data) { fs.readFile('2.txt', 'utf8', function (err, data) { fs.readFile('3.txt', 'utf8', function (err, data) { fs.readFile('4.txt', 'utf8', function (err, data) { // ... }); }); });}); 这就是传说中的 callback hell 基本概念首先它是一个对象，它和 javascript 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口 表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的 promise 只有三种状态，未完成，完成 (fulfilled) 和失败 (rejected) promise 的状态可以由未完成转换成完成，或者未完成转换成失败 promise 的状态转换只发生一次 Promise 状态转换完成后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 Promise 状态转换的情况） promise 有一个 then 方法，then 方法可以接受 3 个函数作为参数 前两个函数对应 promise 的两种状态 fulfilled, rejected 的回调函数，第三个函数用于处理进度信息（.then() 总是返回一个新的 promise） 一个简单的读取文件示例： 12345678910111213141516171819var fs = require('fs');function readFile() { return new Promise(function (resolve, reject) { fs.readFile('1.txt', 'utf-8', function (err, data) { if (err) { reject(err) } else { resolve(data) } }) })}readFile().then(function (data) { console.log(data)}).catch(function (err) { console.log(err)}) setTimeout一般用于在指定的毫秒数后调用函数或计算表达式，语法为 1setTimeout(code, millisec) code 必需，要调用的函数后要执行的 JavaScript 代码串 millisec 必需，在执行代码前需等待的毫秒数 需要注意的是，setTimeout() 只执行 code 一次，如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout() 下面来看看两者的区别 promise 和 setTimeout一个简单的示例 1234567891011setTimeout(function () { console.log(1)}, 0);new Promise(function (resolve) { resolve();}).then(function () { console.log(2);});// 2, 1 简单来说，promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行 在 ES6 中，有一个新的概念建立在事件循环队列之上，叫做 任务队列 简单的理解就是，它是挂在事件循环队列的每个 tick 之后的一个队列，在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中 而会在当前 tick 的任务队列末尾添加一个项目（任务） 一个任务可能引起更多任务被添加到同一个队列末尾，所以，理论上说，任务循环可能无限循环（一个任务总是添加另一个任务，以此类推） 进而导致程序的无限循环，无法转移到下一个事件循环 tick，从概念上看，这和代码中的无限循环（类似 while(true)）的体验几乎是一样的 再来看一个实例 12345678910111213141516setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(3);}).then(function () { console.log(4);});console.log(5);// 结果为 2 3 5 4 1 首先是一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 然后是一个 Promise，里面的函数是会立即执行的，所以首先输出 2 和 3 这里需要注意的是，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中，所以会先输出 5 然后才会输出 4，最后轮到下一个 tick 之后才会输出 1 扩展：promise 的队列与 setTimeout 的队列有何关联？ 再来看下面这个比较绕的问题下面几个的输出值为多少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 一for (var i = 0; i &lt; 5; i++) { console.log(i);}// 二for (var i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000 * i);}// 三for (var i = 0; i &lt; 5; i++) { (function (i) { setTimeout(function () { console.log(i); }, 1000 * i); })(i)}// 四for (let i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); }, 1000 * i);}// 五for (var i = 0; i &lt; 5; i++) { (function () { setTimeout(function () { console.log(i); }, 1000 * i); })(i)}// 六for (var i = 0; i &lt; 5; i++) { setTimeout((function (i) { console.log(i); })(i), i * 1000);}// 七setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(3);}).then(function () { console.log(4);});console.log(5);// 八setTimeout(function () { console.log(1)}, 0);new Promise(function executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } setTimeout(function() { console.log(6) }, 0) console.log(3);}).then(function () { console.log(4);});console.log(5); 最基本的，输出 0 - 4 setTimeout 会延迟执行，那么执行到 console.log 的时候，其实 i 已经变成 5 了，所以结果为 5 个 5 如果要输出 0 到 4，可以使用三和四两种方式 去掉 function() 中的 i，内部就没有对 i 保持引用，结果还是 5 个 5 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 0 - 4 而不会延迟 最后两个有些复杂，但是原理是类似的 都被改写成了 Promise，但是首先需要明确的是，promise 的任务会在当前事件循环末尾中执行，而 setTimeout 中的任务是在下一次事件循环执行 首先是一个 setTimeout，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 1 然后是一个 Promise，里面的函数是会立即执行的，所以首先输出 2 和 3 这里需要注意的是，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中（而不是下一次事件循环），所以会先输出 5 然后才会输出 4，最后轮到下一个 tick 才会输出 1 所以结果为 2 3 5 4 1 至于最后一个，和第七个是一样的，结果为 2 3 5 4 1 6 附录：Promises/A+ 规范promise 代表一个异步操作的最终结果，主要通过 promise 的 then 方法订阅其最终结果的处理回调函数，和订阅因某原因无法成功获取最终结果的处理回调函数 更对详细见：Promises/A+ A 与 A+ 的不同点 -A+ 规范通过术语 thenable 来区分 promise 对象 -A+ 定义 onFulfilled/onRejectd 必须是作为函数来调用，而且调用过程必须是异步的 -A+ 严格定义了 then 方法链式调用时，onFulfilled/onRejectd 的调用顺序","link":"/2018/03/19/JavaScript/31/"},{"title":"JavaScript 中的数据绑定","text":"关于数据双向绑定，绑定的基础就是监听属性的变化事件（propertyChange），现在主流的框架当中的解决方法一般有以下几种 Knockout / Backbone（发布/订阅模式），简单来说就是另外开发一套 API，但使用起来却不得不使用这套 API 来操作 viewModel，导致上手复杂、代码繁琐 Angular（脏检查机制），特点是直接使用原生 JavaScript 来操作 viewModel，但脏检查机制随之带来的就是性能问题 Vue（数据劫持，也就是 Object.defineProperty），会把定义的 viewModel 对象（即 data 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 JavaScript 操作对象，又可以主动触发 propertyChange 事件，效率虽高，但也有一些限制，见后文 另外的几种方式 Object.observe，谷歌对于简化双向绑定机制的尝试，在 Chrome 49 中引入，然而由于性能等问题，并没有被其他各大浏览器及 ES 标准所接受，所以在后续版本当中移除了该方法的实现 Proxy，是 ES6 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 Object.observe 以实现双向绑定） 基于数据劫持实现的双向绑定什么是数据劫持数据劫持比较好理解，通常我们利用 Object.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作 123456789101112131415161718192021222324252627// 这是将要被劫持的对象const data = { name: '',};// 测试函数function test(name) { console.log(name);}// 遍历对象,对其属性值进行劫持Object.keys(data).forEach(function (key) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { console.log(`get`); }, set: function (newValue) { // 当属性值发生变化时我们可以进行额外操作 console.log(`set`); test(newValue); }, });});data.name = `new name`; 数据劫持的优势以及实现思路目前业界分为两个大的流派，一个是以 React 为首的单向数据绑定，另一个是以 Angular、Vue 为主的双向数据绑定 两者主要有两点区别 无需显示调用，例如 Vue 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 Angular 的脏检测或是 react 需要显示调用 setState 可精确得知变化数据：例如上面的例子，我们劫持了属性的 setter，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 diff 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 diff 来找出变化值，这是额外性能损耗 本质上，基于数据劫持的双向绑定离不开 Proxy 与 Object.defineProperty 等方法对对象/对象属性的”劫持”，我们要实现一个完整的双向绑定需要以下几个要点 利用 Proxy 或 Object.defineProperty 生成的 Observer 针对对象/对象的属性进行”劫持”，在属性发生变化后通知订阅者 解析器 Compile 解析模板中的 Directive（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁，它将接收到的 Observer 产生的数据变化，并根据 Compile 提供的指令进行视图渲染，使得数据变化促使视图变化 基于 Object.defineProperty 双向绑定完整的实现可以见 剖析 Vue 原理 &amp;&amp; 实现双向绑定 MVVM，比如上面的示例，就是一个简单的实现 但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等 我们可以参考 Vue 的实现方式，Vue 的操作就是加入了发布订阅模式，结合 Object.defineProperty 的劫持能力，实现了可用性很高的双向绑定 下面是一个完成的例子 12345&lt;main&gt; &lt;p&gt;请输入:&lt;/p&gt; &lt;input type=\"text\" id=\"input\"&gt; &lt;p id=\"p\"&gt;&lt;/p&gt;&lt;/main&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它const Vue = (function() { let uid = 0; // 用于储存订阅者并发布消息 class Dep { constructor() { // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; } // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身 depend() { Dep.target.addDep(this); } // 添加订阅者 addSub(sub) { this.subs.push(sub); } notify() { // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); } } // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher Dep.target = null; // 现在我们需要实现监听者（Observer），用于监听属性值的变化 // 监听者，监听对象属性值的变化 class Observer { constructor(value) { this.value = value; this.walk(value); } // 遍历属性值并监听 walk(value) { Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); } // 执行监听的具体方法 convert(key, val) { defineReactive(this.value, key, val); } } function defineReactive(obj, key, val) { const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: () =&gt; { // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中 // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者 // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法 if (Dep.target) { dep.depend(); } return val; }, set: newVal =&gt; { if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); }, }); } function observe(value) { // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== 'object') { return; } return new Observer(value); } // 我们还需要实现一个订阅者（Watcher） class Watcher { constructor(vm, expOrFn, cb) { this.depIds = {}; // hash 储存订阅者的 id，避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前 Vue 实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 } // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用 update() { this.run(); } addDep(dep) { // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存 // 此判断是避免同 id 的 Watcher 被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) { dep.addSub(this); this.depIds[dep.id] = dep; } } run() { const val = this.get(); console.log(val); if (val !== this.val) { this.val = val; this.cb.call(this.vm, val); } } get() { // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个 Watcher 使用 Dep.target = null; console.log(Dep.target, 2); return val; } } // 将上述方法挂载在 Vue 上 class Vue { constructor(options = {}) { // 简化了 $options 的处理 this.$options = options; // 简化了对 data 的处理 let data = (this._data = this.$options.data); // 将所有 data 最外层属性代理到 Vue 实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); } // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) { new Watcher(this, expOrFn, cb); } _proxy(key) { Object.defineProperty(this, key, { configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; { this._data[key] = val; }, }); } } return Vue;})();// 使用let demo = new Vue({ data: { text: '', },});const p = document.getElementById('p');const input = document.getElementById('input');input.addEventListener('keyup', function(e) { demo.text = e.target.value;});demo.$watch('text', str =&gt; p.innerHTML = str); Object.defineProperty 的缺陷其实我们升级版的双向绑定依然存在漏洞，比如我们将属性值改为数组 1234567891011121314151617181920212223242526272829303132let demo = new Vue({ data: { list: [1], },});const list = document.getElementById('list');const btn = document.getElementById('btn');btn.addEventListener('click', function () { demo.list.push(1);});const render = arr =&gt; { const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); } list.appendChild(fragment);};// 监听数组，每次数组变化则触发渲染函数，然而却无法监听demo.$watch('list', list =&gt; render(list));setTimeout( function () { alert(demo.list); }, 5000,); 是的，Object.defineProperty 的第一个缺陷，无法监听数组变化，然而 Vue 的文档提到了 Vue 是可以检测到数组变化的 其实简单来说，这里就是重写了原来的方法 12345678910111213141516171819202122232425262728const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];const arrayAugmentations = [];aryMethods.forEach((method) =&gt; { // 这里是原生 Array 的原型方法 let original = Array.prototype[method]; // 将 push, pop 等封装好的方法定义在对象 arrayAugmentations 的属性上 // 注意：是属性而非原型属性 arrayAugmentations[method] = function () { console.log('我被改变啦!'); // 调用对应的原生方法并返回结果 return original.apply(this, arguments); };});let list = ['a', 'b', 'c'];// 将我们要监听的数组的原型指针指向上面定义的空数组对象// 别忘了这个空数组的属性上定义了我们封装好的 push 等方法list.__proto__ = arrayAugmentations;list.push('d'); // 我被改变啦！ 4// 这里的 list2 没有被重新定义原型指针，所以就正常输出let list2 = ['a', 'b', 'c'];list2.push('d'); // 4 由于只针对了八种方法进行了 hack，所以其他数组的属性也是检测不到的 我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 Object.defineProperty 的第二个缺陷，只能劫持对象的属性 因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择 1Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); Proxy 实现的双向绑定Proxy 在 ES2015 规范中被正式发布，它在目标对象之前架设一层”拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 我们可以这样认为 Proxy 是 Object.defineProperty 的全方位加强版 Proxy 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 Object.defineProperty Proxy 可以直接监听数组的变化当我们对数组进行操作（push、shift、splice 等）时，会触发对应的方法名称和 length 的变化 下面是一个实例 12345&lt;main&gt; &lt;ul id=\"list\"&gt; &lt;/ul&gt; &lt;button type=\"button\" name=\"button\" id=\"btn\"&gt;添加列表项&lt;/button&gt;&lt;/main&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const list = document.getElementById('list');const btn = document.getElementById('btn');// 渲染列表const Render = { // 初始化 init: function(arr) { const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); } list.appendChild(fragment); }, // 我们只考虑了增加的情况，仅作为示例 change: function(val) { const li = document.createElement('li'); li.textContent = val; list.appendChild(li); },};// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, { get: function(target, key, receiver) { console.log(key); return Reflect.get(target, key, receiver); }, set: function(target, key, value, receiver) { console.log(target, key, value, receiver); if (key !== 'length') { Render.change(value); } return Reflect.set(target, key, value, receiver); },});// 初始化window.onload = function() { Render.init(arr);}// push 数字btn.addEventListener('click', function() { newArr.push(6);}); Proxy的优势Proxy 有多种拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等，是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改","link":"/2018/07/10/JavaScript/34/"},{"title":"FileReader 接口","text":"FileReader 接口主要是将文件读入内存，并提供相应的方法，来读取文件中的数据，当然就能显示本地图片不需上传了 一个简单的示例如下： 1234567891011121314151617181920212223242526var result = document.getElementById('result');var file = document.getElementById('file');// 判断浏览器是否支持 FileReader 接口if (typeof FileReader == 'undefined') { result.InnerHTML = '&lt;p&gt;你的浏览器不支持 FileReader 接口！&lt;/p&gt;'; // 使选择控件不可操作 file.setAttribute('disabled', 'disabled');}function readAsDataURL() { // 检验是否为图像文件 var file = document.getElementById('file').files[0]; if (!/image\\/\\w+/.test(file.type)) { alert('格式不正确！'); return false; } var reader = new FileReader(); // 将文件以 Data URL 形式读入页面 reader.readAsDataURL(file); reader.onload = function (e) { var result = document.getElementById('result'); // 显示文件 result.innerHTML = '&lt;img src= ' + this.result + ' &gt;' }} 123456&lt;p&gt; &lt;input type='file' id='file' /&gt; &lt;input type='button' value=\"读取图像\" onclick=\"readAsDataURL()\" /&gt;&lt;/p&gt;&lt;div id='result' name='result'&gt;&lt;/div&gt; 预览完成后就可以上传到服务器了： 123456789101112131415161718$('#submitBtn').submit(function () { if ($('#upload_file').val()) { $('#upload_btn').attr('disabled', true); $('.tip').html('正在上传中，请稍候...'); $(this).ajaxSubmit({ type: 'post', url: url, success: function (data) { // ... $('#upload_btn').attr('disabled', false); $('.tip').html(''); } }); } // 不刷新页面 return false;}); 方法和事件12345678910111213141516171819202122// 方法abort // 中断读取readAsText(file, [encoding]) // 将文件读取为文本该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8 // 这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容readAsBinaryString(file) // 将文件读取二进制码通常我们将它传送到后端，后端可以通过这段字符串存储文件readAsDataURL(file) // 将文件读取为 DataURL 将文件读取为一串Data URL字符串， // 将小文件以一种特殊格式的URL地址直接读入页面，小文件指图像与html等格式的文件// 事件onabort // 数据读取中断时触发onerror // 数据读取出错时触发onloadstart // 数据读取开始时触发onload // 数据读取成功完成时触发onloadend // 数据读取完成时触发，无论成功失败 分段读取文本信息（slice）有的时候，一次性将一个大文件读入内存，并不是一个很好的选择（如果文件太大，可能直接导致浏览器崩溃），更稳健的方法是分段读取 HTML5 File Api 提供了一个 slice 方法，允许分片读取文件内容 文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充，如果读取失败，则 result 的值为 null ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值 12345678910111213141516171819202122232425262728293031323334353637383940function readBlob(start, end) { var files = document.getElementById('file').files; if (!files.length) { alert('请选择文件'); return false; } var file = files[0], start = parseInt(start, 10) || 0, end = parseInt(end, 10) || (file.size - 1); var r = document.getElementById('range'), c = document.getElementById('content'); var reader = new FileReader(); reader.onloadend = function (e) { if (this.readyState == FileReader.DONE) { c.textContent = this.result; r.textContent = 'Read bytes: ' + (start + 1) + ' - ' + (end + 1) + ' of ' + file.size + ' bytes'; } }; // 兼容 var blob; if (file.webkitSlice) { blob = file.webkitSlice(start, end + 1); } else if (file.mozSlice) { blob = file.mozSlice(start, end + 1); } else if (file.slice) { blob = file.slice(start, end + 1); } reader.readAsBinaryString(blob);};document.getElementById('file').onchange = function () { readBlob(10, 100);} 使用了 FileReader 的 onloadend 事件来检测读取成功与否，如果用 onloadend 则必须检测一下 FileReader 的 readyState 因为 read abort 时也会触发 onloadend 事件，如果我们采用 onload，则可以不用检测 readyState FileReader 进度条既然 FileReader 是异步读取文件内容，那么就应该可以监听它的读取进度 事实上，FileReader 的 onloadstart 以及 onprogress 等事件可以用来监听 FileReader 的读取进度 在 onprogress 的事件处理器中，提供了一个 ProgressEvent 对象，这个事件对象实际上继承了 Event 对象 提供了三个只读属性：lengthComputable、loaded、total，通过以上几个属性，即可实时显示读取进度 12345interface ProgressEvent : Event { readonly attribute boolean lengthComputable; readonly attribute unsigned long long loaded; readonly attribute unsigned long long total;}; ajax 上传并显示进度条： 1234567891011121314151617181920212223242526272829function upLoad() { var myPic = document.querySelector('myPic').files[0]; var fd = new FormData(); fd.append('myPic', myPic); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); } } // 监听附件上传情况 xhr.upload.onprogress = function () { // evt.loaded -- 已经上传大小 // evt.total -- 附件总大小 var loaded = evt.loaded; var tot = evt.total; var per = Math.floor(100 * loaded / tot); var son = document.getElementById('flag'); flag.innerHTML = per + '%'; flag.style.width = per + '%'; } var url = ''; xhr.open('POST', url); xhr.send(fd);} 扩展：FormData 对象FormData 对象，可以把 form 中所有表单元素的 name 与 value 组成一个 queryString，提交到后台 用 jQuery 的方法来说，就是 serialize 了，但是在使用 Ajax 提交时，这过程就变成人工的了，因此，使用 FormData 对象可以减少拼接 queryString 的工作量 可以先创建一个空的 FormData 对象，然后利用 append 方法向该对象添加字段（key/value） 12345var myForm = new FormData();myForm.append('name', 'zhangsan');myForm.append('name', 'lisi');myForm.append('num', 222333); // 数字会被转换成字符串 或者可以取得 form 元素对象，然后将其作为参数传入 FormData 对象中 12var myForm = document.querySelector('#myForm');var formdata = new FormData(myForm); 利用 getFormData 生成 12var myForm = document.querySelector('#myForm');var formdata = myForm.getFormData(); 使用 FormData 提交表单： 123456789101112131415function fsubmit() { var data = new FormData($('#myForm')[0]); $.ajax({ url: 'upLoad.html', type: 'POST', data: data, dataType: 'JSON', cahce: false, processData: false, contentType: false, success: function () { // ... } })} 扩展：window.URL.createObjectURLwindow.URL.createObjectURL 的作用是创建一个新的对象 URL,该对象 URL 可以代表某一个指定的 File 对象或 Blob 对象 关于 Bold 对象，见 MDN -Bold 大体的意思就是 File 对象,就是一个文件，比如我用 input type='file' 标签来上传文件,那么里面的每个文件都是一个 File 对象 Blob 对象,就是二进制数据,比如通过 new Blob() 创建的对象就是 Blob 对象.又比如,在 XMLHttpRequest 里,如果指定 responseType 为 blob,那么得到的返回值也是一个 blob 对象 123objectURL = window.URL.createObjectURL(blob);// blob 参数是一个 File 对象或者 Blob 对象// objectURL 是生成的对象 URL 通过这个 URL，可以获取到所指定文件的完整内容 每次调用 createObjectURL 的时候，一个新的 URL 对象就被创建了，即使你已经为同一个文件创建过一个 URL 如果你不再需要这个对象，要释放它，需要使用 URL.revokeObjectURL() 方法 当页面被关闭，浏览器会自动释放它，但是为了最佳性能和内存使用，当确保不再用得到它的时候，就应该释放它 利用 window.URL.createObjectURL 显示图片： 1234567&lt;input type= 'file' id= 'fileElem' multiple accept= 'image/*' style= 'display:none' onchange= 'handleFiles(this.files)'&gt;&lt;a href='#' id='fileSelect'&gt;Select some files&lt;/a&gt;&lt;div id='fileList'&gt; &lt;p&gt;No files selected!&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637window.URL = window.URL || window.webkitURL;var fileSelect = document.getElementById('fileSelect'), fileElem = document.getElementById('fileElem'), fileList = document.getElementById('fileList');fileSelect.addEventListener('click', function (e) { if (fileElem) { fileElem.click(); } e.preventDefault(); // prevent navigation to '#'}, false);function handleFiles(files) { if (!files.length) { fileList.innerHTML = '&lt;p&gt;No files selected!&lt;/p&gt;'; } else { fileList.innerHTML = ''; var list = document.createElement('ul'); fileList.appendChild(list); for (var i = 0; i &lt; files.length; i++) { var li = document.createElement('li'); list.appendChild(li); var img = document.createElement('img'); img.src = window.URL.createObjectURL(files[i]); img.height = 60; img.onload = function () { window.URL.revokeObjectURL(this.src); } li.appendChild(img); var info = document.createElement('span'); info.innerHTML = files[i].name + ': ' + files[i].size + ' bytes'; li.appendChild(info); } }} 如果有现成的 'img' 标签 1234function upLoadImg() { var myPic = document.getElementById('myPic').files[0]; document.getElementsByTagName('img')[0].src = window.URL.createObjectURL(myPic);} 分段读取进度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var bar = document.getElementById('progress-bar');var progress = document.getElementById('progress');var input = document.getElementById('file');var block = 1 * 1024 * 1024; // 每次读取 1M// 当前文件对象var file;// 当前已读取大小var fileLoaded;// 文件总大小var fileSize;// 每次读取一个 blockfunction readBlob() { var blob; if (file.webkitSlice) { blob = file.webkitSlice(fileLoaded, fileLoaded + block + 1); } else if (file.mozSlice) { blob = file.mozSlice(fileLoaded, fileLoaded + block + 1); } else if (file.slice) { blob = file.slice(fileLoaded, fileLoaded + block + 1); } else { alert('不支持分段读取！'); return false; } reader.readAsBinaryString(blob);}// 每个 blob 读取完毕时调用function loadHandler(e) { fileLoaded += e.total; var percent = fileLoaded / fileSize; if (percent &lt; 1) { // 继续读取下一块 readBlob2(); } else { // 结束 percent = 1; } percent = Math.ceil(percent * 100) + '%'; progress.innerHTML = percent; progress.style.width = percent;}function fileSelect(e) { file = this.files[0]; if (!file) { alert('文件不能为空！'); return false; } fileLoaded = 0; fileSize = file.size; bar.style.display = 'block'; // 开始读取 readBlob2();}var reader = new FileReader();// 只需监听 onload 事件reader.onload = loadHandler;input.onchange = fileSelect 参考： leejersey HTML5 之 FileReader 的使用 JavaScript File API","link":"/2018/08/04/JavaScript/35/"},{"title":"Stream","text":"记录一些关于 Node.js 中的 Stream 相关知识，深入研究才发现 Stream 涉及到了太多东西，本篇只是记录下 Readable 和 Writable 相关知识 其他的比如背压（back pressure）机制，流式数据处理，Browserify 和 Gulp 设计机制啥的以后万一遇到了再来填坑 什么是 StreamStream 的概念最早来源于 Unix 系统，其可以将一个大型系统拆分成一些小的组件，然后将这些小的组件可以很好地运行 TCP/IP 协议中的 TCP 协议也用到了 Stream 的思想，进而可以进行流量控制、差错控制 在 unix 中通过 | 来表示流，在 node 中通过 pipe 方法 Stream 可以认为数据就像管道一样，多次不断地被传递下去，而不是一次性全部传递给下游 Node.js 中的 Stream在 Node.js API 文档 中可以看到下面一段话 123A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter 简单来说 Stream 是 Node 中一个非常重要的概念，被大量对象实现，尤其是 Node 中的 I/O 操作 Stream 是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如 _read、_write、_transform) Stream 是 EventEmitter 的子类，实际上 Stream 的数据传递内部依然是通过事件（data）来实现的 Stream 分为四种：readable、writeable、Duplex、transform Readable可读流（Readable streams）是对提供数据的 源头（source）的抽象 可读流事实上工作在下面两种模式之一：flowing 和 paused 在 flowing 模式下，可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用 在 paused 模式下，必须显式调用 stream.read() 方法来从流中读取数据片段 那如何触发这两种模式呢： flowing mode: 注册事件 data、调用 resume 方法、调用 pipe 方法 paused mode: 调用 pause 方法（没有 pipe 方法）、移除 data 事件 和 unpipe 所有 pipe 如下所示： 12345678910111213141516171819202122232425262728// data 事件触发 flowing modeReadable.prototype.on = function (ev, fn) { // ... if (ev === 'data' &amp;&amp; false !== this._readableState.flowing) { this.resume(); } // ...}// resume 触发 flowing modeReadable.prototype.resume = function () { var state = this._readableState; if (!state.flowing) { debug('resume'); state.flowing = true; resume(this, state); } return this;}// pipe 方法触发 flowing 模式Readable.prototype.resume = function () { if (!state.flowing) { this.resume() }} 简单来说，两种模式取决于一个 flowing 字段： 123true ==&gt; flowing modefalse ==&gt; paused mode 上面三种方式最后均是通过 resume 方法，将 state.flowing = true 可读流的 ‘两种操作模式’ 是一种简单抽象，它抽象了在可读流实现（Readable stream implementation）内部发生的复杂的状态管理过程 在任意时刻，任意可读流应确切处于下面三种状态之一： 12345readable._readableState.flowing = nullreadable._readableState.flowing = falsereadable._readableState.flowing = true 若 readable._readableState.flowing 为 null，由于不存在数据消费者，可读流将不会产生数据 如果监听 data 事件，调用 readable.pipe() 方法，或者调用 readable.resume() 方法，readable._readableState.flowing 的值将会变为 true，这时，随着数据生成，可读流开始频繁触发事件 调用 readable.pause() 方法，readable.unpipe() 方法， 或者接收 ‘背压’（back pressure），将导致 readable._readableState.flowing 值变为 false，这将暂停事件流，但不会暂停数据生成 当 readable._readableState.flowing 值为 false 时， 数据可能堆积到流的内部缓存中 需要注意的是：应该选择其中 一种 来消费数据，而 不应该 在单个流使用多种方法来消费数据 对于大多数用户，建议使用 readable.pipe() 方法来消费流数据，因为它是最简单的一种实现 如果要精细地控制数据传递和产生的过程，可以使用 EventEmitter 和 readable.pause() / readable.resume() 提供的 API paused mode在 paused mode 下，需要手动地读取数据，并且可以直接指定读取数据的长度: 12345678var Read = require('stream').Readable;var r = new Read();r.push('hello');r.push('world');r.push(null);console.log('输出结果为: ', r.read(1).toString()) // 输出结果为: 'h' 还可以通过监听事件 readable，触发时手工读取 chunk 数据: 12345678910111213var Read = require('stream').Readable;var r = new Read();r.push('hello');r.push('world');r.push(null);r.on('readable', function () { var chunk = r.read(); console.log('get data by readable event: ', chunk.toString())});// get data by readable event: hello world! 需要注意的是，一旦注册了 readable 事件，必须手工读取 read 数据，否则数据就会流失，看看内部实现： 123456789101112131415161718192021222324252627function emitReadable_(stream) { debug('emit readable'); stream.emit('readable'); flow(stream);}function flow(stream) { var state = stream._readableState; debug('flow', state.flowing); if (state.flowing) { do { var chunk = stream.read(); } while (null !== chunk &amp;&amp; state.flowing); }}Readable.prototype.read = function (n) { // ... var res = fromList(n, state); if (!util.isNull(ret)) { this.emit('data', ret); } // ...} flow 方法直接 read 数据，将得到的数据通过事件 data 交付出去，然而此处没有注册 data 事件监控 因此，得到的 chunk 数据并没有交付给任何对象，这样数据就白白流失了，所以在触发 emit('readable') 时，需要提前 read 数据 flowing mode通过注册 data、pipe、resume 可以自动获取所需要的数据，看看内部实现： 12345678910111213141516171819202122// 事件 data 方式var Read = require('stream').Readable;var r = new Read();r.push('hello ');r.push('world!');r.push(null)r.on('data', function (chunk) { console.log('chunk :', chunk.toString())})// chunk: hello // chunk: world!// 通过pipe方式var r = new Read();r.push('hello ');r.push('world!');r.push(null)r.pipe(process.stdout)// hello world! 以上两种 mode 总体如下： Writable所有 Writable 流都实现了 stream.Writable 类定义的接口 尽管特定的 Writable 流的实现可能略有差别， 所有的 Writable streams 都可以按一种基本模式进行使用，如下 1234567const myStream = getWritableStreamSomehow();myStream.write('some data');myStream.write('some more data');myStream.end('done writing data'); 本质上 只是需要实现的是 _write(data, enc, next) 方法 1234567891011121314151617181920212223const Writable = require('stream').Writableconst writable = Writable()// 实现 `_write` 方法// 这是将数据写入底层的逻辑writable._write = function (data, enc, next) { // 将流中的数据写入底层 process.stdout.write(data.toString().toUpperCase()) // 写入完成时，调用 `next()` 方法通知流传入下一个数据 process.nextTick(next)}// 所有数据均已写入底层writable.on('finish', () =&gt; process.stdout.write('DONE'))// 将一个数据写入流中writable.write('a' + '\\n')writable.write('b' + '\\n')writable.write('c' + '\\n')// 再无数据写入流时，需要调用 `end` 方法writable.end() 上游通过调用 writable.write(data) 将数据写入可写流中，write() 方法会调用 _write() 将 data 写入底层 在 _write 中，当数据成功写入底层后，必须调用 next(err) 告诉流开始处理下一个数据 next 的调用既可以是同步的，也可以是异步的 上游必须调用 writable.end(data) 来结束可写流，data 是可选的，此后，不能再调用 write 新增数据 在 end 方法调用后，当所有底层的写操作均完成时，会触发 finish 事件 Readable Stream 与 Writeable Stream二者的关系 Readable Stream 是提供数据的 Stream，外部来源的数据均会存储到内部的 buffer 数组内缓存起来 writeable Stream 是消费数据的 Stream，从 readable stream 中获取数据，然后对得到的 chunk 块数据进行处理，至于如何处理，就依赖于具体实现(也就是 _write 的实现) 首先看看 Readdable Stream 与 writeable stream 二者之间的流动关系 pipe 的流程stream 内部是从 readable stream 流到 writeable stream 有两种方法 pipe 连接两个 stream12345678910111213141516var Read = require('stream').Readable;var Write = require('stream').Writable;var r = new Read();var w = new Write();r.push('hello ');r.push('world!');r.push(null)w._write = function (chunk, ev, cb) { console.log(chunk.toString()); cb();}r.pipe(w); pipe 是一种最简单直接的方法连接两个 stream，内部实现了数据传递的整个过程，在开发的时候不需要关注内部数据的流动： 1234567891011121314151617181920Readable.prototype.pipe = function (dest, pipeOpts) { var src = this; // ... src.on('data', ondata); function ondata(chunk) { var ret = dest.write(chunk); if (false === ret) { debug('false write response, pause', src._readableState.awaitDrain); src._readableState.awaitDrain++; src.pause(); } } // ...} 事件 data + 事件 drain 联合实现123456789101112131415161718192021222324252627var Read = require('stream').Readable;var Write = require('stream').Writable;var r = new Read();var w = new Write();r.push('hello ');r.push('world!');r.push(null)w._write = function (chunk, ev, cb) { console.log(chunk.toString()); cb();}r.on('data', function (chunk) { if (!w.write(chunk)) { r.pause(); }})w.on('drain', function () { r.resume();})// hello// world! DuplexDuplex 实际上就是继承了 Readable 和 Writable 的一类流 所以，一个 Duplex 对象既可当成可读流来使用（需要实现 _read 方法），也可当成可写流来使用（需要实现 _write 方法） 12345678910111213141516171819202122232425262728var Duplex = require('stream').Duplexvar duplex = Duplex()// 可读端底层读取逻辑duplex._read = function () { this._readNum = this._readNum || 0 if (this._readNum &gt; 1) { this.push(null) } else { this.push(' ' + (this._readNum++)) }}// 可写端底层写逻辑duplex._write = function (buf, enc, next) { // a, b process.stdout.write('_write ' + buf.toString() + '\\n') next()}// 0, 1duplex.on('data', data =&gt; console.log('ondata', data.toString()))duplex.write('a')duplex.write('b')duplex.end() 上面的代码中实现了 _read 方法，所以可以监听 data 事件来消耗 Duplex 产生的数据 同时，又实现了 _write 方法，可作为下游去消耗数据 因为它既可读又可写，所以称它有两端：可写端和可读端 可写端的接口与 Writable 一致，作为下游来使用，可读端的接口与 Readable 一致，作为上游来使用 TransformTranform 继承自 Duplex，并已经实现了 _read 和 _write 方法 自定义 stream自定义 stream 很简单，只要实现相应的内部待实现方法就可以了，具体来说： readable stream: 实现 _read 方法来解决数据的获取问题 writeable stream: 实现 _write 方法来解决数据的去向问题 tranform stream: 实现 _tranform 方法来解决数据存放在 buffer 前的转换工作 代码如下： 12345678910111213141516171819202122232425// 自定义readable stream的实现var Stream = require('stream');var Read = Stream.Readable;var util = require('util');util.inherits(MyReadStream, Read);function MyReadStream(data, opt) { Read.call(this, opt); this.data = data || [];}MyReadStream.prototype._read = function () { var _this = this; this.data.forEach(function (d) { _this.push(d); }) this.push(null);}var data = ['aa', 'bb', 'cc'];var r = new MyReadStream(data);r.on('data', function (chunk) { console.log(chunk.toString());}) 参考： stream-handbook Node.js Stream - 基础篇 Node.js Stream - 进阶篇 Node.js Stream - 实战篇 streamify-your-node-program Node.js 中文网","link":"/2018/07/12/Node/01/"},{"title":"Node.js 中的 co 模块","text":"Node.js 中的 co 模块可以使我们以同步的形式编写异步代码，这主要得益于 ES6 的 generator 先来看两个对比实例，传统方式下，sayhello 是一个异步函数，执行 helloworld 会先输出 'world' 再输出 'hello'： 1234567891011121314function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello); });}function helloworld() { sayhello(); console.log('world');}helloworld();// 'world'// 'hello' 而使用 co 的方式，会先输出 'hello' 再输出 'world'： 123456789101112131415161718192021function co(gen) { var it = gen(); var ret = it.next(); ret.value.then(function (res) { it.next(res); });}function sayhello() { return Promise.resolve('hello').then(function (hello) { console.log(hello); });}co(function* helloworld() { yield sayhello(); console.log('world');});// 'hello'// 'world' 从上面示例可以看出，generator 函数体可以挂载在 yield 语句处，直到下一次执行 next() co 模块的思路就是利用 generator 的这个特性，将异步操作跟在 yield 后面，当异步操作完成并返回结果后，再触发下一次 next() ，当然，跟在 yield 后面的异步操作需要遵循一定的规范 thunks 和 promises 而我们模拟实现的 co 函数，首先生成一个迭代器，然后执行一遍 next()，得到的 value 是一个 Promise 对象，Promise.then() 里面再执行 next() 简单来说，co 的主要功能分为 异步流程控制，依次执行 generator 函数内的每个位于 yield 后的 Promise 对象，并在 Promise 的状态改变后，把其将要传递给 reslove 函数的结果或传递给 reject 函数的错误返回出来，可供外部来进行传递值等操作，这些 Promise 是串行执行的 若 yield 后是 Promise 对象的数组或属性值是 Promise 对象的对象，则返回出结构相同的 Promise 执行结果数组/对象，并且这些 Promise 是并行执行的 co 自身的返回值也是一个 Promise 对象，可供继续使用 下面就来看看 co 源码中具体是怎样实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// co 的核心代码如下function co(gen) { // 保持当前函数的上下文 var ctx = this; // 截取 co 输入的参数，剔除 arguments 中的第一个参数，即 gen 对象，剩余参数作为 gen 的入参 var args = slice.call(arguments, 1) // co 函数整个的返回值是一个 promise 实例，包装了传递的 generator 函数内所有 promise 的执行 // 这也是它为什么可以使用 then 和 catch 的根源 return new Promise(function (resolve, reject) { // 判断传入的 gen 是否为函数，如果是则执行，将结果赋值给 gen 对象 if (typeof gen === 'function') gen = gen.apply(ctx, args); // 根据 generator 函数执行结果是否存在 next 字段，判断 gen 是否为 generator 迭代器对象 // 若不是，则调用 resolve 返回最外层的 Promise 对象状态 if (!gen || typeof gen.next !== 'function') return resolve(gen); // 如果是 generator 迭代器对象，开始控制 gen.next() 方法的调用 // 调用入口函数 onFulfilled(); // 入口函数，将传递进来的 generator 函数执行到第一个 yield 处来开启第一次的异步调用 // 另外也用作内部使用，作为 resolve 方法，处理异步结果，并继续调用下一个 promise function onFulfilled(res) { var ret; try { // res 为此次调用的 Peomise 结果 // 利用 generator 函数的特性，调用 next() 方法的参数，会作为 yield 的返回值 // 并将异步操作的结果返回给 ret.value ret = gen.next(res); } catch (e) { // 如果发生错误，则把 Peomise 状态指为 rejected，并且把错误结果返回出去 return reject(e); } // 将 generator 函数执行 next() 后的结果再次传入 next() 方法，实现串行调用 next(ret); } // 上面的 onFulfilled 函数作为内部的成功方法，下面这个则作为失败方法 // 实现和上面类似 function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } // 首先需要明确，generator 函数在执行完毕后会返回 { done: true, value: undefined } function next(ret) { // 如果执行完成，直接调用 resolve 把 promise 置为成功状态 if (ret.done) return resolve(ret.value); // 然后把 yield 的值（ret.value）转换成 promise（ctx 为上面保存的 this） // 支持 promise，generator，generatorFunction，array，object var value = toPromise.call(ctx, ret.value); // 成功转换就可以直接给新的 promise 添加 onFulfilled, onRejected // 当新的 promise 状态变成结束态（成功或失败），就会调用对应的回调，整个 next 链路就执行下去了 // 之所以可以一直 next() 下去，这是因为上面的 ret.value 是一个 Peomise 对象 // 当 return value.then(onFulfilled, onRejected) 以后，意味着又要去执行上面的 onFulfilled 了 // 然后会在 onFulfilled 里面再次去调用 next(ret) // 这样就会一直循环下去，直到完成整个链的操作 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 如果以上情况都没发生，则参数为非 Thunk 函数和 Promise 对象 // 那么就将 Promise 对象的状态改为 rejected，从而终止执行 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')); } });} 下面是一些和上面相关的辅助函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 将传入的参数对象转换为 Promise 对象function toPromise(obj) { if (!obj) return obj; // 如果 obj 已经是 Promise 对象，则直接返回 if (isPromise(obj)) return obj; // 如果 generator 是函数或对象，则直接把 obj 作为参数传入 co 函数，并返回 if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果 obj 是函数，则直接视为符合 thunk 规范的函数直接转换为 Promise // 关于 thunk 函数可以参考 阮一峰老师的 Thunk 函数的含义和用法 if ('function' == typeof obj) return thunkToPromise.call(this, obj); // 如果是数组，把数组中每个元素转化为内部 Promise，然后使用 Promise.all 并行计算 if (Array.isArray(obj)) return arrayToPromise.call(this, obj); // 如果是对象，则遍历对象中的每个 key 对应的 value，然后使用 Promise.all 并行计算 if (isObject(obj)) return objectToPromise.call(this, obj); // 最后返回 return obj;}// 这里的 obj 为数组// 所以使用 Array.map 方法，分别对数组中的每一个元素递归执行 toPromise 方法// 再利用 Promise.all 方法，在所有给定的可迭代完成时执行 resolve（或者第一个代码失败）并返回结果function arrayToPromise(obj) { return Promise.all(obj.map(toPromise, this));}// thunk 转为 promisefunction thunkToPromise(fn) { var ctx = this; return new Promise(function (resolve, reject) { fn.call(ctx, function (err, res) { if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); }); });}// 这里的 obj 为对象function objectToPromise(obj) { // results 是将用于返回的对象，使用和 obj 相同的构造函数 var results = new obj.constructor(); // Object.keys 方法用于返回对象的所有的属性名 var keys = Object.keys(obj); // 用于保存所有对象属性的 Promise 的数组 var promises = []; // 利用 for 循环来实现并行的异步调用 for (var i = 0; i &lt; keys.length; i++) { var key = keys[i]; // 转换为 Promise 对象 var promise = toPromise.call(this, obj[key]); // 如果是 promise 对象，直接调用 defer 函数，添加到 promises 数组中，否则直接将结果返回给 result[key] if (promise &amp;&amp; isPromise(promise)) defer(promise, key); else results[key] = obj[key]; } // 将 Promise 数组传入 Promise.all，待 defer 函数中 results 对象的属性都赋值完毕后，返回最终的 results 对象 // 使得后续调用的 then() 可以获得此处的 results return Promise.all(promises).then(function () { return results; }); // key 对应的元素成功转化为 Promise 对象后，调用 Promise 的 resovle 方法 // 以便在 results 中获取每个 Promise 对象成功执行后的结果 function defer(promise, key) { results[key] = undefined; promises.push(promise.then(function (res) { results[key] = res; })); }} 经过上面这些步骤，我们可以得到 yield 后面只能是函数、Promise 对象、Generator 函数、Generator 迭代器对象、数组（元素仅限之前的 4 类）和 Object（对应 value 仅限定之前的 4 类） 现在可以把 co 串行调用 generator 函数中 yield 的过程总结如下： 首先进入最外层的 Promise 通过入口 onFilfilled() 方法，将 generator 函数运行至第一个 yield 处，执行该 yield 后边的异步操作，并将结果传入 next 方法 如果 next 中传入结果的 done 为 true（已经完成），则返回最外层 Promise 的 resolve 如果 next 中传入结果的 done 为 fasle（表示还没执行完），则返回 value（即 yield 后边的对象）然后查看是否可以转化为内部 Promise 对象。如无法转化则抛出错误，返回最外层 Promise 的 reject 若能转化为 Promise 对象，则通过 then(onFilfilled, onRejected) 开始执行 在 onFilfilled() 或者 onRejected() 内部调用再次调用 next() 方法，实现串行执行 yield，并将 yield 后边的对象传递给 next()，依次重复（实现链式调用） 所有 yield 执行返回，将最后的 return 值返回给最外层 Promise 的 resovle 方法，结束 co 对 generator 函数的调用 附录：一个原理类似的 run 函数1234567891011121314151617181920212223242526272829function run(gen) { var args = [].slice(arguments, 1), it; // 在当前上下文中初始化生成器 it = gen.apply(this, args) // 返回一个 promise 用于生成器完成 return Promise.resolve().then(function handleNext(value) { // 对下一个 yield 出的值运行 var next = it.next(value) return (function handleResult(next) { // 生成器运行完毕了吗 if (next.done) { return next.value // 否则继续运行 } else { // 成功就恢复异步循环，把决议的值发回生成器 // 如果 value 是被拒绝的 promise // 就把错误传回生成器进行错误处理 return Promise.resolve(next.value).then(handleNext, function handleErr(err) { return Promise.resolve(it.throw(err)).then(handleResult) }) } })(next) })} 参考： co co 4.6源码解析 Thunk 函数的含义和用法 co 和 koa 异步流程控制：7 行代码学会 co 模块","link":"/2018/07/22/Node/02/"},{"title":"依赖注入（补充）","text":"接上次 依赖注入，之前只是简单的介绍了为什么要使用依赖注入和 Angular 当中的一个简单的依赖注入实例 下面就来详细的理解一下 Angular 当中的依赖注入 依赖注入（DI）是 Angular 的核心，在 Angular 中我们使用 Provider 来描述与 Token 关联的依赖对象的创建方式 创建方式有四种，它们分别是 useClass，useValue，useExisting 和 useFactory useClass123456@NgModule({ providers: [ // 两者名称一样的时候可以使用简洁语法，直接使用 ApiService { provide: ApiService, useClass: ApiService } ],}) ClassProvider 接口定义12345678export interface ClassProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; useClass: Type&lt;any&gt;; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean; } 关于上面的 Type&lt;any&gt; 类型在 Angular 中分为 Type 类型和非 Type 类似，两者的区别在于注入方式的不同 即：非 Type 类型的参数只能用 @Inject(Something) 的方式注入 接口定义如下 12345export interface Type&lt;T&gt; extends Function { new (...args: any[]): T; }export function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function';} useValue123providers: [ { provide: 'SEARCH_URL', useValue: 'http://api.xxx.com'}] ValueProvider 接口如下 123456789export interface ValueProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; // 设置注入的对象 useValue: any; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean;} 如果需要使用的话，直接在当前组件的构造函数当中进行注入即可，需要注意使用 @Inject() 123constructor( @Inject('SEARCH_URL') private searchUrl) { } 还会遇到一种问题，如果在开发中引入第三方库以后，可能会引起比如上面的字符串 Token（SEARCH_URL）的冲突问题 这里可以使用 InjectionToken 来解决 useExistinguseExisting 的意思是使用已经注册的类型注入到这里（别名），比如下面示例意思是将 ApiService 起个叫 ApiServiceAlias 的别名 123providers: [ { provide: 'ApiServiceAlias', useExisting: ApiService }] useFactory1234567891011121314@NgModule({ ... providers: [ { provide: APP_INITIALIZER, useFactory: (config: AppConfig) =&gt; { return () =&gt; config.load(); }, deps: [AppConfig], // 关于这个属性，见下方 multi: true } ]}) 一般用于告诉 Injector (注入器)，通过调用 useFactory 对应的函数，返回 Token 对应的依赖对象 接口定义如下，详细示例可见上方 1234567891011export interface FactoryProvider { // 用于设置与依赖对象关联的 Token 值 // Token 值可能是 Type、InjectionToken、OpaqueToken 的实例或字符串 provide: any; // 设置用于创建对象的工厂函数 useFactory: Function; // 依赖对象列表 deps?: any[]; // 用于标识是否 multiple providers，若是 multiple 类型，则返回与 Token 关联的依赖对象列表 multi?: boolean;} 关于上面示例当中的 MultiMulti providers 让我们可以使用相同的 Token 去注册多个 Provider 123456789const SOME_TOKEN: OpaqueToken = new OpaqueToken('SomeToken');var injector = ReflectiveInjector.resolveAndCreate([ provide(SOME_TOKEN, { useValue: 'dependency one', multi: true }), provide(SOME_TOKEN, { useValue: 'dependency two', multi: true })]);// dependencies == ['dependency one', 'dependency two']var dependencies = injector.get(SOME_TOKEN); 我们使用 multi: true 来告诉 Angular 的依赖注入系统，我们设置的 provider 是 multi provider 我们可以使用相同的 token 值来注册不同的 provider，当我们使用对应的 token 去获取依赖项的时候，我们获取的是已注册的依赖对象列表 使用 multi provider 的原因因为如果使用同一个 token 去注册 provider，后面注册的 provider 将会覆盖前面已经注册的 probider 此外，Angular 使用 multi provider 这种机制，为我们提供了可插拔的钩子（pluggable hooks） 另外需要注意：multi provider 是不能和普通的 provider 混用的 使用 Provider步骤如下所示： 创建 Token 根据实际需求来选择依赖对象的创建方式，如 useClass，useValue，useExisting，useFactory 在 NgModule 或 Component 中注册 providers 使用构造注入的方式，注入与 Token 关联的依赖对象 下面是一个示例，封装 http 服务，比如在每个 Http 的请求头中添加 token（类似拦截器） 123456789101112131415161718192021222324252627282930// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...}// 然后在使用的 Module 当中进行注入@NgModule({ providers: [ { provide: ApiService, usdClass: ApiService } ],})// 然后在组件当中进行注入后使用export class HomePage { constructor( public apiService: ApiService ) {} ngOnInit(): void { this.apiService.get(url) .map(res =&gt; res.json()) .subscribe(v =&gt; { console.log(v) }) }} 一些需要注意的地方： 创建 Token 的时候为了避免命名冲突，尽量避免使用字符串作为 Token 若要创建模块内通用的依赖对象，需要在 NgModule 中注册相关的 provider 若在每个组件中都有唯一的依赖对象，就需要在 Component 中注册相关的 provider 当 DI 解析 Providers 时，都会对提供的每个 provider 进行规范化处理，即转换成标准的形式 12345678910111213141516function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] { providers.forEach(b =&gt; { // 支持简洁的语法，转换为标准格式 if (b instanceof Type) { res.push({ provide: b, useClass: b }); } else if (b &amp;&amp; typeof b == 'object' &amp;&amp; (b as any).provide !== undefined) { res.push(b as NormalizedProvider); } else if (b instanceof Array) { // 如果是数组，进行递归处理 _normalizeProviders(b, res); } else { throw invalidProviderError(b); } }); return res;} Forward ReferenceAngular 通过引入 forwardRef 让我们可以在使用构造注入的时候，使用尚未定义的依赖对象类型 如果不使用 forwardRef 就会遇到类似下面的问题 1234567891011121314151617@Injectable()class Socket { constructor(private buffer: Buffer) { }}console.log(Buffer); // undefined@Injectable()class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }}console.log(Buffer); // [Function: Buffer]// 运行后报错// Error: Cannot resolve all parameters for Socket(undefined).// Make sure they all have valid type or annotations 因为我们编写的代码最终都会被转义为 ES5 来运行，所以在编译阶段变量声明和函数声明会自动提升，而函数表达式不会自动提升 如果要解决上面的问题，最简单的处理方式是交换类定义的顺序，或者还可以使用 Angular 提供的 forward reference 特性 12345678910111213import { forwardRef } from '@angular2/core';@Injectable()class Socket { constructor( @Inject(forwardRef(() =&gt; Buffer)) private buffer ) { }}class Buffer { constructor(@Inject(BUFFER_SIZE) private size: Number) { }} forwardRef 原理分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// @angular/core/src/di/forward_ref.ts/** * Allows to refer to references which are not yet defined. */export function forwardRef(forwardRefFn: ForwardRefFn): Type&lt;any&gt; { // forwardRefFn: () =&gt; Buffer // 当调用 forwardRef 方法时，我们只是在 forwardRefFn 函数对象上，增加了一个私有属性__forward_ref__ (&lt;any&gt;forwardRefFn).__forward_ref__ = forwardRef; // 然后覆写了函数的 toString 方法 (&lt;any&gt;forwardRefFn).toString = function () { return stringify(this()); }; return (&lt;Type&lt;any&gt;&gt;&lt;any&gt;forwardRefFn);}/** * Lazily retrieves the reference value from a forwardRef. */// 用来解析通过 forwardRef 包装过的引用值// 由依赖注入系统调用，当解析 Provider 和创建依赖对象的时候，会自动调用该函数// 如下export function resolveForwardRef(type: any): any { if (typeof type === 'function' &amp;&amp; type.hasOwnProperty('__forward_ref__') &amp;&amp; type.__forward_ref__ === forwardRef) { return (&lt;ForwardRefFn&gt;type)(); // Call forwardRefFn get Buffer } else { return type; }}/********************************************************************/// @angular/core/src/di/reflective_provider.ts/** * 解析Provider */function resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory { let factoryFn: Function; let resolvedDeps: ReflectiveDependency[]; ... if (provider.useClass) { const useClass = resolveForwardRef(provider.useClass); factoryFn = reflector.factory(useClass); resolvedDeps = _dependenciesFor(useClass); }}/********************************************************************//** * 构造依赖对象 */export function constructDependencies( typeOrFunc: any, dependencies: any[]): ReflectiveDependency[] { if (!dependencies) { return _dependenciesFor(typeOrFunc); } else { const params: any[][] = dependencies.map(t =&gt; [t]); return dependencies.map(t =&gt; _extractToken(typeOrFunc, t, params)); }}/** * 抽取Token */function _extractToken( typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency { token = resolveForwardRef(token); if (token != null) { return _createDependency(token, optional, visibility); } else { throw noAnnotationError(typeOrFunc, params); }} inject 装饰器在 Angular 中，Inject 是参数装饰器，主要用来在类的构造函数中描述非 Type 类型的参数对象 在 Angular 中的 Type 类型如下所示 12345678// Type类型 - @angular/core/src/type.tsexport const Type = Function;export function isType(v: any): v is Type&lt;any&gt; { return typeof v === 'function';}export interface Type&lt;T&gt; extends Function { new (...args: any[]): T; } Angular 中常用的非 Type 类型 Token 有：字符串（常量）、OpaqueToken 对象、InjectionToken 对象等 OpaqueToken 对象、InjectionToken 对象的构造如下 12345678910111213141516171819/** 用于创建 OpaqueToken 实例* export const CONFIG = new OpaqueToken('config');*/export class OpaqueToken { constructor(protected _desc: string) {} toString(): string { return `Token ${this._desc}`; }}/** 用于创建 InjectionToken 实例，使用泛型描述该 Token 所关联的依赖对象的类型* const API_URL = new InjectionToken&lt;string&gt;('apiUrl'); */export class InjectionToken&lt;T&gt; extends OpaqueToken { private _differentiate_from_OpaqueToken_structurally: any; constructor(desc: string) { super(desc); } toString(): string { return `InjectionToken ${this._desc}`; }} 一个简单的示例 123456789101112131415161718192021// 公共模块，主要作用是导入 providers// 定义一个常量，用来保存一个地址@NgModule({ providers: [ { provide: 'BASE_CONFIG', useValue: { uri: 'http://localhost:3002' } } ]})// 然后在需要使用的地方使用 @Inject 导入进来即可// 而对于 Http 这种 Type 类型则不需要使用 @Injectconstructor( @Inject('BASE_CONFIG') private config, private http: Http) { // ...} 那么这里就会涉及到几个问题 为什么在构造函数中，非 Type 类型的参数只能用 @Inject(Something) 的方式注入因为只有是 Type 类型的对象，才会被 TypeScript 编译器编译 即我们通过 class 关键字声明的服务，最终都会编译成 ES5 的函数对象 AppService（服务） 中的 @Injectable() 是必须的么如果 AppService 不依赖于其他对象，是可以不用使用 Injectable 类装饰器 当 AppService 需要在构造函数中注入依赖对象，就需要使用 Injectable 类装饰器 所以推荐的做法不管是否有依赖对象，service 中都使用 Injectable 类装饰器 在构造函数中，Type 类型的参数是否可以使用 @Inject(Type) 的方式注入Type 类型的参数也能使用 @Inject(Type) 的方式注入，具体如下： 123456// 虽然可以正常使用，但是编辑器会有提示// [ts] Parameter 'http' implicitly has an 'any' type.constructor(@Inject(Http) private http) { }// 也可以这样使用，但是有些冗余constructor(@Inject(Http) private http: Http) { } 如果是 Type 类型的参数，还是推荐使用下面这样的注入方式 1constructor(private http: Http) { } 注入器和提供器使用的时候定义一个变量用来接收对应的服务 ProductServicr 123constructor( private productServicr: ProductServicr) { } 而在定义的时候，需要在提供器的 providers 属性当中指明 1234567891011121314providers: [ProjectDirective]// 等价于下面这种写法，因为 provide 和 useClass 两者的属性皆为 ProductServicr// 所以可以简写成上面那种形式providers: [{ // provide 属性指定了提供器的 token（key） // 就是根据这个属性来匹配注入的对象和提供器 // 然后才会根据提供器的 useClass 属性再去具体实例化某个类 provide: ProductServicr, // 指明实例化的方式为 new 操作（因为定义的为 useClass） // 比如上方在 constructor 当中注入的 ProductServicr 就是经过 new 操作之后的 // 如果这里定义为 useClass: AnotherProductServicr 的话就不能使用简写的方式 useClass: ProductServicr}] 还可以使用如下方式 1234567providers: [{ provide: ProductServicr, // 在这种情况下就不再是直接去执行 new 一个类的操作了 // 而是通过一个工厂方法返回一个实例，再将这个实例注入到 providers 当中 // 比如做一些初始化的工作 useFactory: () =&gt; { ... }}] 提供器的作用域规则 当一个提供器声明在模块当中时（Module），对于该模块下的所有组件是可见的，所有组件都是可以注入的，即在当前模块的 @NgModule 当中的 providers 当中进行注入之后，当前模块下所有组件可用 当一个提供器声明在组件当中时（Component），只对声明它的组件及其子组件可见，其他组件不可注入 当在模块（Module）和组件（Component）当中声明的提供器具有相同的 token（key）的时候，那么组件当中的提供器会覆盖声明在模块当中的提供器（就近原则） 一般情况下优先将服务提供器声明在模块当中 只有在服务只针对某个组件使用，并且对其他组件不可见的时候，才会声明在组件当中 这种情况十分少见，所以一般推荐声明在模块当中 因为服务最终能不能注入到其他地方，是由它在没有在当前模块的 providers 当中声明来决定的 @Injectable 装饰器如下，一个简单的示例 12345678// 封装 http 为一个服务@Injectable()export class ApiService { constructor( public http: Http ) {} ...} 如果所创建的服务不依赖于其他对象，是可以不用使用 @Injectable() 类装饰器 但当该服务需要在构造函数中注入依赖对象，就需要使用 @Injectable() 装饰器，因为只有声明了 @Injectable() 这个装饰器的服务才可以注入其他服务 推荐的做法不管是否有依赖对象，在创建服务时都使用 @Injectable() 类装饰器，这样所有服务都遵循同样的规则，一致性 如果所依赖的服务是动态加载的一个简单的示例，随机生成的随机数动态加载对应服务 1234567891011121314151617181920212223242526272829// app.module.ts@NgModule({ // ... providers: [{ provide: ProductService, useFactory: () =&gt; { let logger = new LoggerService(); let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } } }, LoggerService]})// logger.service.ts// 一个简单的打印日志的服务import {} from '@angular/core'@Injectable()export class LoggerService { constructor() { } log (messgae: string) { console.log(messgae) }} 需要注意，如果多个组件共用这个服务，那么生成的实例都是相同的，因为工厂方法创建的对象是一个单例对象 工厂方法只会在创建第一个对象的时候被调用一次，然后在整个应用当中所有被注入的服务的实例都是同一个对象 上面的实例中存在两个问题 第一个问题在方法内部，手动实例化了一个 new LoggerService()，意味着工厂方法与这个类是一种强耦合的关系 而我们又声明了 LoggerService 的提供器，所以可以采用下面这种方式来解耦 利用第三个参数 deps 来声明工厂方法所依赖的参数 12345678910111213141516@NgModule({ // ... providers: [{ provide: ProductService, useFactory: (logger： LoggerService) =&gt; { let dev = Math.random() &gt; 0.5 if (dev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService] }, LoggerService]}) 这时 Angular 将会使用 LoggerService 这个提供器来实例化一个 LoggerService 的实例 并将其注入到 ProductService 的工厂方法的参数当中 第二个问题我们是根据一个随机数来决定实例化哪个对象，这样测试是可以的，但是在发布的时候就不适用了 在这种情况下就可以使用一个变量来决定调用哪个方法 然后同样的在 deps 当中进行依赖声明，然后在当作参数的时候传递进去 12345678910111213141516171819202122@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, isDev) =&gt; { if (isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'IS_DEV_ENV'] }, LoggerService, { provide: 'IS_DEV_ENV', useValue: false } ]}) 同样的，可以不单一的注入一个固定的值，也是可以注入一个对象，方便维护 123456789101112131415161718192021222324@NgModule({ // ... providers: [ { provide: ProductService, useFactory: (logger： LoggerService, appConfig) =&gt; { if (appConfig.isDev) { return new ProductService(logger) } else { return new AnotherProductService(logger) } }, deps: [LoggerService, 'APP_CONFIG'] }, LoggerService, { provide: 'APP_CONFIG', useValue: { isDev: false } } ]}) 注入器的层级关系前面的提供器只负责实例化所需的依赖对象，将实例化好的对象注入所需组件的工作则是由注入器来完成的 在程序启动的时候， Angular 首先会创建一个应用级注入器，然后将模块中声明的提供器，都注册到这个注入器当中 被注册的提供器除了应用的主模块声明的以外，还包括所有被引用的模块中声明的提供器 比如 123456789101112// app.module.ts@NgModule({ // ... imports: [ BrowserModule, FormsModule, HttpModule ], providers: [ // ... ]}) 在应用级的注入器里面，除了 AppModule 本身声明的一些提供器（providers）会被注册以外 它引入的部分（imports）所有其他的模块，这些模块当中声明的提供器都会被注册到应用级注入器当中 然后 Angular 会创建启动模块指定的主组件（bootstrap 指定的模块），同时应用级别的注入器会为这个主组件创建一个组件级的注入器，并将组件中声明的提供器注册到这个组件级的注入器上 当子组件被创建的时候，它的父组件的注入器会为这个子组件也创建一个注入器，然后将子组件声明的提供器注册上去 以此类推，应用中会形成一组注入器，这些注入器会形成一个与组件的上下级关系一样的层级关系 不过在一般情况下 Angular 可以通过构造函数的参数自动注入所需的依赖 1constructor(private http: Http) { } 同时也需要注意，Angular 的依赖注入点只有一个，就是它的构造函数 如果一个组件的构造函数为空，那么就可以断定，这个函数没有被注入任何东西 简单来说，分为 1应用级的注入器 ==&gt; 主组件注入器 ==&gt; 子组件注入器 手动添加注入器（避免此类操作）但是需要注意，在实际的使用当中避免使用这种方式 12345678910import { Component, OnInit, Injector } from '@angular/core'import { ProductService } from './product.service'export class ProductComponent implements OnInit { private productService: ProductService; constructor(private injector: Injector) { this.productService = injector.get(this.productService) }}","link":"/2018/10/16/Angular/03/"},{"title":"JavaScript 中的对象","text":"JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…，对象只是带有属性和方法的特殊数据类型，可以使用 typeof 来进行判断 typeof 函数输出的一共有几种类型，在此列出： 12345678910111213141516171819function show(x) { console.log(typeof (x)); // undefined console.log(typeof (10)); // number console.log(typeof ('abc')); // string console.log(typeof (true)); // boolean console.log(typeof (function () { })); // function console.log(typeof ([1, 'a', true])); // object console.log(typeof ({ a: 10, b: 20 })); // object console.log(typeof (null)); // object console.log(typeof (new Number(10))); // object console.log(typeof Symbol()); // symbol}show(); 其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象 剩下的几种情况 – 函数、数组、对象、null、new Number(10) 都是对象，他们都是引用类型 另外 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型 判断一个变量是不是对象非常简单，只需要记住：值类型的类型判断用 typeof，引用类型的类型判断用 instanceof 12var fn = function () { };console.log(fn instanceof Object); // true 下面来看看创建 JavaScript 对象的几种方式 使用 new object() 来创建对象在 JavaScript 中并不存在类，所以可以直接通过 Objeact 来创建对象 12345678var person = new object();person.name = 'abc';person.age = '20';person.say = function () { alert(this.name + ',' + this.age);} 使用如上方式创建，带来的最大问题是，由于没有类的约束，无法实现对象的重复利用，并且没有一种约定，在操作的时候可能会带来问题 使用 JSON 来创建对象json 格式就是 JavaScript 的对象，但是它神略去了 xml 中的标签，而是通过 { } 来完成对象的说明 12345678910var person = { // 通过 '属性名：属性值' 来表示，不同的属性通过 ',' 来间隔，最后一个属性后不能有 ',' name: '张三', age: 20, say: function () { alert(this.name + ',' + this.age); }}person.say(); 通过 json 依然可以创建对象数组，创建的方式和 JavaScript 的数组一样 12345678var arr = [ {name : '张三', age : 20}, {name : '李四', age : 30}];for (var i = 0; i &lt; arr.length; i++) { alert(arr[i]);} 使用工厂模式来创建对象通过工厂的方式来创建 person 对象，在 createPerson 中创建一个对象，然后为这个对象设置相应的属性和方法，之后在返回这个对象 123456789101112131415161718function createPerson(name, age) { var o = new Object(); o.name = name; o.age = age; o.say = function () { alert(this.name + ',' + this.age); } return o;}var p1 = createPerson('张三', 20);var p2 = createPerson('李四', 20);p1.say();p2.say(); 使用工厂的方式，虽然有效的解决了类的问题，但是依然存在一个问题，没有办法检测 p1 和 p2 的数据类型 通过 typeof 仅仅只能检测出 object 类型，如果希望使用 instanceof 来检测的话，无法确定检测的类型 使用构造函数来创建对象通过构造函数的方式创建，和基于工厂的创建类似，最大的区别就是函数的名称，约定成俗，第一个字母大写，使用构造函数创建的时候，在函数内部是通过 this 关键字来完成属性的定义 1234567891011121314151617function Person(name, age) { this.name = name; this.age = age; this.say = function () { alert(this.name + ',' + this.age); }}// 通过 new Person 来创建对象var p1 = new Person('张三', 20);var p2 = new Person('李四', 30);p1.say();p2.say();// 使用构造函数的方式可以通过以下的方式来检测对象的类型alert(p1 instanceof Person); 使用构造函数创建所带来的第一个问题就是每一个对象中都会存在一个方法的拷贝，如果对象行为很多的话，空间的占用率会大大的增加 如果在 Person 内部来创建方法 p1.say() 和 p2.say() 是不一样的 解决方法是可以将函数放到全局变量中去定义，这样可以让类中的行为指向同一个函数 123456789function Person(name, age) { this.name = name; this.age = age; this.say = say;}function say() { alert(this.name + ',' + this.age);} 若是将其设置为全局方法，如果将所有的方法都设为全局函数的时候，这个函数就可以被 window 调用 此时就破坏了对象的封装性，而且如果某个对象有大量的方法，就会导致代码中充斥着大量的全局函数，而不利于维护 原型的内存原型是 JavaScript 中非常特殊的一个对象，当一个函数创建之后，就会随之产生一个原型对象，当通过这个函数的构造函数创建了一个具体的对象之后，在这个具体的对象中就会有一个属性指向原型 123456789101112131415161718192021222324252627// 第一种状态function Person() { }//第二种状态Person.prototype.name = 'Leon';Person.prototype.age = 23;Person.prototype.say = function () { alert(this.name + ',' + this.age);}// 第三种状态// 创建了一个对象之后会有一个 _prop_ 的属性指向原型// 在使用的时候如果在对象内部没有找到属性就会去原型中找，_prop_ 属性是隐藏的var p1 = new Person();p1.say();// 以下方法可以检测出 p1 是否有 _prop_ 指向 Person 的原型alert(Person.prototype.isPrototypeOf(p1));// 第四种状态var p2 = new Person();p2.name = 'lisi';p2.say();p1.say(); 然后依次图解函数中的四种状态，如下所示 第一种状态 以上是第一种状态：function Person(){} Person 函数中有一个 prototype 的属性指向 Person 的原型对象，在原型对象中有一个 constructor 的属性指向了 person 函数，所以可以通过 new Person() 创建对象 第二种状态 以上是第二种状态，通过 Person.prototype.name 为原型设置值以后，这些属性和方法都是设置在 Person 的原型中的 第三种状态 第三种状态是，当使用 Person 创建了对象之后，会在对象中有一个 _prop_ 属性（这个属性是不能被访问的）指向了原型 当使用对象调用原型的时候，首先会在对象的内部找是否有这个属性，如果没有会通过 _prop_ 去原型中找属性，所以当调用 p1.say() 在自己的空间中不存在这个方法，就会去原型中寻找，找到了之后完成 say 的调用 第四种状态 第四种状态，当创建了一个新的 p2 之后，依然会有一个 _prop_ 属性指向 Person 的原型 此时如果通过 p2.name 设置了属性之后，会在对象自己的内存空间中存储 name 的值，当调用 say 方法的时候，在寻找 name 的时候，在自己的空间中找到以后，就不会去原型中查找了 特别注意：原型中的值不会被替换，仅仅只是在查找的时候会被覆盖 原型的重写使用如下方式来编写代码，当属性和方法特别多的时候，编写起来不是很方便，可以通过 json 的格式来编写 123456Person.prototype.name = 'Leon';Person.prototype.age = 23;Person.prototype.say = function () { alert(this.name + ',' + this.age);} 以下方式将会重写原型，由于原型重写，而且没有通过 Person.prototype 来指定，此时 constructor 不会在指向 Person 而是指向 Object 如果 constructor 真的比较重要，可以在 json 中说明原型的指向 1234567891011Person.prototype = { constructor: Person, // 手动指定 constructor name: 'Leon', age: 23, say: function () { alert(this.name + ',' + this.age); }}var p1 = new Person();p1.say(); 测试123456789101112131415161718192021222324function Person() { };var p1 = new Person();Person.prototype.sayHi = function () { alert(this.name + ' :hi');}p1.sayHi();// 注意 是把重写放置在 new Person 之后Person.prototype = { constructor: Person, // 手动指定 constructor name: 'Leon', age: 23, say: function () { alert(this.name + ',' + this.age); }}p1.sayHi(); // 不会报错，但是没有 this.namep2.sayHi() // 此时 p2 没有 sayHi 所以会报错p2.say(); // Leon 23 运行如下图所示： 基于组合和动态原型创建为了解决原型所带来的问题，此外需要通过组合构造函数和原型来实现对象的创建，将属性在构造函数中定义，将方法在原型中定义，这种有效集合了两者的优点，是目前最为常用的一种方式 1234567891011121314151617181920212223242526function Person(name, age, friends) { // 属性在构造函数中定义 this.name = name; this.age = age; this.friends = friends;}Person.prototype = { constructor: Person, // 方法在原型中定义 say: function () { alert(this.name + '[' + this.friends + ']'); }}// 此时所有的属性都是保存在自己的空间中的var p1 = new Person('Leon', 23, ['Aid', 'Cilr']);p1.name = 'Jim';p1.friends.push('Milk'); //为 p1 增加一个朋友p1.say();var p2 = new Person('Aid', 33, ['Leon']);// 此时原型中就多了一个 Milkp2.say(); // Leon adi cilr milk 基于原型的一个实例12345678910111213141516function obj(name) { if (name) { this.name = name; } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj;console.log(a.name); // name1console.log(window.name); // name1console.log(b.name); // name2 一般函数直接调用，默认 this 指向全局 window | global 通过 obj('name1') 调用，返回 this 引用，并传递给 a，此时 a 等于 window 对象，即可输出 name 值 new 操作，new obj 等价于 new obj() ，实例化一个对象，这时 this 指向 obj，要拿到 b.name 的值，需要保证 name 属性存在 属性查找原则是先查找当前实例有没有属性，如果有就直接使用，如果没有，就到原型上去找，在没有就接着原型链一步一步往上 这里为了和 a.name 作属性区别，使用了 if (name) 有条件的构建 this 的属性 name 所以，现在 name 属性提供给 a 使用，原型上的 name 提供给 b 使用 变体一12345678910111213141516171819202122232425262728293031323334// 去掉 if 判断function obj(name) { // if(name) { this.name = name; // } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj;console.log(a.name); // name1console.log(window.name); // name1// 这时，b 实例已经有属性 name，但是参数 name 为 undefined，所以这时可以把 this.name 属性删掉，这样就能去原型找 name 了function obj(name) { // if (name) { this.name = name; // } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj;console.log(a.name); // name1console.log(window.name); // name1delete b.name;console.log(b.name); // name2 变体二 new obj(‘myname’) 试试传个参数123456789101112131415function obj(name) { // if (name) { this.name = name; // } return this;}obj.prototype.name = 'name2';var a = obj('name1');var b = new obj('myname');console.log(a.name); // name1console.log(window.name); // name1console.log(b.name); // myname this 指向问题12345678/* new Constructor*/function new (f) { var n = { '__prop__': f.prototype; } /* step1 */ return function () { f.apply(n, arguments); /* step2 */ return n; /* step3 */ };} 笼统的说，都是指向了构造函数，但实际上是指向了实例化的对象 其实 new 一个构造函数的过程是：先创建一个空对象，然后该对象自然有了 this，然后产生一个继承的过程（为该函数添加一个 __peoto__ 属性，指向构造函数的原型） 这样一来，自然而然空对象就具有了构造函数的所有属性，最后在通过 apply 之类的方式调用构造函数，把环境指向原先的空对象，达到模拟调用构造函数产生一个新对象的目的 再来看看一些比较实际的例子，比如扩展已经存在的对象的原型 为数组添加去除重复项的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 方法一 Array.prototype.cx = function () { var arr = []; for (var i = 0; i &lt; this.length; i++) { if (arr.indexOf(this[i]) == -1) { arr.push(this[i]); } } return arr;}// 方法二 Array.prototype.cx2 = function () { this.sort(); var arr = [this[0]]; for (var i = 1; i &lt; this.length; i++) { if (this[i] !== arr[arr.length - 1]) { arr.push(this[i]); } } return arr;} ``` ## 去掉字符串两边的空格```js// 为 String 扩展一个 trim 的方法，去除两边的空格String.prototype.trim = function () { return this.replace(/(^\\s+)|(\\s+$)/g, '');}``` ## 几种面向对象的书写方式 #### 第一类```js(function () { function Circle(nRadius) { this.nR = nRadius; } Circle.prototype = { PI: 3.14, fnGetArea: function () { return this.PI * this.nR * this.nR; } } var c1 = new Circle(5); alert(c1.fnGetArea()); // 78.5})(); 上面这种可以说是很标准的面向对象 JavaScript 书写方式了我们又称之为工厂模式，优点就是简单容易上手，以上代码略微改动，会有如下这个变种： 12345678910111213141516171819(function () { function Circle(nRadius, sMessage) { this.init.apply(this, arguments); } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } var c = new Circle(5, '构造初始化 面积'); alert(c.fnGetArea()); // 构造初始化 面积: 78.5})(); 上面这个变种，就比较有意思了，this.init.apply(this, arguments); 这行代码把初始化的任务交接给了 init() 方法，这么做的好处就是可以把所有初始化的东西都放在一个地方进行，增加可阅读性 第二类1234567891011121314151617181920(function () { function Circle() { } Circle.prototype = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } var c = new Circle(); c.init(5, '手动构造初始化 面积'); alert(c.fnGetArea()); // 手动构造初始化 面积: 78.5})(); 这类写法从书写角度来看省去了构造函数初始化属性，改用其 init() 中初始化 另一个好处在于不在 new Circle() 构造之初传入参数，个人认为当 new 构造对象的时候，最好不要掺杂参数，这样做很危险 改为手动型初始化更易于代码排查修改，当然这种写法还有一个原因就是他可以很好的转换成一般前端接受的封装型代码，我们把上面的代码也略微改动一下 123456789101112131415(function () { var Circle = { init: function (nRadius, sMessage) { this.nR = nRadius; this.sMessage = sMessage; }, PI: 3.14, fnGetArea: function () { return this.sMessage + ': ' + this.PI * this.nR * this.nR; } } Circle.init(5, '封装型 面积'); alert(Circle.fnGetArea()); // 封装型 面积: 78.5})(); 上面这类代码优点是代码的封装性良好，可以有效的重用，多用于页面功能性效果实现，封装一个 Tab 控件、封装一个跑马灯效果等等 缺点就是不能很好的用作继承，这是和上面三种格式最大区别，可话又说回来一般 JavaScript 代码很少会用到继承的地方，除非是写一个大型库（类似 YUI）会用到继承外，一般写一个功能模块用到封装型代码就够用了 上面介绍了两类 4 种面向对象的写法，一般面向对象书写格式基本都在上面了，熟悉面向对象书写可以有效的增加你对 JavaScript 的理解 熟练使用上面 4 中写法也能够很好的在工作中给代码维护修改带来便利，最后我们再来谈一个技巧，让你的 Javascript 代码在技巧上进化 用对象字面量构造对象一个对象字面量就是包含在一对花括号中的 0 个或多个 名/值 对，上文在面向对象书写格式的时候我们就大量的使用了对象字面量的书写格式 对象字面量书写 Javascript 可以很好的简化代码，又能极大的增加代码可读性，尤其作为参数使用可以有化腐朽为神奇的表现，我们看下面代码 123456789101112131415(function () { function Person(sName, nAge, nWeight, bSingle) { this.sName = sName; this.nAge = nAge; this.nWeight = nWeight; this.bSingle = bSingle; } Person.prototype.showInfo = function () { return this.sName + ' ' + this.nAge + ' ' + this.nWeight + ' ' + this.bSingle; } var p = new Person('张三', 25, 75, true); alert(p.showInfo()); // 张三 25 75 true})(); 上面是一个很标准的工厂模式，一般而言这类写法属于那种规规矩矩没有大错也没有亮点的代码，而且参数不少，一个不小心还会传入错误的参数，而应用对象字面量技巧可以很好的规避此类问题，我们来看改动过后的代码 12345678910111213141516171819202122232425(function () { function Person() { } Person.prototype = { init: function (option) { if (typeof option == 'undefined') { option = {}; } this.sName = option.sName || '张三'; this.nAge = option.nAge || 25; this.nWeight = option.nWeight || 75; this.bSingle = (typeof option.bSingle != 'undefined') ? option.bSingle : true; }, showInfo: function () { return this.sName + ' ' + this.nAge + ' ' + this.nWeight + ' ' + this.bSingle; } } var p = new Person(); p.init({ nWeight: 80, sName: '李四' }) alert(p.showInfo()); // 李四 25 80 true})(); 这里使用第三种面向对象写法，传入参数改成了一个对象字面量，而且传入参数可以是随意设置，位置颠倒也不会有任何问题 这里充分利用对象字面量优点，利用键值对代替原始的传参方式大大提升了可读性和容错性 还有一个改进就是默认值的处理，如果没有传入任何参数，此代码也能很好的运行下去，不会有任何问题 参考： JavaScript 面向对象 全面理解面向对象的 JavaScript","link":"/2017/10/07/JavaScript/25/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"}]}